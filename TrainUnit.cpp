// TrainUnit.cpp
/*
  BEWARE OF COMMENTS in .cpp files:  they were accurate when written but have
  sometimes been overtaken by changes and not updated
  Comments in .h files are believed to be accurate and up to date

  This is a source code file for "railway.exe", a railway operation
  simulator, written originally in Borland C++ Builder 4 Professional with
  later updates in Embarcadero C++Builder 10.2.
  Copyright (C) 2010 Albert Ball [original development]

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// ---------------------------------------------------------------------------
#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include <Forms.hpp>
#include <Buttons.hpp>
#include <ExtCtrls.hpp>
#include <Menus.hpp>
#include <Dialogs.hpp>
#include <Graphics.hpp>
#include <ComCtrls.hpp>
#include <fstream>
#include <vector>
#include <algorithm> //for sort
#include <vcl.h>
#include <stdlib.h> //for rand() & random()
#include <math.hpp> //for speed & performance calcs

#pragma hdrstop

#include "TrainUnit.h"
#include "TrackUnit.h"
#include "GraphicUnit.h"
//#include "DisplayUnit.h" included in TrackUnit.h
#include "PerfLogUnit.h"
#include "Utilities.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)

TTrainController *TrainController;

// ---------------------------------------------------------------------------

int TTrain::NextTrainID = 0; // has to be initialised outside the class

// ---------------------------------------------------------------------------

TExitInfo::TExitInfo()   //default constructor
{
    ServiceReference = "        ";
    RepeatNumber = 0;
    TimeToExitSecs = -1;
}

// ---------------------------------------------------------------------------

TTrain::TTrain(int Caller, int RearStartElementIn, int RearStartExitPosIn, AnsiString InputCode, int StartSpeedIn, int MassIn, double MaxRunningSpeedIn,
               double MaxBrakeRateIn, double PowerAtRailIn, TTrainMode TrainModeIn, TTrainDataEntry *TrainDataEntryPtrIn, int RepeatNumberIn, int IncrementalMinutesIn,
               int IncrementalDigitsIn, int SignallerMaxSpeedIn) : RearStartElement(RearStartElementIn), RearStartExitPos(RearStartExitPosIn), HeadCode(InputCode),
    StartSpeed(StartSpeedIn), Mass(MassIn), MaxRunningSpeed(MaxRunningSpeedIn), MaxBrakeRate(MaxBrakeRateIn), PowerAtRail(PowerAtRailIn),
    TrainMode(TrainModeIn), TrainDataEntryPtr(TrainDataEntryPtrIn), RepeatNumber(RepeatNumberIn), IncrementalMinutes(IncrementalMinutesIn),
    IncrementalDigits(IncrementalDigitsIn), SignallerMaxSpeed(SignallerMaxSpeedIn)
/*
              Construct a new train with general default values and input values for position and headcode.
              Create the frontcode, headcode and background graphics here but don't delete them in a destructor.
              This is because trains are kept in a vector and vectors erase elements during internal operations.
              Deletion is explicit by using a special function.  Increment the static class member NextTrainID
              after setting this train's ID.
*/

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TTrain," + AnsiString(RearStartElementIn) + "," +
                                 AnsiString(RearStartExitPosIn) + "," + AnsiString(InputCode) + "," + AnsiString(StartSpeedIn) + "," + AnsiString(MassIn) + "," +
                                 AnsiString(TrainModeIn));
    // AutoControl = true;//all trains start in auto control
    UpdateCounter = 0;
    TimeTimeLocArrived = false;
    Derailed = false;
    DerailPending = false;
    Crashed = false;
    StoppedAtBuffers = false;
    StoppedAtSignal = false;
    StoppedAtLocation = false;
    StoppedAfterSPAD = false;
    StoppedWithoutPower = false; // new at v2.4.0
    StoppedForTrainInFront = false;
    SignallerStoppingFlag = false;
    SignallerStopped = false;
    SignallerRemoved = false;
    NotInService = false;
    HoldAtLocationInTTMode = false;
    AllowedToPassRedSignal = false;
    CallingOnFlag = false;
    BeingCalledOn = false;
    DepartureTimeSet = false;
    BufferZoomOutFlashRequired = false;
    TimetableFinished = false;
    LastActionDelayFlag = false;
    OneLengthAccelDecel = false;
    TrainCrashedInto = -1;
    BackgroundColour = clNormalBackground;
    Plotted = false;
    TrainGone = false;
    SPADFlag = false;
    FrontCodePtr = new Graphics::TBitmap;
    FrontCodePtr->PixelFormat = pf8bit;
    FrontCodePtr->Height = 8;
    FrontCodePtr->Width = 8;
    FrontCodePtr->Assign(RailGraphics->TempBackground);
    FrontCodePtr->Transparent = false;
    AValue = sqrt(2 * PowerAtRail / Mass);
    TimetableMaxRunningSpeed = MaxRunningSpeed;
    TerminatedMessageSent = false;
    JoinedOtherTrainFlag = false;
    LeavingUnderSigControlAtContinuation = false;
    FollowOnServiceRef = ""; //added at v2.12.0
    TreatPassAsTimeLocDeparture = false; //added at v2.12.0
    StepForwardFlag = false;
    RestoreTimetableLocation = "";
    for(int x = 0; x < 4; x++)
    {
        HeadCodeGrPtr[x] = new Graphics::TBitmap;
        HeadCodeGrPtr[x]->PixelFormat = pf8bit;
        HeadCodeGrPtr[x]->Height = 8;
        HeadCodeGrPtr[x]->Width = 8;
        HeadCodeGrPtr[x]->Assign(RailGraphics->TempBackground);
        HeadCodeGrPtr[x]->Transparent = false;
    }
    for(int x = 0; x < 4; x++)
    {
        BackgroundPtr[x] = new Graphics::TBitmap;
        BackgroundPtr[x]->PixelFormat = pf8bit;
        BackgroundPtr[x]->Height = 8;
        BackgroundPtr[x]->Width = 8;
        BackgroundPtr[x]->Assign(RailGraphics->TempBackground);
        BackgroundPtr[x]->Transparent = false;
    }
    for(int x = 0; x < 4; x++)
    {
        HeadCodePosition[x] = HeadCodeGrPtr[x];
        // set here to ensure have values
    }
    for(int x = 0; x < 4; x++)
    {
        PlotElement[x] = -1; // marker for not plotted yet
    }
    for(int x = 0; x < 3; x++)
    {
        OldZoomOutElement[x] = -1; // marker for not plotted yet
    }
    TrainID = NextTrainID;
    NextTrainID++;

    // new values added to complete initialisation of all TTrain variables

    // ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0)); can't be initialised yet as session trains created with Null
    // TrainDataEntryPtr, initialise in AddTrain
    FrontElementSpeedLimit = 0;
    FrontElementLength = 0;
    EntrySpeed = 0;
    ExitSpeedHalf = 0;
    ExitSpeedFull = 0;
    MaxExitSpeed = 0;
    BrakeRate = 0;
    SignallerStopBrakeRate = 0;
    FirstHalfMove = true;
    EntryTime = 0;
    ExitTimeHalf = 0;
    ExitTimeFull = 0;
    ReleaseTime = 0;
    TRSTime = 0;
    LastActionTime = 0;
    Straddle = MidLag;
    LeadElement = -1;
    LeadEntryPos = 0;
    LeadExitPos = 0;
    MidElement = -1;
    MidEntryPos = 0;
    MidExitPos = 0;
    LagElement = -1;
    LagEntryPos = 0;
    LagExitPos = 0;
    TrainFailed = false; // added at v2.4.0
    for(int x = 0; x < 4; x++)
    {
        HOffset[x] = 0;
        VOffset[x] = 0;
        PlotEntryPos[x] = 0;
    }
    OpTimeToAct = 60; // default value, new at v2.2.0
    TimeToExit = -1;
    ExitPair.first = -1;
    ExitPair.second = -1;
    MinsDelayed = 0.0; // new at v2.2.0
    FirstLaterStopRecoverableTime = 0.0; // new at v2.2.0
    FinishJoinLogSent = false;
    // added at v2.4.0 to prevent repeatdly logging the event
    OriginalPowerAtRail = PowerAtRail;
    ZeroPowerNoFrontSplitMessage = false;
    // added at v2.4.0, no need to include in session file as will only be sent once & better that way
    ZeroPowerNoRearSplitMessage = false;
    FailedTrainNoFinishJoinMessage = false;
    ZeroPowerNoJoinedByMessage = false;
    ZeroPowerNoCDTMessage = false;
    ZeroPowerNoNewServiceMessage = false;
    ZeroPowerNoNewShuttleFromNonRepeatMessage = false;
    ZeroPowerNoRepeatShuttleMessage = false;
    ZeroPowerNoRepeatShuttleOrNewServiceMessage = false;
    TrainFailurePending = false;
    SkippedDeparture = false;
    ActionsSkippedFlag = false;
    SkipPtrValue = 0;
    TrainSkippedEvents = 0;
    DelayedRandMins = 0; //added at v2.13.0
    NewDelay = 0; //added at v2.13.0
    CumulativeDelayedRandMinsOneTrain = 0; //added at v2.13.0
    ActualArrivalTime = TDateTime(0); //added at v2.13.0
    LastSigPassedFailed = false; //added at v2.13.0
    Utilities->CallLogPop(648);
}

// ---------------------------------------------------------------------------

void TTrain::DeleteTrain(int Caller)
/*
          Delete train heap objects (bitmaps) explicitly by this special function rather than by a destructor, because vectors
          erase elements during internal operations & if TTrain had an explicit destructor that deleted the heap elements then
          it would be called when a vector element was erased.  Calling the default TTrain destructor doesn't matter because all that
          does is release the memory of the members (including pointers to the bitmaps), it doesn't destroy the bitmaps themselves.
          It's important therefore to call this function before erasing the vector element, otherwise the pointers to the bitmaps
          would be lost and the bitmaps never destroyed, thereby causing memory leaks.
          No need to delete HeadCodePosition as that just points to existing bitmaps
*/{
    // if(NoDelete) return;//used when a TTrain is created to hold copied values from elsewhere
    TrainController->LogEvent("" + AnsiString(Caller) + ",DeleteTrain," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",DeleteTrain," + HeadCode);
    if(Display->ZoomOutFlag)
    {
        UnplotTrainInZoomOutMode(0);
    }
    if(FrontCodePtr == 0)
    {
        throw Exception("Error in attempting to delete FrontCodePtr");
    }
    delete FrontCodePtr;
    FrontCodePtr = 0;
    for(int x = 0; x < 4; x++)
    {
        if(BackgroundPtr[x] == 0)
        {
            throw Exception("Error in attempting to delete BackgroundPtr[" + AnsiString(x) + "]");
        }
        delete BackgroundPtr[x];
        BackgroundPtr[x] = 0;
    }
    for(int x = 0; x < 4; x++)
    {
        if(HeadCodeGrPtr[x] == 0)
        {
            throw Exception("Error in attempting to delete HeadCodeGrPtr[" + AnsiString(x) + "]");
        }
        delete HeadCodeGrPtr[x];
        HeadCodeGrPtr[x] = 0;
    }
    Utilities->CallLogPop(649);
}

// ---------------------------------------------------------------------------

void TTrain::PlotStartPosition(int Caller)
/*
          Plots the train starting position on screen.  Note that the check for starting on straight points &
          on wrongly set points is carried out in TrainControllerUnit [but have to allow for starting on points because
          ChangeDirection calls this function.].  Train starts on Lead & Mid elements & Straddle = LeadMid unless
          entering at a continuation in which case Straddle = MidLag & train not plotted immediately.
          Set the headcode graphics pointers from the headcode text, then check whether starting at a
          continuation.  If so set Mid & Lag elements to -1 so they won't be plotted, and set Lead values
          for the continuation element.  Otherwise set Lead and Mid values,

          and Lead element value unless
          Mid element is a buffer or continuation.  Set Straddle, then for the Mid element set the graphic
          offsets and headcode positions and front code.  Pick up background bitmaps for the Mid element,
          then check if a train on either Mid or Lag and if so give a warning message and return false so
          that the calling function can delete the train.  Plot the Mid element train values then do similarly
          for the Lag element - set offsets, pick up background bitmaps, and plot the rear two segments of
          the train.  Finally set the Plotted flag and return true.
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotStartPosition," + HeadCode);
    int NextElementPosition, NextEntryPos, ElementLength, SpeedLimit;

    SetHeadCodeGraphics(0, HeadCode);
    // PlotStartTime = TrainController->TTClockTime;
    FirstHalfMove = true;

    // if enter at continuation then don't plot anything at start, but set TrainIDOnElement for continuation entry so as to
    // 'claim' it for this train to prevent any other waiting trains trying to enter
    if(Track->TrackElementAt(163, RearStartElement).TrackType == Continuation)
    {
        LagElement = -1; // not to be plotted
        LagExitPos = 0; // not to be plotted
        LagEntryPos = 0; // not to be plotted
        MidElement = -1; // not to be plotted
        MidExitPos = 0; // not to be plotted
        MidEntryPos = 0; // not to be plotted
        LeadElement = RearStartElement;
        LeadExitPos = 1; // will be 1 for continuation entry
        LeadEntryPos = 0;

        EntrySpeed = StartSpeed;
        MaxExitSpeed = StartSpeed; // initial value
        EntryTime = TrainController->TTClockTime;
        ElementLength = Track->TrackElementAt(164, LeadElement).Length01;
        SpeedLimit = Track->TrackElementAt(165, LeadElement).SpeedLimit01;
        if(EntrySpeed > SpeedLimit)
        {
            EntrySpeed = SpeedLimit;
        }
        if(EntrySpeed > MaxRunningSpeed)
        {
            EntrySpeed = MaxRunningSpeed;
        }
        SetTrainMovementValues(0, LeadElement, LeadEntryPos);
        // LeadElement is the element to be entered

        // Precautionary check - If need to brake EntrySpeed may be too high, so set it to the speed at which
        // can achieve ExitSpeedFull at the half braking rate.
        if(ExitSpeedFull < EntrySpeed)
        {
            double TempEntrySpeed = sqrt((MaxExitSpeed * MaxExitSpeed) + (3.6 * 3.6 * MaxBrakeRate * ElementLength)); // half braking
            if(TempEntrySpeed < EntrySpeed)
            {
                EntrySpeed = TempEntrySpeed;
                SetTrainMovementValues(1, LeadElement, LeadEntryPos);
            }
        }
        Straddle = MidLag; // only for starting on a continuation
        Track->TrackElementAt(536, LeadElement).TrainIDOnElement = TrainID;
        // no need to stop gap flashing if start on continuation
    }
    else // not starting at a continuation
    {
        LagElement = -1;
        LagEntryPos = 0;
        LagExitPos = 0;
        MidElement = RearStartElement;
        MidExitPos = RearStartExitPos;
        MidEntryPos = Track->GetAnyElementOppositeLinkPos(0, MidElement, MidExitPos, Derailed);
        LeadElement = Track->TrackElementAt(166, MidElement).Conn[MidExitPos];
        LeadEntryPos = Track->TrackElementAt(167, MidElement).ConnLinkPos[MidExitPos];
        LeadExitPos = Track->GetAnyElementOppositeLinkPos(1, LeadElement, LeadEntryPos, Derailed);

        EntrySpeed = StartSpeed;
        MaxExitSpeed = StartSpeed; // initial value
        EntryTime = TrainController->TTClockTime;
        bool TempDerail = false; // dummy
        NextElementPosition = Track->TrackElementAt(168, LeadElement).Conn[Track->GetAnyElementOppositeLinkPos(2, LeadElement, LeadEntryPos, TempDerail)];
        NextEntryPos = Track->TrackElementAt(169, LeadElement).ConnLinkPos[Track->GetAnyElementOppositeLinkPos(3, LeadElement, LeadEntryPos, TempDerail)];
        if((PowerAtRail < 1) && EntrySpeed < 1) // added at v2.4.0
        {
            StoppedWithoutPower = true;
        }
        // facing buffers check - ignore starting speed if start facing buffers
        StoppedAtBuffers = false;
        // need to set here as well as in UpdateTrain() in case paused during signaller change direction
        if((Track->TrackElementAt(492, LeadElement).TrackType == Buffers) && (Track->TrackElementAt(493, LeadElement).Config[LeadExitPos] == End)
           && !StoppedWithoutPower)
        {
            FrontElementSpeedLimit = Track->TrackElementAt(494, LeadElement).SpeedLimit01; // use 01 for convenience, not used
            FrontElementLength = Track->TrackElementAt(495, LeadElement).Length01; // use 01 for convenience, not used
            EntrySpeed = 0;
            ExitSpeedHalf = 0;
            ExitSpeedFull = 0;
            MaxExitSpeed = 0;
            // SetTrainMovementValues not called so set this here
            BrakeRate = 0;
            ExitTimeHalf = EntryTime;
            ExitTimeFull = EntryTime;
            StoppedAtSignal = false;
            // new v2.2.0: can't be at buffers and signal! If was set then won't be reset as later
            // signal check is an 'else'
            if(!StoppedAtLocation)
            {
                StoppedAtBuffers = true; // stopped at location takes precedence
            }
        }

        // facing continuation check - don't allow to stop even if no power
        else if((Track->TrackElementAt(513, LeadElement).TrackType == Continuation) && (Track->TrackElementAt(514, LeadElement).Config[LeadExitPos] == End))
        {
            FrontElementSpeedLimit = Track->TrackElementAt(509, LeadElement).SpeedLimit01; // use 01 for convenience, not used
            FrontElementLength = Track->TrackElementAt(510, LeadElement).Length01; // use 01 for convenience, not used
            ExitSpeedHalf = EntrySpeed;
            ExitSpeedFull = EntrySpeed;
            MaxExitSpeed = EntrySpeed;
            BrakeRate = 0;
            ExitTimeHalf = TrainController->TTClockTime + TDateTime(1.8 * (double) FrontElementLength / EntrySpeed / 86400);
            ExitTimeFull = TrainController->TTClockTime + TDateTime(3.6 * (double) FrontElementLength / EntrySpeed / 86400);
        }

        // Signal check
        else if((NextElementPosition > -1) && (NextEntryPos > -1))
        // condition check added as precaution after SloughIECC error reported by James U
        {
            if((Track->TrackElementAt(170, NextElementPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal) &&
               (Track->TrackElementAt(171, NextElementPosition).Attribute == 0) && !StoppedWithoutPower)
            {
                FrontElementSpeedLimit = Track->TrackElementAt(172, LeadElement).SpeedLimit01; // use 01 for convenience, not used
                FrontElementLength = Track->TrackElementAt(173, LeadElement).Length01; // use 01 for convenience, not used
                EntrySpeed = 0;
                ExitSpeedHalf = 0;
                ExitSpeedFull = 0;
                MaxExitSpeed = 0;
                BrakeRate = 0;
                ExitTimeHalf = EntryTime;
                ExitTimeFull = EntryTime;
                if(!StoppedAtLocation) //if it is stopped at location then don't want StoppedAtSignal until departure time if still red then, & UpdateTrain takes care of thet
                {
                    StoppedAtSignal = true;
                    PlotTrainWithNewBackgroundColour(33, clSignalStopBackground, Display);
                    // TrainController->LogActionError(39, HeadCode, "", SignalHold, Track->TrackElementAt(754, NextElementPosition).ElementID);
                }
                if(StoppedAtLocation && (TrainMode == Signaller))
                {
                    // set both StoppedAtLocation & StoppedAtSignal, so that 'pass stop signal' is offered in popup menu rather than move
                    // forwards, but don't change the background colour so still shows as stopped at location
                    StoppedAtSignal = true;
                }
            }
            else
            {
                StoppedAtSignal = false;
                if(NextEntryPos > 1)
                {
                    ElementLength = Track->TrackElementAt(174, NextElementPosition).Length23;
                    SpeedLimit = Track->TrackElementAt(175, NextElementPosition).SpeedLimit23;
                }
                else
                {
                    ElementLength = Track->TrackElementAt(176, NextElementPosition).Length01;
                    SpeedLimit = Track->TrackElementAt(177, NextElementPosition).SpeedLimit01;
                }
                if(EntrySpeed > SpeedLimit)
                {
                    EntrySpeed = SpeedLimit;
                }
                if(EntrySpeed > MaxRunningSpeed)
                {
                    EntrySpeed = MaxRunningSpeed;
                }
                MaxExitSpeed = EntrySpeed;
                TDateTime TestTime = TrainController->TTClockTime; // test
                AnsiString TimeString = Utilities->Format96HHMMSS(TestTime); // test
                SetTrainMovementValues(2, NextElementPosition, NextEntryPos);
                // NextElement is the element to be entered

                // Precautionary check - If need to brake EntrySpeed may be too high, so set it to the speed at which
                // can achieve ExitSpeedFull at the half braking rate.
                if(ExitSpeedFull < EntrySpeed)
                {
                    double TempEntrySpeed = sqrt((MaxExitSpeed * MaxExitSpeed) + (3.6 * 3.6 * MaxBrakeRate * ElementLength));
                    // half braking
                    if(TempEntrySpeed < EntrySpeed)
                    {
                        EntrySpeed = TempEntrySpeed;
                        SetTrainMovementValues(3, NextElementPosition, NextEntryPos);
                    }
                }
            }
        }
        if(Track->TrackElementAt(178, LeadElement).Config[LeadExitPos] == NotSet)
        {
            throw Exception("Error, LeadElement Exit Connection is NotSet");
        }
    }
    if(MidElement > -1) // will be -1 if start on continuation
    {
        Straddle = LeadMid;
        GetOffsetValues(1, HOffset[0], VOffset[0], Track->TrackElementAt(179, LeadElement).Link[LeadExitPos]);
        GetOffsetValues(2, HOffset[1], VOffset[1], Track->TrackElementAt(180, LeadElement).Link[LeadEntryPos]);
        if(LowEntryValue(Track->TrackElementAt(181, LeadElement).Link[LeadEntryPos]))
        {
            for(int x = 0; x < 4; x++)
            {
                HeadCodePosition[x] = HeadCodeGrPtr[3 - x];
            }
        }
        else
        {
            for(int x = 0; x < 4; x++)
            {
                HeadCodePosition[x] = HeadCodeGrPtr[x];
            }
        }
        if(TrainMode == Timetable)
        {
            RailGraphics->ChangeForegroundColour(19, HeadCodePosition[0], FrontCodePtr, clFrontCodeTimetable, BackgroundColour);
        }
        else
        {
            RailGraphics->ChangeForegroundColour(20, HeadCodePosition[0], FrontCodePtr, clFrontCodeSignaller, BackgroundColour);
        }
        HeadCodePosition[0] = FrontCodePtr;
        // pick up background bitmaps [0] & [1] & plot HeadCodes [0] & [1]

        PickUpBackgroundBitmap(0, HOffset[0], VOffset[0], LeadElement, LeadEntryPos, BackgroundPtr[0]);
        PickUpBackgroundBitmap(1, HOffset[1], VOffset[1], LeadElement, LeadEntryPos, BackgroundPtr[1]);
/* Move check to AddTrain, also, now that can start on bridges need to check that other train is on same track before refusing
          if((Track->TrackElementAt(182, LeadElement).TrainIDOnElement > -1) || ((MidElement > -1) && (Track->TrackElementAt(183, MidElement).TrainIDOnElement > -1)))
          {
          ShowMessage("Can't place train " + HeadCode + "; another train already present at location");
          Utilities->CallLogPop(651);
          return false;
          }
*/
        PlotElement[0] = LeadElement;
        PlotEntryPos[0] = LeadEntryPos;
        PlotElement[1] = LeadElement;
        PlotEntryPos[1] = LeadEntryPos;
        PlotTrainGraphic(8, 0, Display);
        PlotTrainGraphic(9, 1, Display);

        GetOffsetValues(3, HOffset[2], VOffset[2], Track->TrackElementAt(184, MidElement).Link[MidExitPos]);
        GetOffsetValues(4, HOffset[3], VOffset[3], Track->TrackElementAt(185, MidElement).Link[MidEntryPos]);

        // pick up background bitmaps [2] & [3]

        PickUpBackgroundBitmap(2, HOffset[2], VOffset[2], MidElement, MidEntryPos, BackgroundPtr[2]);
        PickUpBackgroundBitmap(3, HOffset[3], VOffset[3], MidElement, MidEntryPos, BackgroundPtr[3]);

        PlotElement[2] = MidElement;
        PlotEntryPos[2] = MidEntryPos;
        PlotElement[3] = MidElement;
        PlotEntryPos[3] = MidEntryPos;
        PlotTrainGraphic(10, 2, Display);
        PlotTrainGraphic(11, 3, Display);
        // Plotted = true; set in PlotTrainGraphic
    }
    Display->Update(); // resurrected when Update() dropped from PlotOutput etc
    Utilities->CallLogPop(652);
}

// ---------------------------------------------------------------------------
void TTrain::UnplotTrain(int Caller)
{
    // Note:  If trouble is experienced with the PlotAlternativeTrackRouteGraphic functions remove them & test for train on a bridge and if so call Clearand..
    if(!Plotted)
    {
        return;
    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UnplotTrain," + HeadCode);

    if(Straddle == MidLag)
    {
        if(MidElement > -1)
        {
            PlotBackgroundGraphic(0, 0, Display);
            PlotBackgroundGraphic(1, 1, Display);
            PlotAlternativeTrackRouteGraphic(2, MidElement, MidEntryPos, HOffset[0], VOffset[0], MidLag);
            PlotAlternativeTrackRouteGraphic(3, MidElement, MidEntryPos, HOffset[1], VOffset[1], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
        if(LagElement > -1)
        {
            PlotBackgroundGraphic(2, 2, Display);
            PlotBackgroundGraphic(3, 3, Display);
            PlotAlternativeTrackRouteGraphic(4, LagElement, LagEntryPos, HOffset[2], VOffset[2], MidLag);
            PlotAlternativeTrackRouteGraphic(5, LagElement, LagEntryPos, HOffset[3], VOffset[3], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
    }
    else if(Straddle == LeadMidLag)
    {
        if(LeadElement > -1)
        {
            PlotBackgroundGraphic(4, 0, Display);
            PlotAlternativeTrackRouteGraphic(6, LeadElement, LeadEntryPos, HOffset[0], VOffset[0], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
        if(MidElement > -1)
        {
            PlotBackgroundGraphic(5, 1, Display);
            PlotBackgroundGraphic(6, 2, Display);
            PlotAlternativeTrackRouteGraphic(7, MidElement, MidEntryPos, HOffset[1], VOffset[1], MidLag);
            PlotAlternativeTrackRouteGraphic(8, MidElement, MidEntryPos, HOffset[2], VOffset[2], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
        if(LagElement > -1)
        {
            PlotBackgroundGraphic(7, 3, Display);
            PlotAlternativeTrackRouteGraphic(9, LagElement, LagEntryPos, HOffset[3], VOffset[3], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
    }
    else if(Straddle == LeadMid)
    {
        if(LeadElement > -1)
        {
            PlotBackgroundGraphic(8, 0, Display);
            PlotBackgroundGraphic(9, 1, Display);
            PlotAlternativeTrackRouteGraphic(10, LeadElement, LeadEntryPos, HOffset[0], VOffset[0], MidLag);
            PlotAlternativeTrackRouteGraphic(11, LeadElement, LeadEntryPos, HOffset[1], VOffset[1], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
        if(MidElement > -1)
        {
            PlotBackgroundGraphic(10, 2, Display);
            PlotBackgroundGraphic(11, 3, Display);
            PlotAlternativeTrackRouteGraphic(12, MidElement, MidEntryPos, HOffset[2], VOffset[2], MidLag);
            PlotAlternativeTrackRouteGraphic(13, MidElement, MidEntryPos, HOffset[3], VOffset[3], LeadMidLag);
            // to force plot of locked route marker, needed once only for the element
        }
    }
    if(LeadElement > -1)
    {
        ResetTrainElementID(1, LeadElement, LeadEntryPos);
    }
    if(MidElement > -1)
    {
        ResetTrainElementID(2, MidElement, MidEntryPos);
    }
    if(LagElement > -1)
    {
        ResetTrainElementID(3, LagElement, LagEntryPos);
    }
    Plotted = false;
    BackgroundColour = clNormalBackground;
    Display->Update();
    // without this the screen 'blinks' at next Clearand... prob forces a full repaint for some reason
    // resurrected when Update() dropped from PlotOutput etc
    Utilities->CallLogPop(653);
}

// ----------------------------------------------------------------------------

void TTrain::UpdateTrain(int Caller)
/*
      Note:  Some changes made since comments written

      Brief:
      Enter with Straddle defining train position wrt Lag, Mid & Lead elements.  Is only MidLag at this point
      on first entry at a continuation (with no train plotted), in all other cases it is either LeadMid (when train fully
      on Lead & Mid elements) or LeadMidLag (when train straddling 3 elements).
      Thereafter on entry Straddle = LeadMidLag or LeadMid; LeadMid if train fully on Mid & Lead elements, and
      LeadMidLag if on Lag, Mid and Lead elements (back on lag, front on Lead, & middle 2 segments on Mid).
      If enter with Straddle = LeadMid, then train is in effect in the first half of the next element, and moves half onto it after
      the half time point has been passed.  The values for the next element were set when the train was last updated when Straddle became
      LeadMid from LeadMidLag.  After the half time point has been passed Straddle is
      changed to MidLag within the function and all elements moved down one, old Mid becomes
      the new lag, old Lead becomes the new Mid, and a new Lead is obtained.  Then the new positions are plotted, and finally Straddle is
      incremented to reflect the position the train now occupies.

      Detail:
      Set TrainFailurePending if all conditions met
      Check whether stopped at a non-red signal, and if so reset StoppedAtSignal so train can move.
      Check whether buffers at immediate exit, either when first enter the function or later, and set StoppedAtBuffers if so
      and return.
      If Straddle == LeadMid then train fully on Lead and Mid, so ready for a major update:-
      If there's a LagElement (there will be but include check for good practice - next
      function depends on it) Check whether DerailPending set - set during last GetLeadElement if appropriate but only acted on here when
      train fully on offending point - Derail set and DerailPanding reset, train background
      colour changed (note that BackgroundColour is a property of the train itself) then return.
      If no derail pending reset Lag and Mid elements to the old Mid and Lead values, reset Straddle to MidLag, then set
      the new LeadElement, which will be the next connected element (obtain using GetLeadElement) or -1 if the current
      LeadElement is an exit continuation.  During GetLeadElement the element at LeadElement is checked and if a stop
      signal is found StoppedAtSignal is set to true, otherwise StoppedAtSignal is set to false.  Also Derail is set
      if LeadElement is a fouled trailing point.
      Now, the train is moved on by one segment.  Firstly the last BackgroundElement is set to LagElement, then the last
      segment of the LagElement is unplotted (if there is a LagElement - may be entering at a continuation), by
      replotting the last background segment and checking whether the element is a bridge or crossover with the other
      track in a route, in which case the route colour is replotted.
      Then, if Straddle == LeadMidLag (train will move completely off the element during this function), and the train
      track is in a route, then all the train elements are removed from the route unless it's an autosig route.  Normally only the
      LeadElement will be in a route for a moving train, but when originally placed all elements may be in the route so check them all.
      Note also that there may be two routes at a given element position, but only one of them is the correct one, so this
      is identified prior to the removal.  Also the TrainIDs are reset because the train will be fully off this element at the end of
      the function.  If Straddle == LeadMidlag and the element being left is a ContinuationExit the the TrainGone flag is set so the
      train can be deleted by the calling function, and the function returns.
      If the element is a signal in the train movement direction, then it is reset to red (Attribute = 0) and is replotted
      to show the red aspect.  Finally if element is a signal in the other direction it is replotted as it was - need to
      plot individually because could have any aspect, the background bitmap that was picked up earlier contains just the
      basic red aspect.

      Now all the array values are updated, but the [0] values are as yet invalid, these have to be obtained explicitly from
      the new LeadElement later.  The headcode graphics are updated so that it reads correctly - left to right & top to bottom,
      regardless of direction, and with the correct front code colour.

      The new front segment background bitmap is now picked up and the graphic offsets set, and the segments are plotted.
      No more unplotting is needed as all but the last segment are overwritten by later segments, and the new front
      segment is just plotted, though the background bitmap at that location has to be picked up.  Just where they are
      plotted depends on the Straddle value, [0] is always on Lead, [1] is on Lead if Straddle == LeadMidLag or Mid if
      Straddle == MidLag; [2] is always on Mid, and [3] is on Mid if Straddle == LeadMidLag or Lag if Straddle == MidLag.
      Also prior to plotting the lead segment a crash check is made, and if true the Crashed flag is set and the
      TrainCrashedInto value also set to the current TrainID - this is so it too becomes crashed and hence stopped.

      The Crashed flag is now checked, and if set the front headcode colour is changed to the same as the rest of the code,
      and the background colour changed.  Then the train that is crashed into is also set to Crashed, and its colours
      changed similarly.  The function then returns.

      If Crashed is not set then Straddle is incremented and the function returns.
*/

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UpdateTrain," + HeadCode);
    UpdateCounter++;
    // 100 counts = 5secs (used in splits to prevent too frequent length checks in front & rear splits)
    if(UpdateCounter >= 100)
    {
        UpdateCounter = 0;
    }
    int RandRange = (TrainController->MTBFHours * 3600) / 53;

    // MTBFHours is in timetable clock hours, min value is 1 & max value is 9,999 (integer values on input)
    // but double on use because it represents timetable clock time, so at 1/16 speed RandRange is * 16 (160,000 max) & at 16x speed its /16 (1/16 min)
    // i.e MTBFHours is Input value/TTClockSpeed (conversion is done in InterfaceUnit)
    if(int(TrainController->RandomFailureCounter) == (rand() % 1060))
    // RandomFailureCounter value is fixed for a full cycle of train updates so this
    // makes sure there's no bunching of failures as there is for a fixed comparison number
    // or a small range of comparison numbers.  True every 53 secs (real time) on average rand()
    // gives a random number between 0 and 16384 (defined as RAND_MAX in stdlib.h)
    {
        if(!TrainFailed && !TrainOnContinuation(0) && (RandRange > 0) && (PowerAtRail > 1) && !((TrainMode == Timetable) && TimetableFinished)
           && !Crashed && !Derailed && !((TrainMode == Signaller) && Stopped()))
        // RandomFailureCounter resets to 0 every 53 secs, if RandRange is 0 then no failure rate is set - i.e. failure rate = 0
        // don't fail if:
        // (a) on a continuation (entering or leaving);
        // (b) already failed;
        // (c) power effectively zero (8000) min value for powered; 0.08 for 'no power';
        // (d) train terminated;
        // (e) crashed or derailed; or
        // (f) under signaller control and stopped.
        // (g) TreatPassAsTimeLocDeparture is true  //added at v2.12.0
        {
            if((random(RandRange) == 0) && !TreatPassAsTimeLocDeparture) //!TreatPassAsTimeLocDeparture added at v2.12.0
            // max value for RandRange is over 2x10^9
            {
                // here if failure due
                TrainFailurePending = true;
                // fail when PlotElements set to proper Lead & Mid Elements
            }
        }
    }
/* dropped as it allows a train to stop on a half element - when reach (if Stopped()) at line 1310
   if ((PowerAtRail < 1) && (EntrySpeed < 1)) // added at v2.4.0
   {
       StoppedWithoutPower = true;
   }
*/
//    float TimeToExit; //added at v2.10.0  Removed these so original values retained - used when train on continuation
//    THVShortPair ExitPair; //added at v2.10.0
    int LockedVectorNumber;
    Graphics::TBitmap *EXGraphicPtr = RailGraphics->bmTransparentBgnd;
    // default values - these needed for route checker below
    Graphics::TBitmap *EntryDirectionGraphicPtr = RailGraphics->bmTransparentBgnd;

    if(!SignallerStoppingFlag)
    {
        SignallerStopBrakeRate = 0;
    }
    if(Crashed || Derailed)
    {
        if(Crashed && Track->IsLCAtHV(41, Track->TrackElementAt(875, LeadElement).HLoc, Track->TrackElementAt(876, LeadElement).VLoc))
        {
            PlotTrain(7, Display);
            // replotted every cycle because of level crossing crashes, otherwise a flashing level crossing wipes out half of the train
            Display->Update();
        }
        OpTimeToAct = 0.0;
        // need to set this here as wouldn't be calculated otherwise as return from UpdateTrain
        Utilities->CallLogPop(1017);
        return; // no further action, user has to remove or work around
    }
    if(StoppedForTrainInFront && !RevisedStoppedAtLoc() && !Crashed && !Derailed && !TrainFailed)
    {
        PlotTrainWithNewBackgroundColour(42, clStoppedTrainInFront, Display);
    }
    if(SignallerStopped && !StoppedForTrainInFront && !StoppedAtBuffers && !RevisedStoppedAtLoc() && !Crashed && !Derailed && !TrainFailed)
    {
        PlotTrainWithNewBackgroundColour(43, clSignallerStopped, Display);
    }
    if(StoppedWithoutPower && (TrainMode == Signaller)) //added at v2.13.2 as this condition not covered - was shown as normal
    {
        PlotTrainWithNewBackgroundColour(53, clSignallerStopped, Display);
    }
    if(ActionVectorEntryPtr->FormatType != TimeTimeLoc)
    // introduced at v1.2.0, formerly 'TimeTimeLocArrived = false' was included
    // in the next condition 'if(!Stopped() && !SPADFlag)' which led to repeated arrival messages if signaller control allowed a train
    // to move & then stop again at the same station
    {
        TimeTimeLocArrived = false;
    }
    if(!Stopped() && !SPADFlag && !TrainFailed)
    {
        PlotTrainWithNewBackgroundColour(44, clNormalBackground, Display);
    }
    // set or release StoppedAtBuffers if fully on 2 elements depending on LeadElement
    // Note that if LeadElement == Buffers train must be facing the buffer so no need to check orientation
/* old version where force a stop at buffers regardless of speed
      if((Straddle == LeadMid) && (LeadElement > -1) && (Track->TrackElementAt(, LeadElement).TrackType == Buffers)) StoppedAtBuffers = true;
      else StoppedAtBuffers = false;
*/

    // new version where crash if run into buffers
    if(!Crashed)
    {
        if((Straddle == LeadMid) && (LeadElement > -1) && (Track->TrackElementAt(602, LeadElement).TrackType == Buffers))
        {
            if(ExitSpeedFull > 1)
            {
                Crashed = true;
                RailGraphics->ChangeForegroundColour(24, HeadCodePosition[0], HeadCodePosition[0], clB0G0R0, BackgroundColour);
                PlotTrainWithNewBackgroundColour(40, clCrashedBackground, Display); // red
                TrainController->LogActionError(35, HeadCode, "", FailBufferCrash, Track->TrackElementAt(719, LeadElement).ElementID);
                // SendMissedActionLogs(3, -1, ActionVectorEntryPtr);//-1 is a marker for send messages for all remaining entries, including Fer if present
                // no need for missed action logs - will be sent when train removed
                StoppedAtBuffers = false;
            }
            else if(!RevisedStoppedAtLoc() && !StoppedWithoutPower)
            // stopped at location & stopped without power take precedence
            {
                StoppedAtBuffers = true;
            }
            else
            {
                StoppedAtBuffers = false;
            }
        }
        else
        {
            StoppedAtBuffers = false;
        }
    }
    else
    {
        StoppedAtBuffers = false;
    }
    // if crashed don't want stopped at buffers set

    // also crash if run into a level crossing that is changing or has barriers up
    if(!Crashed)
    {
        if((Straddle == LeadMid) && (LeadElement > -1) && (ExitSpeedFull > 1))
        {
            int H = Track->TrackElementAt(873, LeadElement).HLoc;
            int V = Track->TrackElementAt(874, LeadElement).VLoc;
            if(Track->IsLCAtHV(40, H, V) && !Track->IsLCBarrierDownAtHV(2, H, V))
            {
                Crashed = true;
                RailGraphics->ChangeForegroundColour(26, HeadCodePosition[0], HeadCodePosition[0], clB0G0R0, BackgroundColour);
                PlotTrainWithNewBackgroundColour(47, clCrashedBackground, Display); // red
                TrainController->LogActionError(54, HeadCode, "", FailLevelCrossingCrash, Track->TrackElementAt(877, LeadElement).ElementID);
                // no need for missed action logs - will be sent when train removed
            }
        }
    }
    if(StoppedAtBuffers && !BufferZoomOutFlashRequired && !RevisedStoppedAtLoc() && !Crashed && !Derailed)
    {
        PlotTrainWithNewBackgroundColour(37, clBufferStopBackground, Display);
    }
    // set or reset HoldAtLocationInTTMode (if true then actions are needed before train departs)
    if((TrainMode == Timetable) && RevisedStoppedAtLoc() && (ActionVectorEntryPtr->Command != "") && !((ActionVectorEntryPtr->Command == "pas") && TreatPassAsTimeLocDeparture))
    //if Command == "" then either TimeLoc or TimeTimeLoc so don't hold, and added last part at v2.12.0 so don't hold if have both command == pas and Treat... flag
    {
        HoldAtLocationInTTMode = true;
    }
    else if(TrainMode == Timetable)
    {
        HoldAtLocationInTTMode = false;
    }
    // in Signaller mode HoldAtLocationInTTMode not changed

    // check if departure pending & set times unless already set
    if(TrainMode == Timetable)
    {
        if(!DepartureTimeSet && RevisedStoppedAtLoc())
        // && !StoppedAtBuffers) - drop this, set times whether or not at buffers
        {
            if((ActionVectorEntryPtr->Command != "pas") && (ActionVectorEntryPtr->DepartureTime > TDateTime(-1)) && (ActualArrivalTime > TDateTime(0)))
            {
                AnsiString ReasonArray[24] = {"a driver is awaited","a guard is awaited","of a medical emergency","of a technical problem","of a security issue",
                    "of a safety issue","of a disturbance","a train crew member has been taken ill","the driver has been taken ill","the guard has been taken ill",
                    "a report has been received concerning safety","a shoe has been lost under the train","of a reported theft",
                    "of an incident involving an animal","some luggage has been lost under the train","a minor repair is needed","a suspicious object has to be dealt with safely",
                    "a door is stuck open","additional stock has to be attached","a security alert","of a train fault","of an operating incident","safety checks are required",
                    "of a shortage of on train crew"};
                //(ActionVectorEntryPtr->Command != "pas") added at v2.13.0 to rule out passes, though probably not needed
                //(ActualArrivalTime > TDateTime(0)) added at v2.13.0 to ensure that it has been set and to dismiss trains that are present
                //at start or have no departure time set.
                NewDelay = 0; //section relating to random delays added at v2.13.0
                TDateTime TimetableReleaseTime = TrainController->GetRepeatTime(0, ActionVectorEntryPtr->DepartureTime, RepeatNumber, IncrementalMinutes);  //Timetable value
                TDateTime DwellTime = TimetableReleaseTime - ActualArrivalTime; //Timetable value
                if(DwellTime < TDateTime(30.0 / 86400))
                {
                    DwellTime = TDateTime(30.0 / 86400);
                }
                int randval = random(10000);
                if(randval != 0)  //if randval == 0 or DelayMode == Nil then NewDelay will be 0 as set above
                {
                    if(Utilities->DelayMode == Minor)
                    {
                        if(randval < Utilities->MinorDelayCutoff)
                        {
                            NewDelay = Utilities->MinorDelayFactor * log(Utilities->MinorDelayCutoff/randval);//minutes (confusingly log in C++Builder gives the natural logarithm)
                        }
                    }
                    else if(Utilities->DelayMode == Moderate)
                    {
                        if(randval < Utilities->ModerateDelayCutoff)
                        {
                            NewDelay = Utilities->ModerateDelayFactor * log(Utilities->ModerateDelayCutoff/randval);
                        }
                    }
                    else if(Utilities->DelayMode == Major)
                    {
                        if(randval < Utilities->MajorDelayCutoff)
                        {
                            NewDelay = Utilities->MajorDelayFactor * log(Utilities->MajorDelayCutoff/randval);
                        }
                    }
                }
//NewDelay = 25; //test
                if(double(TrainController->TTClockTime) <= (Utilities->LastDelayTTClockTime + 5.0/1440.0)) //if within 5 mins of last delay for any train
                {                                                                                      //then don't delay.  Added at v2.13.0
                    NewDelay = 0;
                }
                if(NewDelay < 1)
                {
                    NewDelay = 0;
                }
                if(NewDelay < double(DwellTime) * 1440) //if less than scheduled dwell time then no additional delay
                {
                    NewDelay = 0;
                }
                else
                {
                    NewDelay -= double(DwellTime) * 1440;//reduce delay by dwell time
                }
                if(DelayedRandMins > 0)
                {
                    DelayedRandMins -= double(DwellTime) * 1440;//reduce knock-on random delay by dwell time
                }
                if(DelayedRandMins < 0)
                {
                    DelayedRandMins = 0;//can't be less than zero
                }
                if(NewDelay > DelayedRandMins)
                {
                    NewDelay -= DelayedRandMins;  //NewDelay is the additional delay over and above the existing knock-on delay (from earlier random delays)
                                                  //the formula above already includes knock-on effects
                    DelayedRandMins += NewDelay;  //the new total delay, knock-on + additional
//                    CumulativeDelayedRandMinsOneTrain += DelayedRandMins;  //don't add here, add when depart, else this value can be > late mins
                }
                else
                {
                    NewDelay = 0;
//                    CumulativeDelayedRandMinsOneTrain += DelayedRandMins;  //as above
                }
                ReleaseTime = LastActionTime + TDateTime(NewDelay / 1440);  //earliest possible release time
                if(NewDelay < 0.5) //less than the 30 secs min interval
                {
                    ReleaseTime = LastActionTime + TDateTime(30.0 / 86400);
                }
                if(ReleaseTime < TimetableReleaseTime)
                {
                    ReleaseTime = TimetableReleaseTime; //back to correct time
                    NewDelay = 0;
                    DelayedRandMins = 0;
                }
                if(DelayedRandMins > double(ReleaseTime - TimetableReleaseTime) * 1440)
                {
                    DelayedRandMins = double(ReleaseTime - TimetableReleaseTime) * 1440; //reduce this if time has been made up
                }

                if(DelayedRandMins < NewDelay) //may be if reduced above, but if so need to reduce NewDelay also
                {
                    NewDelay = DelayedRandMins;
                }
                //may be possible to simplify all the above but as it seems to work ok leave as is
                if(int(NewDelay) > 0) //additional delay over and above knock-on effects from earlier random delays
                {
                    Utilities->LastDelayTTClockTime = double(TrainController->TTClockTime);
                    if(int(NewDelay) == 1)
                    {
                        Display->WarningLog(12, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + HeadCode + " delayed at " +
                                ActionVectorEntryPtr->LocationName + " by 1 minute");
                        PerfLogForm->PerformanceLog(18, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: " + HeadCode + " delayed at " +
                                ActionVectorEntryPtr->LocationName + " by 1 minute because of a minor technical issue");
                        TrainController->StopTTClockMessage(140, HeadCode + " delayed at " +
                                ActionVectorEntryPtr->LocationName + " by 1 minute because of a minor technical issue");
                    }
                    else
                    {
                        Display->WarningLog(11, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + HeadCode + " delayed at " +
                                ActionVectorEntryPtr->LocationName + " by " + AnsiString(int(NewDelay)) + " minutes");
                        if(NewDelay >= 10) //give variable reasons for >= 10 mins
                        {
                            int randval2 = rand() % 24; //24 reasons
                            AnsiString Reason = ReasonArray[randval2];
                            PerfLogForm->PerformanceLog(19, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: " +
                                    HeadCode + " delayed at " + ActionVectorEntryPtr->LocationName + " by " + AnsiString(int(NewDelay)) +
                                    " minutes because " + Reason);
                            TrainController->StopTTClockMessage(141, HeadCode + " delayed at " + ActionVectorEntryPtr->LocationName + " by " + AnsiString(int(NewDelay)) +
                                    " minutes because " + Reason);
                        }
                        else
                        {
                            PerfLogForm->PerformanceLog(20, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: " +
                                    HeadCode + " delayed at " + ActionVectorEntryPtr->LocationName + " by " + AnsiString(int(NewDelay)) +
                                    " minutes because of a minor problem");
                            TrainController->StopTTClockMessage(142, HeadCode + " delayed at " + ActionVectorEntryPtr->LocationName + " by " + AnsiString(int(NewDelay)) +
                                    " minutes because of a minor problem");
                        }
                    }
                }
                TRSTime = ReleaseTime - TDateTime(10.0 / 86400);
                ActualArrivalTime = TDateTime(0); //only run through this section once per arrival
                DepartureTimeSet = true;
            }
            else if(ActionVectorEntryPtr->DepartureTime > TDateTime(-1)) //as was, for trains that don't have an errival time set
            {//if have skipped to a new service then DepartureTime will be set (in above segement when earlier train arrived)
            //but ArrivalTime won't be set as it is reset to 0 at end of above segement when earlier train arrived, so this segement
            //will run without any random delays which might cause additional complications from mixing modifications and best avoided.
                NewDelay = 0;
                DelayedRandMins = 0;
                ReleaseTime = TrainController->GetRepeatTime(75, ActionVectorEntryPtr->DepartureTime, RepeatNumber, IncrementalMinutes);
                if(ReleaseTime <= LastActionTime + TDateTime(30.0 / 86400))
                {
                    ReleaseTime = LastActionTime + TDateTime(30.0 / 86400);
                }
                TRSTime = ReleaseTime - TDateTime(10.0 / 86400);
                DepartureTimeSet = true;
            }
            else if((ActionVectorEntryPtr->Command == "pas") && TreatPassAsTimeLocDeparture) //new segment at v2.12.0 to treat a pass as a departure
            {//for when skip to a new service at a pass location. As above this also avoids any random delays, and will avoid above segment because
            //departure time isn't set - it's an event time.  Again random delays in this situation might cause additional complications
             //from mixing modifications so best avoided.
                NewDelay = 0;
                DelayedRandMins = 0;
                ReleaseTime = TrainController->GetRepeatTime(74, ActionVectorEntryPtr->EventTime, RepeatNumber, IncrementalMinutes);
                if(ReleaseTime <= LastActionTime + TDateTime(30.0 / 86400))
                {
                    ReleaseTime = LastActionTime + TDateTime(30.0 / 86400);
                }
                TRSTime = ReleaseTime - TDateTime(10.0 / 86400);
                DepartureTimeSet = true;
            }
        }
    }
    if(TrainController->OpTimeToActUpdateCounter == 0)// && TrainController->OpActionPanelVisible) removed last condition so always calc TimeToExit
    {
        OpTimeToAct = CalcTimeToAct(0, TimeToExit, ExitPair); // called after ReleaseTime set
//        this->TimeToExit = TimeToExit;  don't need these as values updated directly
//        this->ExitPair = ExitPair;
        // calculate every 1 sec (in real time, not timetable time) for all trains
    }
    // check if being held at location pending any actions & deal with them if time appropriate & >= 30s since LastActionTime
    if(TrainMode == Timetable)
    {
        if((ActionVectorEntryPtr->Command != "Frh") && (ActionVectorEntryPtr->Command != "Frh-sh"))
        {
            RemainHereLogNotSent = true;
        }
        if(HoldAtLocationInTTMode)
        {
            // ignore TimeLoc & TTLoc departures
            // Action logs given in functions
            if((TrainController->TTClockTime >= GetTrainTime(0, ActionVectorEntryPtr->EventTime)) && (TrainController->TTClockTime >=
                                                                                                      LastActionTime + TDateTime(30.0 / 86400)))
            {
                if(ActionVectorEntryPtr->Command == "fsp")
                {
                    // added for v1.3.2 because when add new train to TrainVector 'this' address likely invalidated, hence make no more changes to 'this' train.  Next clock cycle will deal with any required changes
                    FrontTrainSplit(0);
                    if(TrainFailurePending) // ok, stopped so PlotElements set
                    {
                        TrainHasFailed(0);
                    }
                    Utilities->CallLogPop(2041);
                    return;
                }
                else if(ActionVectorEntryPtr->Command == "rsp")
                {
                    // added for v1.3.2 because when add new train to TrainVector 'this' address likely invalidated, hence make no more changes to 'this' train.  Next clock cycle will deal with any required changes
                    RearTrainSplit(0);
                    if(TrainFailurePending) // ok, stopped so PlotElements set
                    {
                        TrainHasFailed(1);
                    }
                    Utilities->CallLogPop(2042);
                    return;
                }
                else if(ActionVectorEntryPtr->Command == "Fjo")
                {
                    FinishJoin(0);
                }
                else if(ActionVectorEntryPtr->Command == "jbo")
                {
                    JoinedBy(0);
                }
                else if(ActionVectorEntryPtr->Command == "cdt")
                {
                    ChangeTrainDirection(0, false);
                }
                else if(ActionVectorEntryPtr->Command == "Fns")
                {
                    NewTrainService(0, false);
                }
                else if(ActionVectorEntryPtr->Command == "Frh")
                {
                    RemainHere(0);
                }
                else if(ActionVectorEntryPtr->Command == "Fer")
                {
                    TimetableFinished = true;
                }
                // other aspects of 'Fer' dealt with in TTrain::HasTrainGone()
                else if(ActionVectorEntryPtr->Command == "F-nshs")
                {
                    NewShuttleFromNonRepeatService(0, false);
                }
                else if(ActionVectorEntryPtr->Command == "Frh-sh")
                {
                    RepeatShuttleOrRemainHere(0, false);
                }
                else if(ActionVectorEntryPtr->Command == "Fns-sh")
                {
                    RepeatShuttleOrNewNonRepeatService(0, false);
                }
/*
                  F-nshs (FNSShuttle) = Finish New Service (Shuttle) = finish, form new shuttle service in same direction, details =
                  shuttle headcode (no train creation)
                  Frh-sh (TimeCmdHeadCode) = Finish then restart as a shuttle using Snt-sh or Sns-sh, when all shuttle repeats done
                  remain here
                  Fns-sh (FSHNewService) = Finish then restart as a shuttle using Snt-sh or Sns-sh, when all shuttle repeats done
                  form new service via Sns-fsh using the NonRepeatingShuttleLinkHeadCode
*/
            }
        }
        else
        {
            if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailLocTooShort)
            {
                TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
            }
        }
    }
    if(TrainMode == Timetable)
    {
        if(StoppedAtBuffers)
        {
            // error if buffers (& element before it) not at a location, or if buffer location different to ActionVectorEntryPtr location
            // if buffer location same as ActionVectorEntryPtr location & not Frh then error will be given for inability to depart
            AnsiString BufferLocation = Track->TrackElementAt(604, LeadElement).ActiveTrackElementName;
            if(BufferLocation == "")
            {
                BufferLocation = Track->TrackElementAt(605, Track->TrackElementAt(606, LeadElement).Conn[1]).ActiveTrackElementName;
            }
            AnsiString ExpectedLocation = ActionVectorEntryPtr->LocationName;
            if((BufferLocation == "") || (BufferLocation != ExpectedLocation))
            {
                BufferZoomOutFlashRequired = true;
                PlotTrainWithNewBackgroundColour(38, clBufferAttentionNeeded, Display);
                if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailUnexpectedBuffers)
                {
                    TrainController->LogActionError(1, HeadCode, "", FailUnexpectedBuffers, Track->TrackElementAt(603, LeadElement).ElementID);
                    // SendMissedActionLogs(-1, ActionVectorEntryPtr);//-1 is a marker for send messages for all remaining entries, including Fer if present
                    // Drop missed actions so user can still use sig mode to get back on track
                    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailUnexpectedBuffers;
                }
                if(TrainFailurePending) // ok, stopped so PlotElements set
                {
                    BufferZoomOutFlashRequired = false;
                    TrainHasFailed(2);
                }
                Utilities->CallLogPop(1020);
                return;
            }
            else if((BufferLocation != "") && (BufferLocation == ExpectedLocation) && DepartureTimeSet && !RevisedStoppedAtLoc() && (TrainController->TTClockTime >
                                                                                                                                 ReleaseTime))
            {
                BufferZoomOutFlashRequired = true;
                if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailBuffersPreventingStart)
                {
                    PlotTrainWithNewBackgroundColour(39, clBufferAttentionNeeded, Display);
                    TrainController->LogActionError(2, HeadCode, "", FailBuffersPreventingStart, ExpectedLocation);
                    // SendMissedActionLogs(-1, ActionVectorEntryPtr);//-1 is a marker for send messages for all remaining entries, including Fer if present
                    // Drop missed actions so user can still use sig mode to get back on track
                    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailBuffersPreventingStart;
                }
                if(TrainFailurePending) // ok, stopped so PlotElements set
                {
                    BufferZoomOutFlashRequired = false;
                    TrainHasFailed(3);
                }
                Utilities->CallLogPop(1397);
                return;
            }
        }
        else
        {
            BufferZoomOutFlashRequired = false;
        }
    }
    else
    {
        BufferZoomOutFlashRequired = false;
    }
    if(TrainMode == Timetable)
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailUnexpectedBuffers)
        {
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
        }
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailBuffersPreventingStart)
        {
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
        }
    }
    // Pick up element next to the train front (if exists) to check for calling-on, restart after a cleared signal, or
    // restart after stopped for train in front
    int NextElementPosition, NextEntryPos;

    if(LeadElement > -1) // if an exit continuation then not set
    {
        if((Track->TrackElementAt(186, LeadElement).TrackType != Points) || ((LeadEntryPos != 0) && (LeadEntryPos != 2)))
        {
            LeadExitPos = Track->GetNonPointsOppositeLinkPos(LeadEntryPos);
        }
        else if((Track->TrackElementAt(187, LeadElement).TrackType == Points) && ((LeadEntryPos == 0) || (LeadEntryPos == 2)))
        {
            if(Track->TrackElementAt(188, LeadElement).Attribute == 0)
            {
                LeadExitPos = 1;
            }
            else
            {
                LeadExitPos = 3;
            }
        }
        NextElementPosition = Track->TrackElementAt(189, LeadElement).Conn[LeadExitPos];
        NextEntryPos = Track->TrackElementAt(190, LeadElement).ConnLinkPos[LeadExitPos];
    }
    else
    {
        NextElementPosition = -1;
        NextEntryPos = -1;
    }
    if((NextElementPosition > -1) && (NextEntryPos > -1))
    // may be buffers or continuation so need this check
    {
/*
          Check whether calling-on conditions met:-
          a) approaching train has stopped at a signal but not at a location;
          b) if there is a facing train at the station, it is being held appropriately (must be awaiting a join (Fjo or jbo) or a
              change of direction (cdt), remaining here (Frh), or under signaller control);
          c) at least 1 platform available for the approaching train;
          d) points (if any) set for direct route into platform;
          e) approaching train is to stop at station;
          f) no more facing signals between train and platform;
          g) [dropped g]
          h) train in front preventing route being set far enough to release stop signal;
          i) train in front not exiting at continuation;
          j) signal must be within 4km of the stop platform;
          k) [dropped (k), now can set a reoute or part route into platform so can set points more easily];
          l) no existing route conflicts with the route into the platform; and
          m) not failed or without power (these added at v2.10.0)
          If all OK & route or part route not already set then set an unrestricted route into the station (just to the first platform), to prevent point changing or
          other route conflicts - if a partial route set than can still change points outside the route or have a route conflict if another route is set.
*/
        if(TrainMode == Timetable)
        {
            if(CallingOnAllowed(0)) //returns false if failed or no power (modified afer v2.9.2)
            {
                CallingOnFlag = true;
                PlotTrainWithNewBackgroundColour(1, clCallOnBackground, Display); // calling-on background
            }
            else
            {
                if(CallingOnFlag) //TrainHasFailed sets this flag to false (at v2.10.0)
                {
                    if(!TrainFailed) //shouldn't be needed but include for safety at v2.10.0
                    {
                        PlotTrainWithNewBackgroundColour(2, clSignalStopBackground, Display);
                    }
                }
                CallingOnFlag = false;
            }
        }
        if(StoppedAtSignal && ((Track->TrackElementAt(191, NextElementPosition).Attribute > 0) || AllowedToPassRedSignal) && !TrainFailed && !RevisedStoppedAtLoc())
        {
            //'&& !StoppedAtLocation' added at v2.7.0 as if had been stopped at signal before tt control restored then background colour changed to normal when signal changed from red
            // reset PassRedSignal when reached half-way point in next element, if reset here then SetTrainMovementValues
            // sets StoppedAtSignal again & train doesn't move
            StoppedAtSignal = false;
            // need to recalculate exit times since old entry time expired. Straddle now at MidLag with front of train on MidElement
            // hence use MidElement for the calculation so same as would have been used if signal not red, when Straddle was
            // LeadMidLag and front of train was on LeadElement (after the current move)
            PlotTrainWithNewBackgroundColour(36, clNormalBackground, Display);
            EntrySpeed = 0;
            EntryTime = TrainController->TTClockTime;
            FirstHalfMove = true;
            SetTrainMovementValues(4, NextElementPosition, NextEntryPos);
            // NextElement is the element to be entered
        }
        if(StoppedForTrainInFront)
        {
            if(ClearToNextSignal(0))
            {
                StoppedForTrainInFront = false;
                BeingCalledOn = false;
                EntrySpeed = 0;
                EntryTime = TrainController->TTClockTime;
                FirstHalfMove = true;
                SetTrainMovementValues(16, NextElementPosition, NextEntryPos);
            }
            else
            {
                if(TrainFailurePending) // ok, stopped so PlotElements set
                {
                    TrainHasFailed(4);
                }
                Utilities->CallLogPop(1097);
                return;
            }
        }
    }
    if((Straddle == MidLag) && (LeadElement != -1))
    // later check only for Straddle == LeadMid, so need this check here for initial train start
    {
        CheckAndCancelRouteForWrongEndEntry(1, LeadElement, LeadEntryPos);
    }
/*    Logic below as follows: This check is made to allow a restart if had StoppedAtLocation or StoppedForTrainInFront or
      both but potentially able to restart (i.e. not at buffers, not crashed, not derailed, not held at location, departure
      time due, no train in front now & no other stop condition).  Note that can be StoppedForTrainInFront when not at a
      location since this is set in SetTrainMovementValues whenever a train has zero EntrySpeed and there is a train in front,
      which could be when start as Snt.
      If StoppedForTrainInFront but not StoppedAtLocation then need to set TRSTime high so pink not plotted, and ReleaseTime
      low so can restart if appropriate.  BeingCalledOn was set so that when train stopped at a station it wouldn't restart
      until the line was clear of trains up to the next signal.  Hence check whether BeingCalledOn & if so set
      StoppedForTrainInFront, this ensures two things - that the restart check is carried out at each cycle and also that
      a restart won't happen until the line is clear to the next signal, regardless of whether or not the ReleaseTime has been
      reached.
      Then check if TRS time reached & change background to pink if so, & check if release time reached & if so change
      background to white and clear StoppedAtLocation.  Then make check of station name, and recheck StoppedForTrainInFront,
      if it's set check if ClearToNextSignal and if so clear StoppedForTrainInFront & BeingCalledOn.  If not ClearToNextSignal
      then return.  If either not StoppedForTrainInFront or ClearToNextSignal then restart, calling SetTrainMovementValues &
      sending a message to the performancelog.
*/

    if(TrainMode == Timetable)
    {
        if(RevisedStoppedAtLoc() && !StoppedAtBuffers && !Crashed && !Derailed && !HoldAtLocationInTTMode && !TrainFailed)
        {
            if(BeingCalledOn)
            {
                StoppedForTrainInFront = true;
            }
            if(TrainController->TTClockTime >= TRSTime)
            {
                PlotTrainWithNewBackgroundColour(19, clTRSBackground, Display); // light pink
            }
            else //added at v2.14.0 as if a train ready to depart (pink b'gnd) taken under sig control then restored to tt control b'gnd stayed pink,
            {    //even though release time now 30 seconds after tt control restored
                PlotTrainWithNewBackgroundColour(54, clStationStopBackground, Display); // light green
            }
            if(TrainController->TTClockTime >= ReleaseTime)
            {
                // value updated at every scheduled departure & arrival
                PlotTrainWithNewBackgroundColour(20, clNormalBackground, Display);
                AnsiString StationName;
                if(Track->TrackElementAt(193, LeadElement).ActiveTrackElementName != "")
                {
                    StationName = Track->TrackElementAt(194, LeadElement).ActiveTrackElementName;
                }
                else if(Track->TrackElementAt(195, MidElement).ActiveTrackElementName != "")
                {
                    StationName = Track->TrackElementAt(196, MidElement).ActiveTrackElementName;
                }
                else
                {
                    throw Exception("Error - Stopped at through station but neither lead nor mid elements have a name");
                }
                EntrySpeed = 0;
                EntryTime = TrainController->TTClockTime;
                int NextElementPosition = Track->TrackElementAt(199, LeadElement).Conn[Track->GetNonPointsOppositeLinkPos(LeadEntryPos)];
                int NextEntryPos = Track->TrackElementAt(200, LeadElement).ConnLinkPos[Track->GetNonPointsOppositeLinkPos(LeadEntryPos)];
                FirstHalfMove = true;
                StoppedAtLocation = false;

                if((PowerAtRail < 1) && EntrySpeed < 1) // added at v2.4.0
                {
                    StoppedWithoutPower = true;
                }
                if((NextElementPosition > -1) && (NextEntryPos > -1))
                // condition check added for SloughIECC error reported by James U
                {
                    if((Track->TrackElementAt(720, NextElementPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal) &&
                       (Track->TrackElementAt(721, NextElementPosition).Attribute == 0))
                    {
                        StoppedAtSignal = true;
                        if(!StoppedWithoutPower)
                        // if stopped without power just keep existing background colour
                        {
                            PlotTrainWithNewBackgroundColour(41, clSignalStopBackground, Display);
                            // TrainController->LogActionError(40, HeadCode, "", SignalHold, Track->TrackElementAt(755, NextElementPosition).ElementID);
                        }
                    }
                }
                if(ActionVectorEntryPtr->FormatType == TimeTimeLoc)
                {
                    TimeTimeLocArrived = false;
                    LogAction(27, HeadCode, "", Depart, StationName, ActionVectorEntryPtr->DepartureTime, false);
                    // no warning for TimeTimeLoc departure
                }
                else if(TreatPassAsTimeLocDeparture) //added at v2.12.0 so late/early/on time mins recorded accurately
                {
                    LogAction(36, HeadCode, "", Depart, StationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning); //EventTime because the real event is a pass
                }
                else //must be TimeLoc departure
                {
                    LogAction(6, HeadCode, "", Depart, StationName, ActionVectorEntryPtr->DepartureTime, ActionVectorEntryPtr->Warning);
                }
                TreatPassAsTimeLocDeparture = false; //added at v2.12.0, reset after train departs
                DepartureTimeSet = false;
                // no need to set LastActionTime for a departure
                //deal here with departure pointer change, increment if SkippedDeparture
                CumulativeDelayedRandMinsOneTrain += DelayedRandMins;  //only add these after late mins added (in LogAction)

                if(SkippedDeparture)
                {
                    TrainController->SkippedTTEvents += TrainSkippedEvents;
                    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0)) + SkipPtrValue;
                    TrainSkippedEvents = 0;
                    SkippedDeparture = false;
                    SkipPtrValue = 0;
                    ActionsSkippedFlag = false;
                }
                else
                {
                    ActionVectorEntryPtr++;
                }
                // advance pointer beyond departure action - (this line (& LogAction) used to be at the end -  see
                // note
/*
                  Note:  If train stops at station after call on with a TimeTimeLoc loaded, and before the normal stop point, then when
                  SetTrainMovementValues called it assumes a stop at the stop point because the ActionVectorEntryPtr points to a name
                  when NameInTimetableBeforeCDT is called and the stop positions are valid.  So next element train movement is based on
                  this calculation.  However, when the departure time check is made (it is during this function when SetTrainMovementValues
                  is called), the ActionVectorEntryPtr is advanced at the end past the departure location, so at the next element when
                  SetTrainMovementValues is called again, all is normal, i.e. the train doesn't stop again at the location.  But to cure
                  the problem move the ActionVectorEntryPtr increment to before SetTrainMovementValues.
*/
                if((Track->TrackElementAt(201, LeadElement).TrackType == Buffers) && !StoppedWithoutPower)
                {
                    StoppedAtBuffers = true;
                }
                else if(!StoppedWithoutPower)
                // if buffers or no power, don't set values
                {
                    if(Track->TrackElementAt(724, LeadElement).TrackType != Continuation)
                    {
                        SetTrainMovementValues(12, NextElementPosition, NextEntryPos);
                        // NextElement is the element to be entered
                    }
                    else
                    {
                        SetTrainMovementValues(13, LeadElement, LeadEntryPos);
                        // use LeadElement for an exit continuation
                    }
                }
            }
        }
    }
    if(Straddle == LeadMidLag) //train on a half element
    {
        if(TrainController->TTClockTime < ExitTimeFull)
        {
            Utilities->CallLogPop(654);
            return;
        }
    }
    else //train fully on 2 elements
    {
        if(TrainController->TTClockTime < ExitTimeHalf)
        {
            Utilities->CallLogPop(655);
            return;
        }
    }
    if((LeadElement > -1) && (MidElement > -1))
    {
        if((TrainMode == Signaller) && (Track->TrackElementAt(789, LeadElement).TrackType == Continuation))
        {
            // don't allow to stop if exiting at a continuation as causes problems if try to change direction
            // if entering at continuation & LeadElement is a continuation then MidElement will be -1
            //don't need to check for MidElement being continuation because popup menu won't show when exiting at continuation so SignallerStoppingFlag can't be set
            SignallerStoppingFlag = false;
            StepForwardFlag = false;
        }
    }
    if(Stopped())
    // this is what prevents another movement if the train is stopped
    {
        if(TrainFailurePending) // ok, stopped so PlotElements set
        {
            TrainHasFailed(5);
        }
        BrakeRate = 0;
        Utilities->CallLogPop(656);
        return;
    }

    // HERE WHEN READY FOR NEXT MOVE

    //added at v2.10.0 to set SPADFlag if red signal immediately ahead (as it will be if in a locked route)
    //check if due to run past a red signal & if so set SPADFlag (SetTrainMovementValues & its SPAD check only called when arrive fully on 2 elements)
    if(Straddle == LeadMid) //fully on 2 elements
    {
        if(LeadElement > -1)
        {
            if(Track->TrackElementAt(1402, LeadElement).Conn[LeadExitPos] > -1)
            {
                TTrackElement TIF = Track->TrackElementAt(1403, Track->TrackElementAt(1404, LeadElement).Conn[LeadExitPos]);
                if(TIF.TrackType == SignalPost)
                {
                    int TIFEntryPos = Track->TrackElementAt(1405, LeadElement).ConnLinkPos[LeadExitPos];
                    int TIFExitPos = 0;
                    if(TIFEntryPos == 0)
                    {
                        TIFExitPos = 1;
                    }
                    if((TIF.Config[TIFExitPos] == Signal) && TIF.Attribute == 0 && (ExitSpeedHalf > 1) && !AllowedToPassRedSignal && !TIF.CallingOnSet) //use ExitSpeedHalf as may have been stopped at signal so entryspeed is 0
                                      //!TIF.CallingOnSet added at v2.14.0
                    {
                        SPADFlag = true; // user has to intervene to reset & restart after spad
                    }
                }
            }
        }
    }

    // check for train in front & if so stop at next access (when train fully on element next to train)
    if((TrainMode == Signaller) && (Straddle == LeadMidLag))
    // SetTrainMovementValues brakes & stops signaller mode train for a train in front using local
    // variable TrainInFrontInSignallerModeFlag
    {
        if(LeadElement > -1)
        {
            int NextPos = Track->TrackElementAt(649, LeadElement).Conn[LeadExitPos];
            int NextEntryPos = Track->TrackElementAt(650, LeadElement).ConnLinkPos[LeadExitPos];
            if(Track->OtherTrainOnTrack(1, NextPos, NextEntryPos, TrainID))
            // true if another train on NextEntryPos track whether bridge or not
            {
                StoppedForTrainInFront = true;
            }
            else
            {
                StoppedForTrainInFront = false;
            }
        }
    }
    if((Straddle == LeadMid) && SPADFlag)
    // give message + plot background when ready to move half past the signal
    {
        if(NextElementPosition > -1)
        {
            if((Track->TrackElementAt(662, NextElementPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal) &&
               (Track->TrackElementAt(663, NextElementPosition).Attribute == 0))
            {
                AnsiString LocID = AnsiString(Track->TrackElementAt(664, NextElementPosition).ElementID);
                TrainController->LogActionError(3, HeadCode, "", FailSPAD, LocID);
                // if goes past 2 signals then give message twice
                PlotTrainWithNewBackgroundColour(17, clSPADBackground, Display); // Yellow
            }
        }
    }
    if(Straddle == LeadMidLag)
    // During this function train moves fully onto 2 elements, Lead & Mid, so set next 2 moves from here for the element after Lead
    {
        // if SPADFlag set allow to keep moving until signal obscured before setting background colour, & stop only when ExitSpeedFull is 0
        if(SPADFlag)
        {
            if(ExitSpeedFull == 0)
            {
                StoppedAfterSPAD = true;
                // but don't want to stop until have moved fully onto element, hence stop test is before this check
            }
        }
        if((TrainMode == Signaller) && (SignallerStoppingFlag || StepForwardFlag))
        {
            if(ExitSpeedFull == 0)
            {
                // only reach here when will stop on LeadMid, because SetTrainMovementValues called after this (i.e. ExitSpeedFull becomes 0 if not 0 now
                // after this test), and Straddle == LeadMidLag so not accessed at the half-move point, hence only reached at the full move
                // point when the speed is 0.  So, colour change won't occur until fully stopped (early in UpdateTrain()), and the log message
                // is sent at the right time and once only.
                SignallerStopped = true;
                // but don't want to stop until have moved fully onto element, hence stop test is before this check
                StepForwardFlag = false;
                SignallerStoppingFlag = false;
                TTrackElement TE;
                AnsiString Loc = "";
                bool LocNamed = false;
                if(LeadElement > -1)
                {
                    TE = Track->TrackElementAt(782, LeadElement);
                    if(TE.ActiveTrackElementName != "")
                    {
                        Loc = TE.ActiveTrackElementName;
                        LocNamed = true;
                    }
                    else
                    {
                        Loc = "track element " + TE.ElementID;
                    }
                }
                if((MidElement > -1) && !LocNamed)
                {
                    TE = Track->TrackElementAt(783, MidElement);
                    if(TE.ActiveTrackElementName != "")
                    {
                        Loc = TE.ActiveTrackElementName;
                        LocNamed = true;
                    }
                    else if(Loc == "")
                    {
                        Loc = "track element " + TE.ElementID;
                    }
                }
                if(Loc == "")
                {
                    Loc = "outside railway";
                    // must have stopped after left at a continuation (because both lead & mid == -1)
                }
                else
                {
                    Loc = "at " + Loc;
                }
                LogAction(30, HeadCode, "", SignallerStop, Loc, TrainController->TTClockTime, false); // false for warning
            }
        }
        if(LeadElement > -1) // if an exit continuation then not set
        {
            if((Track->TrackElementAt(202, LeadElement).TrackType != Points) || ((LeadEntryPos != 0) && (LeadEntryPos != 2)))
            {
                LeadExitPos = Track->GetNonPointsOppositeLinkPos(LeadEntryPos);
            }
            else if((Track->TrackElementAt(203, LeadElement).TrackType == Points) && ((LeadEntryPos == 0) || (LeadEntryPos == 2)))
            {
                if(Track->TrackElementAt(204, LeadElement).Attribute == 0)
                {
                    LeadExitPos = 1;
                }
                else
                {
                    LeadExitPos = 3;
                }
            }
            NextElementPosition = Track->TrackElementAt(205, LeadElement).Conn[LeadExitPos];
            NextEntryPos = Track->TrackElementAt(206, LeadElement).ConnLinkPos[LeadExitPos];
        }
        else
        {
            NextElementPosition = -1;
            NextEntryPos = -1;
        }
        EntryTime = TrainController->TTClockTime;
        EntrySpeed = ExitSpeedFull;
        FirstHalfMove = true; //will be when finished the move onto 2 elements during this function

        if((PowerAtRail < 1) && EntrySpeed < 1) // added at v2.4.0
        {
            StoppedWithoutPower = true;
        }
        if((NextElementPosition > -1) && (NextEntryPos > -1) && !SPADFlag)
        // may be buffers or continuation.  SPADFlag added at v2.1.0
        // so don't override the SPAD colour & don't set StoppedAtSignal
        {
            if((Track->TrackElementAt(207, NextElementPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal) &&
               (Track->TrackElementAt(208, NextElementPosition).Attribute == 0) && (ExitSpeedFull < 1) && !RevisedStoppedAtLoc())
            {
                StoppedAtSignal = true;
                if(!StoppedWithoutPower)
                // leave background as is if no power, but set StoppedAtSignal
                {
                    PlotTrainWithNewBackgroundColour(34, clSignalStopBackground, Display);
                }
                // TrainController->LogActionError(41, HeadCode, "", SignalHold, Track->TrackElementAt(756, NextElementPosition).ElementID);
            }
        }
        if(!Stopped())
        {
            if((NextElementPosition > -1) && (NextEntryPos > -1))
            // may be buffers or continuation (skip SetTrainMovementValues if buffers, if
            // a stop element that isn't buffers - e.g. station, then will skip the calcs
            // during SetTrainMovementValues to avoid trying to divide by zero - see that
            // function for fuller explanation
            {
                SetTrainMovementValues(8, NextElementPosition, NextEntryPos);
                // NextElement is the element to be entered
            }
            // follow the continuation exits:-
            else if((LeadElement > -1) && (Track->TrackElementAt(209, LeadElement).TrackType == Continuation))
            {
                SetTrainMovementValues(9, LeadElement, LeadEntryPos);
                // Use LeadElement for calcs if lead is a continuation
            }
            else if((MidElement > -1) && (Track->TrackElementAt(210, MidElement).TrackType == Continuation))
            {
                SetTrainMovementValues(10, MidElement, MidEntryPos);
                // Use MidElement for calcs if mid is a continuation
            }
            else if((LagElement > -1) && (Track->TrackElementAt(211, LagElement).TrackType == Continuation))
            {
                SetTrainMovementValues(11, LagElement, LagEntryPos);
                // Use LagElement for calcs if lag is a continuation
            }
        }
        // remove route elements if not autosigs - this section moved from below, was under LagElement > -1 condition but needs to cover LagElement == -1
        if((AllRoutes->GetRouteTypeAndGraphics(2, LeadElement, LeadEntryPos, EXGraphicPtr, EntryDirectionGraphicPtr) == TAllRoutes::NotAutoSigsRoute))
        // Trains may not be in a route
        // Since Straddle = LeadMidLag at this point the train is going to move fully off the existing Lag & fully onto existing Lead element during this function
        {
            // NB if LeadElement == -1 then the above test returns NoRoute
            int TempH = Track->TrackElementAt(213, LeadElement).HLoc;
            int TempV = Track->TrackElementAt(214, LeadElement).VLoc;
            int TempELink = Track->TrackElementAt(215, LeadElement).Link[LeadEntryPos];
            TAllRoutes::TRouteElementPair FirstPair, SecondPair;
            FirstPair = AllRoutes->GetRouteElementDataFromRoute2MultiMap(10, TempH, TempV, SecondPair);
            if((FirstPair.first > -1) && (AllRoutes->GetFixedRouteAt(143, FirstPair.first).GetFixedPrefDirElementAt(153,
                FirstPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(10, TempH, TempV, TempELink);
            }
            else if((SecondPair.first > -1) && (AllRoutes->GetFixedRouteAt(144, SecondPair.first).GetFixedPrefDirElementAt(154,
                 SecondPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(11, TempH, TempV, TempELink);
            }
        }
        if(AllRoutes->GetRouteTypeAndGraphics(3, MidElement, MidEntryPos, EXGraphicPtr, EntryDirectionGraphicPtr) == TAllRoutes::NotAutoSigsRoute)
        // Trains may not be in a route
        {
            int TempH = Track->TrackElementAt(216, MidElement).HLoc;
            int TempV = Track->TrackElementAt(217, MidElement).VLoc;
            int TempELink = Track->TrackElementAt(218, MidElement).Link[MidEntryPos];
            TAllRoutes::TRouteElementPair FirstPair, SecondPair;
            FirstPair = AllRoutes->GetRouteElementDataFromRoute2MultiMap(11, TempH, TempV, SecondPair);
            if((FirstPair.first > -1) && (AllRoutes->GetFixedRouteAt(145, FirstPair.first).GetFixedPrefDirElementAt(155,
                FirstPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(12, TempH, TempV, TempELink);
            }
            else if((SecondPair.first > -1) && (AllRoutes->GetFixedRouteAt(146, SecondPair.first).GetFixedPrefDirElementAt(156,
                SecondPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(13, TempH, TempV, TempELink);
            }
        }
        if(AllRoutes->GetRouteTypeAndGraphics(4, LagElement, LagEntryPos, EXGraphicPtr, EntryDirectionGraphicPtr) == TAllRoutes::NotAutoSigsRoute)
        // Trains may not be in a route
        {
            int TempH = Track->TrackElementAt(219, LagElement).HLoc;
            int TempV = Track->TrackElementAt(220, LagElement).VLoc;
            int TempELink = Track->TrackElementAt(221, LagElement).Link[LagEntryPos];
            TAllRoutes::TRouteElementPair FirstPair, SecondPair;
            FirstPair = AllRoutes->GetRouteElementDataFromRoute2MultiMap(12, TempH, TempV, SecondPair);
            if((FirstPair.first > -1) && (AllRoutes->GetFixedRouteAt(147, FirstPair.first).GetFixedPrefDirElementAt(157,
                FirstPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(14, TempH, TempV, TempELink);
            }
            else if((SecondPair.first > -1) && (AllRoutes->GetFixedRouteAt(148, SecondPair.first).GetFixedPrefDirElementAt(158,
                SecondPair.second).GetELink() == TempELink))
            {
                AllRoutes->RemoveRouteElement(15, TempH, TempV, TempELink);
            }
            AllRoutes->CheckMapAndRoutes(8); // test
        }
        if(LagElement > -1)
        // not entering at a continuation so can deal with train leaving the lag element
        {
            ResetTrainElementID(4, LagElement, LagEntryPos);
            // amended below so route elements removed for the complete train (for NotAutoSigsRoutes), so train never standing on a route once it
            // starts moving, covers for eliminating route when train reaches buffers, and prevents odd route segments when route extended while
            // straddling 3 elements (formerly the last segment was replotted as a route & stayed plotted

            TPrefDirElement PrefDirElement;
            // plot locked route marker for any element if appropriate (i.e. if a locked AutoSigs route) but only when train leaves element completely
            // as this is a 16x16 graphic
            if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(6, LagElement, LagExitPos, PrefDirElement, LockedVectorNumber))
            {
                Display->PlotOutput(22, (Track->TrackElementAt(222, LagElement).HLoc * 16), (Track->TrackElementAt(223, LagElement).VLoc * 16),
                                    RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
            }
            if(ContinuationExit(2, LagElement, LagExitPos))  // true if Element is a continuation and Exitpos is the continuation end
            {
                int RouteNumber;
                TrainGone = true;
                // flag to indicate train to be deleted - outside this function
                if(AllRoutes->GetRouteTypeAndNumber(10, LagElement, LagExitPos, RouteNumber) == TAllRoutes::AutoSigsRoute)
                {
                    TTrainController::TContinuationAutoSigEntry ContinuationAutoSigEntry;
                    ContinuationAutoSigEntry.RouteNumber = RouteNumber;
                    // calc distance from & inc last signal to exit
                    int LastElement = LagElement, LastExitPos = LagExitPos, CumDistance = 0;
                    int NewLastElement = 0, NewLastExitPos = 0;
                    // need above because can't change LastElement & LastExitPos until both new values obtained
                    // while((Track->TrackElementAt(684, LastElement).Config[LastExitPos] != Signal) && (CumDistance < 1200)) as was
                    while((Track->TrackElementAt(913, LastElement).Config[LastExitPos] != Signal) && (CumDistance < 1200) && (Track->TrackElementAt(897,
                                                                                                                                                    LastElement).TrackType != Points))
                    // extra condition above added because of Moric1998's error (see email of 24/03/2016), where had an autosigs route across points, and another continuation on track not occupied by route so
                    // failed when found a new element = -1 when tried to cross the continuation.  Note this routine can only deal with non points as it uses GetNonPointsOppositeLinkPos
                    // leave CumDistance as it was in these circumstances.
                    {
                        if(LastExitPos < 2)
                        {
                            CumDistance += Track->TrackElementAt(685, LastElement).Length01;
                        }
                        else
                        {
                            CumDistance += Track->TrackElementAt(686, LastElement).Length23;
                        }
                        NewLastElement = Track->TrackElementAt(687, LastElement).Conn[Track->GetNonPointsOppositeLinkPos(LastExitPos)];
                        if(NewLastElement == -1)
                        // this will catch buffers or any other connection failure
                        {
                            break; //throw Exception("Error, Connection = -1 in Continuation loop in UpdateTrain");   //dropped at v2.15.0 because of Brent Mackie's error file of
                        }                                                                                             //10/02/23, had two continuations linked with no signal between
                        NewLastExitPos = Track->TrackElementAt(688, LastElement).ConnLinkPos[Track->GetNonPointsOppositeLinkPos(LastExitPos)]; //so when train exited this routine tracked
                        if(NewLastExitPos == -1)                                                                      //back to the entry continuation which had no further connection - doesn't need to be an error at all!
                        {
                            break; //throw Exception("Error, ConnLinkPos = -1 in Continuation loop in UpdateTrain"); //dropped at v2.15.0 because of Brent Mackie's error file of 10/02/23 , see above
                        }
                        LastElement = NewLastElement;
                        LastExitPos = NewLastExitPos;
                    }
                    // if at signal add this in too (may not be signal if 'break;' encountered but doesn't matter)
                    if(CumDistance < 1200)
                    {
                        CumDistance += Track->TrackElementAt(689, LastElement).Length01; // only need 01 for signal
                    }
                    // now have distance including the signal, if >=1200m use 100m (for a signal immediately after the continuation)
                    // else use 1200m - CumDistance
                    int FirstDistance = 0;
                    if(CumDistance >= 1200)
                    {
                        FirstDistance = 100;
                    }
                    else
                    {
                        FirstDistance = 1200 - CumDistance;
                    }
                    if(FirstDistance < 100)
                    {
                        FirstDistance = 100; // don't allow < 100
                    }
                    // can now calc the time delays in seconds - FirstDelay, SecondDelay & ThirdDelay, these are doubles
                    // BUT - first check whether ExitSpeedFull is very low (Mark had divide by zero error with zero exit speed using v2.4.0)
                    if(ExitSpeedFull > 20.0)
                    {
                        ContinuationAutoSigEntry.FirstDelay = 3.6 * double(FirstDistance) / ExitSpeedFull;
                        // speed in km/h & distance in m so mult by 3.6 to bring to secs
                        ContinuationAutoSigEntry.SecondDelay = ContinuationAutoSigEntry.FirstDelay + 4320.0 / ExitSpeedFull;
                        // 4320.0 = 3.6 * 1200, .0 to make it a double
                        ContinuationAutoSigEntry.ThirdDelay = ContinuationAutoSigEntry.SecondDelay + 4320.0 / ExitSpeedFull;
                    }
                    else
                    {
                        ContinuationAutoSigEntry.FirstDelay = 60.0; // 60 secs
                        ContinuationAutoSigEntry.SecondDelay = 120.0;
                        ContinuationAutoSigEntry.ThirdDelay = 180.0;
                    }
                    ContinuationAutoSigEntry.AccessNumber = 0;
                    ContinuationAutoSigEntry.PassoutTime = TrainController->TTClockTime;
                    if(!TrainController->ContinuationAutoSigVector.empty())
                    {
                        TTrainController::TContinuationAutoSigVectorIterator VectorIT;
                        for(VectorIT = TrainController->ContinuationAutoSigVector.begin(); VectorIT != TrainController->ContinuationAutoSigVector.end();
                            VectorIT++)
                        {
                            if(VectorIT->RouteNumber == RouteNumber)
                            {
                                // another train has passed out of same route so erase earlier entry
                                TrainController->ContinuationAutoSigVector.erase(VectorIT);
                                break;
                            }
                        }
                    }
                    TrainController->ContinuationAutoSigVector.push_back(ContinuationAutoSigEntry);
                }
                PlotBackgroundGraphic(14, 3, Display);
                // need to plot this as returning early so will miss the later plot (not a bridge so don't need PlotAlternativeTrackRouteGraphic)
                Display->Update();
                // need to keep this since Update() not called for PlotSmallOutput as too slow
                Utilities->CallLogPop(659);
                return;
            }
            // above covers for exiting at continuation, need XLinkPos check to exclude entering at a continuation
            if(LeadElement > -1)
            {
                TTrackElement &TE = Track->TrackElementAt(224, LeadElement); //added at v2.13.0 for brevity
                if(TE.Config[LeadExitPos] == Signal)
                // changed to lead so reset early
                {
                    LastSigPassedFailed = false; //used to cancel route elements up to next signal for autosigs route
                    TE.Attribute = 0; // red
                    int RouteNumber; //only used for autosigs routes
                    //add chance to fail when train passes a signal
                    if((random(Utilities->SignalChangeEventsPerFailure) == 0) && !TE.Failed && (Utilities->FailureMode != FNil) &&
                        (TrainMode == Timetable) && !TE.CallingOnSet) //can't fail twice, calling on signal can't fail
                    {
                        TTrack::TInfrastructureFailureEntry IFE;
                        IFE.TVPos = LeadElement;
                        TE.Failed = true;
                        Display->WarningLog(19, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Signal failed at " + TE.ElementID);
                        PerfLogForm->PerformanceLog(42, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: Signal failed at " + TE.ElementID);
                        TrainController->StopTTClockMessage(129, "Signal at " + TE.ElementID +
                            " failed when changing aspect.\nTrains can only pass under signaller control.");
                        AllRoutes->RebuildRailwayFlag = true; //force ClearandRebuildRailway at next clock tick
                        LastSigPassedFailed = true;
        //set repair time, random value in minutes between 10 and 179
                        double FailureMinutes = double(random(Utilities->MaxRandomRepairTime) + Utilities->FixedMinRepairTime); //between 10 and 179 minutes at random
                        TDateTime RepairTime = TrainController->TTClockTime + TDateTime(FailureMinutes / 1440);
                        IFE.RepairTime = RepairTime;
                        IFE.FailureTime = TrainController->TTClockTime;
                        Track->FailedSignalsVector.push_back(IFE); //rearwards signals will be set when LagElement leaves signal
                    }
                    TE.CallingOnSet = false;
                    // don't plot if zoomed out
                    if(!Display->ZoomOutFlag)
                    {
                        Track->PlotSignal(4, Track->TrackElementAt(226, LeadElement), Display);
                    }
                    // covers signal resetting in same direction
                }
            }
            if(Track->TrackElementAt(521, LagElement).Config[LagExitPos] == Signal)
            {
                AllRoutes->RebuildRailwayFlag = true; //added at v2.13.0 to replot signal after train left in case it had failed
                if(AllRoutes->GetRouteTypeAndGraphics(5, LagElement, LagEntryPos, EXGraphicPtr, EntryDirectionGraphicPtr) == TAllRoutes::AutoSigsRoute)
                {
                    Display->PlotOutput(23, Track->TrackElementAt(227, LagElement).HLoc * 16, Track->TrackElementAt(228, LagElement).VLoc * 16, EXGraphicPtr);
                    Display->PlotOutput(24, Track->TrackElementAt(229, LagElement).HLoc * 16, Track->TrackElementAt(230, LagElement).VLoc * 16, EntryDirectionGraphicPtr);
                    TPrefDirElement PrefDirElement;
                    // plot locked route marker for same side signal if appropriate (may be covered above but leave in), but only when train leaves element completely as this is a 16x16 graphic
                    if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(8, LagElement, LagExitPos, PrefDirElement, LockedVectorNumber))
                    {
                        Display->PlotOutput(25, (Track->TrackElementAt(231, LagElement).HLoc * 16), (Track->TrackElementAt(232, LagElement).VLoc * 16),
                                            RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                    }
                    if(!(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(9, LagElement, LagExitPos, PrefDirElement,
                                                                                                 LockedVectorNumber)))
                    {
                        AllRoutes->SetTrailingSignalsOnAutoSigsRoute(0, LagElement, LagExitPos);
                    }
                }
            }
            else if((LeadElement > -1) && (Track->TrackElementAt(233, LeadElement).TrackType == SignalPost))
            {
                Track->TrackElementAt(234, LeadElement).Attribute = 0; // red
                Track->TrackElementAt(672, LeadElement).CallingOnSet = false;
                // don't plot if zoomed out
                if(!Display->ZoomOutFlag)
                {
                    Track->PlotSignal(5, Track->TrackElementAt(235, LeadElement), Display);
                }
                // covers signal passed in opposite direction - replot as red, regardless of what it was before, though should already have been red
            }
            else if(Track->TrackElementAt(522, LagElement).TrackType == SignalPost)
            {
                if(AllRoutes->GetRouteTypeAndGraphics(6, LagElement, LagEntryPos, EXGraphicPtr, EntryDirectionGraphicPtr) == TAllRoutes::AutoSigsRoute)
                {
                    Display->PlotOutput(26, Track->TrackElementAt(236, LagElement).HLoc * 16, Track->TrackElementAt(237, LagElement).VLoc * 16, EXGraphicPtr);
                    Display->PlotOutput(27, Track->TrackElementAt(238, LagElement).HLoc * 16, Track->TrackElementAt(239, LagElement).VLoc * 16, EntryDirectionGraphicPtr);
                    // below added at v1.3.0 to reset signals if back out of an autosigs route under signaller control after changing direction, when new LeadElement not on route (if it had
                    // been the route would have been ForceCancelled).  Note that the signal is not facing the direction of travel else would have entered
                    // "if(Track->TrackElementAt(, LagElement).Config[LagExitPos] == Signal)" above and wouldn't be here
                    int RouteNumber;
                    AllRoutes->GetRouteTypeAndNumber(29, LagElement, LagEntryPos, RouteNumber);
                    // already know it's an autosigsroute, this is just to get the RouteNumber
                    // addition below at v1.3.2 - found that a signal that had reached double yellow in ContinuationAutoSigs was reset to red when a following train's lag element
                    // moved off a signal in the normal course of events.  It was caused when a train backed out of an autosigs route under signaller control after changing
                    // direction (see DevHistory.txt). Hence check that the train is in signaller mode and that the train's lead element isn't on the same route before calling SetRouteSignals.
                    int RouteNumber2;
                    AllRoutes->GetRouteTypeAndNumber(30, LeadElement, LeadEntryPos, RouteNumber2);
                    // already know it's an autosigsroute, this is just to get the RouteNumber
                    if((TrainMode == Signaller) && (RouteNumber2 != RouteNumber))
                    // note that if not in a route (as likely) then RouteNumber2 set to -1
                    {
                        AllRoutes->GetFixedRouteAt(217, RouteNumber).SetRouteSignals(10);
                        // this was in the 1.3.0 addition but without the condition
                    }
                    // end of 1.3.2 addition
                    // end of 1.3.0.addition
                }
                TPrefDirElement PrefDirElement;
                // plot locked route marker for opp side signal if appropriate (may be covered above but leave in), but only when train leaves element completely as this is a 16x16 graphic (OK - Straddle == LeadMidLag)
                if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(10, LagElement, LagExitPos, PrefDirElement, LockedVectorNumber))
                {
                    Display->PlotOutput(28, (Track->TrackElementAt(240, LagElement).HLoc * 16), (Track->TrackElementAt(241, LagElement).VLoc * 16),
                                        RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                }
            }
        }
    }
    // straddle ONLY changed here, check if 'LeadMid' first & if so ready for updating Elements
    if(Straddle == LeadMid)
    {
        AllowedToPassRedSignal = false;
        // if had been allowed to pass then at this point it will move half onto signal so can be reset
        // if(LagElement > -1) ResetTrainElementID(LagElement, LagEntryPos);//train fully off old LagElement so can clear TrainOnElement flags - no, reset at earlier call when lag moves off element
        if(DerailPending)
        // set during last GetLeadElement, but only act on it when train fully on offending point
        // i.e. next time Straddle reaches LeadMid
        {
            Derailed = true;
            DerailPending = false;
            RailGraphics->ChangeForegroundColour(21, HeadCodePosition[0], HeadCodePosition[0], clB0G0R0, BackgroundColour);
            PlotTrainWithNewBackgroundColour(6, clDerailedBackground, Display);
            TrainController->LogActionError(4, HeadCode, "", FailDerailed, Track->TrackElementAt(595, LeadElement).ElementID);
            Utilities->CallLogPop(657);
            return;
        }
        LagElement = MidElement;
        LagEntryPos = MidEntryPos;
        LagExitPos = MidExitPos;
        MidElement = LeadElement;
        MidEntryPos = LeadEntryPos;
        MidExitPos = LeadExitPos;
        Straddle = MidLag;
        // train now fully on the updated Lag & Mid, the front segment is going to move onto the new
        // LeadElement during this function (note that if stopped at signal then won't get this far)
        if(LeadElement > -1)
        {
            if(ContinuationExit(1, LeadElement, LeadExitPos))
            // i.e an exit continuation only
            // if don't exclude entry continuations then can't progress past it
            {
                LeadElement = -1;
            }
            else
            {
                GetLeadElement(0);
                // sets or resets DerailPending & StoppedAtSignal, and sets LeadElement values
                CheckAndCancelRouteForWrongEndEntry(2, LeadElement, LeadEntryPos);
                if(Stopped())
                {
                    if(TrainFailurePending) // ok, stopped so PlotElements set
                    {
                        TrainHasFailed(6);
                    }
                    Utilities->CallLogPop(658);
                    return; // i.e. don't move forward one step if next element is a red signal
                }
            }
        }
    }
    if(LagElement > -1)
    {
        // below are the actions required at both half moves for LagElement > -1
        PlotBackgroundGraphic(12, 3, Display);

        // if was in locked route but has timed out when train leaves then plot the normal track graphic over the route graphic that is
        // still in BackgroundGraphic[3], if wasn't in a route then will just replot the same BackgroundGraphic
        // need to do this for each half element

        TPrefDirElement PrefDirElement;
        if(!(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(7, LagElement, LagExitPos, PrefDirElement, LockedVectorNumber)))
        {
            int RouteNumber; // holder for call below - not used
            if(AllRoutes->GetRouteTypeAndNumber(9, LagElement, LagExitPos, RouteNumber) == TAllRoutes::NoRoute)
            {
                if(Utilities->clTransparent == TColor(0xFFFFFF))
                // change to black for a white background
                {
                    RailGraphics->ChangeSpecificColour(0, BackgroundPtr[3], BackgroundPtr[3], clB5G3R0, clB0G0R0);
                    // only applies for AutoSigs Route in case was locked & timed out
                }
                else
                // change to white for a dark background
                {
                    RailGraphics->ChangeSpecificColour(2, BackgroundPtr[3], BackgroundPtr[3], clB5G3R0, clB5G5R5);
                    // only applies for AutoSigs Route in case was locked & timed out
                }
                PlotBackgroundGraphic(13, 3, Display);
            }
        }
        PlotAlternativeTrackRouteGraphic(1, LagElement, LagEntryPos, HOffset[3], VOffset[3], Straddle);
        // above in case train just moving off a bridge & either alternative track in a route - need to keep its route colour,
        // or a train on the opposite track - needs to be replotted
    }
    // update all array values
    HOffset[3] = HOffset[2];
    HOffset[2] = HOffset[1];
    HOffset[1] = HOffset[0];
    VOffset[3] = VOffset[2];
    VOffset[2] = VOffset[1];
    VOffset[1] = VOffset[0];
    Graphics::TBitmap *TempPtr = BackgroundPtr[3];

    BackgroundPtr[3] = BackgroundPtr[2];
    BackgroundPtr[2] = BackgroundPtr[1];
    BackgroundPtr[1] = BackgroundPtr[0];
    BackgroundPtr[0] = TempPtr;

    // update headcode graphics depending on Lead entry value
    if(LeadElement > -1) // if Lead is -1 then stays as is
    {
        if(LowEntryValue(Track->TrackElementAt(242, LeadElement).Link[LeadEntryPos]))
        {
            for(int x = 0; x < 4; x++)
            {
                HeadCodePosition[x] = HeadCodeGrPtr[3 - x];
            }
        }
        else
        {
            for(int x = 0; x < 4; x++)
            {
                HeadCodePosition[x] = HeadCodeGrPtr[x];
            }
        }
    }
    if(TrainMode == Timetable)
    {
        RailGraphics->ChangeForegroundColour(22, HeadCodePosition[0], FrontCodePtr, clFrontCodeTimetable, BackgroundColour); // red
    }
    else
    {
        RailGraphics->ChangeForegroundColour(23, HeadCodePosition[0], FrontCodePtr, clFrontCodeSignaller, BackgroundColour); // blue
    }
    HeadCodePosition[0] = FrontCodePtr;

    // plot new seg [0] on Lead & [2] on Mid ([2] always on Mid)
    if(LeadElement > -1)
    {
        if(Straddle == MidLag)
        // just about to move half onto the new lead element
        {
            GetOffsetValues(5, HOffset[0], VOffset[0], Track->TrackElementAt(243, LeadElement).Link[LeadEntryPos]);
            // pick up new background bitmap [0]
            PickUpBackgroundBitmap(4, HOffset[0], VOffset[0], LeadElement, LeadEntryPos, BackgroundPtr[0]);
            int LeadElementTrainID = Track->TrackElementAt(244, LeadElement).TrainIDOnElement;
            if((LeadElementTrainID > -1) && (LeadElementTrainID != TrainID))
            // check if own ID for entry at continuation, else crashes into itself!
            {
                // OK if crossing on a bridge
                int OtherTrainEntryPos = TrainController->EntryPos(0, LeadElementTrainID, LeadElement);
                if(OtherTrainEntryPos == -1)
                {
                    throw Exception("Error - OtherTrainEntryPos not set");
                }
                if((Track->TrackElementAt(246, LeadElement).TrackType != Bridge) || (LeadEntryPos == OtherTrainEntryPos) ||
                   // LeadEntryPos for rear end crashes
                   (LeadExitPos == OtherTrainEntryPos))
                // LeadExitPos for head-on crashes
                {
                    TrainCrashedInto = Track->TrackElementAt(247, LeadElement).TrainIDOnElement;
                    Crashed = true; // only set if Straddle = MidLag
                    CallingOnFlag = false;
                    // in case was set, need to disable call on if call on button had been pressed
                }
            }
            else if(MidElement > -1) // will be -1 for continuation entries
            {
                // check if about to move onto a crossing diagonal that is occupied by another train, and if so crash
                int MidExitLinkNum = Track->TrackElementAt(889, MidElement).Link[MidExitPos];
                int MidHLoc = Track->TrackElementAt(890, MidElement).HLoc;
                int MidVLoc = Track->TrackElementAt(891, MidElement).VLoc;
                int OtherTrainID = -1;
                if((MidExitLinkNum == 1) || (MidExitLinkNum == 3) || (MidExitLinkNum == 7) || (MidExitLinkNum == 9))
                {
                    if(Track->DiagonalFouledByTrain(0, MidHLoc, MidVLoc, MidExitLinkNum, OtherTrainID))
                    {
                        TrainCrashedInto = OtherTrainID;
                        Crashed = true; // only set if Straddle = MidLag
                        CallingOnFlag = false;
                        // in case was set, need to disable call on if call on button had been pressed
                    }
                }
            }
        }
        else
        {
            GetOffsetValues(6, HOffset[0], VOffset[0], Track->TrackElementAt(248, LeadElement).Link[LeadExitPos]);
            // pick up new background bitmap [0]
            PickUpBackgroundBitmap(5, HOffset[0], VOffset[0], LeadElement, LeadEntryPos, BackgroundPtr[0]);
        }
        PlotElement[0] = LeadElement;
        PlotEntryPos[0] = LeadEntryPos;
        PlotTrainGraphic(12, 0, Display);
    }
    if(MidElement > -1)
    {
        PlotElement[2] = MidElement;
        PlotEntryPos[2] = MidEntryPos;
        PlotTrainGraphic(1, 2, Display);
    }
    // plot the new positions for [1] & [3] graphics -  [1] on Mid if Straddle = MidLag, on Lead if Straddle = LeadMidLag
    // [3] on Lag if Straddle = MidLag, on Mid if Straddle = LeadMidLag
    if(Straddle == MidLag)
    {
        if(MidElement > -1)
        {
            PlotElement[1] = MidElement;
            PlotEntryPos[1] = MidEntryPos;
            PlotTrainGraphic(2, 1, Display);
        }
        if(LagElement > -1)
        {
            PlotElement[3] = LagElement;
            PlotEntryPos[3] = LagEntryPos;
            PlotTrainGraphic(3, 3, Display);
        }
    }
    else // Straddle == LeadMidLag
    {
        if(LeadElement > -1)
        {
            PlotElement[1] = LeadElement;
            PlotEntryPos[1] = LeadEntryPos;
            PlotTrainGraphic(4, 1, Display);
        }
        if(MidElement > -1)
        {
            PlotElement[3] = MidElement;
            PlotEntryPos[3] = MidEntryPos;
            PlotTrainGraphic(5, 3, Display);
        }
    }
    if(Crashed)
    // only reach here if crash into another train, if crash into buffers or an LC then return earlier at the if(Stopped()) test
    {
        RailGraphics->ChangeForegroundColour(0, HeadCodePosition[0], HeadCodePosition[0], clB0G0R0, BackgroundColour);
        PlotTrainWithNewBackgroundColour(7, clCrashedBackground, Display); // red
        TrainController->TrainVectorAtIdent(5, TrainCrashedInto).Crashed = true;
        TrainController->TrainVectorAtIdent(34, TrainCrashedInto).CallingOnFlag = false;
        // in case was set, need to disable call on if call on button had been pressed
        RailGraphics->ChangeForegroundColour(1, TrainController->TrainVectorAtIdent(6, TrainCrashedInto).HeadCodePosition[0],
                                             TrainController->TrainVectorAtIdent(7, TrainCrashedInto).HeadCodePosition[0], clB0G0R0,
                                             TrainController->TrainVectorAtIdent(8, TrainCrashedInto).BackgroundColour);
        TrainController->TrainVectorAtIdent(9, TrainCrashedInto).PlotTrainWithNewBackgroundColour(8, clCrashedBackground, Display); // red
        TrainController->LogActionError(5, HeadCode, TrainController->TrainVectorAtIdent(13, TrainCrashedInto).HeadCode, FailCrashed,
                                        Track->TrackElementAt(621, LeadElement).ElementID);
        Straddle = LeadMidLag;
        // was MidLag but plotted as LeadMidLag so change Straddle accordingly
        Display->Update();
        // resurrected when Update() dropped from PlotOutput etc
        Utilities->CallLogPop(660);
        return;
    }
    // deal here with station stops & pass times after all replotting done but before Straddle changed
    if(TrainMode == Timetable)
    {
        if(Straddle == LeadMidLag)
        {
            if((LeadElement > -1) && (MidElement > -1) && !TimetableFinished)
            {
                // NameInTimetableBeforeCDT returns the number by which the train ActionVectorEntryPtr needs to be incremented
                // to point to the location arrival entry - before a change of direction
                AnsiString LocName = Track->TrackElementAt(249, LeadElement).ActiveTrackElementName;
                bool StopRequired = false;
                int TTVPos = NameInTimetableBeforeCDT(1, LocName, StopRequired);
                if(TTVPos > -1) // -1 if can't find it or if name is ""
                {
                    // check if at buffers (no, dropped buffer check to allow to crash into buffers) or a through station stop,
                    // or a station where next element contains a train or a stop signal, if so
                    // stop now, note that for 2nd check, if next element is a bridge then will have stopped by now so no need
                    // to test the actual track the train is on since it can't be a platform
                    TTrackElement LeadTrackElement = Track->TrackElementAt(258, LeadElement);
                    TTrackElement NextTrackElement; // default for now
                    bool TrainAtStopLinkPos1 = (LeadTrackElement.StationEntryStopLinkPos1 == LeadEntryPos);
                    bool TrainAtStopLinkPos2 = (LeadTrackElement.StationEntryStopLinkPos2 == LeadEntryPos);
                    bool ForwardConnection = (LeadTrackElement.Conn[LeadExitPos] > -1);
                    int NextElementEntryPos = -1;
                    int NextElementExitPos = -1;
                    bool TrainOnNextElement = false;
                    bool StopSignalAtNextElement = false;
                    if(ForwardConnection)
                    // if no forward connection can't derive anything from it without errors
                    {
                        NextTrackElement = Track->TrackElementAt(262, LeadTrackElement.Conn[LeadExitPos]);
                        NextElementEntryPos = LeadTrackElement.ConnLinkPos[LeadExitPos];
                        NextElementExitPos = Track->GetNonPointsOppositeLinkPos(NextElementEntryPos);
                        // this is only for signals so no need to worry about points ambiguity
                        TrainOnNextElement = (NextTrackElement.TrainIDOnElement > -1);
                        StopSignalAtNextElement = ((NextTrackElement.Config[NextElementExitPos] == Signal) && (NextTrackElement.Attribute == 0));
                    }
                    if(TrainAtStopLinkPos1 || TrainAtStopLinkPos2 || (ForwardConnection && (TrainOnNextElement || StopSignalAtNextElement)))
                    {
                        if(TTVPos > 0)
                        {
                            SendMissedActionLogs(1, TTVPos, ActionVectorEntryPtr);
                            ActionVectorEntryPtr += TTVPos;
                        }
                        if(StopRequired)
                        {
                            StoppedAtLocation = true;
                            StoppedAtSignal = false;
                            // may have been set earlier at line 925 so need to reset as
                            // StoppedAtLocation takes precedence and don't want both set at same time or have flashing graphic
                            // in zoom out mode
                            if(!TrainFailed)
                            {
                                PlotTrainWithNewBackgroundColour(12, clStationStopBackground, Display);
                                // pale green
                            }
                            LogAction(8, HeadCode, "", Arrive, LocName, ActionVectorEntryPtr->ArrivalTime, ActionVectorEntryPtr->Warning);
                            ActualArrivalTime = TrainController->TTClockTime;   //added at v2.13.0
                            if(ActionVectorEntryPtr->FormatType == TimeTimeLoc)
                            {
                                TimeTimeLocArrived = true;
                                // used in case of later signaller control, when need to know
                                // whether had arrived or not, to avoid sending the arrival
                                // message twice, see TInterface::TimetableControl1Click
                            }
                        }
                        else
                        {
                            LogAction(25, HeadCode, "", Pass, LocName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
                        }
                        if((ActionVectorEntryPtr->FormatType == TimeLoc) || (ActionVectorEntryPtr->FormatType == PassTime))
                        {
                            ActionVectorEntryPtr++;
                        }
                        // don't alter ActionVectorEntryPtr if at a TimeTimeLoc (& can't be anything else other than TimeLoc or PassTime after calling NameInTimetableBeforeCDT successfully)
                        LastActionTime = TrainController->TTClockTime;
                    }
                }
            }
        }
    }
    if(Straddle == MidLag)
    {
        Straddle = LeadMidLag;
        FirstHalfMove = false;
    }
    else if(Straddle == LeadMidLag)
    {
        Straddle = LeadMid;
        FirstHalfMove = true;
    }
    else if(Straddle == LeadMid)
    {
        throw Exception("Error, Straddle shouldn't be LeadMid prior to resetting at exit from UpdateTrain");
    }
    if(TrainFailurePending) // ok, moving but PlotElements set above
    {
        TrainHasFailed(7);
    }
    Display->Update();
    // need to keep this since Update() not called for PlotSmallOutput as too slow
    Utilities->CallLogPop(661);
}

// ----------------------------------------------------------------------------

Graphics::TBitmap *TTrain::SetOneGraphicCode(char CodeChar)
{
    switch(CodeChar)
    {
    case '0':
        return(RailGraphics->Code0);

    case '1':
        return(RailGraphics->Code1);

    case '2':
        return(RailGraphics->Code2);

    case '3':
        return(RailGraphics->Code3);

    case '4':
        return(RailGraphics->Code4);

    case '5':
        return(RailGraphics->Code5);

    case '6':
        return(RailGraphics->Code6);

    case '7':
        return(RailGraphics->Code7);

    case '8':
        return(RailGraphics->Code8);

    case '9':
        return(RailGraphics->Code9);

    case 'A':
        return(RailGraphics->CodeA);

    case 'B':
        return(RailGraphics->CodeB);

    case 'C':
        return(RailGraphics->CodeC);

    case 'D':
        return(RailGraphics->CodeD);

    case 'E':
        return(RailGraphics->CodeE);

    case 'F':
        return(RailGraphics->CodeF);

    case 'G':
        return(RailGraphics->CodeG);

    case 'H':
        return(RailGraphics->CodeH);

    case 'I':
        return(RailGraphics->CodeI);

    case 'J':
        return(RailGraphics->CodeJ);

    case 'K':
        return(RailGraphics->CodeK);

    case 'L':
        return(RailGraphics->CodeL);

    case 'M':
        return(RailGraphics->CodeM);

    case 'N':
        return(RailGraphics->CodeN);

    case 'O':
        return(RailGraphics->CodeO);

    case 'P':
        return(RailGraphics->CodeP);

    case 'Q':
        return(RailGraphics->CodeQ);

    case 'R':
        return(RailGraphics->CodeR);

    case 'S':
        return(RailGraphics->CodeS);

    case 'T':
        return(RailGraphics->CodeT);

    case 'U':
        return(RailGraphics->CodeU);

    case 'V':
        return(RailGraphics->CodeV);

    case 'W':
        return(RailGraphics->CodeW);

    case 'X':
        return(RailGraphics->CodeX);

    case 'Y':
        return(RailGraphics->CodeY);

    case 'Z':
        return(RailGraphics->CodeZ);

    case 'a':
        return(RailGraphics->Code_a);

    case 'b':
        return(RailGraphics->Code_b);

    case 'c':
        return(RailGraphics->Code_c);

    case 'd':
        return(RailGraphics->Code_d);

    case 'e':
        return(RailGraphics->Code_e);

    case 'f':
        return(RailGraphics->Code_f);

    case 'g':
        return(RailGraphics->Code_g);

    case 'h':
        return(RailGraphics->Code_h);

    case 'i':
        return(RailGraphics->Code_i);

    case 'j':
        return(RailGraphics->Code_j);

    case 'k':
        return(RailGraphics->Code_k);

    case 'l':
        return(RailGraphics->Code_l);

    case 'm':
        return(RailGraphics->Code_m);

    case 'n':
        return(RailGraphics->Code_n);

    case 'o':
        return(RailGraphics->Code_o);

    case 'p':
        return(RailGraphics->Code_p);

    case 'q':
        return(RailGraphics->Code_q);

    case 'r':
        return(RailGraphics->Code_r);

    case 's':
        return(RailGraphics->Code_s);

    case 't':
        return(RailGraphics->Code_t);

    case 'u':
        return(RailGraphics->Code_u);

    case 'v':
        return(RailGraphics->Code_v);

    case 'w':
        return(RailGraphics->Code_w);

    case 'x':
        return(RailGraphics->Code_x);

    case 'y':
        return(RailGraphics->Code_y);

    case 'z':
        return(RailGraphics->Code_z);

    default:
        return(RailGraphics->TempHeadCode);
    }
}

// ----------------------------------------------------------------------------

void TTrain::SetHeadCodeGraphics(int Caller, AnsiString Code)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetHeadCodeGraphics," + HeadCode);
    if(Code.Length() != 4)
    {
        TrainController->StopTTClockMessage(62, "Headcode Incorrect length");
    }
    for(int x = 1; x < 5; x++) // AnsiString indices start at 1
    {
        HeadCodeGrPtr[x - 1]->Assign(SetOneGraphicCode(Code[x]));
    }
    if(BackgroundColour != clB5G5R5)
    // i.e. not the basic graphic colour as loaded from resource file
    {
        for(int x = 0; x < 4; x++)
        {
            RailGraphics->ChangeBackgroundColour3(0, HeadCodeGrPtr[x], HeadCodeGrPtr[x], BackgroundColour, clB5G5R5);
        }
    }
    Utilities->CallLogPop(1484);
}

// ----------------------------------------------------------------------------

void TTrain::GetLeadElement(int Caller)
// assumes Mid & Lag already set, sets LeadElement,
// LeadEntryPos, LeadExitPos & DerailPending (don't want to act on it immediately)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetLeadElement," + HeadCode);
    DerailPending = false;
    LeadElement = Track->TrackElementAt(269, MidElement).Conn[MidExitPos];
    LeadEntryPos = Track->TrackElementAt(270, MidElement).ConnLinkPos[MidExitPos];
    if(Track->TrackElementAt(271, LeadElement).TrackType == Points)
    {
        // attr 0=straight, - links 0 & 1 (0 = lead)
        // attr 1=diverging, - links 2 & 3 (2 = lead)
        // set appropriate next element or derail - use a subroutine & return element & bool for derail
        // points always have links 0 & 2 = lead, link 1 = trailing straight, link 3 = training diverging

        // if enter at lead, exit at whatever attr set at
        // if enter at lag, exit at lead, but set derail wrt attribute
        if((LeadEntryPos == 0) && (Track->TrackElementAt(272, LeadElement).Attribute == 0))
        {
            LeadExitPos = 1;
        }

        // strictly speaking shouldn't need to set to 0 and 2 correctly since TrackIsInARoute caters for both, but
        // best to be on safe side
        else if(LeadEntryPos == 0)
        {
            LeadEntryPos = 2;
            LeadExitPos = 3;
        }
        else if((LeadEntryPos == 2) && (Track->TrackElementAt(273, LeadElement).Attribute == 0))
        {
            LeadEntryPos = 0;
            LeadExitPos = 1;
        }
        else if(LeadEntryPos == 2)
        {
            LeadExitPos = 3;
        }
        else if((LeadEntryPos == 1) && (Track->TrackElementAt(274, LeadElement).Attribute == 0))
        {
            LeadExitPos = 0;
        }
        else if(LeadEntryPos == 1)
        {
            LeadExitPos = 0;
            DerailPending = true;
        }
        else if((LeadEntryPos == 3) && (Track->TrackElementAt(275, LeadElement).Attribute == 0))
        {
            LeadExitPos = 0;
            DerailPending = true;
        }
        else if(LeadEntryPos == 3)
        {
            LeadExitPos = 0;
        }
    }
    else if(LeadEntryPos == 0)
    {
        LeadExitPos = 1;
    }
    else if(LeadEntryPos == 1)
    {
        LeadExitPos = 0;
    }
    else if(LeadEntryPos == 2)
    {
        LeadExitPos = 3;
    }
    else if(LeadEntryPos == 3)
    {
        LeadExitPos = 2;
    }
    // TTrackElement TrackElement = Track->TrackElementAt(276, LeadElement);
/* signal check moved to Update() function
      if((TrackElement.TrackType == SignalPost) && (TrackElement.Config[LeadExitPos] == Signal)
      && (TrackElement.Attribute == 0))//0 = red
      {
      StoppedAtSignal = true;  //comment out for test of locked route graphic replot
      }
      else
      {
      StoppedAtSignal = false;
      }
*/
    Utilities->CallLogPop(662);
}

// ----------------------------------------------------------------------------

void TTrain::GetOffsetValues(int Caller, int &HOffset, int &VOffset, int Link) const
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetOffsetValues," + AnsiString(Link) + "," + HeadCode);
    switch(Link)
    {
    case 1:
    {
        HOffset = 0;
        VOffset = 0;
        break;
    }

    case 2:
    {
        HOffset = 4;
        VOffset = 0;
        break;
    }

    case 3:
    {
        HOffset = 8;
        VOffset = 0;
        break;
    }

    case 4:
    {
        HOffset = 0;
        VOffset = 4;
        break;
    }

    case 6:
    {
        HOffset = 8;
        VOffset = 4;
        break;
    }

    case 7:
    {
        HOffset = 0;
        VOffset = 8;
        break;
    }

    case 8:
    {
        HOffset = 4;
        VOffset = 8;
        break;
    }

    case 9:
    {
        HOffset = 8;
        VOffset = 8;
        break;
    }

    default:
    {
        throw Exception("Error in GetOffsetValues - Link value wrong");
    }
    }
    Utilities->CallLogPop(674);
}

// ---------------------------------------------------------------------------

bool TTrain::LowEntryValue(int EntryLink) const
{
/* returns true if EntryLink is 1, 2, 4 or 7, in these circumstances the front of the train (i.e.
      the character that is red or blue) is the last character of the headcode, otherwise it's the first character of the headcode
*/
    if((EntryLink == 1) || (EntryLink == 2) || (EntryLink == 4) || (EntryLink == 7))
    {
        return(true);
    }
    else
    {
        return(false);
    }
}

// ---------------------------------------------------------------------------

void TTrain::PickUpBackgroundBitmap(int Caller, int HOffset, int VOffset, int Element, int EntryPos, Graphics::TBitmap *GraphicPtr) const
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PickUpBackgroundBitmap," + AnsiString(HOffset) + "," +
                                 AnsiString(VOffset) + "," + AnsiString(Element) + "," + AnsiString(EntryPos) + "," + HeadCode);
    Graphics::TBitmap *EXGraphicPtr = RailGraphics->bmTransparentBgnd;
    // default values
    Graphics::TBitmap *EntryDirectionGraphicPtr = RailGraphics->bmTransparentBgnd;

    TAllRoutes::TRouteType RouteType;

    RouteType = AllRoutes->GetRouteTypeAndGraphics(11, Element, EntryPos, EXGraphicPtr, EntryDirectionGraphicPtr);

    TRect SourceRect, DestRect;

    DestRect.init(0, 0, 8, 8); // initialise left, top, right, bottom
    // note right and bottom rect co-ordinates are 1 greater than the pixel area
    SourceRect.init(HOffset, VOffset, HOffset + 8, VOffset + 8);
    Graphics::TBitmap *TempGraphic = new Graphics::TBitmap;

    TempGraphic->PixelFormat = pf8bit;
    TempGraphic->Width = 16;
    TempGraphic->Height = 16;
    TTrackElement TempElement = Track->TrackElementAt(286, Element);

    if(TempElement.TrackType == Points)
    {
        TempGraphic->Assign(TempElement.GraphicPtr);
        TempGraphic->Transparent = true;
        TempGraphic->TransparentColor = Utilities->clTransparent;
        if(RouteType == TAllRoutes::AutoSigsRoute)
        {
            TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
            TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
        }
        else
        {
            TempGraphic->Canvas->Draw(0, 0, Track->GetFilletGraphic(1, TempElement)); // add fillet
        }
        GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
    }
    else if(TempElement.TrackType == GapJump) // plot set gap
    {
        if(TempElement.SpeedTag == 88)
        {
            TempGraphic->Assign(RailGraphics->gl88set);
        }
        else if(TempElement.SpeedTag == 89)
        {
            TempGraphic->Assign(RailGraphics->gl89set);
        }
        else if(TempElement.SpeedTag == 90)
        {
            TempGraphic->Assign(RailGraphics->gl90set);
        }
        else if(TempElement.SpeedTag == 91)
        {
            TempGraphic->Assign(RailGraphics->gl91set);
        }
        else if(TempElement.SpeedTag == 92)
        {
            TempGraphic->Assign(RailGraphics->gl92set);
        }
        else if(TempElement.SpeedTag == 93)
        {
            TempGraphic->Assign(RailGraphics->bm93set);
        }
        else if(TempElement.SpeedTag == 94)
        {
            TempGraphic->Assign(RailGraphics->bm94set);
        }
        else if(TempElement.SpeedTag == 95)
        {
            TempGraphic->Assign(RailGraphics->gl95set);
        }
        TempGraphic->Transparent = true;
        TempGraphic->TransparentColor = Utilities->clTransparent;
        if(RouteType == TAllRoutes::AutoSigsRoute)
        {
            TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
            TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
        }
        GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
    }
    // new for version 0.6
    else if(TempElement.TrackType == SignalPost)
    {
        if(TempElement.SigAspect == TTrackElement::GroundSignal)
        {
            for(int x = 0; x < 40; x++)
            {
                if((Track->SigTableGroundSignal[x].SpeedTag == TempElement.SpeedTag) && (Track->SigTableGroundSignal[x].Attribute == 0))
                // need to stop aspect
                {
                    TempGraphic->Assign(Track->SigTableGroundSignal[x].SigPtr);
                    break;
                }
            }
        }
        else // normal signal
        {
            TempGraphic->Assign(TempElement.GraphicPtr);
            // GraphicPtr set to normal signal in a signal track element
        }
        TempGraphic->Transparent = true;
        TempGraphic->TransparentColor = Utilities->clTransparent;
        if(RouteType == TAllRoutes::AutoSigsRoute)
        {
            TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
            TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
        }
        GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
    }
    else
    {
        // first check if there's a NamedNonStationLocation element at that position & if so pick up that as the background
        // can't name points gaps or signals so 'else' OK
        bool FoundFlag;
        TTrack::TIMPair IMPair = Track->GetVectorPositionsFromInactiveTrackMap(4, TempElement.HLoc, TempElement.VLoc, FoundFlag);
        if(FoundFlag)
        {
            if(Track->InactiveTrackElementAt(25, IMPair.first).TrackType == NamedNonStationLocation)
            {
                GraphicPtr->Canvas->CopyRect(DestRect, Track->InactiveTrackElementAt(26, IMPair.first).GraphicPtr->Canvas, SourceRect);
                TempGraphic->Assign(RailGraphics->bmName);
                TempGraphic->Transparent = true;
                TempGraphic->TransparentColor = Utilities->clTransparent;
                if(RouteType == TAllRoutes::AutoSigsRoute)
                {
                    TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
                    TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
                }
                else
                {
                    TempGraphic->Canvas->Draw(0, 0, TempElement.GraphicPtr);
                }
                // draw track on top
                GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
            }
            else if(Track->InactiveTrackElementAt(116, IMPair.first).TrackType == LevelCrossing)
            {
                TempGraphic->Assign(TempElement.GraphicPtr);
                TempGraphic->Transparent = true;
                TempGraphic->TransparentColor = Utilities->clTransparent;
                // note that can't be an AutoSigsRoute
                // now overlay the LC central portion
                int BDVectorPos = -1; //not used
                if(Track->AnyLinkedBarrierDownVectorManual(0, Track->InactiveTrackElementAt(130, IMPair.first).HLoc, Track->InactiveTrackElementAt(131, IMPair.first).VLoc, BDVectorPos))
                {
                    TempGraphic->Canvas->Draw(0, 0, RailGraphics->LCPlainMan);
                }
                else
                {
                    TempGraphic->Canvas->Draw(0, 0, RailGraphics->LCPlain);
                }
                GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
            }
            else
            {
                TempGraphic->Assign(TempElement.GraphicPtr);
                TempGraphic->Transparent = true;
                TempGraphic->TransparentColor = Utilities->clTransparent;
                if(RouteType == TAllRoutes::AutoSigsRoute)
                {
                    TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
                    TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
                }
                GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
            }
        }
        else
        {
            TempGraphic->Assign(TempElement.GraphicPtr);
            TempGraphic->Transparent = true;
            TempGraphic->TransparentColor = Utilities->clTransparent;
            if(RouteType == TAllRoutes::AutoSigsRoute)
            {
                TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
                TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
            }
            GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
        }
    }
    delete TempGraphic;
    Utilities->CallLogPop(675);
}

// ---------------------------------------------------------------------------

// This was an attempt to pick up the actual 8x8 graphic from the display, so that text & user graphics would show as soon as the train passed, and overwrite it with the
// reconstructed track, and it works ok but for the little arrows showing route directions at start and end, which extend beyond the track.  It doesn't matter for autosig
// routes because they are replotted (alomg with the direction arrows) but for others they shouldn't be.  Leave in in case an easy way to remove these pointers comes to mind.
/*

  void TTrain::PickUpBackgroundBitmap(int Caller, int HOffset, int VOffset, int Element, int EntryPos, Graphics::TBitmap *GraphicPtr) const
  {
   Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PickUpBackgroundBitmap," + AnsiString(HOffset) +
       "," + AnsiString(VOffset) + "," + AnsiString(Element) + "," + AnsiString(EntryPos) + "," + HeadCode);
   TAllRoutes::TRouteType RouteType;
   Graphics::TBitmap *EXGraphicPtr = RailGraphics->bmTransparentBgnd;
   // default values
   Graphics::TBitmap *EntryDirectionGraphicPtr = RailGraphics->bmTransparentBgnd;
   TTrackElement TempElement = Track->TrackElementAt(, Element); //this is a copy of the element passed into the function
   TRect SourceRect, DestRect, ScreenSourceRect;
   RouteType = AllRoutes->GetRouteTypeAndGraphics(7, Element, EntryPos, EXGraphicPtr, EntryDirectionGraphicPtr);

   DestRect.init(0, 0, 8, 8); //initialise left, top, right, bottom
   // note right and bottom rect co-ordinates are 1 greater than the pixel area
   SourceRect.init(HOffset, VOffset, HOffset + 8, VOffset + 8);

   //add text & user graphics if any to *GraphicPtr prior to adding the track
   int Left = ((TempElement.HLoc - Display->DisplayOffsetH) * 16) + HOffset;
   int Top = ((TempElement.VLoc - Display->DisplayOffsetV) * 16) + VOffset;
   int Right = Left + 8;
   int Bottom = Top + 8;
   ScreenSourceRect.init(Left, Top, Right, Bottom);
   GraphicPtr->Canvas->CopyMode = cmSrcCopy;
   GraphicPtr->Canvas->CopyRect(DestRect, Display->GetImage()->Canvas, ScreenSourceRect);

   Graphics::TBitmap *TempGraphic = new Graphics::TBitmap; //this will hold the 16x16 reconstructed element, prior to transfer of the 8x8 bit to *GraphicPtr
   TempGraphic->PixelFormat = pf8bit;
   TempGraphic->Width = 16;
   TempGraphic->Height = 16;

   Graphics::TBitmap *SourceGraphic = new Graphics::TBitmap; //this will hold the 8x8 element segment from TempGraphic - needed because to keep transparency have to use Draw, not CopyRect
   SourceGraphic->PixelFormat = pf8bit;
   SourceGraphic->Width = 16;
   SourceGraphic->Height = 16;
   SourceGraphic->Transparent = true;
   SourceGraphic->TransparentColor = Utilities->clTransparent;

   if (TempElement.TrackType == Points)
   {
       TempGraphic->Assign(TempElement.GraphicPtr);
       TempGraphic->Transparent = true;
       TempGraphic->TransparentColor = Utilities->clTransparent;
       if (RouteType == TAllRoutes::AutoSigsRoute)
       {
           TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
           TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
       }
       else
       {
           TempGraphic->Canvas->Draw(0, 0, Track->GetFilletGraphic(1, TempElement)); // add fillet
       }
       GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
   }
   else if (TempElement.TrackType == GapJump) // plot set gap
   {
       if (TempElement.SpeedTag == 88)
           TempGraphic->Assign(RailGraphics->gl88set);
       else if (TempElement.SpeedTag == 89)
           TempGraphic->Assign(RailGraphics->gl89set);
       else if (TempElement.SpeedTag == 90)
           TempGraphic->Assign(RailGraphics->gl90set);
       else if (TempElement.SpeedTag == 91)
           TempGraphic->Assign(RailGraphics->gl91set);
       else if (TempElement.SpeedTag == 92)
           TempGraphic->Assign(RailGraphics->gl92set);
       else if (TempElement.SpeedTag == 93)
           TempGraphic->Assign(RailGraphics->bm93set);
       else if (TempElement.SpeedTag == 94)
           TempGraphic->Assign(RailGraphics->bm94set);
       else if (TempElement.SpeedTag == 95)
           TempGraphic->Assign(RailGraphics->gl95set);
       TempGraphic->Transparent = true;
       TempGraphic->TransparentColor = Utilities->clTransparent;
       if (RouteType == TAllRoutes::AutoSigsRoute) {
           TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
           TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
       }
       GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
   }
   // new for version 0.6
   else if (TempElement.TrackType == SignalPost)
   {
       if (TempElement.SigAspect == TTrackElement::GroundSignal)
       {
           for (int x = 0; x < 40; x++)
           {
               if ((Track->SigTableGroundSignal[x].SpeedTag == TempElement.SpeedTag) && (Track->SigTableGroundSignal[x].Attribute == 0))
                   // need to stop aspect
               {
                   TempGraphic->Assign(Track->SigTableGroundSignal[x].SigPtr);
                   break;
               }
           }
       }
       else // normal signal
       {
           TempGraphic->Assign(TempElement.GraphicPtr);
           // GraphicPtr set to normal signal in a signal track element
       }
       TempGraphic->Transparent = true;
       TempGraphic->TransparentColor = Utilities->clTransparent;
       if (RouteType == TAllRoutes::AutoSigsRoute) {
           TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
           TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
       }
       GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
   }
   else {
       // first check if there's a NamedNonStationLocation element at that position & if so pick up that as the background
       // can't name points gaps or signals so 'else' OK
       bool FoundFlag;
       TTrack::TIMPair IMPair = Track->GetVectorPositionsFromInactiveTrackMap
           (4, TempElement.HLoc, TempElement.VLoc, FoundFlag);
       if (FoundFlag)
       {
           if (Track->InactiveTrackElementAt(, IMPair.first).TrackType == NamedNonStationLocation)
           {
               GraphicPtr->Canvas->CopyRect(DestRect,
                   Track->InactiveTrackElementAt(, IMPair.first).GraphicPtr->Canvas, SourceRect);
               TempGraphic->Assign(RailGraphics->bmName);
               TempGraphic->Transparent = true;
               TempGraphic->TransparentColor = Utilities->clTransparent;
               if (RouteType == TAllRoutes::AutoSigsRoute)
               {
                   TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
                   TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
               }
               else
                   TempGraphic->Canvas->Draw(0, 0, TempElement.GraphicPtr);
               // draw track on top
               GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas,
                   SourceRect);
           }
           else if (Track->InactiveTrackElementAt(, IMPair.first).TrackType == LevelCrossing) {
               TempGraphic->Assign(TempElement.GraphicPtr);
               TempGraphic->Transparent = true;
               TempGraphic->TransparentColor = Utilities->clTransparent;
               // note that can't be an AutoSigsRoute
               // now overlay the LC central portion
               TempGraphic->Canvas->Draw(0, 0, RailGraphics->LCPlain);
               GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas,
                   SourceRect);
           }
           else {
               TempGraphic->Assign(TempElement.GraphicPtr);
               TempGraphic->Transparent = true;
               TempGraphic->TransparentColor = Utilities->clTransparent;
               if (RouteType == TAllRoutes::AutoSigsRoute) {
                   TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
                   TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
               }
               GraphicPtr->Canvas->CopyRect(DestRect, TempGraphic->Canvas,
                   SourceRect);
           }
       }
       else {
           TempGraphic->Assign(TempElement.GraphicPtr);
           TempGraphic->Transparent = true;
           TempGraphic->TransparentColor = Utilities->clTransparent;
           if (RouteType == TAllRoutes::AutoSigsRoute) {
               TempGraphic->Canvas->Draw(0, 0, EXGraphicPtr);
               TempGraphic->Canvas->Draw(0, 0, EntryDirectionGraphicPtr);
           }
           SourceGraphic->Canvas->CopyRect(DestRect, TempGraphic->Canvas, SourceRect);
           GraphicPtr->Canvas->Draw(0, 0, SourceGraphic);
       }
   }
   delete TempGraphic;
   delete SourceGraphic;
   Utilities->CallLogPop();
  }
*/
// ---------------------------------------------------------------------------

void TTrain::PlotTrainGraphic(int Caller, int ArrayNumber, TDisplay *Disp)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotTrainGraphic," + AnsiString(ArrayNumber) + "," + HeadCode);
    if(PlotElement[ArrayNumber] == -1)
    {
        Utilities->CallLogPop(676);
        return; // not plotted yet
    }
    SetTrainElementID(0, PlotElement[ArrayNumber], PlotEntryPos[ArrayNumber]);
    // set before plot so gap flashing stops first
    Disp->PlotOutput(29, ((Track->TrackElementAt(295, PlotElement[ArrayNumber]).HLoc * 16) + HOffset[ArrayNumber]),
                     ((Track->TrackElementAt(296, PlotElement[ArrayNumber]).VLoc * 16) + VOffset[ArrayNumber]), HeadCodePosition[ArrayNumber]);
    // Only need to set ID for leading element, stays set until train finally leaves the element
    Plotted = true;
    Utilities->CallLogPop(677);
}

// ---------------------------------------------------------------------------

void TTrain::PlotBackgroundGraphic(int Caller, int ArrayNumber, TDisplay *Disp) const
{
    Disp->PlotOutput(30, ((Track->TrackElementAt(297, PlotElement[ArrayNumber]).HLoc * 16) + HOffset[ArrayNumber]),
                     ((Track->TrackElementAt(298, PlotElement[ArrayNumber]).VLoc * 16) + VOffset[ArrayNumber]), BackgroundPtr[ArrayNumber]);
}

// ---------------------------------------------------------------------------

bool TTrain::BufferAtExit(int Caller, int Element, int ExitPos) const
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",BufferAtExit," + AnsiString(Element) + "," + AnsiString(ExitPos) + "," +
                                 HeadCode);
    if((Track->TrackElementAt(299, Element).TrackType == Buffers) && (Track->TrackElementAt(300, Element).Config[ExitPos] == End))
    {
        Utilities->CallLogPop(678);
        return(true);
    }
    else
    {
        Utilities->CallLogPop(679);
        return(false);
    }
}

// ---------------------------------------------------------------------------

bool TTrain::ContinuationExit(int Caller, int Element, int ExitPos) const
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ContinuationExit," + AnsiString(Element) + "," + AnsiString(ExitPos) +
                                 "," + HeadCode);
    if((Track->TrackElementAt(301, Element).TrackType == Continuation) && (Track->TrackElementAt(302, Element).Config[ExitPos] == End))
    {
        Utilities->CallLogPop(680);
        return(true);
    }
    else
    {
        Utilities->CallLogPop(681);
        return(false);
    }
}

// ---------------------------------------------------------------------------

bool TTrain::IsTrainIDOnBridgeTrackPos01(int Caller, unsigned int TrackVectorPosition)
// test whether this train on a bridge on trackpos 0 & 1
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsTrainIDOnBridgeTrackPos01," + AnsiString(TrackVectorPosition) + "," +
                                 HeadCode);
    if(Track->TrackElementAt(303, TrackVectorPosition).TrackType != Bridge)
    {
        Utilities->CallLogPop(682);
        return(false);
    }
    // if(Track->TrackElementAt(304, TrackVectorPosition).TrainIDOnElement != TrainID) return false; No, if a bridge could be one of 2 TrainIDs
    if(Track->TrackElementAt(305, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 == TrainID)
    {
        if(Track->TrackElementAt(306, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 == TrainID)
        {
            throw Exception("Error, same train on two different bridge tracks");
        }
        else
        {
            Utilities->CallLogPop(684);
            return(true);
        }
    }
    else
    {
        Utilities->CallLogPop(685);
        return(false);
    }
}

// ---------------------------------------------------------------------------

bool TTrain::IsTrainIDOnBridgeTrackPos23(int Caller, unsigned int TrackVectorPosition)
// test whether this train on a bridge on trackpos 2 & 3
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsTrainIDOnBridgeTrackPos23," + AnsiString(TrackVectorPosition) + "," +
                                 HeadCode);
    if(Track->TrackElementAt(307, TrackVectorPosition).TrackType != Bridge)
    {
        Utilities->CallLogPop(686);
        return(false);
    }
    // if(Track->TrackElementAt(308, TrackVectorPosition).TrainIDOnElement != TrainID) return false; No, if a bridge could be one of 2 TrainIDs
    if(Track->TrackElementAt(309, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 == TrainID)
    {
        // don't carry out check for train on tracks 0 & 1 else will enter an infinite loop if train on both
        Utilities->CallLogPop(687);
        return(true);
    }
    else
    {
        Utilities->CallLogPop(688);
        return(false);
    }
}

// ---------------------------------------------------------------------------

void TTrain::SetTrainElementID(int Caller, unsigned int TrackVectorPosition, int EntryPos)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetTrainElementID," + AnsiString(TrackVectorPosition) + "," +
                                 AnsiString(EntryPos) + "," + HeadCode);
    Track->TrackElementAt(310, TrackVectorPosition).TrainIDOnElement = TrainID;

    // unplot GapFlash graphics if land on flashing gap (this done before train plotted - see PlotTrainGraphic)
    if(Track->GapFlashFlag)
    {
        if((LeadElement == Track->GapFlashGreenPosition) || (LeadElement == Track->GapFlashRedPosition))
        {
            Track->GapFlashGreen->PlotOriginal(12, Display);
            Track->GapFlashRed->PlotOriginal(13, Display);
            Track->GapFlashFlag = false;
        }
    }
    if(Track->TrackElementAt(311, TrackVectorPosition).TrackType == Bridge)
    {
        if(EntryPos == -1)
        {
            throw Exception("Error, TrackVectorPosition set but not EntryPos in SetTrainElementID");
        }
        if(EntryPos < 2)
        {
            Track->TrackElementAt(312, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TrainID;
        }
        else
        {
            Track->TrackElementAt(313, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = TrainID;
        }
    }
    Utilities->CallLogPop(690);
}

// ---------------------------------------------------------------------------

void TTrain::ResetTrainElementID(int Caller, unsigned int TrackVectorPosition, int EntryPos)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ResetTrainElementID," + AnsiString(TrackVectorPosition) + "," +
                                 AnsiString(EntryPos) + "," + HeadCode);
    if(Track->TrackElementAt(314, TrackVectorPosition).TrackType != Bridge)
    {
        Track->TrackElementAt(315, TrackVectorPosition).TrainIDOnElement = -1;
    }
    else
    {
        if(EntryPos == -1)
        {
            throw Exception("Error, TrackVectorPosition set but not EntryPos in ResetTrainElementID");
        }
        if(EntryPos < 2)
        {
            Track->TrackElementAt(316, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = -1;
        }
        else
        {
            Track->TrackElementAt(317, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = -1;
        }
        if((EntryPos < 2) && (Track->TrackElementAt(318, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 > -1))
        // i.e. other train on track 2&3
        {
            Track->TrackElementAt(319, TrackVectorPosition).TrainIDOnElement = Track->TrackElementAt(320, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
        }
        else if((EntryPos > 1) && (Track->TrackElementAt(321, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 > -1))
        // i.e. other train on track 1&2
        {
            Track->TrackElementAt(322, TrackVectorPosition).TrainIDOnElement = Track->TrackElementAt(323, TrackVectorPosition).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
        }
        else
        {
            Track->TrackElementAt(324, TrackVectorPosition).TrainIDOnElement = -1;
        }
    }
    Utilities->CallLogPop(691);
}

// ---------------------------------------------------------------------------

void TTrain::PlotAlternativeTrackRouteGraphic(int Caller, unsigned int ElementVecNum, int ElementEntryPos, int HOffset, int VOffset, TStraddle StraddleValue)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotAlternativeTrackRouteGraphic," + AnsiString(ElementVecNum) + "," +
                                 AnsiString(ElementEntryPos) + "," + AnsiString(HOffset) + "," + AnsiString(VOffset) + "," + AnsiString(StraddleValue) + "," + HeadCode);
    int LockedVectorNumber;

    if(Track->TrackElementAt(325, ElementVecNum).TrackType != Bridge)
    // && (Track->TrackElementAt(326, ElementVecNum).TrackType != Crossover))
    {
        // only applies for a bridge as there can't be (or shouldn't be) 2 routes on an element that isn't a bridge
        Utilities->CallLogPop(692);
        return;
    }
    if(AllRoutes->TrackIsInARoute(0, ElementVecNum, (3 - ElementEntryPos)))
    // i.e other track is in a marked route
    // LinkPos doesn't have to be the entry position for the above check
    {
        TRect SourceRect, DestRect;
        DestRect.init(0, 0, 8, 8); // left, top, right, bottom
        // note right and bottom rect co-ordinates are 1 greater than the pixel area
        SourceRect.init(HOffset, VOffset, HOffset + 8, VOffset + 8);
        // identify the route element for the other track
        TAllRoutes::TRouteElementPair RoutePair1, RoutePair2;
        RoutePair1 = AllRoutes->GetRouteElementDataFromRoute2MultiMap(13, Track->TrackElementAt(327, ElementVecNum).HLoc,
                                                                      Track->TrackElementAt(328, ElementVecNum).VLoc, RoutePair2);
        int FirstELink, SecondELink = -1;
        FirstELink = AllRoutes->GetFixedRouteAt(149, RoutePair1.first).GetFixedPrefDirElementAt(159, RoutePair1.second).GetELink();
        // must be at least one
        if(RoutePair2.first > -1)
        {
            SecondELink = AllRoutes->GetFixedRouteAt(150, RoutePair2.first).GetFixedPrefDirElementAt(160, RoutePair2.second).GetELink();
        }
        TPrefDirElement RouteElement;
        // Graphics::TBitmap *RouteGraphic;
        if(FirstELink == Track->TrackElementAt(329, ElementVecNum).Link[ElementEntryPos])
        // i.e. other track is in RoutePair2
        {
            if(SecondELink == -1)
            {
                throw Exception("Error - Second ELink should be set but isn't in PlotAlternativeTrackRouteGraphic [1]");
            }
            if(SecondELink == Track->TrackElementAt(330, ElementVecNum).Link[ElementEntryPos])
            // error if both have same Link number
            {
                throw Exception("Error - First & Second ELinks have same value in PlotAlternativeTrackRouteGraphic");
            }
            // RouteGraphic = AllRoutes->GetFixedRouteAt(151, RoutePair2.first).GetFixedPrefDirElementAt(161, RoutePair2.second).GetEXGraphicPtr();
            RouteElement = AllRoutes->GetFixedRouteAt(152, RoutePair2.first).GetFixedPrefDirElementAt(162, RoutePair2.second);
        }
        else // other track is in RoutePair1
        {
            // RouteGraphic = AllRoutes->GetFixedRouteAt(153, RoutePair1.first).GetFixedPrefDirElementAt(163, RoutePair1.second).GetEXGraphicPtr();
            RouteElement = AllRoutes->GetFixedRouteAt(154, RoutePair1.first).GetFixedPrefDirElementAt(164, RoutePair1.second);
        }
        Graphics::TBitmap *DestGraphic = new Graphics::TBitmap;
        DestGraphic->PixelFormat = pf8bit;
        DestGraphic->Width = 8;
        DestGraphic->Height = 8;
        DestGraphic->Transparent = true;
        // has to be transparent or will overwrite the track that the train has just left
        DestGraphic->TransparentColor = Utilities->clTransparent;
        DestGraphic->Canvas->CopyRect(DestRect, RouteElement.GetRouteEXGraphicPtr()->Canvas, SourceRect);
        Display->PlotOutput(31, (Track->TrackElementAt(331, ElementVecNum).HLoc * 16) + HOffset,
                            (Track->TrackElementAt(332, ElementVecNum).VLoc * 16) + VOffset, DestGraphic);
        // plot locked route marker for other route if appropriate
        TPrefDirElement PrefDirElement; // holder for next call, unused
        // plot locked route marker if appropriate, but only when train leaves element completely as this is a 16x16 graphic
        if(StraddleValue == LeadMidLag)
        {
            if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(11, RouteElement.GetTrackVectorPosition(), RouteElement.GetXLinkPos(),
                                                                                       PrefDirElement, LockedVectorNumber))
            {
                Display->PlotOutput(32, (Track->TrackElementAt(333, ElementVecNum).HLoc * 16), (Track->TrackElementAt(334, ElementVecNum).VLoc * 16),
                                    RailGraphics->LockedRouteCancelPtr[RouteElement.GetELink()]);
            }
        }
        delete DestGraphic;
    }
    // but - there may be a train on the other track - if so need to replot it else the section of route overwrites it
    // also can only be a bridge or trains either have already or soon will crash
    if(Track->TrackElementAt(335, ElementVecNum).TrackType != Bridge)
    {
        Utilities->CallLogPop(695);
        return;
    }
    if(ElementEntryPos > 1) // other train is on track 01
    {
        if(Track->TrackElementAt(336, ElementVecNum).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 > -1)
        {
            TrainController->TrainVectorAtIdent(31, Track->TrackElementAt(337, ElementVecNum).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01).PlotTrain(2, Display);
        }
    }
    else // other train is on track 23
    {
        if(Track->TrackElementAt(338, ElementVecNum).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 > -1)
        {
            TrainController->TrainVectorAtIdent(32, Track->TrackElementAt(339, ElementVecNum).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23).PlotTrain(3, Display);
        }
    }
    Utilities->CallLogPop(696);
}

// ---------------------------------------------------------------------------

void TTrain::CheckAndCancelRouteForWrongEndEntry(int Caller, int Element, int EntryPos)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckAndCancelRouteForWrongEndEntry," + AnsiString(Element) + "," +
                                 AnsiString(EntryPos) + "," + HeadCode);
    int RouteNumber;
    bool WrongRoute = false;
    TPrefDirElement RouteElement;
    TAllRoutes::TRouteElementPair RoutePair;
    TAllRoutes::TRoute2MultiMapIterator Route2MultiMapIterator;

    if(AllRoutes->GetRouteTypeAndNumber(11, Element, EntryPos, RouteNumber) == TAllRoutes::NoRoute)
    // here if single track element & no route, or double track element with no route at EntryPos but still need to check if on points or a crossover on non-route track,
    // and force-erase route if so (bridge OK of course) note that GetRouteTypeAndNumber allows for points having an EntryPos of 0 or 2 & still returns correct values
    {
        if((Track->TrackElementAt(340, Element).TrackType == Crossover) || (Track->TrackElementAt(341, Element).TrackType == Points))
        {
            if(AllRoutes->GetRouteTypeAndNumber(12, Element, (3 - EntryPos), RouteNumber) != TAllRoutes::NoRoute)
            // (3-EntryPos) guarantees other route (0->3; 1->2; 2->1; 3->0)
            {
                if(AllRoutes->GetFixedRouteAt(179, RouteNumber).PrefDirSize() > 2)
                {
                    // don't call for stub end routes
                    TrainController->LogActionError(49, HeadCode, "", RouteForceCancelled, Track->TrackElementAt(799, Element).ElementID);
                }
                AllRoutes->GetModifiableRouteAt(13, RouteNumber).ForceCancelRoute(1);
                Utilities->CallLogPop(697);
                return;
            }
        }
        // also need to check for a route on a crossing diagonal
        TTrackElement TrackElement = Track->TrackElementAt(892, Element);
        int LinkNumber = TrackElement.Link[EntryPos];
        if((LinkNumber == 1) || (LinkNumber == 3) || (LinkNumber == 7) || (LinkNumber == 9))
        {
            if(AllRoutes->DiagonalFouledByRoute(0, TrackElement.HLoc, TrackElement.VLoc, LinkNumber))
            {
                // for LinkNumber = 1, potentially fouled diagonals are at H-1, V, Lk 3 & H, V-1, Lk 7
                bool LogActionErrorCalled = false;
                // to ensure only called once if have 2 routes on the 2 crossed diagonals
                if(LinkNumber == 1)
                {
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(0, TrackElement.HLoc - 1, TrackElement.VLoc, 3, RouteNumber))
                    {
                        if(AllRoutes->GetFixedRouteAt(207, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(55, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                            LogActionErrorCalled = true;
                        }
                        AllRoutes->GetModifiableRouteAt(20, RouteNumber).ForceCancelRoute(3);
                    }
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(1, TrackElement.HLoc, TrackElement.VLoc - 1, 7, RouteNumber))
                    // not else in case have different routes on each diagonal, though shouldn't be possible
                    {
                        if(!LogActionErrorCalled && AllRoutes->GetFixedRouteAt(208, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(56, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                        }
                        AllRoutes->GetModifiableRouteAt(21, RouteNumber).ForceCancelRoute(4);
                    }
                }

                // for LinkNumber = 3, potentially fouled diagonals are at H+1, V, Lk 1 & H, V-1 Lk 9
                else if(LinkNumber == 3)
                {
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(2, TrackElement.HLoc + 1, TrackElement.VLoc, 1, RouteNumber))
                    {
                        if(AllRoutes->GetFixedRouteAt(209, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(57, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                            LogActionErrorCalled = true;
                        }
                        AllRoutes->GetModifiableRouteAt(22, RouteNumber).ForceCancelRoute(5);
                    }
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(3, TrackElement.HLoc, TrackElement.VLoc - 1, 9, RouteNumber))
                    // not else in case have different routes on each diagonal, though shouldn't be possible
                    {
                        if(!LogActionErrorCalled && AllRoutes->GetFixedRouteAt(210, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(58, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                        }
                        AllRoutes->GetModifiableRouteAt(23, RouteNumber).ForceCancelRoute(6);
                    }
                }

                // for LinkNumber = 7, potentially fouled diagonals are at H-1, V, Lk 9 & H, V+1 Lk 1
                else if(LinkNumber == 7)
                {
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(4, TrackElement.HLoc - 1, TrackElement.VLoc, 9, RouteNumber))
                    {
                        if(AllRoutes->GetFixedRouteAt(211, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(59, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                            LogActionErrorCalled = true;
                        }
                        AllRoutes->GetModifiableRouteAt(24, RouteNumber).ForceCancelRoute(7);
                    }
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(5, TrackElement.HLoc, TrackElement.VLoc + 1, 1, RouteNumber))
                    // not else in case have different routes on each diagonal, though shouldn't be possible
                    {
                        if(!LogActionErrorCalled && AllRoutes->GetFixedRouteAt(212, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(60, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                        }
                        AllRoutes->GetModifiableRouteAt(25, RouteNumber).ForceCancelRoute(8);
                    }
                }

                // for LinkNumber = 9, potentially fouled diagonals are at H+1, V, Lk 7 & H, V+1 Lk 3
                else if(LinkNumber == 9)
                {
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(6, TrackElement.HLoc + 1, TrackElement.VLoc, 7, RouteNumber))
                    {
                        if(AllRoutes->GetFixedRouteAt(213, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(61, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                            LogActionErrorCalled = true;
                        }
                        AllRoutes->GetModifiableRouteAt(26, RouteNumber).ForceCancelRoute(9);
                    }
                    if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(7, TrackElement.HLoc, TrackElement.VLoc + 1, 3, RouteNumber))
                    // not else in case have different routes on each diagonal, though shouldn't be possible
                    {
                        if(!LogActionErrorCalled && AllRoutes->GetFixedRouteAt(214, RouteNumber).PrefDirSize() > 2)
                        {
                            // don't call for stub end routes
                            TrainController->LogActionError(62, HeadCode, "", RouteForceCancelled, TrackElement.ElementID);
                        }
                        AllRoutes->GetModifiableRouteAt(27, RouteNumber).ForceCancelRoute(10);
                    }
                }
            }
        }
        Utilities->CallLogPop(698);
        return; // no route on other track or no other track
    }
    // here if there is a route at Element & EntryPos - so there can't be a route on the other track if a 4 track element, unless it's a bridge & that's ok
    for(unsigned int x = 0; x < AllRoutes->GetFixedRouteAt(155, RouteNumber).PrefDirSize(); x++)
    {
        RouteElement = AllRoutes->GetFixedRouteAt(156, RouteNumber).GetFixedPrefDirElementAt(165, x);
        bool PointsAtElement = (Track->TrackElementAt(987, Element).TrackType == Points); // new at v2.4.2 for points check - Xeon repoted it 30/05/20. He found that for routes that
        if(RouteElement.GetTrackVectorPosition() == (unsigned int)Element) // cross bridges at both levels can have entrypos 0 & other exitpos 2 so if don't have this check can cancel a route wrongly
        {
            if(RouteElement.GetELinkPos() == EntryPos)
            {
                Utilities->CallLogPop(699);
                return; // right direction
            }
            else if((RouteElement.GetELinkPos() == 2) && (EntryPos == 0) && PointsAtElement)
            {
                Utilities->CallLogPop(700);
                return; // right direction (points)
            }
            else if((RouteElement.GetELinkPos() == 0) && (EntryPos == 2) && PointsAtElement)
            {
                Utilities->CallLogPop(701);
                return; // right direction (points)
            }
            else if(RouteElement.GetXLinkPos() == EntryPos)
            {
                WrongRoute = true;
                break; // wrong direction
            }
            else if((RouteElement.GetXLinkPos() == 2) && (EntryPos == 0) && PointsAtElement) // ok for bridges
            {
                WrongRoute = true;
                break; // wrong direction
            }
            else if((RouteElement.GetXLinkPos() == 0) && (EntryPos == 2) && PointsAtElement) // ok for bridges
            {
                WrongRoute = true;
                break; // wrong direction
            }
        }
    }
    if(!WrongRoute)
    {
        throw Exception("Error, Element in route but no route found in CheckAndCancelRouteForWrongEndEntry");
    }
    if(AllRoutes->GetFixedRouteAt(180, RouteNumber).PrefDirSize() > 2)
    {
        // don't call for stub end routes
        TrainController->LogActionError(50, HeadCode, "", RouteForceCancelled, Track->TrackElementAt(800, Element).ElementID);
    }
    AllRoutes->GetModifiableRouteAt(14, RouteNumber).ForceCancelRoute(2);
    Utilities->CallLogPop(703);
}

// ---------------------------------------------------------------------------

void TTrain::PlotTrainWithNewBackgroundColour(int Caller, TColor NewBackgroundColour, TDisplay *Disp)
{
    if(BackgroundColour == NewBackgroundColour)
    {
        return; // don't replot if already correct

    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotTrainWithNewBackgroundColour," + AnsiString(NewBackgroundColour));
    bool ColourError = false, ColourError2 = false;

    RailGraphics->ChangeBackgroundColour(1, FrontCodePtr, FrontCodePtr, NewBackgroundColour, BackgroundColour, ColourError);
    if(ColourError)
    {
        ColourError2 = true;
    }
    for(int x = 0; x < 4; x++)
    {
        RailGraphics->ChangeBackgroundColour(2, HeadCodeGrPtr[x], HeadCodeGrPtr[x], NewBackgroundColour, BackgroundColour, ColourError);
        if(ColourError)
        {
            ColourError2 = true;
        }
    }
    if(ColourError2)
    {
        TrainController->StopTTClockMessage(63,
                                            "ERROR:  Colour depth insufficient to display train colours properly.  Please ensure that the 'safe' (web) palette of 256 colours can be displayed");
    }
    // NB need a separate 'for' loop since the plot order can be different from the graphic order depending on the direction
    // of motion
    for(int x = 0; x < 4; x++)
    {
        PlotTrainGraphic(6, x, Disp);
    }
    BackgroundColour = NewBackgroundColour;
    Display->Update();
    // need to keep this since Update() not called for PlotSmallOutput as too slow
    Utilities->CallLogPop(704);
}

// ---------------------------------------------------------------------------

void TTrain::SetTrainMovementValues(int Caller, int TrackVectorPosition, int EntryPos)
/*
Note:  Within the loop BrakeRate can only increase and MaxExitSpeed can only reduce

Summary:  Called during PlotStartPosition to set initial values, when stopped and need to restart, and during UpdateTrain when Straddle is LeadMidLag,
i.e. just as the front of a train is about to move fully onto an element, where TrackVectorPosition is the element immediately in front
of the element the front of the train is moving fully on to.  The function calculates the times and speeds at the next half-element and
full-element moves.

Detail:  TrackVectorPosition & EntryPos correspond to the TrackVector element immediately in front of where the train is at
the end of the current Update().  EntrySpeed is needed but this is a class data member so isn't passed in.  Set the
train BrakeRate to zero (for now, likely to be altered later), & check if zero entry speed with another train directly in front & if so
remain stopped.  Pick up the half length value and speed limit for the EntryPos track, and set FrontElementLength to the length of the
EntryPos track, then set LimitingSpeed to the minimum of the element speed limit or the train's maximum speed.  Check if running past a
red signal and set SPADFlag if so (use 1 for EntrySpeed rather than 0 as this value is a double so could be slightly in excess of 0).
In this case set the brake rate to maximum to stop as soon as possible.

For no SPAD calculate the distance that will be travelled at the maximum speed at which the train can exit the next element at half
MaxBrakeRate, this is DistanceAtHalfBraking (also calculate DistanceAtThreeQuarterBraking - used for stopping under signaller control).
DistanceAtHalfBraking is used as the limiting forward look from the next element (i.e. following EntryPos)
for computing the actual braking rate.  If no more restrictive speed limits or reasons to stop are found within the forward look then the
train can accelerate or stay at its (local) maximum speed for the next element.  The maximum speed on exit from the next element is used
for calculating the forward look because it represents the worst case - i.e. assumes that the train accelerates for the next element.

A loop is now entered where the CumulativeLength is updated and each successive element (if there are any - current element checked
first to see whether buffers or continuation) in turn is examined: first the length of the
current element is added to the cumulative length; then the half length and speedlimit are set for the next element - points are
followed according to their current setting (Attribute), but derailments are ignored as these are dealt with outside this function; checks
are then made to see whether the next element is a red signal (train should stop before it); next element is a buffer (train should stop
at the end of it so the cumulative length has the next element length added); current element is a buffer (train should stop
at the end of the current element so no need to alter the cumulative length); or have reached a named location stop position.  For any of
these reasons, or if stopping under signaller control, there is no more looping, instead the braking rate is calculated to bring the train
to a stop over CumulativeLength.  For all normal purposes the braking rate will be less than half (light braking), or less than three
quarters if stopping under signaller control (heavy braking).  However if signals are reset in front of a train then the train may need
emergency braking (> 90% max brake rate) and a SPAD may result.  Similarly if points are chaged in front of a train that divert it into a
siding then again emeregency braking may be necessary and a crash may result.

If the train is due to stop then the function calculates the half and full times and speeds and returns.  However the calculation depends
on the conditions at entry.  If the EntrySpeed is lower than MaxHalfSpeed and the EntryPos element is the one
that the train has to stop at the end of, as it might be for example if train had been stopped at a signal and the next element is a
buffer, then the train accelerates for half the element and brakes for the other half.
Now the BrakeRate is calculated (limited to the MaxBrakeRate), but if it is less than a value calculated at an earlier pass round
the loop then it retains its earlier value (may be due to a close speed restriction that requires more braking than a more distant stop
requirement).  The MaxExitSpeedAtHalfBraking (maximum speed at which the train can leave the current element and still stop when required
at half the max braking rate) value is also calculated using EntrySpeed and CumulativeLength, but limiting it to the line speed limit or
train MaxRunningSpeed whichever is the lower.  If EntrySpeed > MaxExitSpeedAtHalfBraking then braking is required, so the half and full
speed and time values for the current element are calculated using BrakeRate, EntrySpeed and CurrentElementHalfLength.  If need to stop
at the end of the current elemecumulativent for other than a red signal (SPADs can occur) then ExitSpeedFull is set to 0.  It should be calculated
as 0 anyway for other than a red signal but this makes sure.  If EntrySpeed <= MaxExitSpeedAtHalfBraking then can calculate the half and
full speed and time values for acceleration over the current element, but limit ExitSpeedHalf & Full to MaxExitSpeedAtHalfBraking or to
the current element speed limit if necessary.  Check whether ExitSpeedHalf <= EntrySpeed (+0.01 since it's a double) and use constant speed
time values for Half & Full if so, but prior to this increase EntrySpeed if necessary to avoid a divide by zero error.

If the train is not due to stop within the DistanceAtHalfBraking from the next element following EntryPos then the next element (if there
is one) is checked to see if its speed limit is less than the current value of LimitingSpeed (which is the minimum of any earlier element's
speed limit that has been examined within the loop and the train's MaxRunning speed), and if so LimitingSpeed is set down to it.  Now
the MaxExitSpeedAtHalfBraking is calculated, limiting it to LimitingSpeed if less, in case need to accelerate in the current element, in
which case the exit speeds need to be limited to MaxExitSpeedAtHalfBraking.  If EntrySpeed > LimitingSpeed then calculate the braking rate
to bring the speed down to LimitingSpeed in CumulativeLength, keeping the existing BrakeRate value if lower and keeping it within
MaxBrakeRate.

Then, providing the current element isn't a buffer or continuation, the 'Current' values are updated from the 'Next' values ready for
the next loop iteration.  The loop is broken out of if the current element is a buffer or continuation, the next element is a
continuation, or (CumulativeLength - FrontElementLength) >= DistanceAtHalfBraking.

Now the final Half and Full values can be set for braking (if BrakeRate > 0.01), or accelerating - limiting the half and full exit speed
values to MaxExitSpeedAtHalfBraking if necessary, and using constant speed time values if the exit speeds aren't much different to
EntrySpeed and EntrySpeed > 0.01 (to avoid a divide by zero error).

Note that in no circumstances will a train stop when straddling 3 elements, it will always be fully on two elements.  This is ensured
by UpdateTrain() which never sets any stop conditions unless the train is fully on 2 elements when that function returns, i.e. entered
when Straddle == LeadMidLag
*/
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetTrainMovementValues," + AnsiString(TrackVectorPosition) + "," +
                                 AnsiString(EntryPos) + "," + HeadCode);
    int EntryHalfLength, CurrentElementHalfLength, NextElementHalfLength, CumulativeLength = 0, CurrentTrackVectorPosition = TrackVectorPosition;
    int DistanceAtHalfBraking, DistanceAtThreeQuarterBraking, ExitPos, NextTrackVectorPosition, NextEntryPos;
    bool RedSignalFlag = false, BuffersFlag = false, StationFlag = false, BuffersOrContinuationNowFlag = false, ContinuationNextFlag = false,
         TrainInFrontInSignallerModeFlag = false;
    double LimitingSpeed, FrontElementMaxSpeed, MaxExitSpeedAtHalfBrakingSquared, MaxExitSpeedAtHalfBraking, NextSpeedLimit, TempBrakeRate;
    double ExitSpeedHalfSquared, ExitSpeedFullSquared;
    bool SignallerStopRequired = false;

    MaxExitSpeed = MaxRunningSpeed;
    // set high to begin with to avoid divide by zero errors on restart after stops, will be set lower later

    // Member variables:     EntrySpeed, ExitSpeedHalf, ExitSpeedFull, MaxExitSpeed, BrakeRate, EntryTime, ExitTimeHalf, ExitTimeFull, FrontElementSpeedLimit, FrontElementLength;

    OneLengthAccelDecel = false;
    BrakeRate = 0;

//find FrontElementLength & FrontElementSpeedLimit (these correspond to TrackVectorPosition input value);
    if(CurrentTrackVectorPosition > -1)
    {
        if(Track->TrackElementAt(855, CurrentTrackVectorPosition).TrackType == Points) // this test & section added at v0.6
        {
            if((EntryPos == 0) || (EntryPos == 2))
            {
                if(Track->TrackElementAt(856, CurrentTrackVectorPosition).Attribute == 0)
                {
                    CurrentElementHalfLength = (Track->TrackElementAt(857, CurrentTrackVectorPosition).Length01) / 2;
                    FrontElementSpeedLimit = Track->TrackElementAt(858, CurrentTrackVectorPosition).SpeedLimit01;
                }
                else
                {
                    CurrentElementHalfLength = (Track->TrackElementAt(859, CurrentTrackVectorPosition).Length23) / 2;
                    FrontElementSpeedLimit = Track->TrackElementAt(860, CurrentTrackVectorPosition).SpeedLimit23;
                }
            }
            else if(EntryPos == 1)
            {
                CurrentElementHalfLength = (Track->TrackElementAt(861, CurrentTrackVectorPosition).Length01) / 2;
                FrontElementSpeedLimit = Track->TrackElementAt(862, CurrentTrackVectorPosition).SpeedLimit01;
            }
            else // == 3
            {
                CurrentElementHalfLength = (Track->TrackElementAt(863, CurrentTrackVectorPosition).Length23) / 2;
                FrontElementSpeedLimit = Track->TrackElementAt(864, CurrentTrackVectorPosition).SpeedLimit23;
            }
        }
        else
        {
            if(EntryPos > 1)
            {
                CurrentElementHalfLength = (Track->TrackElementAt(348, CurrentTrackVectorPosition).Length23) / 2;
                FrontElementSpeedLimit = Track->TrackElementAt(349, CurrentTrackVectorPosition).SpeedLimit23;
            }
            else
            {
                CurrentElementHalfLength = (Track->TrackElementAt(350, CurrentTrackVectorPosition).Length01) / 2;
                FrontElementSpeedLimit = Track->TrackElementAt(351, CurrentTrackVectorPosition).SpeedLimit01;
            }
        }
        EntryHalfLength = CurrentElementHalfLength;
        FrontElementLength = 2 * CurrentElementHalfLength;
    }
    else
    {
        throw Exception("Error - CurrentTrackVectorPosition < 0 in SetTrainMovementValues");
    }
    if((CurrentElementHalfLength < 0) || (FrontElementSpeedLimit < 0))
    {
        throw Exception("Error - HalfLength or SpeedLimit < 0 in SetTrainMovementValues");
    }
    // check if zero entry speed with another train directly in front & if so remain stopped
    if(Track->OtherTrainOnTrack(2, CurrentTrackVectorPosition, EntryPos, TrainID) && (EntrySpeed < 1))
    {
        EntrySpeed = 0;
        ExitSpeedHalf = 0;
        ExitSpeedFull = 0;
        MaxExitSpeed = 0;
        BrakeRate = 0;
        ExitTimeHalf = EntryTime + TDateTime(1/24); //set this high in case used later though unlikely
        ExitTimeFull = EntryTime + TDateTime(1/23); //set about 2.5 mins later than half time
        StoppedForTrainInFront = true;
        Utilities->CallLogPop(705);
        return;
    }
    // new at v2.4.0 - check for stopped and zero power
    if((EntrySpeed < 1) && PowerAtRail < 1)
    {
        EntrySpeed = 0;
        ExitSpeedHalf = 0;
        ExitSpeedFull = 0;
        MaxExitSpeed = 0;
        BrakeRate = 0;
        ExitTimeHalf = EntryTime + TDateTime(1/24);  //set this high in case used later though unlikely
        ExitTimeFull = EntryTime + TDateTime(1/23);  //set about 2.5 mins later than half time
        StoppedWithoutPower = true;
        Utilities->CallLogPop(2125);
        return;
    }
//set LimitingSpeed & FrontElementMaxSpeed (internal values)
    if(BeingCalledOn)
    {
        LimitingSpeed = CallOnMaxSpeed;
    }
    else
    {
        LimitingSpeed = MaximumSpeedLimit;
    }
    if(LimitingSpeed > FrontElementSpeedLimit)
    {
        LimitingSpeed = FrontElementSpeedLimit;
    }
    if(LimitingSpeed > MaxRunningSpeed)  //MaxRunningSpeed is set in AddTrain depending on timetable or signaller control mode
    {
        LimitingSpeed = MaxRunningSpeed;
    }
    FrontElementMaxSpeed = LimitingSpeed;

/*
 for braking the deceleration rate is constant so the following formuli (Newton's Laws) are used:-
 (1)  V^2/(3.6^2) = U^2/(3.6^2) - 2FS;
 (2)  V/3.6 = U/3.6 - FT;
 (3)  S = UT/3.6 - 0.5FT^2
 where(V = final speed in kph [km/h/3.6 = m/s], U = initial speed in km/h, F = deceleration rate in m/s/s, S = distance in m & T = time in secs)

 for accelerating the energy input rate (PowerAtRail) is constant so the following formuli are used:-
 (4)  V^2/(3.6^2) - U^2/(3.6^2) = A^2T;
 (5)  V = 3.6 * ((1.5*S*A^2) + U^3/ (3.6)^3)^0.333334;
 where A is a constant (2*PowerAtRail/Mass)^0.5;   V = final speed in kph, U = initial speed in kph , S = distance in m & T = time in secs
 It's a bit unrealistic during the early acceleration phase as it will be too rapid, but shouldn't affect the running unduly

 calc max speed that can attain on exit from next element (as could accelerate over next element) and use that speed to calc
 DistanceAtHalfBraking,  if use actual speed may miss a stop requirement just outside look-ahead & accelerate, and at next calc
 be unable to stop or have hard acceleration followed immediately by hard braking, this speed makes for smoother operation
*/

// check if running past a red signal without permission
    if((Track->TrackElementAt(352, CurrentTrackVectorPosition).Config[Track->GetNonPointsOppositeLinkPos(EntryPos)] == Signal) &&
        (Track->TrackElementAt(353, CurrentTrackVectorPosition).Attribute == 0) && (EntrySpeed > 1) && !AllowedToPassRedSignal &&
        !Track->TrackElementAt(1553, CurrentTrackVectorPosition).CallingOnSet)
    {    //CallingOnSet added at v2.14.0
        SPADFlag = true; // user has to intervene to reset & restart after spad
    }
    if(!SPADFlag)
    {
        ExitSpeedFull = 3.6 * Power(((3 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)), 0.333334);
        // to begin with calc the maximum exit speed (assumes accelerating) and then reduce it if necessary
        // for accelerating the energy input rate (PowerAtRail) is constant so the following formuli are used:-
        // (1)  V^2/(3.6^2) - U^2/(3.6^2) = A^2T;  (2)  V = 3.6 * ((1.5*S*A^2) + U^3/(3.6^3))^0.333334;
        // where A is a constant (2*PowerAtRail/Mass)^0.5;   V = final speed in kph, U = initial speed in kph, S = distance & T = time, note that km/h/3.6 = m/s
        // This is a bit unrealistic during the early acceleration phase as it will be too rapid, but shouldn't affect the running unduly

        double ExitSpeedAtMaxBraking;
        // below introduced at v2.4.0, was ExitSpeedFull = LimitingSpeed; but that allowed very high brake rates when
        // took signaller control of a fast failed train with signaller limiting speed 30km/h
        if((EntrySpeed * EntrySpeed) <= (2 * MaxBrakeRate * FrontElementLength))
        {
            ExitSpeedAtMaxBraking = 0;
        }
        else
        {
            ExitSpeedAtMaxBraking = sqrt((EntrySpeed * EntrySpeed) - 2 * MaxBrakeRate * FrontElementLength);
        }
        double SpeedToUse;
        // use the highest of LimitingSpeed or ExitSpeedAtMaxBraking - added at v2.4.2 because trains entering at a continuation with zero (or very low) speed
        // & 2 elements before signal caused ExitSpeedAtMaxBraking & hence DistanceAtHalfBraking and DistanceAtThreeQuarterBraking to be zero, so no restriction was recognised
        // for first element & train accelerated at maximum rate, then at 2nd element train couldn't brake in time and overran the signal - notified by Micke via Discord on 02/06/20
        if(ExitSpeedAtMaxBraking > LimitingSpeed)
        {
            SpeedToUse = ExitSpeedAtMaxBraking;
        }
        else
        {
            SpeedToUse = LimitingSpeed;
        }
        if(ExitSpeedFull > SpeedToUse)
        {
            ExitSpeedFull = SpeedToUse;
        }
        DistanceAtHalfBraking = ExitSpeedFull * ExitSpeedFull / 3.6 / 3.6 / MaxBrakeRate;
        DistanceAtThreeQuarterBraking = ExitSpeedFull * ExitSpeedFull / 3.6 / 3.6 / 1.5 / MaxBrakeRate; // used for signaller stops

        //now enter a do loop to examine each element in turn from the front of the train to calc the cumulative length and to see if a stop is required (flag set if so -
        //RedSignalFlag, BuffersFlag, StationFlag, TrainInFrontInSignallerModeFlag, SignallerStopRequired, StepForwardFlag) in which case there are no more loops
        // break out of the loop when ((CumulativeLength - FrontElementLength) < DistanceAtHalfBraking ) && ((!BuffersOrContinuationNowFlag && !ContinuationNextFlag) || SignallerStoppingFlag);

        do
        {
            RedSignalFlag = false;
            BuffersFlag = false;
            StationFlag = false;
            BuffersOrContinuationNowFlag = false;
            ContinuationNextFlag = false;
            // have to reset this after the above test
            // add current element length to CumulativeLength
            CumulativeLength += (2 * CurrentElementHalfLength);
            if((CumulativeLength >= DistanceAtThreeQuarterBraking) && (TrainMode == Signaller) && SignallerStoppingFlag)
            {
                SignallerStopRequired = true;
                // once set stays set until SignallerStoppingFlag reset, providing !BuffersOrContinuationNowFlag,
                // set SignallerStopBrakeRate to stop in CumulativeLength unless already higher (i.e. can only increase)
                double TempBR = EntrySpeed * EntrySpeed / 2 / 3.6 / 3.6 / CumulativeLength;
                if(SignallerStopBrakeRate < TempBR)
                {
                    SignallerStopBrakeRate = TempBR;
                }
            }
            // first check for stops within the length of the current element, where don't want any more checks & don't want
            // to add in any extra to the CumulativeLength.  Only applies for buffers & station stops as signals should have been caught
            // during the last loop when the NextTrackVectorPosition was the signal.

            // check if current element is a buffer
            if(Track->TrackElementAt(374, CurrentTrackVectorPosition).TrackType == Buffers)
            {
                // no need to add in the length of this element to CumulativeLength as already included
                BuffersFlag = true;
            }
            // check if current element is a station stop
            if(TrainMode == Timetable)
            {
                bool StopRequired = false;
                if(!TimetableFinished && (NameInTimetableBeforeCDT(12, Track->TrackElementAt(375, CurrentTrackVectorPosition).ActiveTrackElementName,
                        StopRequired) > -1) && ((Track->TrackElementAt(376, CurrentTrackVectorPosition).StationEntryStopLinkPos1 == EntryPos) ||
                        (Track->TrackElementAt(377, CurrentTrackVectorPosition).StationEntryStopLinkPos2 == EntryPos)))
                {
                    // no need to add in the length of element to CumulativeLength
                    if(StopRequired)
                    {
                        StationFlag = true;
                    }
                }
            }
            else
            {
                StationFlag = false;
            }
            // set NextHalfLength & NextSpeedLimit, but only if current element not buffers or exit continuation - no next element for them
            if(((Track->TrackElementAt(354, CurrentTrackVectorPosition).TrackType == Buffers) || (Track->TrackElementAt(355,
                        CurrentTrackVectorPosition).TrackType == Continuation)) && (EntryPos == 1))
            {
                BuffersOrContinuationNowFlag = true;
            }
            if(!BuffersOrContinuationNowFlag && !BuffersFlag && !StationFlag) // skip if buffers or station flags already set
            {
                if(Track->TrackElementAt(356, CurrentTrackVectorPosition).TrackType == Points)
                {
                    if((EntryPos == 0) || (EntryPos == 2))
                    {
                        if(Track->TrackElementAt(357, CurrentTrackVectorPosition).Attribute == 0)
                        {
                            ExitPos = 1;
                        }
                        else
                        {
                            ExitPos = 3;
                        }
                    }
                    else
                    {
                        ExitPos = 0;
                    }
                }
                else
                {
                    ExitPos = Track->GetNonPointsOppositeLinkPos(EntryPos);
                }
                NextTrackVectorPosition = Track->TrackElementAt(358, CurrentTrackVectorPosition).Conn[ExitPos];
                NextEntryPos = Track->TrackElementAt(359, CurrentTrackVectorPosition).ConnLinkPos[ExitPos];
                if(NextTrackVectorPosition > -1)
                {
                    if(Track->TrackElementAt(845, NextTrackVectorPosition).TrackType == Points)
                    // this test & section added at v0.6
                    {
                        if((NextEntryPos == 0) || (NextEntryPos == 2))
                        {
                            if(Track->TrackElementAt(846, NextTrackVectorPosition).Attribute == 0)
                            {
                                NextElementHalfLength = (Track->TrackElementAt(847, NextTrackVectorPosition).Length01) / 2;
                                NextSpeedLimit = Track->TrackElementAt(848, NextTrackVectorPosition).SpeedLimit01;
                            }
                            else
                            {
                                NextElementHalfLength = (Track->TrackElementAt(849, NextTrackVectorPosition).Length23) / 2;
                                NextSpeedLimit = Track->TrackElementAt(850, NextTrackVectorPosition).SpeedLimit23;
                            }
                        }
                        else if(NextEntryPos == 1)
                        {
                            NextElementHalfLength = (Track->TrackElementAt(851, NextTrackVectorPosition).Length01) / 2;
                            NextSpeedLimit = Track->TrackElementAt(852, NextTrackVectorPosition).SpeedLimit01;
                        }
                        else // == 3
                        {
                            NextElementHalfLength = (Track->TrackElementAt(853, NextTrackVectorPosition).Length23) / 2;
                            NextSpeedLimit = Track->TrackElementAt(854, NextTrackVectorPosition).SpeedLimit23;
                        }
                    }
                    else
                    {
                        if(NextEntryPos > 1)
                        {
                            NextElementHalfLength = (Track->TrackElementAt(360, NextTrackVectorPosition).Length23) / 2;
                            NextSpeedLimit = Track->TrackElementAt(361, NextTrackVectorPosition).SpeedLimit23;
                        }
                        else
                        {
                            NextElementHalfLength = (Track->TrackElementAt(362, NextTrackVectorPosition).Length01) / 2;
                            NextSpeedLimit = Track->TrackElementAt(363, NextTrackVectorPosition).SpeedLimit01;
                        }
                    }
                }
                else
                {
                    throw Exception("Error - Trying to access NextTrackVectorPosition when none present in SetTrainMovementValues");
                }
                // now check for stops, first cover those where don't want to add in length of next element
                // check if next element is a red signal - Attr 0,
                // note that this doesn't apply to trains stopped at a red signal since the signal position is
                // CurrentTrackVectorPosition not NextTrackVectorPosition
                bool StopRequired;
                if(Track->TrackElementAt(364, NextTrackVectorPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal)
                {
                    if(Track->TrackElementAt(365, NextTrackVectorPosition).Attribute == 0)
                    {
                        // no need to add in the length of element to CumulativeLength
                        RedSignalFlag = true;
                    }
                    // next element is a red signal
                }
                // check if current element is a station & next element contains a train - trains will always stop without crashing at a
                // station they are due to stop at even if there is a train in front blocking the normal stop position - providing there is
                // at least one platform element free
                else if((TrainMode == Timetable) && !TimetableFinished && (NameInTimetableBeforeCDT(10, Track->TrackElementAt(368,
                                                                                                                              CurrentTrackVectorPosition).ActiveTrackElementName, StopRequired) > -1) && Track->OtherTrainOnTrack(3, NextTrackVectorPosition,
                                                                                                                                                                                                                                  NextEntryPos, TrainID))
                {
                    // no need to add in the length of element to CumulativeLength
                    if(StopRequired)
                    {
                        StationFlag = true;
                    }
                }
                // check if next element contains a train & in Signaller mode (always stops for train in front if in signaller mode)
                else if((TrainMode == Signaller) && Track->OtherTrainOnTrack(4, NextTrackVectorPosition, NextEntryPos, TrainID))
                // (Track->TrackElementAt(651, NextTrackVectorPosition).TrainIDOnElement > -1))
                {
                    // no need to add in the length of element to CumulativeLength
                    TrainInFrontInSignallerModeFlag = true;
                }
                // check if next element is a buffer
                else if(Track->TrackElementAt(366, NextTrackVectorPosition).TrackType == Buffers)
                {
                    // need to add in the length of that element to CumulativeLength
                    CumulativeLength += Track->TrackElementAt(367, NextTrackVectorPosition).Length01;
                    BuffersFlag = true;
                }
                // check if next element is a station stop
                else if((TrainMode == Timetable) && !TimetableFinished && (NameInTimetableBeforeCDT(11, Track->TrackElementAt(370,
                              NextTrackVectorPosition).ActiveTrackElementName, StopRequired) > -1) && ((Track->TrackElementAt(371,
                              NextTrackVectorPosition).StationEntryStopLinkPos1 == EntryPos) || (Track->TrackElementAt(372,
                              NextTrackVectorPosition).StationEntryStopLinkPos2 == EntryPos)))
                {
                    // need to add in the length of that element to CumulativeLength if a stop required
                    if(StopRequired)
                    {
                        StationFlag = true;
                        CumulativeLength += Track->TrackElementAt(373, NextTrackVectorPosition).Length01;
                    }
                }
            }
            //now can decide whether need to stop over CumulativeLength
            if(RedSignalFlag || BuffersFlag || StationFlag || TrainInFrontInSignallerModeFlag || SignallerStopRequired || StepForwardFlag) // no more loops
            {
                // have to come to a stop over CumulativeLength
                if(CumulativeLength == FrontElementLength)
                // will be if StepForwardFlag (if stopped to begin with on zero power then earlier check will intercept it and it won't reach here
                // only one length to go before stop so check whether need to accelerate for half length then brake for latter
                // half;  calc speed at halfway point that corresponds to half braking rate for latter half of track element,
                // and if less than EntrySpeed then skip this section (don't need any acceleration)
                // if not calc speed at halfway point & if less than above set half speed to this value;
                // use constant acceleration in calculating half time point
                {
                    MaxExitSpeed = 0;
                    double MaxHalfSpeed;
                    double MaxHalfSpeedAtHalfBraking = 3.6 * sqrt(MaxBrakeRate * FrontElementLength / 2);
                    // have to halve the element length, & can't be zero or negative so no need to test
                    // if(MaxHalfSpeedAtHalfBraking > LimitingSpeed) MaxHalfSpeed = LimitingSpeed; else MaxHalfSpeed = MaxHalfSpeedAtHalfBraking;
                    if(MaxHalfSpeedAtHalfBraking > FrontElementMaxSpeed)
                    {
                        MaxHalfSpeed = FrontElementMaxSpeed;
                    }
                    else
                    {
                        MaxHalfSpeed = MaxHalfSpeedAtHalfBraking;
                    }
                    if(MaxHalfSpeed > (2 * EntrySpeed))
                    // use 2x to prevent kangarooing at last element when had
                    // been braking smoothly at less that 50% braking rate, 2x should prevent all but extreme cases
                    {
                        ExitSpeedHalf = 3.6 * Power(((1.5 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)),
                                                    0.333334);
                        bool HalfSpeedLimited = false;
                        if(MaxHalfSpeed < ExitSpeedHalf)
                        {
                            ExitSpeedHalf = MaxHalfSpeed;
                            HalfSpeedLimited = true;
                        }
                        if(PowerAtRail > 1)
                        // added at v2.4.0 in case reach here with failed train, when can't use AValue in denominator as close zero
                        {
                            // [km/h/3.6 = m/s]
                            ExitTimeHalf =
                                EntryTime + TDateTime(((ExitSpeedHalf * ExitSpeedHalf) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue) / 86400.0);
                        }
                        else
                        {
                            ExitTimeHalf = EntryTime + TDateTime(EntryHalfLength * 3.6 / EntrySpeed / 86400.0);
                        }
                        // the above is the time taken to accelerate to ExitSpeedHalf, so if this is reached before the half
                        // way point (i.e. HalfSpeedLimited is set) then the time will be too short; change later to equal the
                        // braking time; not fully accurate but better to be equal than have a short acceleration period followed
                        // by a long braking period
                        ExitSpeedFull = 0;
                        TempBrakeRate = ExitSpeedHalf * ExitSpeedHalf / 2 / 3.6 / 3.6 / EntryHalfLength;
                        if(TempBrakeRate > MaxBrakeRate)
                        {
                            TempBrakeRate = MaxBrakeRate;
                        }
                        // shouldn't be but leave in anyway
                        if(TempBrakeRate > BrakeRate)
                        {
                            BrakeRate = TempBrakeRate;
                        }
                        // BrakeRate may already have been set in an earlier loop so don't want to reduce it
                        ExitTimeFull = ExitTimeHalf + TDateTime(ExitSpeedHalf / 3.6 / BrakeRate / 86400.0);
                        if(HalfSpeedLimited)
                        // this is the change referred to above
                        {
                            TDateTime BrakingTime = ExitTimeFull - ExitTimeHalf;
                            ExitTimeHalf = EntryTime + BrakingTime;
                            ExitTimeFull = ExitTimeHalf + BrakingTime;
                        }
                        OneLengthAccelDecel = true; //used in TrackTrainFloat in InterfaceUnit.cpp to show accelerating for first half move then decelerating
                        Utilities->CallLogPop(1095);
                        return;
                    }
                }
                // set braking to achieve speed = 0 @ CumulativeLength up to MaxBrakeRate
                // calc MaxExitSpeed for element at EntryPosition & set to this or existing val if lower,
                // calc th, tf, sh, & sf
                TempBrakeRate = EntrySpeed * EntrySpeed / 2 / 3.6 / 3.6 / CumulativeLength;
                if(TempBrakeRate > MaxBrakeRate)
                {
                    TempBrakeRate = MaxBrakeRate;
                }
                if(TempBrakeRate > BrakeRate)
                {
                    BrakeRate = TempBrakeRate;
                }
                // BrakeRate may already have been set in an earlier loop so don't want to reduce it
                if(SignallerStopRequired)
                // set BrakeRate to max of its calculated value or SignallerStopBrakeRate
                {
                    if(SignallerStopBrakeRate < BrakeRate)
                    {
                        SignallerStopBrakeRate = BrakeRate;
                        // this prevents the brakerate from reducing for a signaller stop
                        // regardless of other conditions that may change as progress round the loop
                    }
                }
                if(SignallerStopBrakeRate > BrakeRate)
                // prevents BrakeRate dropping below SignallerStopBrakeRate once it's been set whether or not SignallerStopRequired set
                // SignallerStopRequired may not be set if a red signal found in a later calc, & brakerate may then drop
                {
                    BrakeRate = SignallerStopBrakeRate;
                }
                int TempMaxExitSpeed;
                // calc current value & if less than MaxExitSpeed set that to this
                MaxExitSpeedAtHalfBrakingSquared = 3.6 * 3.6 * MaxBrakeRate * (CumulativeLength - FrontElementLength);
                if(MaxExitSpeedAtHalfBrakingSquared < 10)
                {
                    MaxExitSpeedAtHalfBraking = 0;
                }
                else
                {
                    MaxExitSpeedAtHalfBraking = sqrt(MaxExitSpeedAtHalfBrakingSquared);
                }
                // if(MaxExitSpeedAtHalfBraking > LimitingSpeed) MaxExitSpeed = LimitingSpeed; else MaxExitSpeed = MaxExitSpeedAtHalfBraking;
                // I think the above was dropped because it could cause MaxExitSpeed to increase (MaxExitSpeed is an external variable retained between loops)
                if(MaxExitSpeedAtHalfBraking > FrontElementMaxSpeed)
                {
                    TempMaxExitSpeed = FrontElementMaxSpeed;
                }
                else
                {
                    TempMaxExitSpeed = MaxExitSpeedAtHalfBraking;
                }
                if(TempMaxExitSpeed < MaxExitSpeed)
                {
                    MaxExitSpeed = TempMaxExitSpeed;
                }
                // here have EntrySpeed & MaxExitSpeed (for the next element), BrakeRate (to bring speed to zero over
                // Cumulativelength, and Cumulativelength

                if((EntrySpeed > MaxExitSpeed) || SignallerStopRequired || (SignallerStopBrakeRate > 0.01)) // need to brake
                {
                    ExitSpeedHalfSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 2 * BrakeRate * EntryHalfLength);
                    if(ExitSpeedHalfSquared < 10)
                    {
                        ExitSpeedHalf = 0;
                    }
                    else
                    {
                        ExitSpeedHalf = sqrt(ExitSpeedHalfSquared);
                    }
                    ExitTimeHalf = EntryTime + TDateTime((EntrySpeed - ExitSpeedHalf) / 3.6 / BrakeRate / 86400.0);
                    ExitSpeedFullSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 4 * BrakeRate * EntryHalfLength);
                    if(ExitSpeedFullSquared < 10)
                    {
                        ExitSpeedFull = 0;
                    }
                    else
                    {
                        ExitSpeedFull = sqrt(ExitSpeedFullSquared);
                    }
                    if((StationFlag) && (CumulativeLength == FrontElementLength))
                    {
                        ExitSpeedFull = 0;
                        // force a stop for station (not for buffers or red signal)
                    }
                    ExitTimeFull = EntryTime + TDateTime((EntrySpeed - ExitSpeedFull) / 3.6 / BrakeRate / 86400.0);
                }
                // new condition at v2.4.0
                else if(PowerAtRail <= 1)
                // use EntrySpeed, CumulativeLength & BrakeRate to calculate the half and full exit times and speeds for next element
                // avoid using AValue in denominator or have excessively long times
                {
                    ExitSpeedHalfSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * BrakeRate * FrontElementLength);
                    ExitSpeedHalf = sqrt(ExitSpeedHalfSquared);
                    ExitTimeHalf = EntryTime + TDateTime((EntrySpeed - ExitSpeedHalf) / (3.6 * BrakeRate * 86400.0));

                    ExitSpeedFullSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 2 * BrakeRate * FrontElementLength);
                    ExitSpeedFull = sqrt(ExitSpeedFullSquared);
                    ExitTimeFull = EntryTime + TDateTime((EntrySpeed - ExitSpeedFull) / (3.6 * BrakeRate * 86400.0));
                }
                else // e.g. moving towards a signal or station after a speed limit, so can accelerate unless no power
                     // without the power need above condition or have hours of delay times, above added at v2.4.0
                {
                    // for accelerating the energy input rate (PowerAtRail) is constant so the following formuli are used:-
                    // (1)  V^2/(3.6^2) - U^2/(3.6^2) = A^2T;  (2)  V = 3.6 * ((1.5*S*A^2) + U^3/(3.6^3))^0.333334;
                    // where A is a constant (2*PowerAtRail/Mass)^0.5;   V = final speed in kph, U = initial speed in kph, S = distance & T = time, note that km/h/3.6 = m/s
                    // This is a bit unrealistic during the early acceleration phase as it will be too rapid, but shouldn't affect the running unduly
                    BrakeRate = 0;
                    ExitSpeedHalf = 3.6 * Power(((1.5 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)),
                                                0.333334);
                    ExitSpeedFull = 3.6 * Power(((3 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)), 0.333334);
                    // above valid for ExitSpeedHalf & Full <= MaxExitSpeed
                    if(ExitSpeedHalf <= MaxExitSpeed)
                    // can accelerate continually over the half length
                    {
                        ExitTimeHalf = EntryTime + TDateTime(((ExitSpeedHalf * ExitSpeedHalf) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue)
                                                             / 86400.0);
                        if(ExitSpeedFull <= MaxExitSpeed)
                        // can accelerate continually over the full length
                        // i.e both (ExitSpeedHalf <= MaxExitSpeed) & (ExitSpeedFull <= MaxExitSpeed)
                        {
                            ExitTimeFull =
                                EntryTime + TDateTime(((ExitSpeedFull * ExitSpeedFull) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue) / 86400.0);
                        }
                        else // (ExitSpeedHalf <= MaxExitSpeed) but (ExitSpeedFull > MaxExitSpeed)
                             // accelerate to MaxExitSpeed then reamin at this speed for rest of element
                        {
                            // added at v0.6 as a safeguard
                            if(MaxExitSpeed < EntrySpeed)
                            {
                                MaxExitSpeed = EntrySpeed;
                            }
                            // to prevent DeltaExitTimeToMaxInSecs being negative
                            if(MaxExitSpeed < 1)
                            {
                                MaxExitSpeed = 1;
                            }
                            // to prevent divide by zero error
                            // below as was
                            ExitSpeedFull = MaxExitSpeed;
                            double DeltaExitTimeToMaxInSecs = ((MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue);
                            double DistanceToMax = ((MaxExitSpeed * MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / 3.6 /
                                (1.5 * AValue * AValue);
                            double RemainingDistance = double(FrontElementLength) - DistanceToMax;
                            double DeltaRemainingTimeInSecs = 3.6 * RemainingDistance / MaxExitSpeed;
                            ExitTimeFull = EntryTime + TDateTime((DeltaExitTimeToMaxInSecs + DeltaRemainingTimeInSecs) / 86400.0);
                        }
                    }
                    else // ExitSpeedHalf > MaxExitSpeed, so ExitSpeedFull must also be > MaxExitSpeed
                         // accelerate over first half to MaxExitSpeed then remain at this speed for rest of the first and
                         // second halves of the element
                    {
                        // added at v0.6 as a safeguard
                        if(MaxExitSpeed < EntrySpeed)
                        {
                            MaxExitSpeed = EntrySpeed;
                        }
                        // to prevent DeltaExitTimeToMaxInSecs being negative
                        if(MaxExitSpeed < 1)
                        {
                            MaxExitSpeed = 1; // to prevent divide by zero error
                        }
                        // below as was
                        ExitSpeedHalf = MaxExitSpeed;
                        double DeltaExitTimeToMaxInSecs = ((MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue);
                        double DistanceToMax = ((MaxExitSpeed * MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / 3.6 /
                            (1.5 * AValue * AValue);
                        double RemainingDistance = double(FrontElementLength / 2) - DistanceToMax;
                        // remaining distance to half length
                        double DeltaRemainingTimeInSecs = 3.6 * RemainingDistance / MaxExitSpeed;
                        ExitTimeHalf = EntryTime + TDateTime((DeltaExitTimeToMaxInSecs + DeltaRemainingTimeInSecs) / 86400.0);
                        ExitSpeedFull = MaxExitSpeed;
                        ExitTimeFull = ExitTimeHalf + TDateTime(3.6 * EntryHalfLength / MaxExitSpeed / 86400.0);
                    }
                }
                Utilities->CallLogPop(706);
                return;
            }
            else
            {
                if(!BuffersOrContinuationNowFlag)
                {
                    if(NextSpeedLimit < LimitingSpeed)
                    {
                        LimitingSpeed = NextSpeedLimit;
                    }
                }
                // calc max exit speed at half braking to ensure don't accelerate past it (if acceleration is required)
                int TempMaxExitSpeed;
                // calc current value & if less than MaxExitSpeed set that to this
                // Note that LimitingSpeed is the max value at the end of CumulativeLength, so MaxExitSpeedAtHalfBrakingSquared will be larger
                MaxExitSpeedAtHalfBrakingSquared = (LimitingSpeed * LimitingSpeed) + (3.6 * 3.6 * MaxBrakeRate * (CumulativeLength - FrontElementLength));
                if(MaxExitSpeedAtHalfBrakingSquared < 10)
                {
                    MaxExitSpeedAtHalfBraking = 0;
                }
                else
                {
                    MaxExitSpeedAtHalfBraking = sqrt(MaxExitSpeedAtHalfBrakingSquared);
                }
                if(MaxExitSpeedAtHalfBraking > FrontElementMaxSpeed)
                {
                    TempMaxExitSpeed = FrontElementMaxSpeed;
                }
                else
                {
                    TempMaxExitSpeed = MaxExitSpeedAtHalfBraking;
                }
                if(TempMaxExitSpeed < MaxExitSpeed)
                {
                    MaxExitSpeed = TempMaxExitSpeed;
                }
                // MaxExitSpeed is an external variable & this can reduce its value
                if(EntrySpeed > LimitingSpeed)
                // note that LimitingSpeed is more restrictive than MaxExitSpeed
                // calc TempBrakeRate & set BrakeRate to this or keep existing val if higher
                {
                    TempBrakeRate = ((EntrySpeed * EntrySpeed) - (LimitingSpeed * LimitingSpeed)) / 3.6 / 3.6 / 2 / CumulativeLength;
                    if(TempBrakeRate > MaxBrakeRate)
                    {
                        TempBrakeRate = MaxBrakeRate;
                    }
                    // shouldn't be for speedlimits since all known in advance, but include anyway
                    if(TempBrakeRate > BrakeRate)
                    {
                        BrakeRate = TempBrakeRate;
                    }
                    // BrakeRate may already have been set in an earlier loop so don't want to reduce it
                }
            }
            if(!BuffersOrContinuationNowFlag)
            {
                CurrentTrackVectorPosition = NextTrackVectorPosition;
                EntryPos = NextEntryPos;
                CurrentElementHalfLength = NextElementHalfLength;
                if(Track->TrackElementAt(378, NextTrackVectorPosition).TrackType == Continuation)
                {
                    ContinuationNextFlag = true;
                }
            }
        }
        while(((CumulativeLength - FrontElementLength) < DistanceAtHalfBraking) && ((!BuffersOrContinuationNowFlag && !ContinuationNextFlag) ||
                                                                                    SignallerStoppingFlag));
        // check from the end of the front element, if include the front element and could brake during it, then will skip further loops
        // & miss a stop requirement just beyond the front element.  happened in Richard Standing's railway where a new service introduced
        // on a 100m length, with 20m length after & then a red signal - train accelerated over the 100m then caused a SPAD as too short a
        // stopping distance after it.

        //(!BuffersOrContinuationNowFlag && !ContinuationNextFlag) true when no continuation on either the next element and next but one element.
        //There won't be a buffer on the next element or would have caught earlier, just using this flag for convenience.

        // If SignallerStoppingFlag then don't exit loop because of an imminent continuation, because continuation
        // not immediately in front (if it is then LeadElement will be the continuation & SignallerStoppingFlag will be reset in UpdateTrain()),
        // need to at least give a chance to stop on signaller command, if keep moving until continuation is immediately in front then will
        // exit loop & that is OK as don't want to stop so close to a continuation, if that happens it means that the command to stop was given
        // too late

        // set final braking or acc'n speed & time values
        if(BrakeRate > 0.01)
        {
            ExitSpeedHalfSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 2 * BrakeRate * EntryHalfLength);
            if(ExitSpeedHalfSquared < 10)
            {
                ExitSpeedHalf = 0;
            }
            else
            {
                ExitSpeedHalf = sqrt(ExitSpeedHalfSquared);
            }
            ExitTimeHalf = EntryTime + TDateTime((EntrySpeed - ExitSpeedHalf) / 3.6 / BrakeRate / 86400.0);
            ExitSpeedFullSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 4 * BrakeRate * EntryHalfLength);
            if(ExitSpeedFullSquared < 10)
            {
                ExitSpeedFull = 0;
            }
            else
            {
                ExitSpeedFull = sqrt(ExitSpeedFullSquared);
            }
            ExitTimeFull = EntryTime + TDateTime((EntrySpeed - ExitSpeedFull) / 3.6 / BrakeRate / 86400.0);
        }
        else
        {
            // for accelerating the energy input rate (PowerAtRail) is constant so the following formuli are used:-
            // (1)  V^2/(3.6^2) - U^2/(3.6^2) = A^2T;  (2)  V = 3.6 * ((1.5*S*A^2) + U^3/ (3.6)^3)^0.333334;
            // where A is a constant (2*PowerAtRail/Mass)^0.5;   V = final speed in kph, U = initial speed in kph , S = distance in m & T = time
            // This is a bit unrealistic during the early acceleration phase as it will be too rapid, but shouldn't affect the running unduly

            BrakeRate = 0;
            ExitSpeedHalf = 3.6 * Power(((1.5 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)), 0.333334);
            ExitSpeedFull = 3.6 * Power(((3 * EntryHalfLength * AValue * AValue) + (EntrySpeed * EntrySpeed * EntrySpeed / 3.6 / 3.6 / 3.6)), 0.333334);
            // above valid for ExitSpeedHalf & Full <= MaxExitSpeed
            if(ExitSpeedHalf <= MaxExitSpeed)
            {
                if(PowerAtRail > 1)
                // added at v2.4.0 in case reach here with failed train, when can't use AValue in denominator as close zero
                {
                    // [km/h/3.6 = m/s]
                    ExitTimeHalf = EntryTime + TDateTime(((ExitSpeedHalf * ExitSpeedHalf) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue)
                                                         / 86400.0);
                }
                else
                {
                    ExitTimeHalf = EntryTime + TDateTime(EntryHalfLength * 3.6 / EntrySpeed / 86400.0);
                }
                if(ExitSpeedFull <= MaxExitSpeed)
                // (ExitSpeedHalf <= MaxExitSpeed) & (ExitSpeedFull <= MaxExitSpeed)
                {
                    if(PowerAtRail > 1)
                    // added at v2.4.0 in case reach here with failed train, when can't use AValue in denominator as close zero
                    {
                        // [km/h/3.6 = m/s]
                        ExitTimeFull = EntryTime + TDateTime(((ExitSpeedFull * ExitSpeedFull) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue)
                                                             / 86400.0);
                    }
                    else
                    {
                        ExitTimeFull = EntryTime + TDateTime(2 * EntryHalfLength * 3.6 / EntrySpeed / 86400.0);
                    }
                }
                else // (ExitSpeedHalf <= MaxExitSpeed) & (ExitSpeedFull > MaxExitSpeed)
                {
                    // added at v0.6 as a safeguard
                    if(MaxExitSpeed < EntrySpeed)
                    {
                        MaxExitSpeed = EntrySpeed;
                    }
                    // to prevent DeltaExitTimeToMaxInSecs being negative
                    if(MaxExitSpeed < 1)
                    {
                        MaxExitSpeed = 1; // to prevent divide by zero error
                    }
                    // below as was
                    ExitSpeedFull = MaxExitSpeed;
                    double DeltaExitTimeToMaxInSecs;
                    double DistanceToMax;
                    if(PowerAtRail > 1) // added at v2.4.0
                    {
                        DeltaExitTimeToMaxInSecs = ((MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue);
                        DistanceToMax = ((MaxExitSpeed * MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / 3.6 /
                            (1.5 * AValue * AValue);
                    }
                    else // shouldn't ever get here given that ExitSpeedFull > ExitSpeedHalf
                    {
                        DeltaExitTimeToMaxInSecs = 2 * EntryHalfLength * 3.6 / EntrySpeed;
                        // these not really accurate but will be good enough
                        DistanceToMax = EntryHalfLength;
                    }
                    double RemainingDistance = double(FrontElementLength) - DistanceToMax;
                    double DeltaRemainingTimeInSecs = 3.6 * RemainingDistance / MaxExitSpeed;
                    ExitTimeFull = EntryTime + TDateTime((DeltaExitTimeToMaxInSecs + DeltaRemainingTimeInSecs) / 86400.0);
                }
            }
            else // ExitSpeedHalf > MaxExitSpeed, ExitSpeedFull must be > MaxExitSpeed
            {
                // added at v0.6 as a safeguard
                if(MaxExitSpeed < EntrySpeed)
                {
                    MaxExitSpeed = EntrySpeed;
                }
                // to prevent DeltaExitTimeToMaxInSecs being negative
                if(MaxExitSpeed < 1)
                {
                    MaxExitSpeed = 1; // to prevent divide by zero error
                }
                // below as was
                ExitSpeedHalf = MaxExitSpeed;
                double DeltaExitTimeToMaxInSecs;
                double DistanceToMax;
                if(PowerAtRail > 1) // added at v2.4.0
                {
                    DeltaExitTimeToMaxInSecs = ((MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / (AValue * AValue);
                    DistanceToMax = ((MaxExitSpeed * MaxExitSpeed * MaxExitSpeed) - (EntrySpeed * EntrySpeed * EntrySpeed)) / 3.6 / 3.6 / 3.6 /
                        (1.5 * AValue * AValue);
                }
                else
                {
                    DeltaExitTimeToMaxInSecs = 2 * EntryHalfLength * 3.6 / EntrySpeed;
                    // these not really accurate but will be good enough
                    DistanceToMax = EntryHalfLength / 2;
                }
                double RemainingDistance = double(FrontElementLength / 2) - DistanceToMax; // remaining distance to half length
                double DeltaRemainingTimeInSecs = 3.6 * RemainingDistance / MaxExitSpeed;
                ExitTimeHalf = EntryTime + TDateTime((DeltaExitTimeToMaxInSecs + DeltaRemainingTimeInSecs) / 86400.0);
                ExitSpeedFull = MaxExitSpeed;
                ExitTimeFull = ExitTimeHalf + TDateTime(3.6 * EntryHalfLength / MaxExitSpeed / 86400.0);
            }
        }
    }

    else // SPADFlag set
    {
        BrakeRate = MaxBrakeRate;
        ExitSpeedHalfSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 2 * BrakeRate * EntryHalfLength);
        if(ExitSpeedHalfSquared < 10)
        {
            ExitSpeedHalf = 0;
        }
        else
        {
            ExitSpeedHalf = sqrt(ExitSpeedHalfSquared);
        }
        ExitTimeHalf = EntryTime + TDateTime((EntrySpeed - ExitSpeedHalf) / 3.6 / BrakeRate / 86400.0);
        ExitSpeedFullSquared = (EntrySpeed * EntrySpeed) - (3.6 * 3.6 * 4 * BrakeRate * EntryHalfLength);
        if(ExitSpeedFullSquared < 10)
        {
            ExitSpeedFull = 0;
        }
        else
        {
            ExitSpeedFull = sqrt(ExitSpeedFullSquared);
        }
        ExitTimeFull = EntryTime + TDateTime((EntrySpeed - ExitSpeedFull) / 3.6 / BrakeRate / 86400.0);

        // check if the exit speed is < 80% of the stopping speed for the next element, and if so stop at end of this element
        // this is because would stop short of end of next element (in reality the time to reach the end of the next element
        // would be too short (could be so short as to make the train jump) as time is calculated purely on speed & brake rate);
        // 80% is used as the brake rate might be set to come to a halt at the end of the next element in which case the speed
        // will be the stopping speed.
        if(ExitSpeedFull > 0)
        {
            if(Track->TrackElementAt(746, CurrentTrackVectorPosition).TrackType == Points)
            {
                if((EntryPos == 0) || (EntryPos == 2))
                {
                    if(Track->TrackElementAt(747, CurrentTrackVectorPosition).Attribute == 0)
                    {
                        ExitPos = 1;
                    }
                    else
                    {
                        ExitPos = 3;
                    }
                }
                else
                {
                    ExitPos = 0;
                }
            }
            else
            {
                ExitPos = Track->GetNonPointsOppositeLinkPos(EntryPos);
            }
            NextTrackVectorPosition = Track->TrackElementAt(748, CurrentTrackVectorPosition).Conn[ExitPos];
            NextEntryPos = Track->TrackElementAt(749, CurrentTrackVectorPosition).ConnLinkPos[ExitPos];
            if(NextTrackVectorPosition > -1) // not a continuation or buffer
            {
                int NextElementLength;
                if(NextEntryPos > 1)
                {
                    NextElementLength = (Track->TrackElementAt(750, NextTrackVectorPosition).Length23);
                }
                else
                {
                    NextElementLength = (Track->TrackElementAt(751, NextTrackVectorPosition).Length01);
                }
                double NextStoppingSpeed = sqrt(3.6 * 3.6 * 2 * BrakeRate * NextElementLength);
                if(ExitSpeedFull < (0.8 * NextStoppingSpeed))
                {
                    ExitSpeedFull = 0;
                }
            }
        }
    }
    // allow all values to be set normally in case need to brake, then test for zero power & need to coast
    if(PowerAtRail < 1) // new at v2.4.0    note that km/h/3.6 = m/s
    {
        // bring to a stop in 20 elements at 100km/h & assume each 100m long for calculating exit times but if on a continuation maintain speed
        if(LeadElement > -1)
        {
            if(Track->TrackElementAt(961, LeadElement).TrackType == Continuation)
            // don't stop on a continuation either entering or leaving
            {
                ExitSpeedHalf = EntrySpeed;
                ExitSpeedFull = EntrySpeed;
                MaxExitSpeed = LimitingSpeed;
                BrakeRate = 0;
                ExitTimeHalf = EntryTime + TDateTime((50 * 3.6 / (EntrySpeed) / 86400.0));
                // assume length is 50m for ease of calc
                ExitTimeFull = ExitTimeHalf + TDateTime((50 * 3.6 / (ExitSpeedHalf) / 86400.0));
                Utilities->CallLogPop(2126);
                return;
            }
        }
        else if(MidElement > -1)
        {
            if(Track->TrackElementAt(962, MidElement).TrackType == Continuation)
            {
                ExitSpeedHalf = EntrySpeed;
                ExitSpeedFull = EntrySpeed;
                MaxExitSpeed = LimitingSpeed;
                BrakeRate = 0;
                ExitTimeHalf = EntryTime + TDateTime((50 * 3.6 / (EntrySpeed) / 86400.0));
                // assume length is 50m for ease of calc
                ExitTimeFull = ExitTimeHalf + TDateTime((50 * 3.6 / (ExitSpeedHalf) / 86400.0));
                Utilities->CallLogPop(2127);
                return;
            }
        }
        else if(LagElement > -1)
        {
            if(Track->TrackElementAt(963, LagElement).TrackType == Continuation)
            {
                ExitSpeedHalf = EntrySpeed;
                ExitSpeedFull = EntrySpeed;
                MaxExitSpeed = LimitingSpeed;
                BrakeRate = 0;
                ExitTimeHalf = EntryTime + TDateTime((50 * 3.6 / (EntrySpeed) / 86400.0));
                // assume length is 50m for ease of calc
                ExitTimeFull = ExitTimeHalf + TDateTime((50 * 3.6 / (ExitSpeedHalf) / 86400.0));
                Utilities->CallLogPop(2128);
                return;
            }
        }
        if(EntrySpeed > 7.5) // keep going for at least another element
        {
            ExitSpeedHalf = EntrySpeed - 2.5;
            ExitSpeedFull = EntrySpeed - 5;
            MaxExitSpeed = LimitingSpeed;
            BrakeRate = 0;
            ExitTimeHalf = EntryTime + TDateTime((50 * 3.6 / (EntrySpeed - 1.25) / 86400.0));
            // assume length is 50m for ease of calc
            ExitTimeFull = ExitTimeHalf + TDateTime((50 * 3.6 / (ExitSpeedHalf - 1.25) / 86400.0));
            Utilities->CallLogPop(2129);
            return;
        }
        else // stop immediately, don't enter next element, floating label had displayed last exit speed full on 2nd half move so with zero when fully on element
        {
            // will appear to have slowed at steady rate
            ExitSpeedHalf = 0;
            ExitSpeedFull = 0;
            MaxExitSpeed = LimitingSpeed;
            BrakeRate = 0;
            ExitTimeHalf = EntryTime + TDateTime(1/24); //set this high in case used later though unlikely
            ExitTimeFull = EntryTime + TDateTime(1/23); //set about 2.5 mins later than half time
            StoppedWithoutPower = true;
            Utilities->CallLogPop(2130);
            return;
        }
    }
    // TempBrakeRate=MinSingle; TempBrakeRate=MaxSingle; TempBrakeRate=MinDouble; TempBrakeRate=MaxDouble;//included to stop warnings from unused declarations in math.hpp
    // TempBrakeRate=MinExtended; TempBrakeRate=MaxExtended; TempBrakeRate=MinComp; TempBrakeRate=MaxComp;//included to stop warnings from unused declarations in math.hpp
    Utilities->CallLogPop(707);
}
// ---------------------------------------------------------------------------
/*
  bool TTrain::IsTerminalStation(int TrackVectorPosition, int EntryPos)
  {
  int NextExitPos;
  TTrackElement NextElement = Track->TrackElementAt(379, TrackVectorPosition), TempElement;
  if(TimetableVector.empty()) return false;
  if(NextElement.ActiveTrackElementName != TimetableVector.begin()->LocationName) return false;
  while((NextElement.ActiveTrackElementName == TimetableVector.begin()->LocationName) && (NextElement.TrackType != Buffers))
  {
  //check for points & follow attribute, but don't worry about a derail as that dealt with elsewhere
  if((NextElement.TrackType != Points) || ((EntryPos != 0) && (EntryPos != 2)))
  {
  NextExitPos = Track->GetNonPointsOppositeLinkPos(EntryPos);
  }
  else if((NextElement.TrackType == Points) && ((EntryPos == 0) || (EntryPos == 2)))
  {
  if(NextElement.Attribute == 0) NextExitPos = 1; else NextExitPos = 3;
  }
  TempElement = Track->TrackElementAt(380, NextElement.Conn[NextExitPos]);//need temp as NextElement used in next step
  NextElement = TempElement;
  }
  if(NextElement.ActiveTrackElementName != TimetableVector.begin()->LocationName) return false;
  if(NextElement.TrackType == Buffers) return true;
  return false;//shouldn't reach here but include to prevent compiler return warning
  }
*/
// ---------------------------------------------------------------------------

int TTrain::NameInTimetableBeforeCDT(int Caller, AnsiString Name, bool &Stop)
/*
          returns the number by which the train ActionVectorEntryPtr needs
          to be incremented to point to the location arrival entry or passtime entry before a change of direction.  Used to display missed
          actions when a stop or pass location has been reached before other timetabled events have been carried out.  If can't find it, or Name
          is "", -1 is returned.  A change of direction is the limit of the search because a train may not stop at a location on the way out
          but stop on way back, and in these circumstances no actions have been missed.  Stop indicates whether the train will stop at (true)
          or pass (false) the location.
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",NameInTimetableBeforeCDT," + Name + "," + HeadCode);
    Stop = false;
    if(TimetableFinished || (Name == ""))
    {
        Utilities->CallLogPop(957);
        return(-1);
    }
    TActionVectorEntry *Ptr = ActionVectorEntryPtr;
/*added the following check at v2.11.1 because of a fault found in Kevin Smith's railway (notified 02/01/22).  CH01 started at
Chester behind the stop position, but when it departed and this function was called it found Chester again with no cdt
before it (it went round the Liverpool Loop), so it stopped again when it reached the stop position and reported all intermediate stops as having been
missed.  This check is for the train just having departed from the station in question, and if it has then any further stations
with the same name are ignored - i.e. it stops a train from stopping at the same station twice in succession.
*/
    if(Ptr > &TrainDataEntryPtr->ActionVector.at(0))
    {
        Ptr--;
        if((Ptr->DepartureTime > TDateTime(-1)) && (Ptr->LocationName == Name))
        {
            if((Ptr->FormatType == TimeLoc) || (Ptr->FormatType == TimeTimeLoc))
            {
                Utilities->CallLogPop(2444);
                return(-1);
            }
        }
    }
    // start looking from current pointer position
    for(TActionVectorEntry *Ptr = ActionVectorEntryPtr; Ptr < &TrainDataEntryPtr->ActionVector.back(); Ptr++)
    {
        if((Ptr->Command == "cdt") || (Ptr->FormatType == Repeat))
        {
            break;
        }
        if((Ptr->ArrivalTime > TDateTime(-1)) && (Ptr->LocationName == Name))
        {
            if((Ptr->FormatType == TimeLoc) || (Ptr->FormatType == TimeTimeLoc))
            {
                Stop = true;
                Utilities->CallLogPop(960);
                return (Ptr - ActionVectorEntryPtr);
            }
        }
        if((Ptr->EventTime > TDateTime(-1)) && (Ptr->LocationName == Name) && (Ptr->Command == "pas"))
        {
            Utilities->CallLogPop(1517);
            return (Ptr - ActionVectorEntryPtr);
        }
    }
    Utilities->CallLogPop(959);
    return(-1); // not found a valid entry
}

// ---------------------------------------------------------------------------

bool TTrain::ClearToNextSignal(int Caller)
/* Checks forward from train LeadElement, following leading point attributes but ignoring trailing point attributes,
          until finds either a train or a signal/buffers/continuation/loop.  If finds a train returns false, else returns true.
          Ignores the call-on signal.
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ClearToNextSignal" + "," + HeadCode);
    int ReturnVal = 0;
    int ElementCount = 0;
/*   dropped at v2.12.0 as takes up a great deal of time unnecessarily - substitute 1000 elements instead and return true (very unlikley to need to search this far [10km at min length])
    for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
    {
        Track->TrackElementAt(1031, x).TempTrackMarker01 = false;
        Track->TrackElementAt(1032, x).TempTrackMarker23 = false;
    }
*/
    int CurrentTrackVectorPosition = LeadElement, NextTrackVectorPosition;
    int EntryPos = LeadEntryPos, ExitPos, NextEntryPos;

    while(true)
    {
        if((Track->TrackElementAt(382, CurrentTrackVectorPosition).TrainIDOnElement > -1) && (Track->TrackElementAt(383,
                                                                                                                    CurrentTrackVectorPosition).TrainIDOnElement != TrainID))
        {
            ReturnVal = 1;
            break;
        }
        if(((Track->TrackElementAt(384, CurrentTrackVectorPosition).TrackType == Buffers) || (Track->TrackElementAt(385,
                                                                                                                    CurrentTrackVectorPosition).TrackType == Continuation)) && (EntryPos == 1))
        {
            ReturnVal = 2;
            break;
        }
        if((EntryPos < 2) && (Track->TrackElementAt(386, CurrentTrackVectorPosition).Config[1 - EntryPos] == Signal) && (Track->TrackElementAt(529,
            CurrentTrackVectorPosition).Attribute != 4)) // Attr 4 == call-on signal
        {
            ReturnVal = 3;
            break;
        }
/*  not needed at and after v2.12.0, see above
        if((Track->TrackElementAt(387, CurrentTrackVectorPosition).TrackType == Bridge) || (Track->TrackElementAt(388, CurrentTrackVectorPosition).TrackType == Crossover))
        {
            if((EntryPos < 2) && (Track->TrackElementAt(523, CurrentTrackVectorPosition).TempTrackMarker01))
            // must be a loop - reached same point as examined earlier
            {
                ReturnVal = 4;
                break;
            }
            else if((EntryPos > 1) && (Track->TrackElementAt(524, CurrentTrackVectorPosition).TempTrackMarker23))
            {
                ReturnVal = 4;
                break;
            }
        }
        else
        {
            if((Track->TrackElementAt(525, CurrentTrackVectorPosition).TempTrackMarker01) || (Track->TrackElementAt(526, CurrentTrackVectorPosition).TempTrackMarker23))
            {
                ReturnVal = 4;
                break;
            }
        }
        if(EntryPos < 2)
        {
            Track->TrackElementAt(389, CurrentTrackVectorPosition).TempTrackMarker01 = true;
        }
        else
        {
            Track->TrackElementAt(527, CurrentTrackVectorPosition).TempTrackMarker23 = true;
        }
*/

        if(Track->TrackElementAt(390, CurrentTrackVectorPosition).TrackType == Points)
        {
            if((EntryPos == 0) || (EntryPos == 2))
            {
                if(Track->TrackElementAt(391, CurrentTrackVectorPosition).Attribute == 0)
                {
                    ExitPos = 1;
                }
                else
                {
                    ExitPos = 3;
                }
            }
            else
            {
                ExitPos = 0;
            }
        }
        else
        {
            ExitPos = Track->GetNonPointsOppositeLinkPos(EntryPos);
        }
        NextTrackVectorPosition = Track->TrackElementAt(392, CurrentTrackVectorPosition).Conn[ExitPos];
        NextEntryPos = Track->TrackElementAt(393, CurrentTrackVectorPosition).ConnLinkPos[ExitPos];
        CurrentTrackVectorPosition = NextTrackVectorPosition;
        EntryPos = NextEntryPos;
        ElementCount++;
        if(ElementCount > 1000)
        {
            ReturnVal = 4;
            break;
        }
    }
    if(ReturnVal == 1)
    {
        Utilities->CallLogPop(708);
        return(false);
    }
    if(ReturnVal == 2)
    {
        Utilities->CallLogPop(709);
        return(true);
    }
    if(ReturnVal == 3)
    {
        Utilities->CallLogPop(946);
        return(true);
    }
    if(ReturnVal == 4)
    {
        Utilities->CallLogPop(947);
        return(true);
    }
    else
    {
        throw Exception("Error - failed to set ReturnVal in ClearToNextSignal()");
    }
}

// ---------------------------------------------------------------------------

bool TTrain::CallingOnAllowed(int Caller)
/*
          Check whether calling-on conditions met - a) approaching train has stopped at a signal but not at a location;
          b) if there is a facing train at the station, it is being held appropriately (must be awaiting a join (Fjo or jbo) or a
          change of direction (cdt), remaining here (Frh), or under signaller control);
          c) at least 1 platform available for the approaching train; d) points (if any) set for direct route into platform;
          e) approaching train is to stop at station; f) no more facing signals between train and platform; g) [dropped g]
          h) train in front preventing route being set far enough to release stop signal; i) train in front not exiting at continuation; j) signal must be within 4km of
          the stop platform; k) [dropped (k), now can set a reoute or part route into platform so can set points more easily.] l) no existing route conflicts with the route into the platform,
          m) not failed or stopped without power
          If all OK & route or part route not already set then set an unrestricted route into the station (just to the first platform), to prevent point changing or other route conflicts - if a partial route set than can still
          change points outside the route or have a route conflict if another route is set.
*/{
    if(Track->RouteFlashFlag || TrainFailed || StoppedWithoutPower)  //failed & no power conditions added at v2.10.0
    {
        return(false);   // don't want to create a new route from the stop signal if one is already in construction & can't call on if failed or no power
    }
    // some of the callingon route elements may be involved
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CallingOnAllowed" + "," + HeadCode);
    bool PlatformFoundFlag = false, StopRequired = false, SkipRouteCheck = false, RouteOrPartRouteSet = false; // last added at v1.2.0
    int CurrentTrackVectorPosition = LeadElement, NextTrackVectorPosition, ElementNumber = 0, Distance = 0;
    int RouteStartPosition;
    // this is the track vector position of the start element for the new unrestricted route - one past the stop signal
    int PlatformPosition;
    // the track vector position of the first stop platfrom
    int EntryPos = LeadEntryPos, ExitPos, NextEntryPos, RouteID;
    // not used here
    AnsiString LeadStationName = Track->TrackElementAt(395, LeadElement).ActiveTrackElementName; // still OK even if ""
    int LeadElementDistance = Track->TrackElementAt(1017, LeadElement).Length01; //added after 2.7.0 as don't want to add this to overall distance since train has already covered this distance
    // use Length01, may be wrong for points/crossovers/bridges but unlikely to occur in practice
    // must be stopped at a signal but not at a location & still in timetable (a)
    if(RevisedStoppedAtLoc() || !StoppedAtSignal || TimetableFinished || Crashed || Derailed || DerailPending || StoppedAfterSPAD || StoppedForTrainInFront)
    // no need to check for SignallerStopped as this function only called in Timetable mode
    {
        Utilities->CallLogPop(711);
        return(false);
    }
    while(true)
    {
        TTrackElement &CurrentTrackElement = Track->TrackElementAt(396, CurrentTrackVectorPosition);
        // don't look further than 4km ahead (j)
        if(Distance > (4000 + LeadElementDistance))
        {
            Utilities->CallLogPop(967);
            return(false);
        }
        // if find another train on an element in front, before find a valid platform, return false (c)
        if((CurrentTrackElement.TrainIDOnElement > -1) && (CurrentTrackElement.TrainIDOnElement != TrainID) && !PlatformFoundFlag)
        {
            Utilities->CallLogPop(713);
            return(false);
        }
        // if find another train in front when there is a valid platform (keep searching after find a platform as train may still
        // be facing later on)
        if((CurrentTrackElement.TrainIDOnElement > -1) && (CurrentTrackElement.TrainIDOnElement != TrainID) && PlatformFoundFlag)
        {
            // get LeadElement, if -1 return (could be exiting at continuation) (i)
            TTrain OtherTrain = TrainController->TrainVectorAtIdent(12, CurrentTrackElement.TrainIDOnElement);
            if(OtherTrain.LeadElement == -1)
            {
                Utilities->CallLogPop(714);
                return(false);
            }
            // if a facing train then make sure it is awaiting a join (Fjo or jbo) or a change of direction (cdt), or remaining here (Frh) (b)
            if(OtherTrain.LeadElement == CurrentTrackVectorPosition)
            {
                AnsiString OtherCommand = OtherTrain.ActionVectorEntryPtr->Command;
                if((OtherCommand == "Fjo") || (OtherCommand == "jbo") || (OtherCommand == "cdt") || (OtherCommand == "Frh") ||
                   (OtherTrain.TrainMode == Signaller))
                {
                    break;
                }
                else
                {
                    Utilities->CallLogPop(955);
                    return(false);
                }
            }
            else // (h)
            {
                break;
            }
        }
        // if reach buffers or exit continuation return false (can set route)
        if(((CurrentTrackElement.TrackType == Buffers) || (CurrentTrackElement.TrackType == Continuation)) && (EntryPos == 1))
        {
            Utilities->CallLogPop(716);
            return(false);
        }
        // if reach forward signal (other than the one the train is waiting at) return false (can set route) (f)
        if((EntryPos < 2) && (CurrentTrackElement.Config[1 - EntryPos] == Signal) && (CurrentTrackVectorPosition != Track->TrackElementAt(404,
                                                                                                                                          LeadElement).Conn[LeadExitPos]))
        {
            Utilities->CallLogPop(717);
            return(false);
        }
        // if reach a location that isn't in timetable return false - drop this as still can't set a route
/*
          if((Track->TrackElementAt(405, CurrentTrackVectorPosition).ActiveTrackElementName != "") && (Track->TrackElementAt(406, CurrentTrackVectorPosition).ActiveTrackElementName != LeadStationName) &&
          (NameInTimetableBeforeCDT(14, Track->TrackElementAt(407, CurrentTrackVectorPosition).ActiveTrackElementName) == -1))
          {
          Utilities->CallLogPop(718);
          return false;
          }
*/
        // if reach a location that is in timetable set PlatformFoundFlag (but not if position is points set to diverge) (e)
        if((CurrentTrackElement.ActiveTrackElementName != "") && (CurrentTrackElement.ActiveTrackElementName != LeadStationName) &&
           (NameInTimetableBeforeCDT(15, CurrentTrackElement.ActiveTrackElementName, StopRequired) > -1))
        {
            if(StopRequired)
            {
                if((CurrentTrackElement.TrackType != Points) || ((CurrentTrackElement.TrackType == Points) && (CurrentTrackElement.Attribute == 0)))
                {
                    if(!PlatformFoundFlag)
                    {
                        PlatformPosition = CurrentTrackVectorPosition;
                    }
                    // ensure this only set once at first valid platform position - the unrestricted route will end here
                    PlatformFoundFlag = true;
                }
            }
        }
        // Drop this below - was to prevent call-on if front train had left the station.  Criterion now is not that front
        // train has to be at station but that has to be before the next forward signal
/*
          if((Track->TrackElementAt(411, CurrentTrackVectorPosition).ActiveTrackElementName == "") && (PlatformFoundFlag))
          {
          Utilities->CallLogPop(719);
          return false;
          }
*/
        // make sure points are followed correctly (d) & set ExitPos
        if(CurrentTrackElement.TrackType == Points)
        {
            if((EntryPos == 0) || (EntryPos == 2))
            {
                if(CurrentTrackElement.Attribute == 0)
                {
                    ExitPos = 1;
                }
                else
                {
                    ExitPos = 3;
                }
            }
            if(EntryPos == 1)
            {
                if(CurrentTrackElement.Attribute == 0)
                {
                    ExitPos = 0;
                }
                else
                {
                    Utilities->CallLogPop(720);
                    return(false);
                }
            }
            if(EntryPos == 3)
            {
                if(CurrentTrackElement.Attribute == 1)
                {
                    ExitPos = 0;
                }
                else
                {
                    Utilities->CallLogPop(721);
                    return(false);
                }
            }
        }
        else
        {
            ExitPos = Track->GetNonPointsOppositeLinkPos(EntryPos);
        }
        // check existing routes - if element forward of the signal (ElementNumber == 2) is AutoSignals then OK without further checks as this route must extend to
        // the next signal so must at least reach the station, also if have another route set (must be unrestricted) from either the stop signal or the element after it
        // to or towards the platform (& all points set correctly) then OK, otherwise reject if (1) there are any route elements already set from element
        // forward of element after the signal to & including the first platform element (covers crossover with other route set) or (2) a fouled diagonal (k)
        if(ElementNumber < 2)
        {
            SkipRouteCheck = true;
        }
        else
        {
            SkipRouteCheck = false;
        }
        if(ElementNumber == 1) // the stop signal
        {
            RouteStartPosition = CurrentTrackVectorPosition;
        }
/*
          if(ElementNumber == 2)
          {
          if(AllRoutes->GetRouteTypeAndNumber(18, CurrentTrackVectorPosition, EntryPos, RouteID) == AllRoutes->AutoSigsRoute) AutoSigs = true;
          else AutoSigs = false;
          if(AllRoutes->GetRouteTypeAndNumber(25, CurrentTrackVectorPosition, EntryPos, RouteID) == AllRoutes->NotAutoSigsRoute) OtherFullRouteSet = true;
          }
*/
        if(ElementNumber > 1)
        {
            if(AllRoutes->GetRouteTypeAndNumber(26, CurrentTrackVectorPosition, EntryPos, RouteID) != AllRoutes->NoRoute)
            {
                RouteOrPartRouteSet = true;
            }
            else
            {
                RouteOrPartRouteSet = false;
            }
        }
        if(!SkipRouteCheck && !RouteOrPartRouteSet)
        {
            if(AllRoutes->TrackIsInARoute(16, CurrentTrackVectorPosition, EntryPos)) // must be a conflicting route
            {
                Utilities->CallLogPop(1859);
                return(false);
            }
            int ExitLink = CurrentTrackElement.Link[ExitPos];
            if((ExitLink == 1) || (ExitLink == 3) || (ExitLink == 7) || (ExitLink == 9))
            {
                if(AllRoutes->DiagonalFouledByRouteOrTrain(6, CurrentTrackElement.HLoc, CurrentTrackElement.VLoc, ExitLink))
                {
                    Utilities->CallLogPop(1850);
                    return(false);
                }
            }
        }
        // finished all checks, now update CurrentTrackVectorPosition & EntryPos for the next iteration
        if(EntryPos < 2)
        {
            Distance += CurrentTrackElement.Length01;
        }
        else
        {
            Distance += CurrentTrackElement.Length23;
        }
        NextTrackVectorPosition = CurrentTrackElement.Conn[ExitPos];
        NextEntryPos = CurrentTrackElement.ConnLinkPos[ExitPos];
        CurrentTrackVectorPosition = NextTrackVectorPosition;
        EntryPos = NextEntryPos;
        ElementNumber++;
    } // while(true)

    // if all OK & autosigs route not already set then set an unrestricted route into the station (just to the first platform)
    // from the stop signal (note that it may be last in an autosigs route)
    // a single element route at the stop signal should have been removed prior to this function being called (that called before
    // this in ClockTimer2)

    // now add elements to the CallonVector
    TAllRoutes::TCallonEntry CallonEntry(RouteOrPartRouteSet, RouteStartPosition, PlatformPosition);

    AllRoutes->CallonVector.push_back(CallonEntry);
    Utilities->CallLogPop(1860);
    return(true); // return false if fail to set route for any reason
}

// ---------------------------------------------------------------------------
/*
  bool TTrain::TimetableFinished()
  {
  if((ActionVectorEntryPtr == TrainDataEntryPtr->ActionVector.end()) || (ActionVectorEntryPtr->FormatType == Repeat))//past all actions
  {
  return true;
  }
  return false;
  }
*/
// ---------------------------------------------------------------------------

AnsiString TTrain::GetTrainHeadCode(int Caller)

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetTrainHeadCode" + "," + HeadCode);
    AnsiString RepeatHeadCode = TrainController->GetRepeatHeadCode(0, HeadCode, RepeatNumber, IncrementalDigits);

    Utilities->CallLogPop(1452);
    return(RepeatHeadCode);
}

// ---------------------------------------------------------------------------

TDateTime TTrain::GetTrainTime(int Caller, TDateTime Time)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetTrainTime," + Utilities->Format96HHMMSS(Time));
    TDateTime RepeatTime = TrainController->GetRepeatTime(1, Time, RepeatNumber, IncrementalMinutes);

    Utilities->CallLogPop(1453);
    return(RepeatTime);
}

// ---------------------------------------------------------------------------

bool TTrain::IsThereAnAdjacentTrain(int Caller, TTrain *&TrainToBeJoinedBy)
{
    // Used to check for a stopped adjacent train for use in PopUp menu //new at v2.4.0
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsThereAnAdjacentTrain" + "," + HeadCode);
    // check if there's a stopped adjacent train, if there is but not under sig control give a message in calling function
    // first check that train is fully on the railway
    bool FrontValid = false, RearValid = false;
    TTrackElement FrontAdjacentTrackElement, RearAdjacentTrackElement;

    if((LeadElement == -1) || (MidElement == -1))
    {
        TrainToBeJoinedBy = NULL;
        Utilities->CallLogPop(2131);
        return(false);
    }
    if(Track->TrackElementAt(964, LeadElement).Conn[LeadExitPos] > -1)
    {
        FrontAdjacentTrackElement = Track->TrackElementAt(965, (Track->TrackElementAt(966, LeadElement).Conn[LeadExitPos]));
        FrontValid = true;
    }
    if(Track->TrackElementAt(967, MidElement).Conn[MidEntryPos] > -1)
    {
        RearAdjacentTrackElement = Track->TrackElementAt(968, (Track->TrackElementAt(969, MidElement).Conn[MidEntryPos]));
        RearValid = true;
    }
    int TrainToBeJoinedByID = -1;

    // first check if on a 2-track element & select correct ID number if so
    if(FrontValid)
    {
        if(FrontAdjacentTrackElement.TrackType == Bridge)
        {
            if(Track->TrackElementAt(970, LeadElement).ConnLinkPos[LeadExitPos] > 1)
            {
                TrainToBeJoinedByID = FrontAdjacentTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
            }
            else
            {
                TrainToBeJoinedByID = FrontAdjacentTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
            }
        }
        else
        {
            TrainToBeJoinedByID = FrontAdjacentTrackElement.TrainIDOnElement;
        }
    }
    if((TrainToBeJoinedByID < 0) && RearValid)
    {
        // first check if on a 2-track element & select correct ID number if so
        if(RearAdjacentTrackElement.TrackType == Bridge)
        {
            if(Track->TrackElementAt(971, MidElement).ConnLinkPos[MidEntryPos] > 1)
            {
                TrainToBeJoinedByID = RearAdjacentTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
            }
            else
            {
                TrainToBeJoinedByID = RearAdjacentTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
            }
        }
        else
        {
            TrainToBeJoinedByID = RearAdjacentTrackElement.TrainIDOnElement;
        }
    }
    if(TrainToBeJoinedByID < 0) // no adjacent train
    {
        TrainToBeJoinedBy = NULL;
        Utilities->CallLogPop(2132);
        return(false);
    }
    TrainToBeJoinedBy = &(TrainController->TrainVectorAtIdent(44, TrainToBeJoinedByID));
    if(!TrainToBeJoinedBy->Stopped())
    {
        TrainToBeJoinedBy = NULL;
        Utilities->CallLogPop(2133);
        return(false);
    }
    Utilities->CallLogPop(2134);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrain::LogAction(int Caller, AnsiString OwnHeadCode, AnsiString OtherHeadCode, TActionType ActionType, AnsiString LocationName,
                       TDateTime TimetableNonRepeatTime, bool Warning)
/*
          Time = timetable time, the time adjustments for repeat trains is carried out internally
          Not all messages need this, if not needed a dummy value is required but not used

          Arrive:  06:05:40: 2F46 arrived at Old Street 1 minute late
          Pass:  06:05:40: 2F46 passed Old Street 1 minute late
          Terminate:  06:05:40: 2F46 terminated at Old Street 1 minute late
          //NB for Frh just give terminated message but without event time - don't use this function
          Depart:  06:05:15: 3F43 departed from Essex Road 2 minutes late
          Create:  06:05:40: 2F46 created at Old Street 1 minute late
          Enter:  06:05:40: 2F46 entered railway at Old Street 1 minute late
          Leave:  06:05:40: 2F46 left railway at 57-N4 1 minute late
          FrontSplit:  06:05:40: 2F46 split from front to 3D54 at Old Street 1 minute late
          RearSplit:  06:05:40: 2F46 split from rear to 3D54 at Old Street 1 minute late
          JoinedByOther:  06:05:40: 2F46 joined by 3D54 at Old Street 1 minute late
          ChangeDirection:  06:05:40: 2F46 changed direction at Old Street 1 minute late
          NewService:  06:05:40: 2F46 became new service 3D54 at Old Street 1 minute late
          TakeManualControl:  06:05:40: 2F46 taken under signaller control at Old Street
          RestoreTimetableControl:  06:05:40: 2F46 restored to timetable control at Old Street
          RemoveTrain:  06:05:40: 2F46 REMOVED FROM RAILWAY DUE TO CRASH at Old Street
          RemoveTrain:  06:05:40: 2F46 REMOVED FROM RAILWAY DUE TO DERAILMENT at Old Street
          RemoveTrain:  06:05:40: 2F46 REMOVED FROM RAILWAY at Old Street
          SignallerMoveForwards  06:05:40: 2F46 received signaller authority to proceed
          SignallerChangeDirection  06:05:40: 2F46 changed direction under signaller control at Old Street
          SignallerPassRedSignal  06:05:40: 2F46 received signaller authority to pass stop signal
          SignallerJoin 06:05:40: 2F46 joined under signaller control by 3D54 at Old Street    //new at v2.4.0
          TrainFailure 06:05:40: 2F46 suffered an onboard power failure at Old Street    //new at v2.4.0
          RepairFailedTrain 06:05:40: 2F46 failure repaired at Old Street    //new at v2.4.0
          SignallerControlStop  06:05:40: 2F46 received signaller instruction to stop
          SignallerStop  06:05:40: 2F46 stopped on signaller command
          SignallerLeave:  06:05:40: 2F46 left railway under signaller control at 57-N4
          SignallerStepForward:  06:05:40: 2F46 received signaller authority to step forward
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LogAction," + OwnHeadCode + "," + OtherHeadCode + "," +
                                 AnsiString(ActionType) + "," + LocationName + "," + HeadCode);
    AnsiString BaseLog = "", WarningBaseLog = "", PerfLog = "", ActionLog = "";
    int IntMinsLate = 0;

    // need to set it in case MinsLate == 0, since it isn't tested for that
    if(ActionType == Arrive)
    {
        ActionLog = " arrived at ";
    }
    if(ActionType == Terminate)
    {
        if(TerminatedMessageSent) // to avoid it being sent twice
        {
            Utilities->CallLogPop(1104);
            return;
        }
        ActionLog = " terminated at ";
        TerminatedMessageSent = true;
    }
    if(ActionType == Depart)
    {
        ActionLog = " departed from ";
    }
    if(ActionType == Pass)
    {
        ActionLog = " passed ";
    }
    if(ActionType == Create)
    {
        ActionLog = " created at ";
    }
    if(ActionType == Enter)
    {
        ActionLog = " entered railway at ";
    }
    if(ActionType == Leave)
    {
        ActionLog = " left railway at ";
    }
    if(ActionType == FrontSplit)
    {
        ActionLog = " split from front to ";
    }
    if(ActionType == RearSplit)
    {
        ActionLog = " split from rear to ";
    }
    if(ActionType == JoinedByOther)
    {
        ActionLog = " joined by ";
    }
    if(ActionType == ChangeDirection)
    {
        ActionLog = " changed direction at ";
    }
    if(ActionType == NewService)
    {
        ActionLog = " became new service ";
    }
    if(ActionType == TakeSignallerControl)
    {
        ActionLog = " taken under signaller control at ";
    }
    if(ActionType == RestoreTimetableControl)
    {
        ActionLog = " restored to timetable control at ";
    }
    if(ActionType == RemoveTrain)
    {
        if(Crashed)
        {
            ActionLog = " REMOVED FROM RAILWAY DUE TO CRASH at ";
        }
        else if(Derailed)
        {
            ActionLog = " REMOVED FROM RAILWAY DUE TO DERAILMENT at ";
        }
        else
        {
            ActionLog = " REMOVED FROM RAILWAY at ";
        }
    }
    if(ActionType == SignallerMoveForwards)
    {
        ActionLog = " received signaller authority to proceed";
    }
    if(ActionType == SignallerStepForward)
    {
        ActionLog = " received signaller authority to step forward";
    }
    if(ActionType == SignallerChangeDirection)
    {
        ActionLog = " changed direction under signaller control at ";
    }
    if(ActionType == SignallerPassRedSignal)
    {
        ActionLog = " received signaller authority to pass stop signal";
    }
    if(ActionType == SignallerControlStop)
    {
        ActionLog = " received signaller instruction to stop";
    }
    if(ActionType == SignallerStop)
    {
        ActionLog = " stopped on signaller instruction ";
    }
    if(ActionType == SignallerJoin)
    {
        ActionLog = " joined under signaller control by ";
    }
    if(ActionType == TrainFailure)
    {
        ActionLog = " suffered an onboard power failure at ";
    }
    if(ActionType == RepairFailedTrain)
    {
        ActionLog = " failure repaired at ";
    }
    if(ActionType == SignallerLeave)
    {
        ActionLog = " left railway under signaller control at ";
    }
    if(OtherHeadCode != "")
    {
        OtherHeadCode += " at ";
    }
    TDateTime ActualTime = TrainController->TTClockTime;

    if(Warning)
    {
        BaseLog = Utilities->Format96HHMMSS(ActualTime) + " WARNING: " + HeadCode + ActionLog + OtherHeadCode + LocationName;
        WarningBaseLog = Utilities->Format96HHMMSS(ActualTime) + ": " + HeadCode + ActionLog + OtherHeadCode + LocationName; //added time at v2.13.0
    }
    else
    {
        BaseLog = Utilities->Format96HHMMSS(ActualTime) + ": " + HeadCode + ActionLog + OtherHeadCode + LocationName;
    }
    bool TimePerformance = true;

    if((ActionType == TakeSignallerControl) || (ActionType == RestoreTimetableControl) || (ActionType == RemoveTrain) || (ActionType == SignallerMoveForwards)
       || (ActionType == SignallerChangeDirection) || (ActionType == SignallerPassRedSignal) || (ActionType == SignallerControlStop) ||
       (ActionType == SignallerStop) || (ActionType == SignallerLeave) || (ActionType == SignallerStepForward) || (ActionType == SignallerJoin) ||
       (ActionType == TrainFailure) || (ActionType == RepairFailedTrain))
    // SignallerJoin & RepairFailedTrain new at v2.4.0
    {
        TimePerformance = false;
    }
    if(TimePerformance)
    {
        double MinsLate = ((double)(ActualTime - GetTrainTime(1, TimetableNonRepeatTime))) * 1440;
        MinsDelayed = float(MinsLate);
        if(ActionType == Pass) //added at v2.9.2 to prevent time to act increasing suddenly for early pass times then becoming 'NOW' when stops at signal
        {
            MinsDelayed = 0;
        }
        // new v2.2.0 for OpActionPanel, can be positive or negative
        if(ActionType == Arrive)
        {
            MinsDelayed -= FirstLaterStopRecoverableTime;
        }
        // since train has just arrived this value is the
        // recoverable time available at this stop, so reduce MinsDelayed by this amount to prevent it being
        // subtracted from later stop recoverable times.
        if(MinsLate < 0)
        {
            IntMinsLate = int(ceil(MinsLate));
        }
        if(MinsLate > 0)
        {
            IntMinsLate = int(floor(MinsLate));
        }
        if(IntMinsLate == 0)
        {
            PerfLog = " on time";
        }
        else if(IntMinsLate == 1)
        {
            PerfLog = " 1 minute late";
        }
        else if(IntMinsLate == -1)
        {
            PerfLog = " 1 minute early";
        }
        else if(IntMinsLate > 1)
        {
            PerfLog = " " + AnsiString(IntMinsLate) + " minutes late";
        }
        else if(IntMinsLate < -1)
        {
            int PosIntMinsLate = -IntMinsLate;
            PerfLog = " " + AnsiString(PosIntMinsLate) + " minutes early";
        }
        if(LocationName.Pos('-') > 0)
        {
            PerfLog = "," + PerfLog;
            // if a position add a comma to separate vertical position number from number of minutes (better appearance)
        }
        PerfLogForm->PerformanceLog(0, BaseLog + PerfLog);
    }
    else
    {
        PerfLogForm->PerformanceLog(1, BaseLog);
    }
    if(Warning)
    {
        Display->WarningLog(0, WarningBaseLog);
    }
    // update statistics
    if((ActionType == Arrive) && (IntMinsLate == 0))
    {
        TrainController->OnTimeArrivals++;
    }
    else if((ActionType == Arrive) && (IntMinsLate > 0))
    {
        TrainController->LateArrivals++;
        TrainController->TotLateArrMins += IntMinsLate;
    }
    else if((ActionType == Arrive) && (IntMinsLate < 0))
    {
        TrainController->EarlyArrivals++;
        TrainController->TotEarlyArrMins += abs(IntMinsLate);
    }

    else if((ActionType == Pass) && (IntMinsLate == 0))
    {
        TrainController->OnTimePasses++;
    }
    else if((ActionType == Pass) && (IntMinsLate > 0))
    {
        TrainController->LatePasses++;
        TrainController->TotLatePassMins += IntMinsLate;
    }
    else if((ActionType == Pass) && (IntMinsLate < 0))
    {
        TrainController->EarlyPasses++;
        TrainController->TotEarlyPassMins += abs(IntMinsLate);
    }

    else if((ActionType == Leave) && (IntMinsLate == 0)) //new at v2.9.1 as had been omitted in error earlier
    {
        TrainController->OnTimeExits++;
    }
    else if((ActionType == Leave) && (IntMinsLate > 0))
    {
        TrainController->LateExits++;
        TrainController->TotLateExitMins += IntMinsLate;
    }
    else if((ActionType == Leave) && (IntMinsLate < 0))
    {
        TrainController->EarlyExits++;
        TrainController->TotEarlyExitMins += abs(IntMinsLate);
    }

    else if((ActionType == Depart) && (IntMinsLate == 0)) //can't depart early
    {
        TrainController->OnTimeDeps++;
    }
    else if((ActionType == Depart) && (IntMinsLate > 0))
    {
        TrainController->LateDeps++;
        TrainController->TotLateDepMins += IntMinsLate;
    }
    Utilities->CallLogPop(968);
}

// ---------------------------------------------------------------------------

void TTrain::TrainHasFailed(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainHasFailed," + HeadCode);
    if(Crashed || Derailed || DerailPending)
    {
        TrainFailurePending = false;
        Utilities->CallLogPop(2135);
        return;
    }
    AnsiString LocName = "";

    if(LeadElement > -1)
    {
        LocName = Track->TrackElementAt(972, LeadElement).ActiveTrackElementName;
    }
    if((LocName == "") && (MidElement > -1))
    {
        LocName = Track->TrackElementAt(973, MidElement).ActiveTrackElementName;
    }
    if((LocName == "") && LeadElement > -1)
    {
        LocName = Track->TrackElementAt(974, LeadElement).ElementID;
    }
    if((LocName == "") && (MidElement > -1))
    {
        LocName = Track->TrackElementAt(975, MidElement).ElementID;
    }
    TrainController->StopTTClockMessage(81, HeadCode + " has suffered an onboard power failure at " + LocName);
    TrainFailed = true;
    TrainFailurePending = false;
    CallingOnFlag = false;  //added at v2.10.0
    OriginalPowerAtRail = PowerAtRail;
    PowerAtRail = 0.08;
    AValue = sqrt(2 * PowerAtRail / Mass);
    PlotTrainWithNewBackgroundColour(48, clTrainFailedBackground, Display);
    // TrainFailed only called when PlotElements properly set to Lead, Mid & Lag elements
    if(Stopped())
    {
        EntrySpeed = 0;
        ExitSpeedHalf = 0;
        ExitSpeedFull = 0;
        MaxExitSpeed = 0;
        BrakeRate = 0;
        StoppedWithoutPower = true;
    }
    TrainController->NumFailures++;
    LogAction(33, HeadCode, "", TrainFailure, LocName, TDateTime(0), true);
    // true for warning, TDateTime not used
    Utilities->CallLogPop(2136);
}

// ---------------------------------------------------------------------------

void TTrain::FrontTrainSplit(int Caller)
{
/*
      Split logic is:-  at least one of 4 final train positions must overlap with one of original train positions, & final 4 positions
      will maximise the number at the location.  Note that this function isn't sophisticated enough to account for trains already at the
      location in determining the 4 positions, and will give a failure message if a train obstructs any of the 4 positions.  In these
      circumstances the other train will need to be moved sufficiently away to release all 4 positions, then the train will split.
*/
    TrainController->LogEvent("" + AnsiString(Caller) + ",FrontTrainSplit" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",FrontTrainSplit" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can split when power restored
    {
        if(!ZeroPowerNoFrontSplitMessage)
        {
            TrainController->StopTTClockMessage(82, HeadCode + ": A train without power can't split");
        }
        ZeroPowerNoFrontSplitMessage = true;
        Utilities->CallLogPop(2137);
        return;
    }
    AnsiString LocationName = Track->TrackElementAt(555, LeadElement).ActiveTrackElementName;

    if(LocationName == "")
    {
        LocationName = Track->TrackElementAt(837, MidElement).ActiveTrackElementName;
    }
    int FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos, SecondNamedLinkedElementPos;
    int RearTrainRearPosition, RearTrainFrontPosition, RearTrainExitPos;
    int FrontTrainRearPosition, FrontTrainFrontPosition, FrontTrainExitPos;
    AnsiString OtherHeadCode = TrainController->GetRepeatHeadCode(1, ActionVectorEntryPtr->OtherHeadCode, RepeatNumber, IncrementalDigits);

    // determine all positions & exits
    if(LocationName != "")
    {
        // if message given only call at ~5 sec intervals
        if(!(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailLocTooShort) || (UpdateCounter == 0))
        {
            FirstNamedElementPos = LeadElement;
            if(!Track->ThisNamedLocationLongEnoughForSplit(0, LocationName, FirstNamedElementPos,
                                                           // check if possible with LeadElement as First
                                                           SecondNamedElementPos, FirstNamedLinkedElementPos, SecondNamedLinkedElementPos))
            {
                FirstNamedElementPos = MidElement;
                if(!Track->ThisNamedLocationLongEnoughForSplit(1, LocationName, FirstNamedElementPos,
                                                               // if not then accept second if possible (though if Lead no good hard to see how Mid could work, but leave in)
                                                               SecondNamedElementPos, FirstNamedLinkedElementPos, SecondNamedLinkedElementPos))
                {
                    if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailLocTooShort)
                    {
                        TrainController->LogActionError(6, HeadCode, "", FailLocTooShort, LocationName);
                        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailLocTooShort;
                    }
                    Utilities->CallLogPop(1009);
                    return;
                }
            }
            else
            {
                // if first is possible then check if all 4 positions at location, and if not try the second
                int LeadPosA = FirstNamedElementPos;
                int LeadPosB = FirstNamedLinkedElementPos;
                int LeadPosC = SecondNamedElementPos;
                int LeadPosD = SecondNamedLinkedElementPos;
                // count number of positions that are at the location
                int LeadNumAtLoc = 0;
                if(Track->TrackElementAt(758, LeadPosA).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(759, LeadPosB).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(760, LeadPosC).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(761, LeadPosD).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(LeadNumAtLoc < 4)
                {
                    FirstNamedElementPos = MidElement;
                    if(!Track->ThisNamedLocationLongEnoughForSplit(4, LocationName, FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos,
                                                                   SecondNamedLinkedElementPos)) // restore originals
                    {
                        FirstNamedElementPos = LeadPosA;
                        FirstNamedLinkedElementPos = LeadPosB;
                        SecondNamedElementPos = LeadPosC;
                        SecondNamedLinkedElementPos = LeadPosD;
                    }
                    else // count number at location
                    {
                        int MidNumAtLoc = 0;
                        if(Track->TrackElementAt(762, FirstNamedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(763, FirstNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(764, FirstNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(765, SecondNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(LeadNumAtLoc > MidNumAtLoc)
                        // change back, else keep new values
                        {
                            FirstNamedElementPos = LeadPosA;
                            FirstNamedLinkedElementPos = LeadPosB;
                            SecondNamedElementPos = LeadPosC;
                            SecondNamedLinkedElementPos = LeadPosD;
                        }
                    }
                }
            }
        }
        else
        {
            Utilities->CallLogPop(1791);
            return;
        }
    }
    else
    {
        throw Exception("Error - LocationName not set in FrontTrainSplit");
    }
    // set front & rear train parameters
    // need RearTrainRearPosition, RearTrainFrontPosition, RearTrainExitPos, FrontTrainRearPosition, FrontTrainFrontPosition & FrontTrainExitPos;
    // have LeadElement & MidElement of train defining its direction, & one or other on FirstNamedElementPos
    // have FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos & SecondNamedLinkedElementPos from ThisNamedLocationLongEnoughForSplit.
    if(LeadElement == FirstNamedElementPos)
    {
        if(MidElement == SecondNamedElementPos)
        {
            FrontTrainFrontPosition = FirstNamedLinkedElementPos;
            FrontTrainRearPosition = FirstNamedElementPos;
            RearTrainFrontPosition = SecondNamedElementPos;
            RearTrainRearPosition = SecondNamedLinkedElementPos;
        }
        else // MidElement must == FirstNamedLinkedElementPos
        {
            FrontTrainFrontPosition = SecondNamedLinkedElementPos;
            FrontTrainRearPosition = SecondNamedElementPos;
            RearTrainFrontPosition = FirstNamedElementPos;
            RearTrainRearPosition = FirstNamedLinkedElementPos;
        }
    }
    else // MidElement == FirstNamedElementPos
    {
        if(LeadElement == SecondNamedElementPos)
        {
            FrontTrainFrontPosition = SecondNamedLinkedElementPos;
            FrontTrainRearPosition = SecondNamedElementPos;
            RearTrainFrontPosition = FirstNamedElementPos;
            RearTrainRearPosition = FirstNamedLinkedElementPos;
        }
        else // LeadElement must == FirstNamedLinkedElementPos
        {
            FrontTrainFrontPosition = FirstNamedLinkedElementPos;
            FrontTrainRearPosition = FirstNamedElementPos;
            RearTrainFrontPosition = SecondNamedElementPos;
            RearTrainRearPosition = SecondNamedLinkedElementPos;
        }
    }
    RearTrainExitPos = -1;
    for(int x = 0; x < 4; x++)
    {
        if(Track->TrackElementAt(584, RearTrainRearPosition).Conn[x] == RearTrainFrontPosition)
        {
            RearTrainExitPos = x;
            break;
        }
    }
    if(RearTrainExitPos == -1)
    {
        throw Exception("Error - RearTrainRearPosition not linked to RearTrainFrontPosition in FrontTrainSplit");
    }
    FrontTrainExitPos = -1;
    for(int x = 0; x < 4; x++)
    {
        if(Track->TrackElementAt(585, FrontTrainRearPosition).Conn[x] == FrontTrainFrontPosition)
        {
            FrontTrainExitPos = x;
            break;
        }
    }
    if(FrontTrainExitPos == -1)
    {
        throw Exception("Error - FrontTrainRearPosition not linked to FrontTrainFrontPosition in FrontTrainSplit");
    }
    // check no train (apart from self) on any of the 4 elements & fail if so
    int TrainIDOnRearOfRearTrain, TrainIDOnFrontOfRearTrain, TrainIDOnRearOfFrontTrain, TrainIDOnFrontOfFrontTrain;
    TTrackElement RearMostElement = Track->TrackElementAt(574, RearTrainRearPosition);

    if((RearMostElement.TrackType == Bridge) && (RearTrainExitPos > 1))
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
    }
    else if((RearMostElement.TrackType == Bridge) && (RearTrainExitPos < 2))
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
    }
    else
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnElement;
    }
    // RearTrainFrontPosition = RearMostElement.Conn[RearTrainExitPos];
    TrainIDOnFrontOfRearTrain = Track->TrackElementAt(575, RearTrainFrontPosition).TrainIDOnElement;
    // can't be a bridge
    TrainIDOnRearOfFrontTrain = Track->TrackElementAt(576, FrontTrainRearPosition).TrainIDOnElement;
    // can't be a bridge
    // FrontTrainFrontPosition = Track->TrackElementAt(578,FrontTrainRearPosition).Conn[FrontTrainExitPos];
    TTrackElement FrontMostElement = Track->TrackElementAt(577, FrontTrainFrontPosition);

    if((FrontMostElement.TrackType == Bridge) && (FrontTrainExitPos > 1))
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
    }
    else if((FrontMostElement.TrackType == Bridge) && (FrontTrainExitPos < 2))
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
    }
    else
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnElement;
    }
    if(((TrainIDOnRearOfRearTrain > -1) && (TrainIDOnRearOfRearTrain != TrainID)) || ((TrainIDOnFrontOfRearTrain > -1) && (TrainIDOnFrontOfRearTrain != TrainID)
                                                                                      ) || ((TrainIDOnRearOfFrontTrain > -1) && (TrainIDOnRearOfFrontTrain != TrainID)) ||
       ((TrainIDOnFrontOfFrontTrain > -1) && (TrainIDOnFrontOfFrontTrain != TrainID)))
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailSplitDueToOtherTrain)
        {
            TrainController->LogActionError(8, HeadCode, "", FailSplitDueToOtherTrain, LocationName);
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailSplitDueToOtherTrain;
        }
        // don't advance ActionVectorEntryPtr as need to keep trying, other train may move off eventually
        Utilities->CallLogPop(1010);
        return;
    }
    if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailSplitDueToOtherTrain)
    {
        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
    }
    // reposition existing rear train, need to do this first for 2 reasons - 1) will likely be in the way of the new front train, and 2)
    // the new train will likely cause a reallocation of the TrainVector, and if so the reference to the existing train will be invalidated.
    // Hence deal with existing train while it references a valid entry in the vector, but retain the Old ActionVectorEntryPtr in a separate
    // variable as it is needed for setting up the new train
    TActionVectorEntry *OldActionVectorEntryPtr = ActionVectorEntryPtr;

    UnplotTrain(0);
    StartSpeed = 0;
    RearStartElement = RearTrainRearPosition;
    RearStartExitPos = RearTrainExitPos;
    StoppedAtLocation = true;
    if((PowerAtRail < 1) && EntrySpeed < 1) // added at v2.4.0
    {
        StoppedWithoutPower = true;
    }
    PlotStartPosition(3);
    PlotTrainWithNewBackgroundColour(14, clStationStopBackground, Display);
    LogAction(9, HeadCode, OtherHeadCode, FrontSplit, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;

    Mass = Mass / 2;
//    MaxBrakeRate = MaxBrakeRate / 2;  this was wrong - want brake rate to stay the same, brake force is halved but that not a train parameter
//    and when needed it's calculated from rate & mass - changed at v2.15.0
    PowerAtRail = PowerAtRail / 2;
    AValue = sqrt(2 * PowerAtRail / Mass);
    // shouldn't change but include in case not set earlier

    // create new front train
/*
      TrainController::AddTrain(int RearPosition, int FrontPosition, AnsiString HeadCode, int StartSpeed, int Mass,
      double MaxRunningSpeed, double MaxBrakeRate, double PowerAtRail, AnsiString ModeStr, TTrainDataEntry *TrainDataEntryPtr,
      int RepeatNumber, int IncrementalMinutes, int SignallerSpeed)
*/
    // same Mass, MaxBrakeRate & PowerAtRail as this train's halved values, and same MaxRunningSpeed as this train
    TActionEventType EventType = NoEvent;

    if(!TrainController->AddTrain(0, FrontTrainRearPosition, FrontTrainFrontPosition, OtherHeadCode, 0, Mass, MaxRunningSpeed, MaxBrakeRate, PowerAtRail,
                                  "Timetable", OldActionVectorEntryPtr->LinkedTrainEntryPtr, RepeatNumber, IncrementalMinutes, IncrementalDigits, SignallerMaxSpeed, false, EventType))
    // false for SignallerControl
    {
        Utilities->CallLogPop(1721); // EventType not used here
        // if fails either a throw will have been sent in AddTrain or start position failed prob because of
        // another train, in which case a message will have been sent to the perf log, also might well clear later
        // when other train moves away
        return;
    }
    // Note data in 'this' now probably invalid as there has been a new addition to the TrainVector, so the train is likely to have a new address, hence make no more changes for the current train
    // see mods in UpdateTrain for v1.3.2
    TrainController->TrainAdded = true;

    TTrainOperatingData &TTOD = OldActionVectorEntryPtr->LinkedTrainEntryPtr->TrainOperatingDataVector.at(RepeatNumber); // this is for the newly created train

    TTOD.TrainID = TrainController->TrainVector.back().TrainID;
    TTOD.RunningEntry = Running;
    Utilities->CallLogPop(998);
}

// ---------------------------------------------------------------------------

void TTrain::RearTrainSplit(int Caller)
{
/*
      Split logic is:-  at least one of 4 final train positions must overlap with one of original train positions, & final 4 positions
      will maximise the number at the location.  Note that this function isn't sophisticated enough to account for trains already at the
      location in determining the 4 positions, and will give a failure message if a train obstructs any of the 4 positions.  In these
      circumstances the other train will need to be moved sufficiently away to release all 4 positions, then the train will split.
*/
    TrainController->LogEvent("" + AnsiString(Caller) + ",RearTrainSplit" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RearTrainSplit" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can split when power restored
    {
        if(!ZeroPowerNoRearSplitMessage)
        {
            TrainController->StopTTClockMessage(83, HeadCode + ": A train without power can't split");
        }
        ZeroPowerNoRearSplitMessage = true;
        Utilities->CallLogPop(2138);
        return;
    }
    AnsiString LocationName = Track->TrackElementAt(587, LeadElement).ActiveTrackElementName;

    if(LocationName == "")
    {
        LocationName = Track->TrackElementAt(838, MidElement).ActiveTrackElementName;
    }
    int FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos, SecondNamedLinkedElementPos;
    int RearTrainRearPosition, RearTrainFrontPosition, RearTrainExitPos;
    int FrontTrainRearPosition, FrontTrainFrontPosition, FrontTrainExitPos;
    AnsiString OtherHeadCode = TrainController->GetRepeatHeadCode(2, ActionVectorEntryPtr->OtherHeadCode, RepeatNumber, IncrementalDigits);

    // determine all positions & exits
    if(LocationName != "")
    {
        // if message given only call at ~5 sec intervals
        if(!(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailLocTooShort) || (UpdateCounter == 0))
        {
            FirstNamedElementPos = LeadElement;
            if(!Track->ThisNamedLocationLongEnoughForSplit(2, LocationName, FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos,
                                                           SecondNamedLinkedElementPos))
            {
                FirstNamedElementPos = MidElement;
                if(!Track->ThisNamedLocationLongEnoughForSplit(3, LocationName, FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos,
                                                               SecondNamedLinkedElementPos))
                {
                    if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailLocTooShort)
                    {
                        TrainController->LogActionError(9, HeadCode, "", FailLocTooShort, LocationName);
                        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailLocTooShort;
                    }
                    Utilities->CallLogPop(1013);
                    return;
                }
            }
            else
            {
                // if first is possible then check if all 4 positions at location, and if not try the second
                int LeadPosA = FirstNamedElementPos;
                int LeadPosB = FirstNamedLinkedElementPos;
                int LeadPosC = SecondNamedElementPos;
                int LeadPosD = SecondNamedLinkedElementPos;
                // count number of positions that are at the location
                int LeadNumAtLoc = 0;
                if(Track->TrackElementAt(767, LeadPosA).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(768, LeadPosB).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(769, LeadPosC).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(Track->TrackElementAt(770, LeadPosD).ActiveTrackElementName == LocationName)
                {
                    LeadNumAtLoc++;
                }
                if(LeadNumAtLoc < 4)
                {
                    FirstNamedElementPos = MidElement;
                    if(!Track->ThisNamedLocationLongEnoughForSplit(5, LocationName, FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos,
                                                                   SecondNamedLinkedElementPos)) // restore originals
                    {
                        FirstNamedElementPos = LeadPosA;
                        FirstNamedLinkedElementPos = LeadPosB;
                        SecondNamedElementPos = LeadPosC;
                        SecondNamedLinkedElementPos = LeadPosD;
                    }
                    else // count number at location
                    {
                        int MidNumAtLoc = 0;
                        if(Track->TrackElementAt(771, FirstNamedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(772, FirstNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(773, FirstNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(Track->TrackElementAt(774, SecondNamedLinkedElementPos).ActiveTrackElementName == LocationName)
                        {
                            MidNumAtLoc++;
                        }
                        if(LeadNumAtLoc > MidNumAtLoc)
                        // change back, else keep new values
                        {
                            FirstNamedElementPos = LeadPosA;
                            FirstNamedLinkedElementPos = LeadPosB;
                            SecondNamedElementPos = LeadPosC;
                            SecondNamedLinkedElementPos = LeadPosD;
                        }
                    }
                }
            }
        }
        else
        {
            Utilities->CallLogPop(1792);
            return;
        }
    }
    else
    {
        throw Exception("Error - LocationName not set in RearTrainSplit");
    }
    // set front & rear train parameters
    // need RearTrainRearPosition, RearTrainFrontPosition, RearTrainExitPos, FrontTrainRearPosition, FrontTrainFrontPosition & FrontTrainExitPos;
    // have LeadElement & MidElement of train defining its direction, & one or other on FirstNamedElementPos
    // have FirstNamedElementPos, SecondNamedElementPos, FirstNamedLinkedElementPos & SecondNamedLinkedElementPos from ThisNamedLocationLongEnoughForSplit.
    if(LeadElement == FirstNamedElementPos)
    {
        if(MidElement == SecondNamedElementPos)
        {
            FrontTrainFrontPosition = FirstNamedLinkedElementPos;
            FrontTrainRearPosition = FirstNamedElementPos;
            RearTrainFrontPosition = SecondNamedElementPos;
            RearTrainRearPosition = SecondNamedLinkedElementPos;
        }
        else // MidElement must == FirstNamedLinkedElementPos
        {
            FrontTrainFrontPosition = SecondNamedLinkedElementPos;
            FrontTrainRearPosition = SecondNamedElementPos;
            RearTrainFrontPosition = FirstNamedElementPos;
            RearTrainRearPosition = FirstNamedLinkedElementPos;
        }
    }
    else // MidElement == FirstNamedElementPos
    {
        if(LeadElement == SecondNamedElementPos)
        {
            FrontTrainFrontPosition = SecondNamedLinkedElementPos;
            FrontTrainRearPosition = SecondNamedElementPos;
            RearTrainFrontPosition = FirstNamedElementPos;
            RearTrainRearPosition = FirstNamedLinkedElementPos;
        }
        else // LeadElement must == FirstNamedLinkedElementPos
        {
            FrontTrainFrontPosition = FirstNamedLinkedElementPos;
            FrontTrainRearPosition = FirstNamedElementPos;
            RearTrainFrontPosition = SecondNamedElementPos;
            RearTrainRearPosition = SecondNamedLinkedElementPos;
        }
    }
    RearTrainExitPos = -1;
    for(int x = 0; x < 4; x++)
    {
        if(Track->TrackElementAt(588, RearTrainRearPosition).Conn[x] == RearTrainFrontPosition)
        {
            RearTrainExitPos = x;
            break;
        }
    }
    if(RearTrainExitPos == -1)
    {
        throw Exception("Error - RearTrainRearPosition not linked to RearTrainFrontPosition in RearTrainSplit");
    }
    FrontTrainExitPos = -1;
    for(int x = 0; x < 4; x++)
    {
        if(Track->TrackElementAt(589, FrontTrainRearPosition).Conn[x] == FrontTrainFrontPosition)
        {
            FrontTrainExitPos = x;
            break;
        }
    }
    if(FrontTrainExitPos == -1)
    {
        throw Exception("Error - FrontTrainRearPosition not linked to FrontTrainFrontPosition in RearTrainSplit");
    }
    // check no train (apart from self) on any of the 4 elements & fail if so
    int TrainIDOnRearOfRearTrain, TrainIDOnFrontOfRearTrain, TrainIDOnRearOfFrontTrain, TrainIDOnFrontOfFrontTrain;
    TTrackElement RearMostElement = Track->TrackElementAt(590, RearTrainRearPosition);

    if((RearMostElement.TrackType == Bridge) && (RearTrainExitPos > 1))
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
    }
    else if((RearMostElement.TrackType == Bridge) && (RearTrainExitPos < 2))
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
    }
    else
    {
        TrainIDOnRearOfRearTrain = RearMostElement.TrainIDOnElement;
    }
    // RearTrainFrontPosition = RearMostElement.Conn[RearTrainExitPos];
    TrainIDOnFrontOfRearTrain = Track->TrackElementAt(591, RearTrainFrontPosition).TrainIDOnElement;
    // can't be a bridge
    TrainIDOnRearOfFrontTrain = Track->TrackElementAt(592, FrontTrainRearPosition).TrainIDOnElement;
    // can't be a bridge
    // FrontTrainFrontPosition = Track->TrackElementAt(593,FrontTrainRearPosition).Conn[FrontTrainExitPos];
    TTrackElement FrontMostElement = Track->TrackElementAt(594, FrontTrainFrontPosition);

    if((FrontMostElement.TrackType == Bridge) && (FrontTrainExitPos > 1))
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
    }
    else if((FrontMostElement.TrackType == Bridge) && (FrontTrainExitPos < 2))
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
    }
    else
    {
        TrainIDOnFrontOfFrontTrain = FrontMostElement.TrainIDOnElement;
    }
    if(((TrainIDOnRearOfRearTrain > -1) && (TrainIDOnRearOfRearTrain != TrainID)) || ((TrainIDOnFrontOfRearTrain > -1) && (TrainIDOnFrontOfRearTrain != TrainID)
                                                                                      ) || ((TrainIDOnRearOfFrontTrain > -1) && (TrainIDOnRearOfFrontTrain != TrainID)) ||
       ((TrainIDOnFrontOfFrontTrain > -1) && (TrainIDOnFrontOfFrontTrain != TrainID)))
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != FailSplitDueToOtherTrain)
        {
            TrainController->LogActionError(11, HeadCode, "", FailSplitDueToOtherTrain, LocationName);
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = FailSplitDueToOtherTrain;
        }
        // don't advance ActionVectorEntryPtr as need to keep trying, other train may move off eventually
        Utilities->CallLogPop(1014);
        return;
    }
    if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported == FailSplitDueToOtherTrain)
    {
        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
    }
    // reposition existing front train, need to do this first for 2 reasons - 1) will likely be in the way of the new rear train, and 2)
    // the new train will likely cause a reallocation of the TrainVector, and if so the reference to the existing train will be invalidated.
    // Hence deal with existing train while it references a valid entry in the vector, but retain the Old ActionVectorEntryPtr in a separate
    // variable as it is needed for setting up the new train
    TActionVectorEntry *OldActionVectorEntryPtr = ActionVectorEntryPtr;

    UnplotTrain(1);
    StartSpeed = 0;
    RearStartElement = FrontTrainRearPosition;
    RearStartExitPos = FrontTrainExitPos;
    StoppedAtLocation = true;
    if((PowerAtRail < 1) && EntrySpeed < 1) // added at v2.4.0
    {
        StoppedWithoutPower = true;
    }
    PlotStartPosition(4);
    PlotTrainWithNewBackgroundColour(15, clStationStopBackground, Display);
    LogAction(10, HeadCode, OtherHeadCode, RearSplit, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    Mass = Mass / 2;
    // TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).Mass = Mass;
//    MaxBrakeRate = MaxBrakeRate / 2;  this was wrong - want brake rate to stay the same, brake force is halved but that not a train parameter
//    and when needed it's calculated from rate & mass - changed at v2.15.0
    // TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).MaxBrakeRate = MaxBrakeRate;
    PowerAtRail = PowerAtRail / 2;
    // TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).PowerAtRail = PowerAtRail;
    AValue = sqrt(2 * PowerAtRail / Mass);
    // shouldn't change but include in case not set earlier

    // create new rear train
/*
      TrainController::AddTrain(int RearPosition, int FrontPosition, AnsiString HeadCode, int StartSpeed, int Mass,
      double MaxRunningSpeed, double MaxBrakeRate, double PowerAtRail, AnsiString ModeStr, TTrainDataEntry *TrainDataEntryPtr,
      int RepeatNumber, int IncrementalMinutes)
*/
    // same Mass, MaxBrakeRate & PowerAtRail as this train's halved values, and same MaxRunningSpeed as this train
    TActionEventType EventType = NoEvent;

    if(!TrainController->AddTrain(1, RearTrainRearPosition, RearTrainFrontPosition, OtherHeadCode, 0, Mass, MaxRunningSpeed, MaxBrakeRate, PowerAtRail,
                                  "Timetable", OldActionVectorEntryPtr->LinkedTrainEntryPtr, RepeatNumber, IncrementalMinutes, IncrementalDigits, SignallerMaxSpeed, false, EventType))
    // false for SignallerControl
    {
        Utilities->CallLogPop(1722); // EventType not used here
        // if fails either a throw will have been sent in AddTrain or start position failed prob because of
        // another train, in which case a message will have been sent to the perf log, also might well clear later
        // when other train moves away
        return;
    }
    // Note data in 'this' now probably invalid as there has been a new addition to the TrainVector, so the train is likely to have a new address, hence make no more changes for the current train
    // see mods in UpdateTrain for v1.3.2
    TrainController->TrainAdded = true;
    TTrainOperatingData &TTOD = OldActionVectorEntryPtr->LinkedTrainEntryPtr->TrainOperatingDataVector.at(RepeatNumber); // this is for the newly created train

    TTOD.TrainID = TrainController->TrainVector.back().TrainID;
    TTOD.RunningEntry = Running;
    Utilities->CallLogPop(1015);
}

// ---------------------------------------------------------------------------

void TTrain::FinishJoin(int Caller)
{
    if(FinishJoinLogSent == false)
    {
        TrainController->LogEvent("" + AnsiString(Caller) + ",FinishJoin" + "," + HeadCode);
        FinishJoinLogSent = true; // so don't keep logging this event
        // don't need to  reset it to false after the event as the train is deleted
    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",FinishJoin" + "," + HeadCode);
    if(TrainFailed)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can join when repaired) Can FinishJoin if zero power & not failed, as for empty stock
    {
        if(!FailedTrainNoFinishJoinMessage)
        {
            TrainController->StopTTClockMessage(84, HeadCode + ": A failed train can't join another under timetable control");
        }
        FailedTrainNoFinishJoinMessage = true;
        Utilities->CallLogPop(2139);
        return;
    }
    if(TrainGone)
    // this means that the train has already joined the other & is awaiting deletion by TrainController
    // without this the 'waiting' message can be given since the other train's ActionVectorEntryPtr has moved
    // on from jbo & TrainToJoinIsAdjacent returns false
    {
        Utilities->CallLogPop(1035);
        return;
    }
    TTrain *TrainToJoin;
    AnsiString JBOHeadCode = TrainController->GetRepeatHeadCode(3, ActionVectorEntryPtr->OtherHeadCode, RepeatNumber, IncrementalDigits);

    if(!TrainToJoinIsAdjacent(0, TrainToJoin))
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != WaitingForJBO)
        {
            // PerfLogForm->PerformanceLog(2, TrainController->TTClockTime.FormatString("hh:nn:ss") + ": " + HeadCode + " waiting to join " + JBOHeadCode + " at " + ActionVectorEntryPtr->LocationName);
            TrainController->LogActionError(51, HeadCode, JBOHeadCode, WaitingForJBO, ActionVectorEntryPtr->LocationName);
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = WaitingForJBO;
        }
        Utilities->CallLogPop(1030);
        return; // keep this here in case need to add code before final return
    }
    // no need to clear error report flag here, cleared in jbo function
    // No need to set TimetableFinished, done in jbo function
    Utilities->CallLogPop(1031);
}

// ---------------------------------------------------------------------------

void TTrain::JoinedBy(int Caller)
{
    if(TrainController->OpTimeToActUpdateCounter == 0)  //added at v2.13.2. Use OpTimeToActUpdateCounter for convenience so only issue the event log
                                                        //once every second rather than many times.  Can't use an event logged  flag because there may
                                                        //be several trains that are to be joined by others
    {
        TrainController->LogEvent("" + AnsiString(Caller) + "," + HeadCode + ",Waiting to be joined");
    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",JoinedBy" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can join when power restored)
    {
        if(!ZeroPowerNoJoinedByMessage)
        {
            TrainController->StopTTClockMessage(85, HeadCode + ": A train without power can't be joined by another under timetable control");
        }
        ZeroPowerNoJoinedByMessage = true;
        Utilities->CallLogPop(2140);
        return;
    }
    TTrain *TrainToBeJoinedBy;
    AnsiString FJOHeadCode = TrainController->GetRepeatHeadCode(4, ActionVectorEntryPtr->OtherHeadCode, RepeatNumber, IncrementalDigits);

    if(!TrainToBeJoinedByIsAdjacent(0, TrainToBeJoinedBy))
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != WaitingForFJO)
        {
            // PerfLogForm->PerformanceLog(3, TrainController->TTClockTime.FormatString("hh:nn:ss") + ": " + HeadCode + " waiting to be joined by " + FJOHeadCode + " at " + ActionVectorEntryPtr->LocationName);
            TrainController->LogActionError(52, HeadCode, FJOHeadCode, WaitingForFJO, ActionVectorEntryPtr->LocationName);
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = WaitingForFJO;
        }
        LastActionDelayFlag = true;
        // need to update LastActionTime if this train first to arrive as need 30s after
        // both adjacent before the join
        Utilities->CallLogPop(1032);
        return;
    }
    // here when other train is adjacent
    if(LastActionDelayFlag)
    {
        LastActionTime = TrainController->TTClockTime;
        // need to update this as need 30s after both adjacent before the join
        LastActionDelayFlag = false;
        Utilities->CallLogPop(1033);
        return;
    }
    // here when other train is adjacent & 30 secs elapsed since both adjacent

    // set new values for mass etc
    if(MaxRunningSpeed > TrainToBeJoinedBy->MaxRunningSpeed)
    {
        MaxRunningSpeed = TrainToBeJoinedBy->MaxRunningSpeed;
    }
    double OtherBrakeForce = TrainToBeJoinedBy->MaxBrakeRate * TrainToBeJoinedBy->Mass;
    double OwnBrakeForce = MaxBrakeRate * Mass;
    double CombinedBrakeRate = (OtherBrakeForce + OwnBrakeForce) / (TrainToBeJoinedBy->Mass + Mass);

    Mass += TrainToBeJoinedBy->Mass;
    MaxBrakeRate = CombinedBrakeRate;
    PowerAtRail += TrainToBeJoinedBy->PowerAtRail;
    AValue = sqrt(2 * PowerAtRail / Mass);

    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
    TrainToBeJoinedBy->TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
    TrainToBeJoinedBy->TimetableFinished = true;
    TrainToBeJoinedBy->TrainGone = true;
    TrainController->LogEvent("" + AnsiString(Caller) + "," + HeadCode + ",Joined By," + FJOHeadCode); //added at v2.13.2 to provide more information
    // this will cause other train to be deleted
    TrainToBeJoinedBy->JoinedOtherTrainFlag = true;
    LogAction(11, HeadCode, FJOHeadCode, JoinedByOther, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    Utilities->CallLogPop(1034);
}

// ---------------------------------------------------------------------------

void TTrain::ChangeTrainDirection(int Caller, bool NoLogFlag)
{
    TrainController->LogEvent("" + AnsiString(Caller) + ",ChangeTrainDirection" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ChangeTrainDirection" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can change direction when power restored)
    {
        if(!ZeroPowerNoCDTMessage)
        {
            TrainController->StopTTClockMessage(86, HeadCode + ": A train without power can't change direction under timetable control");
        }
        ZeroPowerNoCDTMessage = true;
        Utilities->CallLogPop(2141);
        return;
    }
    TColor TempColour = BackgroundColour;

    UnplotTrain(2);
    RearStartElement = LeadElement;
    RearStartExitPos = LeadEntryPos;
    StartSpeed = 0;
    StoppedAtLocation = true;
    PlotStartPosition(1);
    PlotTrainWithNewBackgroundColour(27, TempColour, Display);
    // plot same as was - should always be pale green
    if(!NoLogFlag)
    {
        LogAction(12, HeadCode, "", ChangeDirection, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
        ActionVectorEntryPtr++;
    }
    LastActionTime = TrainController->TTClockTime;

    //now erase a stub route if there is one, added at v2.5.1
    //first element of route is now immediately behind the train (i.e. next to MidElement)
    if(MidEntryPos >= 0)
    {
        TTrackElement MidTrackElement = Track->TrackElementAt(996, MidElement);
        int FirstRouteElementVecPos = MidTrackElement.Conn[MidEntryPos];
        int FirstRouteLinkPos = MidTrackElement.ConnLinkPos[MidEntryPos];
        int RouteNumber = -1;
        TAllRoutes::TRouteType RouteType = AllRoutes->GetRouteTypeAndNumber(34, FirstRouteElementVecPos, FirstRouteLinkPos, RouteNumber);
        if(RouteType == TAllRoutes::NotAutoSigsRoute)
        {
            TOneRoute &OR = AllRoutes->GetModifiableRouteAt(28, RouteNumber);
            int CorrectRouteID = OR.RouteID; //added at v2.13.0 as when last element removed & route removed from vector OR becomes the next route after the erased one and
                                      //elements can continue to be removed from that route
            TTrackElement TE = Track->TrackElementAt(997, FirstRouteElementVecPos);
            if((TE.TrackType != SignalPost) && (TE.TrackType != Continuation)) //all autosigs routes have signalpost or continuation at 0 so they are automatically excluded
            {
                bool FirstPass = true; //added at v2.8.0
                while((OR.PrefDirSize() > 0) && (OR.RouteID == CorrectRouteID)) //remove the route up to but not including the next facing signal, in case a pref dir route extends to another signal
                {  // && (OR.RouteID == RouteID) added at v2.13.0 to prevent another route having elements removed
                    TPrefDirElement PDE = OR.GetFixedPrefDirElementAt(247, 0); //these will change at each element removal because OR is a reference to the real route
                    int TVPos2 = PDE.GetTrackVectorPosition();
                    if(FirstPass && (TVPos2 != FirstRouteElementVecPos)) //route is not directed away from cdt train, could be a call-on for another train (added at v2.8.0)
                    {
                        break;
                    }
                    TTrackElement TE2 = Track->TrackElementAt(998, TVPos2);
                    if(Track->TrackElementAt(999, PDE.GetTrackVectorPosition()).Config[PDE.GetXLinkPos()] != Signal)
                    {
                        AllRoutes->RemoveRouteElement(22, TE2.HLoc, TE2.VLoc, PDE.GetELink());
                    }
                    else
                    {
                        break;
                    }
                    FirstPass = false;
                }
                AllRoutes->RebuildRailwayFlag = true;
                // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode, to replot without stub route
            }
        }
    }
    Utilities->CallLogPop(1012);
}

// ---------------------------------------------------------------------------

void TTrain::NewTrainService(int Caller, bool NoLogFlag) //, bool NoLogFlag added at v2.12.0 for new service tt skips
// change to new train, give new service message
//same RepeatNumber used for the new service
{ //Note that CumulativeDelayedRandMinsOneTrain carried forward from earlier train (parameter added at v2.13.0)
    TrainController->LogEvent("" + AnsiString(Caller) + ",NewTrainService" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",NewTrainService" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can form new service when power restored)
    {
        if(!ZeroPowerNoNewServiceMessage)
        {
            TrainController->StopTTClockMessage(87, HeadCode + ": A train without power can't form a new service");
        }
        ZeroPowerNoNewServiceMessage = true;
        Utilities->CallLogPop(2142);
        return;
    }
    AnsiString NewHeadCode = TrainController->GetRepeatHeadCode(5, ActionVectorEntryPtr->OtherHeadCode, RepeatNumber, IncrementalDigits);

    if(!NoLogFlag)
    {
        LogAction(13, HeadCode, NewHeadCode, NewService, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    }
    UnplotTrain(3);
    RearStartElement = MidElement;
    RearStartExitPos = MidExitPos;
    StartSpeed = 0;
    TrainDataEntryPtr = ActionVectorEntryPtr->LinkedTrainEntryPtr;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).TrainID = TrainID;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).RunningEntry = Running;
    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
    HeadCode = NewHeadCode;
    StoppedAtLocation = true;
    PlotStartPosition(5);
    PlotTrainWithNewBackgroundColour(21, clStationStopBackground, Display);
    // pale green
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    TerminatedMessageSent = false;
    Utilities->CallLogPop(1022);
}

// ---------------------------------------------------------------------------

void TTrain::RemainHere(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + AnsiString(Caller) + ",RemainHere" + "," + HeadCode);
    if(RemainHereLogNotSent) // to prevent repeated logs
    {
        TrainController->LogEvent(Utilities->TimeStamp() + AnsiString(Caller) + ",RemainHere" + "," + HeadCode);
        RemainHereLogNotSent = false;
    }
    if(!TerminatedMessageSent)
    {
        PerfLogForm->PerformanceLog(5, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + HeadCode + " terminated at " +
                                ActionVectorEntryPtr->LocationName);
        LastActionTime = TrainController->TTClockTime;
        TerminatedMessageSent = true;
    }
    TimetableFinished = true;
    Utilities->CallLogPop(1023);
}

// ---------------------------------------------------------------------------

void TTrain::SendMissedActionLogs(int Caller, int IncNum, TActionVectorEntry *Ptr)
/*
          Enter with pointer at next expected action, and IncNum the number by which have to increase the pointer
          to reach the action that is valid for the train's current position.  i.e. IncNum error messages to be sent
          except where an action is a departure, starting at the current value for the pointer
          If IncNum is -1, then send messages for all remaining actions, including Fer if present
          If IncNum is -2, then send messages for all remaining actions, except Fer if present
*/{
    if((Ptr->Command == "Snt") && Ptr->SignallerControl)
    {
        return; // if remove train that starts under signaller control no messages needed

    }
    TrainController->LogEvent("" + AnsiString(Caller) + ",SendMissedActionLogs," + AnsiString(IncNum) + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SendMissedActionLogs," + AnsiString(IncNum) + "," + HeadCode);
    if(IncNum > 0)
    {
        for(int x = 0; x < IncNum; x++)
        {
            if(x > 0)
            {
                Ptr++;
            }
            // arrival - no need to test for termination as this section only covers missed actions up to the
            // arrival point - may terminate later but that not missed
            if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime > TDateTime(-1)))
            {
                TrainController->LogActionError(12, HeadCode, "", FailMissedArrival, Ptr->LocationName);
            }
            // arrival & departure
            if(Ptr->FormatType == TimeTimeLoc)
            {
                TrainController->LogActionError(13, HeadCode, "", FailMissedArrival, Ptr->LocationName);
            }
            // departure
            else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
            {
                continue; // skip TimeLoc departures, message given for arrivals
            }
            // pass
            else if(Ptr->FormatType == PassTime)
            {
                TrainController->LogActionError(36, HeadCode, "", FailMissedPass, Ptr->LocationName);
            }
            // split
            else if((Ptr->Command == "fsp") || (Ptr->Command == "rsp"))
            {
                TrainController->LogActionError(14, HeadCode, "", FailMissedSplit, Ptr->LocationName);
            }
            // jbo
            else if(Ptr->Command == "jbo")
            {
                TrainController->LogActionError(15, HeadCode, "", FailMissedJBO, Ptr->LocationName);
            }
            // Errors - have reached a station stop point (before a cdt) during Train->Update() so intervening actions can't
            // be starts, finishes or cdt
            else if((Ptr->Command == "Fns") || (Ptr->Command == "Frh") || (Ptr->Command == "Fer") || (Ptr->Command == "Fjo") || (Ptr->Command == "Snt") ||
                    (Ptr->Command == "Sfs") || (Ptr->Command == "Snt-sh") || (Ptr->Command == "Sns") || (Ptr->Command == "Sns-sh") || (Ptr->Command == "Sns-fsh") ||
                    (Ptr->Command == "cdt") || (Ptr->Command == "Frh-sh") || (Ptr->Command == "Fns-sh") || (Ptr->Command == "F-nshs") ||
                    (Ptr->FormatType == Repeat))
            {
                throw Exception("Error - illegal command in SendMissedActionLogs for IncNum = " + AnsiString(IncNum) + ", and command = " + Ptr->Command);
            }
        }
    }
    else
    {
        bool IncludeFER = false;
        if(IncNum == -1)
        {
            IncludeFER = true;
        }
        while(true) // finish commands & repeats break out of loop
        {
            // Fer & excluded - send normal exit log to give minutes late or early - no, have already sent an unexpected exit message
            if(!IncludeFER && (Ptr->Command == "Fer"))
            {
                break;
            }
            // Fer & included
            else if(IncludeFER && (Ptr->Command == "Fer"))
            {
                TrainController->LogActionError(19, HeadCode, "", FailMissedExitRailway, "");
                break;
            }
            // Repeat
            else if(Ptr->FormatType == Repeat)
            {
                break;
            }
            // Fjo
            else if(Ptr->Command == "Fjo")
            {
                TrainController->LogActionError(16, HeadCode, "", FailMissedJoinOther, Ptr->LocationName);
                break;
            }
            // Frh
            else if(Ptr->Command == "Frh")
            {
                if(!TerminatedMessageSent)
                {
                    TrainController->LogActionError(17, HeadCode, "", FailMissedTerminate, Ptr->LocationName);
                    TerminatedMessageSent = true;
                }
                break;
            }
            // Frh-sh
            else if(Ptr->Command == "Frh-sh")
            {
                if(!TerminatedMessageSent)
                {
                    TrainController->LogActionError(53, HeadCode, "", FailMissedNewService, Ptr->LocationName);
                    TerminatedMessageSent = true;
                }
                break;
            }
            // Fns, F-nshs, Fns-sh
            else if((Ptr->Command == "Fns") || (Ptr->Command == "F-nshs") || (Ptr->Command == "Fns-sh"))
            {
                TrainController->LogActionError(18, HeadCode, "", FailMissedNewService, Ptr->LocationName);
                break;
            }
            // end of breakout actions
            // arrival
            if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime > TDateTime(-1)))
            {
                if(IsTrainTerminating(1))
                {
                    TrainController->LogActionError(20, HeadCode, "", FailMissedTerminate, Ptr->LocationName);
                    TerminatedMessageSent = true;
                }
                else
                {
                    TrainController->LogActionError(21, HeadCode, "", FailMissedArrival, Ptr->LocationName);
                }
            }
            // arrival & departure
            else if(Ptr->FormatType == TimeTimeLoc)
            {
                TrainController->LogActionError(22, HeadCode, "", FailMissedArrival, Ptr->LocationName);
            }
            // departure
            else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
            {
                Ptr++;
                continue; // skip TimeLoc departures, message given for arrivals
            }
            // pass
            else if(Ptr->FormatType == PassTime)
            {
                TrainController->LogActionError(37, HeadCode, "", FailMissedPass, Ptr->LocationName);
            }
            // split
            else if((Ptr->Command == "fsp") || (Ptr->Command == "rsp"))
            {
                TrainController->LogActionError(23, HeadCode, "", FailMissedSplit, Ptr->LocationName);
            }
            // jbo
            else if(Ptr->Command == "jbo")
            {
                TrainController->LogActionError(24, HeadCode, "", FailMissedJBO, Ptr->LocationName);
            }
            // cdt
            else if(Ptr->Command == "cdt")
            {
//                TrainController->LogActionError(25, HeadCode, "", FailMissedChangeDirection, Ptr->LocationName); //commented out at v2.12.0 as cdts not counted as missed events
            }
            // Errors
            else if((Ptr->Command == "Snt-sh") || (Ptr->Command == "Sfs") || (Ptr->Command == "Sns") || (Ptr->Command == "Sns-sh") ||
                    (Ptr->Command == "Sns-fsh") || ((Ptr->Command == "Snt") && !Ptr->SignallerControl))
            {
                throw Exception("Error - illegal command in SendMissedActionLogs for IncNum = " + AnsiString(IncNum) + ", and command = " + Ptr->Command);
            }
            Ptr++;
        }
        TimetableFinished = true;
    }
    Utilities->CallLogPop(1021);
}

// ---------------------------------------------------------------------------

bool TTrain::TrainToJoinIsAdjacent(int Caller, TTrain* &TrainToJoin)
// ensure same repeatnumber
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainToJoinIsAdjacent" + "," + HeadCode);
    TTrainDataEntry *TrainToJoinTDEntry = ActionVectorEntryPtr->LinkedTrainEntryPtr;

    if(TrainToJoinTDEntry->TrainOperatingDataVector.at(RepeatNumber).RunningEntry != Running)
    {
        Utilities->CallLogPop(1024);
        return(false);
    }
    TrainToJoin = &(TrainController->TrainVectorAtIdent(33, TrainToJoinTDEntry->TrainOperatingDataVector.at(RepeatNumber).TrainID));
    if(TrainToJoin->StoppedAtLocation && (TrainToJoin->TrainMode == Timetable) && (TrainToJoin->ActionVectorEntryPtr->Command == "jbo"))
    {
        if((Track->TrackElementAt(610, LeadElement).Conn[LeadExitPos] == TrainToJoin->LeadElement) || (Track->TrackElementAt(611,
                                                                                                                             LeadElement).Conn[LeadExitPos] == TrainToJoin->MidElement) || (Track->TrackElementAt(612, MidElement).Conn[MidEntryPos] == TrainToJoin->LeadElement)
           || (Track->TrackElementAt(613, MidElement).Conn[MidEntryPos] == TrainToJoin->MidElement))
        {
            Utilities->CallLogPop(1025);
            return(true);
        }
    }
    Utilities->CallLogPop(1026);
    return(false);
}

// ---------------------------------------------------------------------------

bool TTrain::TrainToBeJoinedByIsAdjacent(int Caller, TTrain* &TrainToBeJoinedBy)
// ensure same repeatnumber
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainToBeJoinedByIsAdjacent" + "," + HeadCode);
    TTrainDataEntry *TrainToBeJoinedByTDEntry = ActionVectorEntryPtr->LinkedTrainEntryPtr;

    if(TrainToBeJoinedByTDEntry->TrainOperatingDataVector.at(RepeatNumber).RunningEntry != Running)
    {
        Utilities->CallLogPop(1027);
        return(false);
    }
    TrainToBeJoinedBy = &(TrainController->TrainVectorAtIdent(15, TrainToBeJoinedByTDEntry->TrainOperatingDataVector.at(RepeatNumber).TrainID));
    if(TrainToBeJoinedBy->StoppedAtLocation && (TrainToBeJoinedBy->TrainMode == Timetable) && (TrainToBeJoinedBy->ActionVectorEntryPtr->Command == "Fjo"))
    {
        if((Track->TrackElementAt(614, LeadElement).Conn[LeadExitPos] == TrainToBeJoinedBy->LeadElement) || (Track->TrackElementAt(615,
                                                                                                                                   LeadElement).Conn[LeadExitPos] == TrainToBeJoinedBy->MidElement) || (Track->TrackElementAt(616,
                                                                                                                                                                                                                              MidElement).Conn[MidEntryPos] == TrainToBeJoinedBy->LeadElement) || (Track->TrackElementAt(617,
                                                                                                                                                                                                                                                                                                                         MidElement).Conn[MidEntryPos] == TrainToBeJoinedBy->MidElement))
        {
            Utilities->CallLogPop(1028);
            return(true);
        }
    }
    Utilities->CallLogPop(1029);
    return(false);
}

// ---------------------------------------------------------------------------

void TTrain::NewShuttleFromNonRepeatService(int Caller, bool NoLogFlag) //bool NoLogFlag added at v2.12.0 for new service TT skips)
{  //same RepeatNumber (i.e. 0) used for the new shuttle
//Note that CumulativeDelayedRandMinsOneTrain carried forward from earlier train (parameter added at v2.13.0)
    TrainController->LogEvent("" + AnsiString(Caller) + ",NewShuttleFromNonRepeatService" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",NewShuttleFromNonRepeatService" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can for new service when power restored)
    {
        if(!ZeroPowerNoNewShuttleFromNonRepeatMessage)
        {
            TrainController->StopTTClockMessage(88, HeadCode + ": A train without power can't form a new service");
        }
        ZeroPowerNoNewShuttleFromNonRepeatMessage = true;
        Utilities->CallLogPop(2143);
        return;
    }
    AnsiString NewHeadCode = ActionVectorEntryPtr->NonRepeatingShuttleLinkHeadCode;

    if(!NoLogFlag)
    {
        LogAction(15, HeadCode, NewHeadCode, NewService, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    }
    UnplotTrain(4);
    RearStartElement = MidElement;
    RearStartExitPos = MidExitPos;
    StartSpeed = 0;
    TrainDataEntryPtr = ActionVectorEntryPtr->LinkedTrainEntryPtr;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).TrainID = TrainID;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).RunningEntry = Running;
    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
    HeadCode = NewHeadCode;
    IncrementalMinutes = TrainDataEntryPtr->ActionVector.back().RearStartOrRepeatMins;
    IncrementalDigits = TrainDataEntryPtr->ActionVector.back().FrontStartOrRepeatDigits;
    StoppedAtLocation = true;
    PlotStartPosition(6);
    PlotTrainWithNewBackgroundColour(22, clStationStopBackground, Display);
    // pale green
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    TerminatedMessageSent = false;
    Utilities->CallLogPop(1078);
}

// ---------------------------------------------------------------------------

void TTrain::RepeatShuttleOrRemainHere(int Caller, bool NoLogFlag) //bool NoLogFlag added at v2.12.0 for new service TT skips)
// need to check whether all repeats finished or not
{  //Note that CumulativeDelayedRandMinsOneTrain carried forward from earlier train (parameter added at v2.13.0)
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RepeatShuttleOrRemainHere" + "," + HeadCode);
    if(RemainHereLogNotSent) // to prevent repeated logs
    {
        TrainController->LogEvent("" + AnsiString(Caller) + ",RepeatShuttleOrRemainHere" + "," + HeadCode);
        RemainHereLogNotSent = false;
    }
    if(RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))
    // finished all repeats
    {
        if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != ShuttleFinishedRemainingHere)
        {   //no need to suppress this LogAction because BecomeNewService won't be available in this case
            LogAction(26, HeadCode, "", Terminate, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
            TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = ShuttleFinishedRemainingHere;
            TerminatedMessageSent = true;
            // no need to clear message as no more actions
        }
        TimetableFinished = true;
        Utilities->CallLogPop(1080);
        return;
    }
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can for new service when power restored)
    {
        if(!ZeroPowerNoRepeatShuttleMessage)
        {
            TrainController->StopTTClockMessage(89, HeadCode + ": A train without power can't form a new service");
        }
        ZeroPowerNoRepeatShuttleMessage = true;
        Utilities->CallLogPop(2144);
        return;
    }
    int TempRepeatNumber = RepeatNumber + 1;
    // need the next repeat value in order to obtain a correct NewHeadCode, but don't increase it
    // until after LogAction or the wrong time will be used
    AnsiString NewHeadCode = TrainController->GetRepeatHeadCode(6, ActionVectorEntryPtr->OtherHeadCode, TempRepeatNumber, IncrementalDigits);

    if(!NoLogFlag)
    {
        LogAction(16, HeadCode, NewHeadCode, NewService, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    }
    RepeatNumber++;
    UnplotTrain(5);
    RearStartElement = MidElement;
    RearStartExitPos = MidExitPos;
    StartSpeed = 0;
    TrainDataEntryPtr = ActionVectorEntryPtr->LinkedTrainEntryPtr;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).TrainID = TrainID;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).RunningEntry = Running;
    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
    HeadCode = NewHeadCode;
    StoppedAtLocation = true;
    PlotStartPosition(7);
    PlotTrainWithNewBackgroundColour(23, clStationStopBackground, Display);
    // pale green
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    TerminatedMessageSent = false;
    Utilities->CallLogPop(1079);
}

// ---------------------------------------------------------------------------

void TTrain::RepeatShuttleOrNewNonRepeatService(int Caller, bool NoLogFlag) //bool NoLogFlag added at v2.12.0 for new service TT skips
{   //Note that CumulativeDelayedRandMinsOneTrain carried forward from earlier train (parameter added at v2.13.0)
    TrainController->LogEvent("" + AnsiString(Caller) + ",RepeatShuttleOrNewNonRepeatService" + "," + HeadCode);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RepeatShuttleOrNewNonRepeatService" + "," + HeadCode);
    if(PowerAtRail < 1)
    // new at v2.4.0 (ActionVectorEntryPtr not incremented so can for new service when power restored)
    {
        if(!ZeroPowerNoRepeatShuttleOrNewServiceMessage)
        {
            TrainController->StopTTClockMessage(90, HeadCode + ": A train without power can't form a new service");
        }
        ZeroPowerNoRepeatShuttleOrNewServiceMessage = true;
        Utilities->CallLogPop(2145);
        return;
    }
    if(RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))
    // finished all repeats
    {
        AnsiString NewHeadCode = ActionVectorEntryPtr->NonRepeatingShuttleLinkHeadCode;
        if(!NoLogFlag)
        {
            LogAction(17, HeadCode, NewHeadCode, NewService, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
        }
        RepeatNumber = 0;
        UnplotTrain(6);
        RearStartElement = MidElement;
        RearStartExitPos = MidExitPos;
        StartSpeed = 0;
        TrainDataEntryPtr = ActionVectorEntryPtr->NonRepeatingShuttleLinkEntryPtr;
        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).TrainID = TrainID; // but note that RepeatNumber = 0
        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).RunningEntry = Running; // but note that RepeatNumber = 0
        ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
        HeadCode = NewHeadCode;
        StoppedAtLocation = true;
        PlotStartPosition(9);
        PlotTrainWithNewBackgroundColour(24, clStationStopBackground, Display); // pale green
        ActionVectorEntryPtr++;
        LastActionTime = TrainController->TTClockTime;
        TerminatedMessageSent = false;
        Utilities->CallLogPop(1081);
        return;
    }
    int TempRepeatNumber = RepeatNumber + 1;
    // need the next repeat value in order to obtain a correct NewHeadCode, but don't increase it
    // until after LogAction or the wrong time will be used
    AnsiString NewHeadCode = TrainController->GetRepeatHeadCode(7, ActionVectorEntryPtr->OtherHeadCode, TempRepeatNumber, IncrementalDigits);

    if(!NoLogFlag)
    {
        LogAction(18, HeadCode, NewHeadCode, NewService, ActionVectorEntryPtr->LocationName, ActionVectorEntryPtr->EventTime, ActionVectorEntryPtr->Warning);
    }
    RepeatNumber++;
    UnplotTrain(7);
    RearStartElement = MidElement;
    RearStartExitPos = MidExitPos;
    StartSpeed = 0;
    TrainDataEntryPtr = ActionVectorEntryPtr->LinkedTrainEntryPtr;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).TrainID = TrainID;
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).RunningEntry = Running;
    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
    HeadCode = NewHeadCode;
    StoppedAtLocation = true;
    PlotStartPosition(8);
    PlotTrainWithNewBackgroundColour(25, clStationStopBackground, Display);
    // pale green
    ActionVectorEntryPtr++;
    LastActionTime = TrainController->TTClockTime;
    TerminatedMessageSent = false;
    Utilities->CallLogPop(1082);
}

// ---------------------------------------------------------------------------

bool TTrain::IsTrainTerminating(int Caller)
{
    // Search ActionVector from the position after the entry value for Ptr to the end, and return true if find a Finish
    // entry before Fer or TimeLoc.  No point checking for TimeTimeLoc since at a stop location now so a later TimeTimeLoc
    // must be preceded by a TimeLoc departure
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsTrainTerminating" + "," + HeadCode);
    for(unsigned int x = 1; x < TrainDataEntryPtr->ActionVector.size(); x++)
    {
        if((ActionVectorEntryPtr + x) < &TrainDataEntryPtr->ActionVector.back())
        {
            if(((ActionVectorEntryPtr + x)->Command == "Fer") || ((ActionVectorEntryPtr + x)->FormatType == TimeLoc))
            {
                Utilities->CallLogPop(1083);
                return(false);
            }
            else if((ActionVectorEntryPtr + x)->SequenceType == FinishSequence)
            {
                Utilities->CallLogPop(1084);
                return(true);
            }
        }
    }
    Utilities->CallLogPop(1085);
    return(false);
}

// ---------------------------------------------------------------------------

bool TTrain::AbleToMove(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",AbleToMove" + "," + HeadCode);
    bool Able = true;

    if(Crashed || Derailed || StoppedAtBuffers || StoppedAtSignal || StoppedWithoutPower) // StoppedWithoutPower added at v2.4.0
    {
        // StoppedForTrainInFront removed as tested below
        Utilities->CallLogPop(2146); // added v2.4.0
        return(false); // added v2.4.0
    }
    if(LeadElement > -1)
    {
        if(Track->TrackElementAt(801, LeadElement).TrackType == Buffers)  //moved up here from 'else' below at v2.12.0
        {
            StoppedForTrainInFront = false;
            // don't set StoppedAtBuffers as (presumably) StoppedAtLocation & leave it at that
            Utilities->CallLogPop(2456);
            return(false);
        }
        int FrontPos = Track->TrackElementAt(678, LeadElement).Conn[LeadExitPos];
        int FrontEntryPos = Track->TrackElementAt(679, LeadElement).ConnLinkPos[LeadExitPos];
        if((FrontPos > -1) && (TrainMode == Signaller) && StoppedForTrainInFront) //check if train in front still there
        {
            TTrackElement TrackElement = Track->TrackElementAt(680, FrontPos);
            if((TrackElement.TrackType != Bridge) && (TrackElement.TrainIDOnElement == -1))
            {
                Able = true;
                StoppedForTrainInFront = false;
            }
            else if((TrackElement.TrackType == Bridge) && (FrontEntryPos < 2) && (TrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 == -1))
            {
                Able = true;
                StoppedForTrainInFront = false;
            }
            else if((TrackElement.TrackType == Bridge) && (FrontEntryPos > 1) && (TrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 == -1))
            {
                Able = true;
                StoppedForTrainInFront = false;
            }
            else
            {
                Able = false; //added at v2.12.0 as train still in front so don't want signaller popup options to move available
            }
        }
    }
    else // leaving at a continuation so keep going
    {
        Able = true;
        StoppedForTrainInFront = false;
    }
    Utilities->CallLogPop(1454);
    return(Able);
}

// ---------------------------------------------------------------------------

bool TTrain::AbleToMoveButForSignal(int Caller)
{
    // first check if a train immediately in front (may have moved there since this train stopped so StoppedForTrainInFront
    // won't be set; if there is a train then set StoppedForTrainInFront
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",AbleToMoveButForSignal" + "," + HeadCode);
    // addition below for v1.3.2 after Carwyn Thomas fault reported 24/05/15 - need to check if exiting at continuation (LeadElement == -1) as if so fails at VecPos = .....
    if(LeadElement == -1) // exiting at continuation
    {
        Utilities->CallLogPop(2045);
        return(false);
    }
    // end of addition
    int VecPos = Track->TrackElementAt(654, LeadElement).Conn[LeadExitPos];
    int NextEntryPos = Track->TrackElementAt(655, LeadElement).ConnLinkPos[LeadExitPos];

    if(Track->OtherTrainOnTrack(5, VecPos, NextEntryPos, TrainID))
    {
        StoppedForTrainInFront = true;
        Utilities->CallLogPop(1455);
        return(false);
    }
    else
    {
        Utilities->CallLogPop(1456);
        return(StoppedAtSignal && !(Crashed || Derailed || StoppedAtBuffers || StoppedForTrainInFront || StoppedWithoutPower));
        // StoppedWithoutPower added v2.4.0
    }
}

// ---------------------------------------------------------------------------

void TTrain::SignallerChangeTrainDirection(int Caller)
{
    // unplots & replots train, which checks for facing signal and sets StoppedAtSignal if req'd
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SignallerChangeTrainDirection" + "," + HeadCode);
    TColor TempColour = BackgroundColour;

    UnplotTrain(8);
    RearStartElement = LeadElement;
    RearStartExitPos = LeadEntryPos;
    StartSpeed = 0;
    PlotStartPosition(2);
    PlotTrainWithNewBackgroundColour(26, TempColour, Display);

    //now erase a stub route if there is one, added at v2.5.1
    //first element of route is now immediately behind the train (i.e. next to MidElement)
    if(MidEntryPos >= 0)
    {
        TTrackElement MidTrackElement = Track->TrackElementAt(1000, MidElement);
        int FirstRouteElementVecPos = MidTrackElement.Conn[MidEntryPos];
        int FirstRouteLinkPos = MidTrackElement.ConnLinkPos[MidEntryPos];
        int RouteNumber = -1;
        TAllRoutes::TRouteType RouteType = AllRoutes->GetRouteTypeAndNumber(35, FirstRouteElementVecPos, FirstRouteLinkPos, RouteNumber);
        if(RouteType == TAllRoutes::NotAutoSigsRoute)
        {
            TOneRoute &OR = AllRoutes->GetModifiableRouteAt(29, RouteNumber);
            int CorrectRouteID = OR.RouteID; //added at v2.13.0 as when last element removed & route removed from vector OR becomes the next route after the erased one and
                                      //elements can continue to be removed from that route
            TTrackElement TE = Track->TrackElementAt(1001, FirstRouteElementVecPos);
            if((TE.TrackType != SignalPost) && (TE.TrackType != Continuation)) //all autosigs routes have signalpost or continuation at 0 so they are automatically excluded
            {
                bool FirstPass = true; //added at v2.8.0
                while((OR.PrefDirSize() > 0) && (OR.RouteID == CorrectRouteID)) //remove the route up to but not including the next facing signal, in case a pref dir route extends to another signal
                {  // && (OR.RouteID == RouteID) added at v2.13.0 to prevent another route having elements removed
                    TPrefDirElement PDE = OR.GetFixedPrefDirElementAt(248, 0); //these will change at each element removal because OR is a reference to the real route
                    int TVPos2 = PDE.GetTrackVectorPosition();
                    if(FirstPass && (TVPos2 != FirstRouteElementVecPos)) //route is not directed away from cdt train, could be a call-on for another train (added at v2.8.0)
                    {
                        break;
                    }
                    TTrackElement TE2 = Track->TrackElementAt(1002, TVPos2);
                    if(Track->TrackElementAt(1003, PDE.GetTrackVectorPosition()).Config[PDE.GetXLinkPos()] != Signal)
                    {
                        AllRoutes->RemoveRouteElement(23, TE2.HLoc, TE2.VLoc, PDE.GetELink());
                    }
                    else
                    {
                        break;
                    }
                    FirstPass = false;
                }
                AllRoutes->RebuildRailwayFlag = true;
                // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode, to replot without stub route
            }
        }
    }
    Utilities->CallLogPop(1102);
}

// ---------------------------------------------------------------------------

AnsiString TTrain::FloatingLabelNextString(int Caller, TActionVectorEntry *Ptr)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString(Ptr - &TrainDataEntryPtr->ActionVector.front()) +
                                 ",FloatingLabelNextString" + "," + HeadCode);
    AnsiString RetStr = "", LocationName = "";
    //record action time - may be arrival, departure or event for use later (added at v2.13.2)
    TDateTime ActionTime = Ptr->ArrivalTime;
    if(ActionTime == TDateTime(-1))
    {
        ActionTime = Ptr->DepartureTime;
    }
    if(ActionTime == TDateTime(-1))
    {
        ActionTime = Ptr->EventTime;
    }
    //If ActionTime still TDateTime(-1) then the train has terminated and 'None...' will be returned
    //Now correct it for repeats
    if(ActionTime != TDateTime(-1))
    {
        ActionTime = GetTrainTime(64, ActionTime);
    }
    if(int(DelayedRandMins) > 0)
    {
        if((Ptr->Command != "") && (Ptr->Command[1] == 'S'))
        {
            throw Exception("Error - start entry in FloatingLabelNextString");
        }
        if(Ptr->FormatType == TimeTimeLoc)
        {
            if(TrainMode == Timetable)
            {
                if(!TrainAtLocation(0, LocationName) || (LocationName != Ptr->LocationName))
                // not arrived yet in tt mode
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(2, Ptr->ArrivalTime + TDateTime(DelayedRandMins/1440)));
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(3, Ptr->DepartureTime));
                }
            }
            else // TrainMode == Signaller
            {
                if(!DepartureTimeSet) // not arrived yet
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(45, Ptr->ArrivalTime + TDateTime(DelayedRandMins/1440)));
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(36, Ptr->DepartureTime));
                }
            }
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
        {
            RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(4, Ptr->ArrivalTime + TDateTime(DelayedRandMins/1440)));
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(5, Ptr->DepartureTime));
        }
        else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture) //added at v2.12.0 for becoming new service early (see BecomeNewservice)
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(46, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->FormatType == PassTime) //must come after 'else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture)'
        {
            RetStr = "Pass " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(31, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->Command == "Fns")
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(8, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(6, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
            RetStr = GetNewServiceDepartureInfo(0, Ptr, RepeatNumber, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if(Ptr->Command == "F-nshs")
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode + " at " + Ptr->LocationName + " at approx. " +
                Utilities->Format96HHMM(GetTrainTime(32, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
            RetStr = GetNewServiceDepartureInfo(1, Ptr, 0, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
            //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
            //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
            //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(9, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(7, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(2, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode,
            +" at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(8, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
            RetStr = GetNewServiceDepartureInfo(3, Ptr, 0, Ptr->NonRepeatingShuttleLinkEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(10, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(9, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(4, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr ="None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Frh")
        {
            RetStr = "None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fer")
        {
            AnsiString AllowedExits = "";
            RetStr = "Exit railway" + TrainController->GetExitLocationAndAt(1, Ptr->ExitList, AllowedExits) + " at approx. " + Utilities->Format96HHMM(GetTrainTime(10, Ptr->EventTime + TDateTime(DelayedRandMins/1440))) + AllowedExits;
        }
        else if(Ptr->Command == "Fjo")
        {
            RetStr = "Join " + TrainController->GetRepeatHeadCode(11, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName + " at approx. " +
                Utilities->Format96HHMM(GetTrainTime(11, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->Command == "jbo")
        {
            RetStr = "Joined by " + TrainController->GetRepeatHeadCode(12, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(GetTrainTime(12, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->Command == "fsp")
        {
            RetStr = "Front split to " + TrainController->GetRepeatHeadCode(13, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(GetTrainTime(13, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->Command == "rsp")
        {
            RetStr = "Rear split to " + TrainController->GetRepeatHeadCode(14, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(GetTrainTime(14, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
        else if(Ptr->Command == "cdt")
        {
            RetStr = "Change direction at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(15, Ptr->EventTime + TDateTime(DelayedRandMins/1440)));
        }
    }
    else if(TrainController->TTClockTime > ActionTime) //condition added at v2.13.2 for trains that are delayed other than suffering a random delay
    {
        if((Ptr->Command != "") && (Ptr->Command[1] == 'S'))
        {
            throw Exception("Error - start entry in FloatingLabelNextString where TTClockTime > ActionTime");
        }
        if(Ptr->FormatType == TimeTimeLoc)
        {
            if(TrainMode == Timetable)
            {
                if(!TrainAtLocation(4, LocationName) || (LocationName != Ptr->LocationName))
                // not arrived yet in tt mode
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);
                }
            }
            else // TrainMode == Signaller
            {
                if(!DepartureTimeSet) // not arrived yet
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);
                }
            }
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
        {
            RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);
        }
        else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture) //added at v2.12.0 for becoming new service early (see BecomeNewservice)
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->FormatType == PassTime) //must come after 'else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture)'
        {
            RetStr = "Pass " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->Command == "Fns")
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(60, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
            RetStr = GetNewServiceDepartureInfo(19, Ptr, RepeatNumber, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if(Ptr->Command == "F-nshs")
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode + " at " + Ptr->LocationName + " at approx. " +
                Utilities->Format96HHMM(TrainController->TTClockTime);
            RetStr = GetNewServiceDepartureInfo(20, Ptr, 0, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
            //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
            //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
            //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(61, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(21, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode,
            +" at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
            RetStr = GetNewServiceDepartureInfo(22, Ptr, 0, Ptr->NonRepeatingShuttleLinkEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(62, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(23, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr ="None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Frh")
        {
            RetStr = "None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fer")
        {
            AnsiString AllowedExits = "";
            RetStr = "Exit railway" + TrainController->GetExitLocationAndAt(5, Ptr->ExitList, AllowedExits) /*+ " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime)*/ + AllowedExits;
        }
        else if(Ptr->Command == "Fjo")
        {
            RetStr = "Join " + TrainController->GetRepeatHeadCode(63, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;// + " at approx. " +
//                Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->Command == "jbo")
        {
            RetStr = "Joined by " + TrainController->GetRepeatHeadCode(64, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;// +
//                " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->Command == "fsp")
        {
            RetStr = "Front split to " + TrainController->GetRepeatHeadCode(65, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->Command == "rsp")
        {
            RetStr = "Rear split to " + TrainController->GetRepeatHeadCode(66, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
        else if(Ptr->Command == "cdt")
        {
            RetStr = "Change direction at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(TrainController->TTClockTime);
        }
    }
    else //train not delayed
    {
        if((Ptr->Command != "") && (Ptr->Command[1] == 'S'))
        {
            throw Exception("Error - start entry in FloatingLabelNextString in final 'else'");
        }
        if(Ptr->FormatType == TimeTimeLoc)
        {
            if(TrainMode == Timetable)
            {
                if(!TrainAtLocation(3, LocationName) || (LocationName != Ptr->LocationName))
                // not arrived yet in tt mode
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(48, Ptr->ArrivalTime));
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(3, Ptr->DepartureTime));
                }
            }
            else // TrainMode == Signaller
            {
                if(!DepartureTimeSet) // not arrived yet
                {
                    RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(49, Ptr->ArrivalTime));
                }
                else
                {
                    RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(36, Ptr->DepartureTime));
                }
            }
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
        {
            RetStr = "Arrive " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(50, Ptr->ArrivalTime));
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(5, Ptr->DepartureTime));
        }
        else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture) //added at v2.12.0 for becoming new service early (see BecomeNewservice)
        {
            RetStr = "Depart " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(51, Ptr->EventTime));
        }
        else if(Ptr->FormatType == PassTime) //must come after 'else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture)'
        {
            RetStr = "Pass " + Ptr->LocationName;// + " at approx. " + Utilities->Format96HHMM(GetTrainTime(52, Ptr->EventTime));
        }
        else if(Ptr->Command == "Fns")
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(53, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(53, Ptr->EventTime));
            RetStr = GetNewServiceDepartureInfo(10, Ptr, RepeatNumber, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if(Ptr->Command == "F-nshs")
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode + " at " + Ptr->LocationName + " at approx. " +
                Utilities->Format96HHMM(GetTrainTime(54, Ptr->EventTime));
            RetStr = GetNewServiceDepartureInfo(12, Ptr, 0, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
            //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
            //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
            //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(54, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(55, Ptr->EventTime));
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(14, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode,
            +" at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(56, Ptr->EventTime));
            RetStr = GetNewServiceDepartureInfo(16, Ptr, 0, Ptr->NonRepeatingShuttleLinkEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
        {
            RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(55, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
                Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(57, Ptr->EventTime));
            // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
            RetStr = GetNewServiceDepartureInfo(18, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr, false); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            RetStr ="None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Frh")
        {
            RetStr = "None, train terminated at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fer")
        {
            AnsiString AllowedExits = "";
            RetStr = "Exit railway" + TrainController->GetExitLocationAndAt(4, Ptr->ExitList, AllowedExits) /*+ " at approx. " + Utilities->Format96HHMM(GetTrainTime(62, Ptr->EventTime))*/ + AllowedExits;
        }
        else if(Ptr->Command == "Fjo")
        {
            RetStr = "Join " + TrainController->GetRepeatHeadCode(56, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;// + " at approx. " +
//                Utilities->Format96HHMM(GetTrainTime(58, Ptr->EventTime));
        }
        else if(Ptr->Command == "jbo")
        {
            RetStr = "Joined by " + TrainController->GetRepeatHeadCode(57, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;// +
//                " at approx. " + Utilities->Format96HHMM(GetTrainTime(59, Ptr->EventTime));
        }
        else if(Ptr->Command == "fsp")
        {
            RetStr = "Front split to " + TrainController->GetRepeatHeadCode(58, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(GetTrainTime(60, Ptr->EventTime));
        }
        else if(Ptr->Command == "rsp")
        {
            RetStr = "Rear split to " + TrainController->GetRepeatHeadCode(59, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
                " at approx. " + Utilities->Format96HHMM(GetTrainTime(61, Ptr->EventTime));
        }
        else if(Ptr->Command == "cdt")
        {
            RetStr = "Change direction at " + Ptr->LocationName + " at approx. " + Utilities->Format96HHMM(GetTrainTime(63, Ptr->EventTime));
        }
    }
    Utilities->CallLogPop(1124);
    return(RetStr);
}

// ---------------------------------------------------------------------------
/* as was
AnsiString TTrain::FloatingLabelNextString(int Caller, TActionVectorEntry *Ptr)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString(Ptr - &TrainDataEntryPtr->ActionVector.front()) +
                                 ",FloatingLabelNextString" + "," + HeadCode);
    AnsiString RetStr = "", LocationName = "";

    if((Ptr->Command != "") && (Ptr->Command[1] == 'S'))
    {
        throw Exception("Error - start entry in FloatingLabelNextString");
    }
    if(Ptr->FormatType == TimeTimeLoc)
    {
        if(TrainMode == Timetable)
        {
            if(!TrainAtLocation(, LocationName) || (LocationName != Ptr->LocationName))
            // not arrived yet in tt mode
            {
                RetStr = "Arrive " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->ArrivalTime));
            }
            else
            {
                RetStr = "Depart " + Ptr->LocationName + " approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(, Ptr->DepartureTime));
            }
        }
        else // TrainMode == Signaller
        {
            if(!DepartureTimeSet) // not arrived yet
            {
                RetStr = "Arrive " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->ArrivalTime));
            }
            else
            {
                RetStr = "Depart " + Ptr->LocationName + " approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(, Ptr->DepartureTime));
            }
        }
    }
    else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
    {
        RetStr = "Arrive " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->ArrivalTime));
    }
    else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
    {
        RetStr = "Depart " + Ptr->LocationName + " approx. " + Utilities->Format96HHMM(ReleaseTime);//GetTrainTime(, Ptr->DepartureTime));
    }
    else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture) //added at v2.12.0 for becoming new service early (see BecomeNewservice)
    {
        RetStr = "Depart " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->FormatType == PassTime) //must come after 'else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture)'
    {
        RetStr = "Pass " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->Command == "Fns")
    {
        RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " +
            Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
        RetStr = GetNewServiceDepartureInfo(, Ptr, RepeatNumber, Ptr->LinkedTrainEntryPtr, RetStr); //if there is a next service this adds the new service departure time to RetStr
    }
    else if(Ptr->Command == "F-nshs")
    {
        RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode + " at " + Ptr->LocationName + " at " +
            Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
        RetStr = GetNewServiceDepartureInfo(, Ptr, 0, Ptr->LinkedTrainEntryPtr, RetStr); //if there is a next service this adds the new service departure time to RetStr
        //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
        //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
        //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
    }
    else if((Ptr->Command == "Fns-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
    {
        RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
            Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
        // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
        RetStr = GetNewServiceDepartureInfo(, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr); //if there is a next service this adds the new service departure time to RetStr
    }
    else if((Ptr->Command == "Fns-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
    {
        RetStr = "Forms new service " + Ptr->NonRepeatingShuttleLinkHeadCode,
        +" at " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
        RetStr = GetNewServiceDepartureInfo(, Ptr, 0, Ptr->NonRepeatingShuttleLinkEntryPtr, RetStr); //if there is a next service this adds the new service departure time to RetStr
    }
    else if((Ptr->Command == "Frh-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not last repeat number
    {
        RetStr = "Forms new service " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " +
            Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
        // use RepeatNumber+1 as it's the repeat number of the NEXT shuttle service that is relevant
        RetStr = GetNewServiceDepartureInfo(, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, RetStr); //if there is a next service this adds the new service departure time to RetStr
    }
    else if((Ptr->Command == "Frh-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
    {
        RetStr ="None, train terminated at " + Ptr->LocationName;
    }
    else if(Ptr->Command == "Frh")
    {
        RetStr = "None, train terminated at " + Ptr->LocationName;
    }
    else if(Ptr->Command == "Fer")
    {
        AnsiString AllowedExits = "";
        RetStr = "Exit railway" + TrainController->GetExitLocationAndAt(, Ptr->ExitList, AllowedExits) + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime)) + AllowedExits;
    }
    else if(Ptr->Command == "Fjo")
    {
        RetStr = "Join " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName + " at " +
            Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->Command == "jbo")
    {
        RetStr = "Joined by " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
            " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->Command == "fsp")
    {
        RetStr = "Front split to " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
            " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->Command == "rsp")
    {
        RetStr = "Rear split to " + TrainController->GetRepeatHeadCode(, Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName +
            " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    else if(Ptr->Command == "cdt")
    {
        RetStr = "Change direction at " + Ptr->LocationName + " at " + Utilities->Format96HHMM(GetTrainTime(, Ptr->EventTime));
    }
    Utilities->CallLogPop();
    return(RetStr);
}
*/
// ---------------------------------------------------------------------------

AnsiString TTrain::GetNewServiceDepartureInfo(int Caller, TActionVectorEntry *Ptr, int RptNum, TTrainDataEntry *LinkedTrainDataPtr, AnsiString RetStr, bool TimetableTime)
{   //last bool added at v2.13.2 so departure info adds random delay if actual rather than not timetable time required
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString(Ptr - &TrainDataEntryPtr->ActionVector.front()) + ","
                                 + AnsiString(RptNum) + ",GetNewServiceDepartureInfo," + HeadCode);
    AnsiString DepTime = "", EventTime = "";
    bool CDTFlag = false; //reports if train changes direction before departs
    TActionVector NewServiceAV = LinkedTrainDataPtr->ActionVector;
    AnsiString CurrentLocation = NewServiceAV.at(0).LocationName; //added at v2.12.0 to show departure direction
    AnsiString TowardsLocation = ""; //added at v2.12.0 to show departure direction
    for(TActionVectorIterator AVI = NewServiceAV.begin(); AVI < NewServiceAV.end(); AVI++) //added at v2.12.0 to obtain departure direction
    {
        if((AVI->LocationName != CurrentLocation) && (AVI->LocationName != "") && (TowardsLocation == ""))
        {
            TowardsLocation = AVI->LocationName;
        }
        else if((AVI->Command == "Fer") && (TowardsLocation == "") && !AVI->ExitList.empty())
        {
            TTrackElement TE = Track->TrackElementAt(1452, (AVI->ExitList.front()));
            if(TE.ActiveTrackElementName != "")
            {
                TowardsLocation = TE.ActiveTrackElementName;
            }
            else
            {
                TowardsLocation = AnsiString("track element ID ") + TE.ElementID;
            }
        }
    }

    for(TActionVectorIterator AVI = NewServiceAV.begin(); AVI < NewServiceAV.end(); AVI++)
    {
        if(AVI->Command == "cdt")
        {
            CDTFlag = !CDTFlag; //toggles flag - allows for there being more than one cdt before departure
            continue;
        }
        if((AVI->Command == "fsp") || (AVI->Command == "rsp"))
        {
            TDateTime TTTime = TrainController->GetControllerTrainTime(19, AVI->EventTime, RptNum, IncrementalMinutes);
            if((DelayedRandMins >= 1) && !TimetableTime)
            {
                EventTime = Utilities->Format96HHMM(TTTime + TDateTime(DelayedRandMins/1440));
            }
            else if((TrainController->TTClockTime > TTTime) && !TimetableTime)
            {
                EventTime = Utilities->Format96HHMM(TrainController->TTClockTime);
            }
            else  //((DelayedRandMins == 0) && (TTClockTime <= TTTime)) || TimetableTime
            {
                EventTime = Utilities->Format96HHMM(TTTime);
            }
            RetStr += "\nNew service splits at approx. " + EventTime;
            Utilities->CallLogPop(2234);
            return(RetStr);
        }
        if(AVI->Command == "jbo")
        {
            TDateTime TTTime = TrainController->GetControllerTrainTime(20, AVI->EventTime, RptNum, IncrementalMinutes);
            if((DelayedRandMins >= 1) && !TimetableTime)
            {
                EventTime = Utilities->Format96HHMM(TTTime + TDateTime(DelayedRandMins/1440));
            }
            else if((TrainController->TTClockTime > TTTime) && !TimetableTime)
            {
                EventTime = Utilities->Format96HHMM(TrainController->TTClockTime);
            }
            else  //((DelayedRandMins == 0) && (TTClockTime <= TTTime)) || TimetableTime
            {
                EventTime = Utilities->Format96HHMM(TTTime);
            }
            RetStr += "\nNew service joined by " + AVI->OtherHeadCode + " at approx. " + EventTime;
            Utilities->CallLogPop(2235);
            return(RetStr);
        }
        if((AVI->FormatType == TimeLoc) && (AVI->DepartureTime > TDateTime(-1))) //departure time set
        {
            if(TimetableTime) //don't add random delay
            {
                DepTime = Utilities->Format96HHMM(TrainController->GetControllerTrainTime(17, AVI->DepartureTime, RptNum, IncrementalMinutes));
                if(CDTFlag)
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service changes direction then departs towards " + TowardsLocation + " at " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service changes direction then departs at " + DepTime;
                    }
                }
                else
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service departs towards " + TowardsLocation + " at " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service departs at " + DepTime;
                    }
                }
            }
            else if(DelayedRandMins >= 1)//add random delay
            {
                DepTime = Utilities->Format96HHMM(TrainController->GetControllerTrainTime(24, AVI->DepartureTime + TDateTime(DelayedRandMins/1440), RptNum, IncrementalMinutes));
                if(CDTFlag)
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service changes direction then departs towards " + TowardsLocation + " at approx. " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service changes direction then departs at approx. " + DepTime;
                    }
                }
                else
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service departs towards " + TowardsLocation + " at approx. " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service departs at approx. " + DepTime;
                    }
                }
            }
            else //no random delay but may be delayed for other reasons
            {
                TDateTime TTTime = TrainController->GetControllerTrainTime(25, AVI->DepartureTime, RptNum, IncrementalMinutes);
                if(TrainController->TTClockTime > TTTime)
                {
                    DepTime = Utilities->Format96HHMM(TrainController->TTClockTime);
                }
                else
                {
                    DepTime = Utilities->Format96HHMM(TTTime);
                }
                if(CDTFlag)
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service changes direction then departs towards " + TowardsLocation + " at approx. " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service changes direction then departs at approx. " + DepTime;
                    }
                }
                else
                {
                    if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                    {
                        RetStr += "\nNew service departs towards " + TowardsLocation + " at approx. " + DepTime;
                    }
                    else
                    {
                        RetStr += "\nNew service departs at approx. " + DepTime;
                    }
                }
            }
            Utilities->CallLogPop(2236);
            return(RetStr);
        }
    }
    Utilities->CallLogPop(2208);
    return(RetStr); //if reach here then RetStr doesn't change
}

// ---------------------------------------------------------------------------

AnsiString TTrain::FloatingTimetableString(int Caller, TActionVectorEntry *Ptr)
// Enter with Ptr pointing to first action to be listed (i.e. next action)
// If there are actions to be skipped but a departure is awaited (SkippedDeparture = true) then after the departure Ptr moves forward by SkipPtrValue
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString(Ptr - &TrainDataEntryPtr->ActionVector.front()) +
                                 ",FloatingTimetableString" + "," + HeadCode);
    AnsiString RetStr = "", PartStr = "";
    int Count = 0;
    bool SkipDep = false, SkipDepActedOn = false; //SkipDepActedOn ensures only one SkipDep acted on
    AnsiString LocName = Ptr->LocationName;

    if((Ptr->Command != "") && (Ptr->Command[1] == 'S') && (TrainMode == Timetable))
    // can start in signaller control so exclude this
    {
        throw Exception("Error - start entry in FloatingTimetableString");
    }
    TActionVectorEntry *EntryPtr = Ptr; //used in TimeTimeLoc check later
    bool FirstPass = true;
    Ptr--; // because incremented at start of loop

    // different first TimeTimeLoc display if in signaller control
    do
    {
        Ptr++;
        if((Ptr->FormatType == Repeat) || TimetableFinished)
        {
            break;
        }
        if((Ptr->FormatType == TimeTimeLoc) && FirstPass)
        {
            AnsiString TrainLoc = "";
            if(TrainMode == Timetable)
            {
                if(TrainAtLocation(1, TrainLoc) && (TrainLoc == Ptr->LocationName) && (Ptr == EntryPtr)) //added '&& (Ptr == EntryPtr)' at v2.6.0 when allow multiple same location entries
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(33, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                    if((LocName == Ptr->LocationName) && (LocName != "") && SkippedDeparture && !SkipDepActedOn)
                    {
                        SkipDep = true; //0 for incremental minutes because don't reduce the departure time when later actions have been skipped
                    }
                }
                else if(Ptr->ArrivalTime == Ptr->DepartureTime)
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(34, Ptr->ArrivalTime)) + ": Arrive & depart from " + Ptr->LocationName;
                }
                else
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(16, Ptr->ArrivalTime)) + ": Arrive at " + Ptr->LocationName + '\n' +
                        Utilities->Format96HHMM(GetTrainTime(17, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                    Count++; // because there are 2 entries
                }
            }
            else // TrainMode == Signaller
            {
                if(DepartureTimeSet)
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(37, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                    if((LocName == Ptr->LocationName) && (LocName != "") && SkippedDeparture && !SkipDepActedOn)
                    {
                        SkipDep = true; //0 for incremental minutes because don't reduce the departure time when later actions have been skipped
                    }
                }
                else if(Ptr->ArrivalTime == Ptr->DepartureTime)
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(38, Ptr->ArrivalTime)) + ": Arrive & depart from " + Ptr->LocationName;
                }
                else
                {
                    PartStr = Utilities->Format96HHMM(GetTrainTime(39, Ptr->ArrivalTime)) + ": Arrive at " + Ptr->LocationName + '\n' +
                        Utilities->Format96HHMM(GetTrainTime(40, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                    Count++; // because there are 2 entries
                }
            }
        }
        else if((Ptr->FormatType == TimeTimeLoc) && !FirstPass)
        {
            AnsiString TrainLoc = "";
            if((TrainAtLocation(2, TrainLoc)) && (TrainLoc == Ptr->LocationName) && (Ptr == EntryPtr)) //added '&& (Ptr == EntryPtr)' at v2.6.0 when allow multiple same location entries
            {
                PartStr = Utilities->Format96HHMM(GetTrainTime(41, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                if((LocName == Ptr->LocationName) && (LocName != "") && SkippedDeparture && !SkipDepActedOn)
                {
                        SkipDep = true; //0 for incremental minutes because don't reduce the departure time when later actions have been skipped
                }
            }
            else if(Ptr->ArrivalTime == Ptr->DepartureTime)
            {
                PartStr = Utilities->Format96HHMM(GetTrainTime(42, Ptr->ArrivalTime)) + ": Arrive & depart from " + Ptr->LocationName;
            }
            else
            {
                PartStr = Utilities->Format96HHMM(GetTrainTime(43, Ptr->ArrivalTime)) + ": Arrive at " + Ptr->LocationName + '\n' +
                    Utilities->Format96HHMM(GetTrainTime(44, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
                Count++; // because there are 2 entries
            }
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(18, Ptr->ArrivalTime)) + ": Arrive at " + Ptr->LocationName;
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(19, Ptr->DepartureTime)) + ": Depart from " + Ptr->LocationName;
            if((LocName == Ptr->LocationName) && (LocName != "") && SkippedDeparture && !SkipDepActedOn)
            {
                SkipDep = true; //0 for incremental minutes because don't reduce the departure time when later actions have been skipped
            }
        }
        else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture) //added at v2.12.0 for becoming new service early (see BecomeNewService)
        {                                                               //note that TreatPassAsTimeLocDeparture can't be set if have SkippedDeparture
            PartStr = Utilities->Format96HHMM(GetTrainTime(47, Ptr->EventTime)) + ": Depart from " + Ptr->LocationName;
        }
        else if(Ptr->FormatType == PassTime) //must come after 'else if((Ptr->FormatType == PassTime) && TreatPassAsTimeLocDeparture)'
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(30, Ptr->EventTime)) + ": Pass " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fns")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(20, Ptr->EventTime)) + ": Form new service " + TrainController->GetRepeatHeadCode(15,
                    Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;
            PartStr = GetNewServiceDepartureInfo(5, Ptr, RepeatNumber, Ptr->LinkedTrainEntryPtr, PartStr, true); //if there is a next service this adds the new service departure time to PartStr
        }
        else if(Ptr->Command == "F-nshs")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(35, Ptr->EventTime)) + ": Form new service " + Ptr->NonRepeatingShuttleLinkHeadCode + " at " +
                Ptr->LocationName;
            PartStr = GetNewServiceDepartureInfo(6, Ptr, 0, Ptr->LinkedTrainEntryPtr, PartStr, true); //if there is a next service this adds the new service departure time to RetStr
            //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
            //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
            //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not the last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(21, Ptr->EventTime)) + ": Form new service " + TrainController->GetRepeatHeadCode(16,
                                                                                                                                             Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " + Ptr->LocationName;
            // use RepeatNumber+1 because it's the repeat number of the NEXT shuttle service that is relevant
            PartStr = GetNewServiceDepartureInfo(7, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, PartStr, true); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Fns-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(22, Ptr->EventTime)) + ": Form new service " + Ptr->NonRepeatingShuttleLinkHeadCode,
            +" at " + Ptr->LocationName;
            PartStr = GetNewServiceDepartureInfo(8, Ptr, 0, Ptr->NonRepeatingShuttleLinkEntryPtr, PartStr, true); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber < (TrainDataEntryPtr->NumberOfTrains - 1))) // not the last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(23, Ptr->EventTime)) + ": Form new service " + TrainController->GetRepeatHeadCode(17,
                                                                                                                                             Ptr->OtherHeadCode, RepeatNumber + 1, IncrementalDigits) + " at " + Ptr->LocationName;
            // use RepeatNumber+1 because it's the repeat number of the NEXT shuttle service that is relevant
            PartStr = GetNewServiceDepartureInfo(9, Ptr, RepeatNumber + 1, Ptr->LinkedTrainEntryPtr, PartStr, true); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepeatNumber >= (TrainDataEntryPtr->NumberOfTrains - 1))) // last repeat number
        {
            PartStr = "Terminate at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Frh")
        {
            PartStr = "Terminate at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fer")
        {
            AnsiString AllowedExits = "";
            PartStr = Utilities->Format96HHMM(GetTrainTime(24, Ptr->EventTime)) + ": Exit railway" + TrainController->GetExitLocationAndAt(2, Ptr->ExitList, AllowedExits) + AllowedExits;
        }
        else if(Ptr->Command == "Fjo")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(25, Ptr->EventTime)) + ": Join " + TrainController->GetRepeatHeadCode(18, Ptr->OtherHeadCode,
                                                                                                                                 RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "jbo")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(26, Ptr->EventTime)) + ": Joined by " + TrainController->GetRepeatHeadCode(19, Ptr->OtherHeadCode,
                                                                                                                                      RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "fsp")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(27, Ptr->EventTime)) + ": Front split to " + TrainController->GetRepeatHeadCode(20,
                                                                                                                                           Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "rsp")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(28, Ptr->EventTime)) + ": Rear split to " + TrainController->GetRepeatHeadCode(21,
                                                                                                                                          Ptr->OtherHeadCode, RepeatNumber, IncrementalDigits) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "cdt")
        {
            PartStr = Utilities->Format96HHMM(GetTrainTime(29, Ptr->EventTime)) + ": Change direction at " + Ptr->LocationName;
        }
        if(RetStr != "")
        {
            RetStr = RetStr + '\n' + PartStr;
        }
        else
        {
            RetStr = PartStr;
        }
        FirstPass = false;
        Count++;

        if(SkipDep)
        {
            Ptr = &(TrainDataEntryPtr->ActionVector.at(0)) + SkipPtrValue;
            Ptr--; //it is incremented at the start of the next loop
            SkipDep = false;
            SkipDepActedOn = true;
        }
    }
    while(!TimetableFinished && (Count < 32) && ((Ptr->Command == "") || ((Ptr->Command != "") && (Ptr->Command[1] != 'F'))));
    // limit of 32 allows a max of 34 entries (33 + 1 for the new service departure time) (may have gone from 32 to 34 because of a TimeTimeLoc), which with track and
    // train status gives a max of 48 lines, at 13 pixels each, = 624 pixels & screen height has 641 so will fit comfortably.  Also 34 timetable entries is as far
    // forward as anyone should wish to see without looking at the full timetable
    if(TimetableFinished)
    {
        if(TrainMode == Timetable)
        {
            RetStr = "Timetable finished";
        }
        else
        {
            RetStr = "No timetable";
        }
    }
    Utilities->CallLogPop(1125);
    return("Timetable:\n" + RetStr);
}

// ---------------------------------------------------------------------------

void TTrain::SaveOneSessionTrain(int Caller, std::ofstream &OutFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveOneSessionTrain" + "," + HeadCode);
    Utilities->SaveFileString(OutFile, HeadCode);
    Utilities->SaveFileInt(OutFile, RearStartElement);
    Utilities->SaveFileInt(OutFile, RearStartExitPos);
    Utilities->SaveFileInt(OutFile, StartSpeed);
    Utilities->SaveFileInt(OutFile, SignallerMaxSpeed);
    Utilities->SaveFileBool(OutFile, HoldAtLocationInTTMode);
    Utilities->SaveFileInt(OutFile, RepeatNumber);
    Utilities->SaveFileInt(OutFile, IncrementalMinutes);
    Utilities->SaveFileInt(OutFile, IncrementalDigits);
    Utilities->SaveFileInt(OutFile, Mass);
    Utilities->SaveFileInt(OutFile, FrontElementSpeedLimit);
    Utilities->SaveFileInt(OutFile, FrontElementLength);
    Utilities->SaveFileDouble(OutFile, EntrySpeed);
    Utilities->SaveFileDouble(OutFile, ExitSpeedHalf);
    Utilities->SaveFileDouble(OutFile, ExitSpeedFull);
    Utilities->SaveFileDouble(OutFile, TimetableMaxRunningSpeed);
    Utilities->SaveFileDouble(OutFile, MaxRunningSpeed);
    Utilities->SaveFileDouble(OutFile, MaxExitSpeed);
    Utilities->SaveFileDouble(OutFile, MaxBrakeRate);
    Utilities->SaveFileDouble(OutFile, BrakeRate);
    Utilities->SaveFileDouble(OutFile, PowerAtRail);
    Utilities->SaveFileBool(OutFile, FirstHalfMove);
    Utilities->SaveFileBool(OutFile, OneLengthAccelDecel);
    Utilities->SaveFileDouble(OutFile, double(EntryTime));
    Utilities->SaveFileDouble(OutFile, double(ExitTimeHalf));
    Utilities->SaveFileDouble(OutFile, double(ExitTimeFull));
    Utilities->SaveFileDouble(OutFile, double(ReleaseTime));
    Utilities->SaveFileDouble(OutFile, double(TRSTime));
    Utilities->SaveFileDouble(OutFile, double(LastActionTime));
    Utilities->SaveFileBool(OutFile, CallingOnFlag);
    Utilities->SaveFileBool(OutFile, BeingCalledOn);
    Utilities->SaveFileBool(OutFile, DepartureTimeSet);
    Utilities->SaveFileInt(OutFile, (short)TrainMode);
    Utilities->SaveFileBool(OutFile, TimetableFinished);
    Utilities->SaveFileBool(OutFile, LastActionDelayFlag);
    Utilities->SaveFileBool(OutFile, SignallerRemoved);
    Utilities->SaveFileBool(OutFile, TerminatedMessageSent);
    Utilities->SaveFileBool(OutFile, Derailed);
    Utilities->SaveFileBool(OutFile, DerailPending);
    Utilities->SaveFileBool(OutFile, Crashed);
    Utilities->SaveFileBool(OutFile, StoppedAtBuffers);
    Utilities->SaveFileBool(OutFile, StoppedAtSignal);
    Utilities->SaveFileBool(OutFile, StoppedAtLocation);
    Utilities->SaveFileBool(OutFile, SignallerStopped);
    Utilities->SaveFileBool(OutFile, StoppedAfterSPAD);
    Utilities->SaveFileBool(OutFile, StoppedForTrainInFront);
    Utilities->SaveFileBool(OutFile, NotInService);
    Utilities->SaveFileBool(OutFile, Plotted);
    Utilities->SaveFileBool(OutFile, TrainGone);
    Utilities->SaveFileBool(OutFile, SPADFlag);
    Utilities->SaveFileBool(OutFile, TimeTimeLocArrived);
    Utilities->SaveFileInt(OutFile, HOffset[0]);
    Utilities->SaveFileInt(OutFile, HOffset[1]);
    Utilities->SaveFileInt(OutFile, HOffset[2]);
    Utilities->SaveFileInt(OutFile, HOffset[3]);
    Utilities->SaveFileInt(OutFile, VOffset[0]);
    Utilities->SaveFileInt(OutFile, VOffset[1]);
    Utilities->SaveFileInt(OutFile, VOffset[2]);
    Utilities->SaveFileInt(OutFile, VOffset[3]);
    Utilities->SaveFileInt(OutFile, PlotElement[0]);
    Utilities->SaveFileInt(OutFile, PlotElement[1]);
    Utilities->SaveFileInt(OutFile, PlotElement[2]);
    Utilities->SaveFileInt(OutFile, PlotElement[3]);
    Utilities->SaveFileInt(OutFile, PlotEntryPos[0]);
    Utilities->SaveFileInt(OutFile, PlotEntryPos[1]);
    Utilities->SaveFileInt(OutFile, PlotEntryPos[2]);
    Utilities->SaveFileInt(OutFile, PlotEntryPos[3]);
    Utilities->SaveFileInt(OutFile, TrainCrashedInto);
    Utilities->SaveFileInt(OutFile, (short)Straddle);
    Utilities->SaveFileInt(OutFile, NextTrainID);
    Utilities->SaveFileInt(OutFile, TrainID);
    Utilities->SaveFileInt(OutFile, LeadElement);
    Utilities->SaveFileInt(OutFile, LeadEntryPos);
    Utilities->SaveFileInt(OutFile, LeadExitPos);
    Utilities->SaveFileInt(OutFile, MidElement);
    Utilities->SaveFileInt(OutFile, MidEntryPos);
    Utilities->SaveFileInt(OutFile, MidExitPos);
    Utilities->SaveFileInt(OutFile, LagElement);
    Utilities->SaveFileInt(OutFile, LagEntryPos);
    Utilities->SaveFileInt(OutFile, LagExitPos);
    int ColourNumber;

    if(BackgroundColour == clBufferAttentionNeeded)
    {
        ColourNumber = 0;
    }
    else if(BackgroundColour == clBufferStopBackground)
    {
        ColourNumber = 1;
    }
    else if(BackgroundColour == clCallOnBackground)
    {
        ColourNumber = 2;
    }
    else if(BackgroundColour == clCrashedBackground)
    {
        ColourNumber = 3;
    }
    else if(BackgroundColour == clDerailedBackground)
    {
        ColourNumber = 4;
    }
    else if(BackgroundColour == clFrontCodeSignaller)
    {
        ColourNumber = 5;
    }
    else if(BackgroundColour == clFrontCodeTimetable)
    {
        ColourNumber = 6;
    }
    else if(BackgroundColour == clNormalBackground)
    {
        ColourNumber = 7;
    }
    else if(BackgroundColour == clSignallerStopped)
    {
        ColourNumber = 8;
    }
    else if(BackgroundColour == clSignalStopBackground)
    {
        ColourNumber = 9;
    }
    else if(BackgroundColour == clSPADBackground)
    {
        ColourNumber = 10;
    }
    else if(BackgroundColour == clStationStopBackground)
    {
        ColourNumber = 11;
    }
    else if(BackgroundColour == clStoppedTrainInFront)
    {
        ColourNumber = 12;
    }
    else if(BackgroundColour == clTRSBackground)
    {
        ColourNumber = 13;
    }
    else if(BackgroundColour == clTrainFailedBackground)
    {
        ColourNumber = 14; // added at v2.4.0
    }
    Utilities->SaveFileInt(OutFile, ColourNumber);

    // additional data
    bool ForwardHeadCode;

    if(HeadCodePosition[3] == HeadCodeGrPtr[3])
    {
        ForwardHeadCode = true;
    }
    // can't use 'if(HeadCodePosition[0] == HeadCodeGrPtr[0])' as HeadCodePosition[0] is set to FrontCodePtr
    else
    {
        ForwardHeadCode = false;
    }
    Utilities->SaveFileBool(OutFile, ForwardHeadCode);

    int TrainDataEntryValue = TrainDataEntryPtr - &(TrainController->TrainDataVector.at(0));

    Utilities->SaveFileInt(OutFile, TrainDataEntryValue);
    int ActionVectorEntryValue = ActionVectorEntryPtr - &(TrainDataEntryPtr->ActionVector.at(0));

    Utilities->SaveFileInt(OutFile, ActionVectorEntryValue);
    // now the marker comes next which was ****** originally but used for RestoreTimetableLocation as well some time ago (came before the asterisks)
    // but at v2.4.0 need to include StoppedWithoutPower, while keeping length of marker at 6, because that is tested in earlier versions
    // so use the last asterisk position for this - 0 for false & 1 for true
    // note that failed train data is handled in InterfaceUnit.cpp & stored after the performance file
    AnsiString Marker;

    if(StoppedWithoutPower)
    {
        Marker = "*****1";
    }
    else
    {
        Marker = "*****0";
    }
    if(RestoreTimetableLocation == "")
    {
        Utilities->SaveFileString(OutFile, Marker);
    }
    else
    {
        AnsiString CombinedString = RestoreTimetableLocation + Marker;
        Utilities->SaveFileString(OutFile, CombinedString);
        // RestoreTimetableLocation + marker
    }
    // Note: including RestoreTimetableLocation with the marker is to correct an oversight - it should have been saved earlier
    Utilities->CallLogPop(1457);
}

// ---------------------------------------------------------------------------

void TTrain::LoadOneSessionTrain(int Caller, std::ifstream &InFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadOneSessionTrain"); // don't have headcode yet
    HeadCode = Utilities->LoadFileString(InFile);
    RearStartElement = Utilities->LoadFileInt(InFile);
    RearStartExitPos = Utilities->LoadFileInt(InFile);
    StartSpeed = Utilities->LoadFileInt(InFile);
    SignallerMaxSpeed = Utilities->LoadFileInt(InFile);
    if(SignallerMaxSpeed < 10)
    {
        SignallerMaxSpeed = 10; // added at v0.6 to avoid low max speeds
    }
    HoldAtLocationInTTMode = Utilities->LoadFileBool(InFile);
    RepeatNumber = Utilities->LoadFileInt(InFile);
    IncrementalMinutes = Utilities->LoadFileInt(InFile);
    IncrementalDigits = Utilities->LoadFileInt(InFile);
    Mass = Utilities->LoadFileInt(InFile);
    FrontElementSpeedLimit = Utilities->LoadFileInt(InFile);
    if(FrontElementSpeedLimit > TTrain::MaximumSpeedLimit)
    {
        FrontElementSpeedLimit = TTrain::MaximumSpeedLimit;
    }
    // above added at v2.1.0 for legacy session files where value may not have been limited
    FrontElementLength = Utilities->LoadFileInt(InFile);
    EntrySpeed = Utilities->LoadFileDouble(InFile);
    ExitSpeedHalf = Utilities->LoadFileDouble(InFile);
    ExitSpeedFull = Utilities->LoadFileDouble(InFile);
    TimetableMaxRunningSpeed = Utilities->LoadFileDouble(InFile);
    if(TimetableMaxRunningSpeed < 10)
    {
        TimetableMaxRunningSpeed = 10; // added at v0.6 to avoid low max speeds
    }
    MaxRunningSpeed = Utilities->LoadFileDouble(InFile);
    if(MaxRunningSpeed < 10)
    {
        MaxRunningSpeed = 10; // added at v0.6 to avoid low max speeds
    }
    MaxExitSpeed = Utilities->LoadFileDouble(InFile);
    MaxBrakeRate = Utilities->LoadFileDouble(InFile);
    BrakeRate = Utilities->LoadFileDouble(InFile);
    PowerAtRail = Utilities->LoadFileDouble(InFile);
    FirstHalfMove = Utilities->LoadFileBool(InFile);
    OneLengthAccelDecel = Utilities->LoadFileBool(InFile);
    EntryTime = TDateTime(Utilities->LoadFileDouble(InFile));
    ExitTimeHalf = TDateTime(Utilities->LoadFileDouble(InFile));
    ExitTimeFull = TDateTime(Utilities->LoadFileDouble(InFile));
    ReleaseTime = TDateTime(Utilities->LoadFileDouble(InFile));
    TRSTime = TDateTime(Utilities->LoadFileDouble(InFile));
    LastActionTime = TDateTime(Utilities->LoadFileDouble(InFile));
    CallingOnFlag = Utilities->LoadFileBool(InFile);
    BeingCalledOn = Utilities->LoadFileBool(InFile);
    DepartureTimeSet = Utilities->LoadFileBool(InFile);
    TrainMode = TTrainMode(Utilities->LoadFileInt(InFile));
    TimetableFinished = Utilities->LoadFileBool(InFile);
    LastActionDelayFlag = Utilities->LoadFileBool(InFile);
    SignallerRemoved = Utilities->LoadFileBool(InFile);
    TerminatedMessageSent = Utilities->LoadFileBool(InFile);
    Derailed = Utilities->LoadFileBool(InFile);
    DerailPending = Utilities->LoadFileBool(InFile);
    Crashed = Utilities->LoadFileBool(InFile);
    StoppedAtBuffers = Utilities->LoadFileBool(InFile);
    StoppedAtSignal = Utilities->LoadFileBool(InFile);
    StoppedAtLocation = Utilities->LoadFileBool(InFile);
    SignallerStopped = Utilities->LoadFileBool(InFile);
    StoppedAfterSPAD = Utilities->LoadFileBool(InFile);
    StoppedForTrainInFront = Utilities->LoadFileBool(InFile);
    NotInService = Utilities->LoadFileBool(InFile);
    Plotted = Utilities->LoadFileBool(InFile);
    TrainGone = Utilities->LoadFileBool(InFile);
    SPADFlag = Utilities->LoadFileBool(InFile);
    TimeTimeLocArrived = Utilities->LoadFileBool(InFile);
    HOffset[0] = Utilities->LoadFileInt(InFile);
    HOffset[1] = Utilities->LoadFileInt(InFile);
    HOffset[2] = Utilities->LoadFileInt(InFile);
    HOffset[3] = Utilities->LoadFileInt(InFile);
    VOffset[0] = Utilities->LoadFileInt(InFile);
    VOffset[1] = Utilities->LoadFileInt(InFile);
    VOffset[2] = Utilities->LoadFileInt(InFile);
    VOffset[3] = Utilities->LoadFileInt(InFile);
    PlotElement[0] = Utilities->LoadFileInt(InFile);
    PlotElement[1] = Utilities->LoadFileInt(InFile);
    PlotElement[2] = Utilities->LoadFileInt(InFile);
    PlotElement[3] = Utilities->LoadFileInt(InFile);
    PlotEntryPos[0] = Utilities->LoadFileInt(InFile);
    PlotEntryPos[1] = Utilities->LoadFileInt(InFile);
    PlotEntryPos[2] = Utilities->LoadFileInt(InFile);
    PlotEntryPos[3] = Utilities->LoadFileInt(InFile);
    TrainCrashedInto = Utilities->LoadFileInt(InFile);
    Straddle = (TStraddle)(Utilities->LoadFileInt(InFile));
    NextTrainID = Utilities->LoadFileInt(InFile);
    // will be same for all but best to save all anyway
    TrainID = Utilities->LoadFileInt(InFile);
    LeadElement = Utilities->LoadFileInt(InFile);
    LeadEntryPos = Utilities->LoadFileInt(InFile);
    LeadExitPos = Utilities->LoadFileInt(InFile);
    MidElement = Utilities->LoadFileInt(InFile);
    MidEntryPos = Utilities->LoadFileInt(InFile);
    MidExitPos = Utilities->LoadFileInt(InFile);
    LagElement = Utilities->LoadFileInt(InFile);
    LagEntryPos = Utilities->LoadFileInt(InFile);
    LagExitPos = Utilities->LoadFileInt(InFile);
    int ColourNumber = TColor(Utilities->LoadFileInt(InFile));

    if(ColourNumber == 0)
    {
        BackgroundColour = clBufferAttentionNeeded;
    }
    else if(ColourNumber == 1)
    {
        BackgroundColour = clBufferStopBackground;
    }
    else if(ColourNumber == 2)
    {
        BackgroundColour = clCallOnBackground;
    }
    else if(ColourNumber == 3)
    {
        BackgroundColour = clCrashedBackground;
    }
    else if(ColourNumber == 4)
    {
        BackgroundColour = clDerailedBackground;
    }
    else if(ColourNumber == 5)
    {
        BackgroundColour = clFrontCodeSignaller;
    }
    else if(ColourNumber == 6)
    {
        BackgroundColour = clFrontCodeTimetable;
    }
    else if(ColourNumber == 7)
    {
        BackgroundColour = clNormalBackground;
    }
    else if(ColourNumber == 8)
    {
        BackgroundColour = clSignallerStopped;
    }
    else if(ColourNumber == 9)
    {
        BackgroundColour = clSignalStopBackground;
    }
    else if(ColourNumber == 10)
    {
        BackgroundColour = clSPADBackground;
    }
    else if(ColourNumber == 11)
    {
        BackgroundColour = clStationStopBackground;
    }
    else if(ColourNumber == 12)
    {
        BackgroundColour = clStoppedTrainInFront;
    }
    else if(ColourNumber == 13)
    {
        BackgroundColour = clTRSBackground;
    }
    else if(ColourNumber == 14)
    {
        BackgroundColour = clTrainFailedBackground; // added at v2.4.0

    }
    // additional data
    SetHeadCodeGraphics(1, HeadCode);
    // sets the BackgroundColour to the loaded value
    bool ForwardHeadCode = Utilities->LoadFileBool(InFile);

    if(ForwardHeadCode)
    {
        for(int x = 0; x < 4; x++)
        {
            HeadCodePosition[x] = HeadCodeGrPtr[x];
        }
    }
    else
    {
        for(int x = 0; x < 4; x++)
        {
            HeadCodePosition[x] = HeadCodeGrPtr[3 - x];
        }
    }
    // if crashed & in timetable mode then change FrontCodePtr to black, if in signaller mode then change to blue whether crashed or not
    if(TrainMode == Timetable)
    {
        if(Crashed)
        {
            RailGraphics->ChangeForegroundColour2(0, HeadCodePosition[0], FrontCodePtr, clB0G0R0, BackgroundColour);
        }
        else
        {
            RailGraphics->ChangeForegroundColour2(1, HeadCodePosition[0], FrontCodePtr, clFrontCodeTimetable, BackgroundColour);
        }
    }
    else
    {
        RailGraphics->ChangeForegroundColour2(2, HeadCodePosition[0], FrontCodePtr, clFrontCodeSignaller, BackgroundColour);
    }
    HeadCodePosition[0] = FrontCodePtr;
    // pick up background bitmaps, none if MidLag as no train plotted - entering at continuation
    if(Straddle == LeadMid)
    {
        if(LeadElement > -1)
        {
            PickUpBackgroundBitmap(6, HOffset[0], VOffset[0], LeadElement, LeadEntryPos, BackgroundPtr[0]);
        }
        if(LeadElement > -1)
        {
            PickUpBackgroundBitmap(7, HOffset[1], VOffset[1], LeadElement, LeadEntryPos, BackgroundPtr[1]);
        }
        if(MidElement > -1)
        {
            PickUpBackgroundBitmap(8, HOffset[2], VOffset[2], MidElement, MidEntryPos, BackgroundPtr[2]);
        }
        if(MidElement > -1)
        {
            PickUpBackgroundBitmap(9, HOffset[3], VOffset[3], MidElement, MidEntryPos, BackgroundPtr[3]);
        }
    }
    else if(Straddle == LeadMidLag)
    {
        if(LeadElement > -1)
        {
            PickUpBackgroundBitmap(10, HOffset[0], VOffset[0], LeadElement, LeadEntryPos, BackgroundPtr[0]);
        }
        if(MidElement > -1)
        {
            PickUpBackgroundBitmap(11, HOffset[1], VOffset[1], MidElement, MidEntryPos, BackgroundPtr[1]);
        }
        if(MidElement > -1)
        {
            PickUpBackgroundBitmap(12, HOffset[2], VOffset[2], MidElement, MidEntryPos, BackgroundPtr[2]);
        }
        if(LagElement > -1)
        {
            PickUpBackgroundBitmap(13, HOffset[3], VOffset[3], LagElement, LagEntryPos, BackgroundPtr[3]);
        }
    }
    int TrainDataEntryValue = Utilities->LoadFileInt(InFile);

    TrainDataEntryPtr = &(TrainController->TrainDataVector.at(0)) + TrainDataEntryValue;
    int ActionVectorEntryValue = Utilities->LoadFileInt(InFile);

    ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0)) + ActionVectorEntryValue;

    // need to set the TrainID if arriving at a continuation but hasn't been plotted yet
    if(LeadElement > -1)
    // need to include this in case train exiting & no lead element
    {
        if(Track->TrackElementAt(667, LeadElement).TrackType == Continuation)
        {
            Track->TrackElementAt(668, LeadElement).TrainIDOnElement = TrainID; // no need to stop gap flashing if a continuation
        }
    }
    AValue = sqrt(2 * PowerAtRail / Mass);

    AnsiString LocationAndMarker = Utilities->LoadFileString(InFile);

    // possible RestoreTimetableLocation + Marker, where Marker is
    // "*****0" for !StoppedWithoutPower and "*****1" otherwise (from v2.4.0)
    // Note: including RestoreTimetableLocation with the marker is to correct an oversight - RestoreTimetableLocation should have been saved earlier
    // added at beta v0.2e
    if((LocationAndMarker[1] != '*') && (LocationAndMarker.Length() > 6))
    // name not allowed to include the '*' character
    {
        AnsiString Location = LocationAndMarker.SubString(1, LocationAndMarker.Length() - 6);
        bool GiveMessagesFalse = false;
        bool CheckLocationsExistInRailwayTrue = true;
        if(TrainController->CheckLocationValidity(3, Location, GiveMessagesFalse, CheckLocationsExistInRailwayTrue))
        {
            // otherwise take no action
            RestoreTimetableLocation = Location;
        }
    }
    AnsiString Marker = LocationAndMarker.SubString(LocationAndMarker.Length() - 5, 6);

    StoppedWithoutPower = false;
    if(Marker[6] == '1')
    {
        StoppedWithoutPower = true;
    }
    Utilities->CallLogPop(1458);
}

// ---------------------------------------------------------------------------

bool TTrain::CheckOneSessionTrain(std::ifstream &InFile)
{
    if(!Utilities->CheckFileStringZeroDelimiter(InFile))
    {
        return(false); // HeadCode

    }
    if(!Utilities->CheckFileInt(InFile, 0, 1000000))
    {
        return(false); // RearStartElement

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // RearStartExitPos

    }
    if(!Utilities->CheckFileInt(InFile, 0, MaximumSpeedLimit))
    {
        return(false); // StartSpeed

    }
    if(!Utilities->CheckFileInt(InFile, 0, MaximumSpeedLimit))
    {
        return(false); // SignallerMaxSpeed

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // HoldAtLocationInTTMode

    }
    if(!Utilities->CheckFileInt(InFile, 0, 5760))
    {
        return(false); // RepeatNumber (max 96 x 60 at 1 min intervals)

    }
    if(!Utilities->CheckFileInt(InFile, 0, 5760))
    {
        return(false); // IncrementalMinutes (max 96 x 60)

    }
    if(!Utilities->CheckFileInt(InFile, 0, 1000000))
    {
        return(false); // IncrementalDigits

    }
    if(!Utilities->CheckFileInt(InFile, 0, 10000000))
    {
        return(false); // Mass

    }
    if(!Utilities->CheckFileInt(InFile, 0, 100000000))
    {
        return(false);
    }
    // FrontElementSpeedLimit - changed at v2.1.0 - effectively
    // not checked so as to allow for legacy session files, for new session files limit is set when loaded, see above
    if(!Utilities->CheckFileInt(InFile, 0, 10000000))
    {
        return(false); // FrontElementLength

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // EntrySpeed

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // ExitSpeedHalf

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // ExitSpeedFull

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // TimetableMaxRunningSpeed

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // MaxRunningSpeed

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // MaxExitSpeed

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // MaxBrakeRate

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // BrakeRate

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // PowerAtRail

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // FirstHalfMove

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // OneLengthAccelDecel

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(EntryTime)

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(ExitTimeHalf)

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(ExitTimeFull)

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(ReleaseTime)

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(TRSTime)

    }
    if(!Utilities->CheckFileDouble(InFile))
    {
        return(false); // double(LastActionTime)

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // CallingOnFlag

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // BeingCalledOn

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // DepartureTimeSet

    }
    if(!Utilities->CheckFileInt(InFile, 0, 2))
    {
        return(false); // (short)TrainMode

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // TimetableFinished

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // LastActionDelayFlag

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // SignallerRemoved

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // TerminatedMessageSent

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // Derailed

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // DerailPending

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // Crashed

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // StoppedAtBuffers

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // StoppedAtSignal

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // StoppedAtLocation

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // SignallerStopped

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // StoppedAfterSPAD

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // StoppedForTrainInFront

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // NotInService

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // Plotted

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // TrainGone

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // SPADFlag

    }
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // TimeTimeLocArrived

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // HOffset[0]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // HOffset[1]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // HOffset[2]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // HOffset[3]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // VOffset[0]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // VOffset[1]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // VOffset[2]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 15))
    {
        return(false); // VOffset[3]

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // PlotElement[0]

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // PlotElement[1]

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // PlotElement[2]

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // PlotElement[3]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // PlotEntryPos[0]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // PlotEntryPos[1]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // PlotEntryPos[2]

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // PlotEntryPos[3]

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // TrainCrashedInto

    }
    if(!Utilities->CheckFileInt(InFile, 0, 2))
    {
        return(false); // (short)Straddle

    }
    if(!Utilities->CheckFileInt(InFile, 0, 1000000))
    {
        return(false); // NextTrainID

    }
    if(!Utilities->CheckFileInt(InFile, 0, 1000000))
    {
        return(false); // TrainID

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // LeadElement

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // LeadEntryPos

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // LeadExitPos

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // MidElement

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // MidEntryPos

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // MidExitPos

    }
    if(!Utilities->CheckFileInt(InFile, -1, 1000000))
    {
        return(false); // LagElement

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // LagEntryPos

    }
    if(!Utilities->CheckFileInt(InFile, 0, 3))
    {
        return(false); // LagExitPos

    }
    if(!Utilities->CheckFileInt(InFile, 0, 14))
    {
        return(false);
    }
    // Background colour number  //14 is failed colour at v2.4.0
    if(!Utilities->CheckFileBool(InFile))
    {
        return(false); // ForwardHeadCode

    }
    if(!Utilities->CheckFileInt(InFile, 0, 10000))
    {
        return(false); // TrainDataEntryValue

    }
    if(!Utilities->CheckFileInt(InFile, 0, 10000))
    {
        return(false); // ActionVectorEntryValue

    }
    if(!Utilities->CheckFileStringZeroDelimiter(InFile))
    {
        return(false); // End of train marker + possible RestoreTimetableLocation

    }
    // and StoppedWithoutPower flag
    return(true);
}

// ---------------------------------------------------------------------------

void TTrain::PlotTrainInZoomOutMode(int Caller, bool Flash)
{
    // order below reflects significance so earlier shows first, as may have more than one flag set
    // only plot flashing trains when Flash is true

/*
     clCrashedBackground     (TColor)0x0000FF red
     clDerailedBackground    (TColor)0x0000FF red
     clSPADBackground        (TColor)0x00FFFF yellow
     clTrainFailedBackground (TColor)0x0066FF orange        new at v2.4.0
     clCallOnBackground      (TColor)0xFF33FF light magenta
     clSignalStopBackground  (TColor)0x00FF66 green
     clBufferAttentionNeeded (TColor)0xFFFF00 cyan
     clStationStopBackground (TColor)0xCCFFCC pale green
     clTRSBackground         (TColor)0xFFCCFF light pink
     clBufferStopBackground  (TColor)0xFFFFCC pale cyan
     clStoppedTrainInFront   (TColor)0xFF9999 lavender blue
     clSignallerStopped      (TColor)0x99CCFF caramel
     clNormalBackground      (TColor)0xCCCCCC grey
*/

    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotTrainInZoomOutMode" + "," + HeadCode);
    bool HideFlashingTrain = true;
    // hide it when Flash false so it blinks on and off
    // if don't hide it it stays displayed all the time
    Graphics::TBitmap *SmallTrainBitmap;

    // NB ensure retain same order as zoomed in order so colours correspond
    if(BackgroundColour == clCrashedBackground)
    {
        TrainController->CrashWarning = true;
        SmallTrainBitmap = RailGraphics->smRed;
    }
    else if(BackgroundColour == clDerailedBackground)
    {
        TrainController->DerailWarning = true;
        SmallTrainBitmap = RailGraphics->smRed;
    }
    else if(BackgroundColour == clSPADBackground)
    {
        TrainController->SPADWarning = true;
        SmallTrainBitmap = RailGraphics->smYellow;
    }
    else if(BackgroundColour == clTrainFailedBackground)
    {
        TrainController->TrainFailedWarning = true;
        SmallTrainBitmap = RailGraphics->smOrange;
    }
    else if(BackgroundColour == clCallOnBackground)
    {
        TrainController->CallOnWarning = true;
        SmallTrainBitmap = RailGraphics->smMagenta;
    }
    else if(BackgroundColour == clSignalStopBackground)
    {
        TrainController->SignalStopWarning = true;
        SmallTrainBitmap = RailGraphics->smBrightGreen;
    }
    else if(BackgroundColour == clBufferAttentionNeeded)
    {
        TrainController->BufferAttentionWarning = true;
        SmallTrainBitmap = RailGraphics->smCyan;
    }
    else if((BackgroundColour == clStationStopBackground) || (BackgroundColour == clTRSBackground))
    {
        SmallTrainBitmap = RailGraphics->smPaleGreen;
        HideFlashingTrain = false;
    }
    else if(BackgroundColour == clBufferStopBackground)
    {
        SmallTrainBitmap = RailGraphics->smCyan;
        HideFlashingTrain = false;
    }
    else if(BackgroundColour == clStoppedTrainInFront)
    {
        SmallTrainBitmap = RailGraphics->smLightBlue;
        HideFlashingTrain = false;
    }
    else if(BackgroundColour == clSignallerStopped)
    {
        SmallTrainBitmap = RailGraphics->smCaramel;
        HideFlashingTrain = false;
    }
    else
    {
        SmallTrainBitmap = RailGraphics->smBlack; // moving
        HideFlashingTrain = false;
    }
    // now plot the new train
    // just plot lead & mid, unless lead == -1 in which case plot mid & lag
    if((LeadElement > -1) && (!HideFlashingTrain || Flash))
    {
        Display->PlotSmallOutput(4, Track->TrackElementAt(441, LeadElement).HLoc * 4, Track->TrackElementAt(442, LeadElement).VLoc * 4, SmallTrainBitmap);
    }
    if((MidElement > -1) && (!HideFlashingTrain || Flash))
    {
        Display->PlotSmallOutput(5, Track->TrackElementAt(443, MidElement).HLoc * 4, Track->TrackElementAt(444, MidElement).VLoc * 4, SmallTrainBitmap);
    }
    if((LeadElement == -1) && (LagElement > -1) && (!HideFlashingTrain || Flash))
    {
        Display->PlotSmallOutput(6, Track->TrackElementAt(445, LagElement).HLoc * 4, Track->TrackElementAt(446, LagElement).VLoc * 4, SmallTrainBitmap);
    }
    OldZoomOutElement[0] = LeadElement;
    OldZoomOutElement[1] = MidElement;
    OldZoomOutElement[2] = LagElement;
    Utilities->CallLogPop(1459);
}

// ---------------------------------------------------------------------------

void TTrain::UnplotTrainInZoomOutMode(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UnplotTrainInZoomOutMode," + AnsiString(TrainID) + "," + HeadCode);
    if(!Display->ZoomOutFlag)
    {
        Utilities->CallLogPop(1304);
        return;
    }
    for(int y = 0; y < 3; y++)
    {
        if(OldZoomOutElement[y] > -1)
        {
            bool FoundFlag = false;
            TTrackElement ATElement = Track->TrackElementAt(717, OldZoomOutElement[y]);
            TTrackElement IATElement1, IATElement2;
            // default elements to begin with
            Display->PlotSmallOutput(7, ATElement.HLoc * 4, ATElement.VLoc * 4, RailGraphics->smSolidBgnd); // plot the blank
            TTrack::TIMPair IMPair = Track->GetVectorPositionsFromInactiveTrackMap(14, ATElement.HLoc, ATElement.VLoc, FoundFlag);
            // Note, have to plot inactives before track because track has to overwrite NamedLocationElements
            if(FoundFlag)
            {
                IATElement1 = Track->InactiveTrackElementAt(87, IMPair.first);
                Display->PlotSmallOutput(8, IATElement1.HLoc * 4, IATElement1.VLoc * 4, IATElement1.SmallGraphicPtr);
                if(IMPair.first != IMPair.second)
                {
                    IATElement2 = Track->InactiveTrackElementAt(88, IMPair.second);
                    Display->PlotSmallOutput(9, IATElement2.HLoc * 4, IATElement2.VLoc * 4, IATElement2.SmallGraphicPtr);
                }
            }
            Display->PlotSmallOutput(10, ATElement.HLoc * 4, ATElement.VLoc * 4, ATElement.SmallGraphicPtr);
        }
    }
    Utilities->CallLogPop(1305);
}

// ---------------------------------------------------------------------------

bool TTrain::TrainAtLocation(int Caller, AnsiString &LocationName)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainAtLocation" + "," + HeadCode);
    LocationName = "";
    if(!RevisedStoppedAtLoc())
    {
        Utilities->CallLogPop(1398);
        return(false);
    }
    if(LeadElement > -1)
    {
        LocationName = Track->TrackElementAt(681, LeadElement).ActiveTrackElementName;
    }
    if((LocationName == "") && (MidElement > -1))
    {
        LocationName = Track->TrackElementAt(682, MidElement).ActiveTrackElementName;
    }
    if((LocationName == "") && (LagElement > -1))
    {
        LocationName = Track->TrackElementAt(683, LagElement).ActiveTrackElementName;
    }
    if(LocationName == "")
    {
        throw Exception("Error - Location name not set in TrainAtLocation");
    }
    Utilities->CallLogPop(1399);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrain::PlotTrain(int Caller, TDisplay *Disp)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotTrain" + "," + HeadCode);
    for(int x = 0; x < 4; x++)
    {
        PlotTrainGraphic(7, x, Disp);
    }
    Utilities->CallLogPop(647);
}

// ---------------------------------------------------------------------------

void TTrain::WriteTrainToImage(int Caller, Graphics::TBitmap *Bitmap)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",WriteTrainToImage" + "," + HeadCode);
    for(int x = 0; x < 4; x++)
    {
        if(PlotElement[x] > -1)
        {
            Bitmap->Canvas->Draw(((Track->TrackElementAt(744, PlotElement[x]).HLoc - Track->GetHLocMin()) * 16 + HOffset[x]),
                                 ((Track->TrackElementAt(745, PlotElement[x]).VLoc - Track->GetVLocMin()) * 16 + VOffset[x]), HeadCodePosition[x]);
        }
    }
    Utilities->CallLogPop(1708);
}

// ---------------------------------------------------------------------------

bool TTrain::LinkOccupied(int Caller, int TrackVectorPosition, int LinkNumber) // added at v1.2.0
{
    // return true for any part of train occupying LinkNumber at TrackVectorPosition, false for anything else, including no LinkNumber & no TrackVectorPosition
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LinkOccupied," + AnsiString(TrackVectorPosition) + "," +
                                 AnsiString(LinkNumber) + "," + HeadCode);

/* Note on Straddle:  Straddle defines the actual train position wrt Lag, Mid & Lead elements at all times other than within UpdateTrain.  Is only MidLag outside UpdateTrain
      on first entry at a continuation (with no train plotted), and that has no relevance here. In all other cases it is either LeadMid (when train fully
      on Lead & Mid elements) or LeadMidLag (when train straddling 3 elements).
*/

    // note that MidElement always fully occupied
    if((MidElement == TrackVectorPosition) && ((Track->TrackElementAt(883, TrackVectorPosition).Link[MidEntryPos] == LinkNumber) || (Track->TrackElementAt(884,
                                                                                                                                                           TrackVectorPosition).Link[MidExitPos] == LinkNumber)))
    {
        Utilities->CallLogPop(2005);
        return(true);
    }
    if(Straddle == LeadMid)
    {
        if((LeadElement == TrackVectorPosition) && ((Track->TrackElementAt(885, TrackVectorPosition).Link[LeadEntryPos] == LinkNumber) ||
                                                    (Track->TrackElementAt(886, TrackVectorPosition).Link[LeadExitPos] == LinkNumber)))
        {
            Utilities->CallLogPop(2006);
            return(true);
        }
    }
    else if(Straddle == LeadMidLag)
    {
        if((LeadElement == TrackVectorPosition) && (Track->TrackElementAt(887, TrackVectorPosition).Link[LeadEntryPos] == LinkNumber))
        // only interested in LeadEntryPos as train not occupying ExitPos yet
        {
            Utilities->CallLogPop(2007);
            return(true);
        }
        else if((LagElement == TrackVectorPosition) && (Track->TrackElementAt(888, TrackVectorPosition).Link[LagExitPos] == LinkNumber))
        // only interested in LagExitPos as train has left EntryPos
        {
            Utilities->CallLogPop(2008);
            return(true);
        }
    }
    Utilities->CallLogPop(2009);
    return(false);
}

// ---------------------------------------------------------------------------

float TTrain::CalcTimeToAct(int Caller, float &TimeToExit, THVShortPair &ExitPair) // only called for running trains.
///New v2.2.0 for operator action panel.  Calls CalcDistanceToRedSignal and uses the current speed to estimate
///the time in minutes assuming a constant deceleration rate to it.  If a buffer, continuation, stopping location, an autosignal
///route after the next red signal, service finished or train being called on, then -1 is returned to signal that there is to be no display for that train.
///If stopped at a location the time is still calculated assuming a speed of 30km/h and the time to start added to it.
// TimeToExit & ExitPair added for multiplayer
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CalcTimeToAct, " + HeadCode);
    int DistanceToRedSignal = 0, DistanceToExit = -1;
    float TimeToAct = 0, LastTimeToExit = TimeToExit;
    TimeToExit = -1;
    ExitPair.first = -1;
    ExitPair.second = -1;
    float MinsEarly = 0;  //added at v2.6.1
    TDateTime DepartureTime; //added at v2.6.1  //ArrivalTime used instead of this at v2.9.0 but still calculate it in case need it later for some reason
    TDateTime ArrivalTime; //added at v2.9.0 as MinsEarly used DepartureTime which wasn't correct
    float TempTTE;

    if(TrainFailed)
    {
        Utilities->CallLogPop(2147);
        return(0); // time to act now, time to exit set above
    }
    if(SignallerStopped)
    {
        Utilities->CallLogPop(2080);
        return(-1); //time to exit set above
    }
    if(BeingCalledOn) //added at v2.7.0 so zero time to act cancelled right away
    {
        Utilities->CallLogPop(2266);
        return(-1); // time to exit set above
    }

    // check if exiting at a continuation, if so there's no action time needed but still need exit time  & ExitPair
    if((LeadElement == -1) && (MidElement == -1) && (LagElement > -1) && (Track->TrackElementAt(1411, LagElement).TrackType == Continuation)
            /*&& (ExitSpeedFull > 1)*/) //LagElement is the exit       //ExitSpeedFull removed at v2.12.0 because of Cameron Neasom's error 28/01/22 - braking as entered continuation
    {
        if(Straddle == LeadMidLag) //only half of rear train element on exit, 0.5 lengths to exit
        {
            if(ExitSpeedFull > 0) //added at v2.12.0 because of Cameron Neasom's error 28/01/22
            {
                TempTTE = (0.5 * Track->TrackElementAt(1412, LagElement).Length01) * 3.6 / 60 / ExitSpeedFull;
                if(TempTTE < LastTimeToExit)
                {
                    TimeToExit = TempTTE; //else leave as is, don't want a sudden increase in time
                }
                else
                {
                    TimeToExit = LastTimeToExit;
                }
            }
            else
            {
                TimeToExit = LastTimeToExit;
            }
            ExitPair.first = Track->TrackElementAt(1413, LagElement).HLoc;
            ExitPair.second = Track->TrackElementAt(1414, LagElement).VLoc;
            Utilities->CallLogPop(2342);
            return(-1);
        }
        else
        {
            TimeToExit = 0; //all train exited
            ExitPair.first = Track->TrackElementAt(1415, LagElement).HLoc;
            ExitPair.second = Track->TrackElementAt(1416, LagElement).VLoc;
            Utilities->CallLogPop(2343);
            return(-1);
        }
    }
    if((LeadElement == -1) && (MidElement > -1) && (Track->TrackElementAt(1417, MidElement).TrackType == Continuation)/* && (ExitSpeedFull > 1)*/)
    //here MidElement is the exit  //ExitSpeedFull removed at v2.12.0 because of Cameron Neasom's error 28/01/22 - braking as entered continuation
    {
        if(Straddle == LeadMidLag) //front element of train half off the exit, 1.5 lengths to exit
        {
            if(ExitSpeedFull > 0) //added at v2.12.0 because of Cameron Neasom's error 28/01/22
            {
                TempTTE = (1.5 * Track->TrackElementAt(1418, MidElement).Length01) * 3.6 / 60 / ExitSpeedFull;
                if(TempTTE < LastTimeToExit)
                {
                    TimeToExit = TempTTE; //else leave as is, don't want a sudden increase in time
                }
                else
                {
                    TimeToExit = LastTimeToExit;
                }
            }
            else
            {
                TimeToExit = LastTimeToExit;
            }
            ExitPair.first = Track->TrackElementAt(1419, MidElement).HLoc;
            ExitPair.second = Track->TrackElementAt(1420, MidElement).VLoc;
            Utilities->CallLogPop(2344);
            return(-1);
        }
        else //front element of train fully off the exit, one length to exit
        {
            if(ExitSpeedFull > 0) //added at v2.12.0 because of Cameron Neasom's error 28/01/22
            {
                TempTTE = (Track->TrackElementAt(1421, MidElement).Length01) * 3.6 / 60 / ExitSpeedFull;
                if(TempTTE < LastTimeToExit)
                {
                    TimeToExit = TempTTE; //else leave as is, don't want a sudden increase in time
                }
                else
                {
                    TimeToExit = LastTimeToExit;
                }
            }
            else
            {
                TimeToExit = LastTimeToExit;
            }
            ExitPair.first = Track->TrackElementAt(1422, MidElement).HLoc;
            ExitPair.second = Track->TrackElementAt(1423, MidElement).VLoc;
            Utilities->CallLogPop(2345);
            return(-1);
        }
    }
    if(LeadElement > -1)
    {
        if((Track->TrackElementAt(1424, LeadElement).Conn[LeadExitPos] == -1) && (Track->TrackElementAt(1425, LeadElement).TrackType == Continuation)
               /* && (ExitSpeedFull > 1)*/) //LeadElement is the exit.  If LeadMidLag have lead half on exit or if LeadMid have lead full on exit
        {                               //if LeadMidLag have 2.5 lengths to exit, else have 2 lengths to exit
                                        //ExitSpeedFull removed at v2.12.0 because of Cameron Neasom's error 28/01/22 - braking as entered continuation
            if(Straddle == LeadMidLag)
            {
                if(ExitSpeedFull > 0) //added at v2.12.0 because of Cameron Neasom's error 28/01/22
                {
                    TempTTE = (2.5 * Track->TrackElementAt(1426, LeadElement).Length01) * 3.6 / 60 / ExitSpeedFull;
                    if(TempTTE < LastTimeToExit)
                    {
                        TimeToExit = TempTTE; //else leave as is, don't want a sudden increase in time
                    }
                    else
                    {
                        TimeToExit = LastTimeToExit;
                    }
                }
                else
                {
                    TimeToExit = LastTimeToExit;
                }
                ExitPair.first = Track->TrackElementAt(1427, LeadElement).HLoc;
                ExitPair.second = Track->TrackElementAt(1428, LeadElement).VLoc;
                Utilities->CallLogPop(2346);
                return(-1);
            }
            else
            {
                if(ExitSpeedFull > 0) //added at v2.12.0 because of Cameron Neasom's error 28/01/22
                {
                    TempTTE = (2 * Track->TrackElementAt(1429, LeadElement).Length01) * 3.6 / 60 / ExitSpeedFull;
                    if(TempTTE < LastTimeToExit)
                    {
                        TimeToExit = TempTTE; //else leave as is, don't want a sudden increase in time
                    }
                    else
                    {
                        TimeToExit = LastTimeToExit;
                    }
                }
                else
                {
                    TimeToExit = LastTimeToExit;
                }
                ExitPair.first = Track->TrackElementAt(1430, LeadElement).HLoc;
                ExitPair.second = Track->TrackElementAt(1431, LeadElement).VLoc;
                Utilities->CallLogPop(2347);
                return(-1);
            }
        }
    }
//here if LeadElement > -1 and its forward connection also > -1

    // calc distance to next red signal
    if(!Stopped() || RevisedStoppedAtLoc())
    {
        int FirstPosToBeMeasured = Track->TrackElementAt(953, LeadElement).Conn[LeadExitPos];
        int FirstEntryPos = Track->TrackElementAt(954, LeadElement).ConnLinkPos[LeadExitPos];
        if((Straddle == LeadMidLag) && (TrainMode == Timetable))
/* In TTMode it's important to set the first element to be measured ahead of the lead element only when the train fully on
                  2 elements. Otherwise, if the train is only half on the lead element and approaching a station stop where the platform doesn't
                  extend beyond the lead element stop point, the element ahead of the lead element is not a location whereas the ActionVector
                  still points to the station stop location.  In these circumstances the train hasn't yet stopped, so the dwell time at the
                  stop isn't calculated, and the station to be stopped at isn't found as a future stop and nor are any other future stops
                  because the ActionVector name never matches a future station.  Hence all dwell times are omitted until the train lands fully
                  on two elements.  To avoid this when Straddle is LeadMidLag the first element to be measured is set to the lead element, so
                  before the train has stopped the current station is still recognised as a future stop.
                  In signaller mode stops don't count, and if pass stop signal command is given then when have LeadMidLag the current element
                  becomes the signal, and the time to act indication becomes 'NOW'.
*/
        {
            FirstPosToBeMeasured = LeadElement;
            FirstEntryPos = LeadEntryPos;
        }
        float CurrentStopTime; // set to 0 at start of function
        float LaterStopTime; // set to 0 at start of function
        float RecoverableTime; // set to 0 at start of function
        int AvTrackSpeed; // set to zero at start of function
        bool SigControlAndCanPassRedSignal = ((TrainMode == Signaller) && AllowedToPassRedSignal);
        DistanceToRedSignal = TrainController->CalcDistanceToRedSignalandStopTime(0, FirstPosToBeMeasured, FirstEntryPos, SigControlAndCanPassRedSignal,
                              ActionVectorEntryPtr, HeadCode, TrainID, CurrentStopTime, LaterStopTime, RecoverableTime, AvTrackSpeed, DistanceToExit, ExitPair);
//at this point can't have both DistanceToRedSignal and DistanceToExit both set.  Either both will be unset (-1) or one will be set.
//Therefore since need to calculate the time for each in the same way use a generic

        if((DistanceToRedSignal == -1) && (DistanceToExit == -1))// both unset so no action needed
        {
            TimeToExit = -1;
            Utilities->CallLogPop(2076);
            return(-1);
        }
//else one or other is set
        bool DistanceToRedSignalSet = (DistanceToRedSignal > -1);
        bool DistanceToExitSet = (DistanceToExit > -1);
        int GenericDistance = DistanceToRedSignal;
        if(DistanceToExitSet)
        {
            GenericDistance = DistanceToExit;
        }
/* Have     MinsDelayed;        pos or neg,
        CurrentStopTime;    pos or zero
        LaterStopTime;      pos or zero
        RecoverableTime;    pos or zero

        & from these calculate TotalStopTime. noting that:
        If stopped CurrentStopTime automatically adjusts for all early running and for as much late running as possible
        RecoverableTime always < LaterStopTime or both zero
        can't subtract more than RecoverableTime (MinsDelayed > 0)
        only subtract from LaterStopTime, not CurrentTime (MinsDelayed > 0)
        only subtract from LaterStopTime if LaterStopTime > 0 (MinsDelayed > 0)
        only add to LaterStopTime if LaterStopTime > 0 (MinsDelayed < 0)
        if running early & stopped at location CurrentStopTime will automatically include the excess
*/
        float TimeToSubtract, TotalStopTime;
        if(MinsDelayed > RecoverableTime)
        {
            TimeToSubtract = RecoverableTime;
        }
        else
        {
            TimeToSubtract = MinsDelayed; // may be negative;
        }
        if((AvTrackSpeed > 0) && (DistanceToStationStop <= GenericDistance) && (DistanceToStationStop > 0)) //protection against div by zero, not needed of no stop
        //before red signal, DistanceToStationStop != 0 as set to 0 if invalid
        //added at v2.6.1, DistanceToStationStop is calculated in SetTrainMovementValues, AvTrackSpeed is average to next red signal, but should be ok to use for
        //next station stop
        //after 2.7.0 changed (DistanceToStationStop < DistanceToRedSignal) to (DistanceToStationStop <= DistanceToRedSignal) because often have departure signal
        //next to the stop platform and if so the two distances are the same and the station stop time isn't included. Also after 2.7.0 used GetRepeatTime... to calc
        //departure time because ActionVectorEntryPtr->DepartureTime is the base time and therefore incorrect for repeats.
        //first find departure time from the next stop
        //at v2.9.0 changed MinsEarly calc to use ArrivalTime instead of departure time
        {
            if(ActionVectorEntryPtr->FormatType == TimeTimeLoc) //if already arrived then MinsEarly will be < 0 so becomes set to 0
            {
                ArrivalTime = TrainController->GetRepeatTime(71, ActionVectorEntryPtr->ArrivalTime, RepeatNumber, IncrementalMinutes);
                DepartureTime = TrainController->GetRepeatTime(69, ActionVectorEntryPtr->DepartureTime, RepeatNumber, IncrementalMinutes);
                MinsEarly = (double(ArrivalTime - TrainController->TTClockTime) * 86400 / 60) - (DistanceToStationStop * 3.6 / 60 / AvTrackSpeed);
            }
            else if((ActionVectorEntryPtr->FormatType == TimeLoc) && (ActionVectorEntryPtr->ArrivalTime != TDateTime(-1))) // not arrived yet
            {
                ArrivalTime = TrainController->GetRepeatTime(72, ActionVectorEntryPtr->ArrivalTime, RepeatNumber, IncrementalMinutes);
                MinsEarly = (double(ArrivalTime - TrainController->TTClockTime) * 86400 / 60) - (DistanceToStationStop * 3.6 / 60 / AvTrackSpeed);
                if((ActionVectorEntryPtr + 1)->FormatType == TimeLoc)
                {
                    // must be a departure
                    DepartureTime = TrainController->GetRepeatTime(70, (ActionVectorEntryPtr + 1)->DepartureTime, RepeatNumber, IncrementalMinutes);
                }
            }
            else if((ActionVectorEntryPtr->FormatType == TimeLoc) && (ActionVectorEntryPtr->ArrivalTime == TDateTime(-1))) //already arrived
            {
                MinsEarly = 0;
            }
            if(MinsEarly < 0)
            {
                MinsEarly = 0;
            }
        }
        if(MinsDelayed < 0) // MinsDelayed < 0 means have arrived early at a station
        {
            if(CurrentStopTime > 0)
            {
                TotalStopTime = CurrentStopTime + LaterStopTime;
            }
            // stopped at loc, will depart on time
            else
            {
                TotalStopTime = LaterStopTime - MinsDelayed;
            }
            // not stopped, will depart on time at first later stop so add the delay
        }
        else if((MinsEarly > 0) && !Stopped()) //running early
        {
            TotalStopTime = LaterStopTime + MinsEarly;
        }
        else // on time or running late
        {
            if(LaterStopTime == 0)
            {
                TotalStopTime = CurrentStopTime;
            }
            // no later stops, if stopped now will depart as soon as possible,
            // if not stopped no stop times to add
            else
            {
                TotalStopTime = CurrentStopTime + LaterStopTime - TimeToSubtract; // later stops so deduct as much as can
            }
        }
        if(AvTrackSpeed < 30)
        {
            AvTrackSpeed = 30;
        }
        int Speed = AvTrackSpeed;
        if(AvTrackSpeed > int(MaxRunningSpeed))
        {
            Speed = int(MaxRunningSpeed);
        }
        if(TrainMode == Signaller)
        {
            Speed = SignallerMaxSpeed;
            TotalStopTime = 0;
        }
        if(DistanceToRedSignalSet)
        {
            TimeToAct = TotalStopTime + GenericDistance * 3.6 / 60 / Speed;
            // accel & decel taken into account in
            // CalcDistanceToRedSignalandStopTime
            // 3.6 convertsKm/h to m/s & 60 converts seconds to minutes
            TimeToExit = -1;
            Utilities->CallLogPop(2079);
            return(TimeToAct);
        }
        else //DistanceToExitSet must be true
        {
            TimeToExit = TotalStopTime + GenericDistance * 3.6 / 60 / Speed;
            // accel & decel taken into account in
            // CalcDistanceToRedSignalandStopTime
            // 3.6 convertsKm/h to m/s & 60 converts seconds to minutes
            Utilities->CallLogPop(2370);
            return(-1); //no red signal so no time to act
        }
    }
    else // stopped not at location
    {
        if(Crashed || Derailed || StoppedAtBuffers || StoppedAtSignal || StoppedAfterSPAD)
        {
            TimeToAct = 0.0;
            TimeToExit = -1;
        }
        if(StoppedWithoutPower) //added at v2.13.2 as this situation was missed & time to act was 0 [If train failed then covered above]
        {
            TimeToAct = -1;
            TimeToExit = -1;
        }
        // but if stopped at a signal & autosigs route after it then ok, provided signal not failed
        if(StoppedAtSignal)
        {
            int NextElement = Track->TrackElementAt(928, LeadElement).Conn[LeadExitPos];
            int NextEntryPos = Track->TrackElementAt(929, LeadElement).ConnLinkPos[LeadExitPos];
            bool NextElementFailed = Track->TrackElementAt(1548, NextElement).Failed; //added at v2.13.2
            int NextExitPos;
            if(Track->TrackElementAt(930, NextElement).TrackType == Points)
            {
                if((NextEntryPos == 0) || (NextEntryPos == 2))
                // leading entry point
                {
                    if(Track->TrackElementAt(931, NextElement).Attribute == 0)
                    {
                        NextExitPos = 1;
                    }
                    else
                    {
                        NextExitPos = 3;
                    }
                }
                else
                {
                    NextExitPos = 0; // trailing entry point
                }
            }
            else
            {
                NextExitPos = Track->GetNonPointsOppositeLinkPos(NextEntryPos);
            }
            int NextButOneElement = Track->TrackElementAt(932, NextElement).Conn[NextExitPos];
            int NextButOneEntryPos = Track->TrackElementAt(933, NextElement).ConnLinkPos[NextExitPos];
            int RouteNumber; // holder for referenced value, not used
            if((AllRoutes->GetRouteTypeAndNumber(32, NextButOneElement, NextButOneEntryPos, RouteNumber) == TAllRoutes::AutoSigsRoute) && !NextElementFailed)
            {                                                                                                   //NextElementFailed added at v2.13.2
                TimeToAct = -1;
                TimeToExit = -1;
            }
        }
        Utilities->CallLogPop(2074);
        return(TimeToAct);
    }
}

// ---------------------------------------------------------------------------

bool TTrain::TrainOnContinuation(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainOnContinuation, " + HeadCode);
    if(LeadElement > -1)
    {
        if(Track->TrackElementAt(976, LeadElement).TrackType == Continuation)
        {
            Utilities->CallLogPop(2148);
            return(true);
        }
    }
    if(MidElement > -1)
    {
        if(Track->TrackElementAt(977, MidElement).TrackType == Continuation)
        {
            Utilities->CallLogPop(2149);
            return(true);
        }
    }
    if(LagElement > -1)
    {
        if(Track->TrackElementAt(978, LagElement).TrackType == Continuation)
        {
            Utilities->CallLogPop(2150);
            return(true);
        }
    }
    Utilities->CallLogPop(2151);
    return(false);
}

// ---------------------------------------------------------------------------
// TTrainController
// ---------------------------------------------------------------------------

TTrainController::TTrainController()
{
    OnTimeArrivals = 0;
    LateArrivals = 0;
    EarlyArrivals = 0;
    OnTimePasses = 0;
    LatePasses = 0;
    EarlyPasses = 0;
    OnTimeExits = 0; //these 3 exits added at v2.9.2 - missed in error earlier
    LateExits = 0;
    EarlyExits = 0;
    OnTimeDeps = 0;
    LateDeps = 0;
    MissedStops = 0;
    OtherMissedEvents = 0;
    UnexpectedExits = 0;
    NumFailures = 0;
    IncorrectExits = 0;
    SPADEvents = 0;
    SPADRisks = 0;
    CrashedTrains = 0;
    Derailments = 0;
    TotArrDepPass = 0;
    TotLateArrMins = 0;
    TotEarlyArrMins = 0;
    TotLatePassMins = 0;
    TotEarlyPassMins = 0;
    TotLateExitMins = 0; //added at v2.9.1
    TotEarlyExitMins = 0; //added at v2.9.1
    TotLateDepMins = 0;
    ExcessLCDownMins = 0;
    SkippedTTEvents = 0; //added at v2.11.0
    TTClockTime = 0; // added for v0.6
    SignallerTrainRemovedOnAutoSigsRoute = false;
    // added at v1.3.0 to ensure false at start
    OpTimeToActUpdateCounter = 0; // new v2.2.0
    OpActionPanelVisible = false; // new v2.2.0
    // reset all message flags, stops them being given twice (shouldn't be needed here but add for safety) //new at v2.4.0
    SSHigh = false;
    MRSHigh = false;
    MRSLow = false;
    MassHigh = false;
    BFHigh = false;
    BFLow = false;
    PwrHigh = false;
    SigSHigh = false;
    SigSLow = false;
    randomize();
    // to seed rand() & random() with a random number (see UpdateTrain)
}

// ---------------------------------------------------------------------------

TTrainController::~TTrainController()
{
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        TrainVectorAt(32, x).DeleteTrain(4);
    }
    TrainVector.clear();
}

// ---------------------------------------------------------------------------

void TTrainController::LogEvent(AnsiString Str)
{
    AnsiString FullStr = Utilities->TimeStamp() + "," + TTClockTime.FormatString("hh:nn:ss") + "," + Str;

    // restrict to last 1000 entries
    Utilities->EventLog.push_back(FullStr);
    if(Utilities->EventLog.size() > 1000)
    {
        Utilities->EventLog.pop_front();
    }
}

// ---------------------------------------------------------------------------

void TTrainController::Operate(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",Operate");
    bool ClockState = Utilities->Clock2Stopped;
    Utilities->Clock2Stopped = true;
    // new section dealing with Snt & Snt-sh additions
    // BUT don't add trains if points or route flashing [conditions added for Version 0.6 as a result of Najamuddin's error - 15/01/11] - wait until next
    // clock tick after stops flashing
    if(!Track->RouteFlashFlag && !Track->PointFlashFlag)
    {
        for(unsigned int x = 0; x < TrainDataVector.size(); x++)
        {
            TTrainDataEntry & TDEntry = TrainDataVector.at(x);
            const TActionVectorEntry &AVEntry0 = TDEntry.ActionVector.at(0);
            TActionEventType EventType = NoEvent;
            if(AVEntry0.Command == "Snt")
            {
                // calc below only for Snt & Snt-sh entries rather than all entries to save time
                const TActionVectorEntry &AVEntryLast = TDEntry.ActionVector.at(TDEntry.ActionVector.size() - 1);
                int IncrementalMinutes = 0;
                int IncrementalDigits = 0;
                if(AVEntryLast.FormatType == Repeat)
                {
                    IncrementalMinutes = AVEntryLast.RearStartOrRepeatMins;
                    IncrementalDigits = AVEntryLast.FrontStartOrRepeatDigits;
                }
                if((AVEntryLast.FormatType == Repeat) && (TDEntry.NumberOfTrains < 2))
                {
                    throw Exception("Error - Repeat entry && less than two trains for Snt entry: " + TDEntry.HeadCode);
                }
                // see above note

                for(int y = 0; y < TDEntry.NumberOfTrains; y++)
                {
                    TTrainOperatingData &TTOD = TDEntry.TrainOperatingDataVector.at(y);
                    if(TTOD.RunningEntry != NotStarted)
                    {
                        continue;
                    }

//Multiplayer: here check for a train entering at a coupling {RearStartOrRepeatMins shows if it's a coupling or not), and can only be a Snt entry
//if so and no arrival signalled yet bypass the timetabled arrival
//if so and arrival signalled then start the new service, using the repeat number and headcode for the entering train
//if a repeat is skipped then should be ok if it arrives later as its RunningEntry is still NotStarted

                    if(GetRepeatTime(2, AVEntry0.EventTime, y, IncrementalMinutes) > TTClockTime)
                    {
                        break; // all the rest will also be greater
                    }
                    AnsiString TrainHeadCode = GetRepeatHeadCode(22, TDEntry.HeadCode, y, IncrementalDigits);
                    if(AddTrain(2, AVEntry0.RearStartOrRepeatMins, AVEntry0.FrontStartOrRepeatDigits, TrainHeadCode, TDEntry.StartSpeed, TDEntry.Mass,
                                TDEntry.MaxRunningSpeed, TDEntry.MaxBrakeRate, TDEntry.PowerAtRail, "Timetable", &TDEntry, y, IncrementalMinutes, IncrementalDigits,
                                TDEntry.SignallerSpeed, AVEntry0.SignallerControl, EventType))
                    {
                        TTOD.TrainID = TrainVector.back().TrainID;
                        TTOD.RunningEntry = Running;
                    }
                    else if(EventType == FailTrainEntry)
                    {
                        break; // if a train can't enter no point checking any more repeats as they won't be able to enter either
                    }
                }
            }
            if(AVEntry0.Command == "Snt-sh")
            // just start this once, shuttle repeats take care of restarts
            {
                // calc below only for Snt & Snt-sh entries rather than all entries to save time
                const TActionVectorEntry &AVEntryLast = TDEntry.ActionVector.at(TDEntry.ActionVector.size() - 1);
                int IncrementalMinutes = 0;
                int IncrementalDigits = 0;
                if(AVEntryLast.FormatType == Repeat)
                {
                    IncrementalMinutes = AVEntryLast.RearStartOrRepeatMins;
                    IncrementalDigits = AVEntryLast.FrontStartOrRepeatDigits;
                }
                if((AVEntryLast.FormatType == Repeat) && (TDEntry.NumberOfTrains < 2))
                {
                    throw Exception("Error - Repeat entry && less than two trains for Snt-sh entry: " + TDEntry.HeadCode);
                }
                // see above note
                TTrainOperatingData &TTOD = TDEntry.TrainOperatingDataVector.at(0);
                if(TTOD.RunningEntry == NotStarted)
                {
                    if(AVEntry0.EventTime <= TTClockTime)
                    {
                        if(AddTrain(3, AVEntry0.RearStartOrRepeatMins, AVEntry0.FrontStartOrRepeatDigits, TDEntry.HeadCode, TDEntry.StartSpeed, TDEntry.Mass,
                                    TDEntry.MaxRunningSpeed, TDEntry.MaxBrakeRate, TDEntry.PowerAtRail, "Timetable", &TDEntry, 0, IncrementalMinutes, IncrementalDigits,
                                    TDEntry.SignallerSpeed, false, EventType))
                        // false for SignallerControl
                        {
                            TTOD.TrainID = TrainVector.back().TrainID;
                            TTOD.RunningEntry = Running;
                        }
                        else if(EventType == FailTrainEntry)
                        {
                            break; // if a train can't enter no point checking any more repeats as they won't be able to enter either
                        }
                    }
                }
            }
        }
    }

    // deal with running trains but abort if any vectors added, would probably be OK but don't risk a vector reallocation disrupting the
    // iteration, next cycle will catch up with any other pending updates
    if(!TrainVector.empty())
    {
        TrainAdded = false;

//elapsed time investigations

//elapsed time  segment
//double Start, End;
//AnsiString ElapsedTimeReport = "";
//end elasped time segment
        AllRoutes->CallonVector.clear(); // this will be rebuilt during the calls to UpdateTrain
//elapsed time  segment
//PerfLogForm->PerformanceLog(-1, "\n Train vector size: " + AnsiString(TrainVector.size()) + '\n');
//PerfLogForm->PerformanceLog(-1, "Start time list");
//end elapsed time  segment
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
//elapsed time  segment
//Start = double(GetTime()) * 86400; //secs
//end elapsed time  segment
            TrainVectorAt(33, x).UpdateTrain(0);
//elapsed time  segment
//End = double(GetTime()) * 86400;
//ElapsedTimeReport = TrainVectorAt(-1, x).TrainDataEntryPtr->ServiceReference + AnsiString(" ") + AnsiString(int((End - Start) * 1000)); //msecs
//PerfLogForm->PerformanceLog(-1, ElapsedTimeReport);
//end elapsed time  segment

//end elapsed time investigations

         /* added HasTrainGone() condition below in v0.4c to prevent 2 trains both having TrainGone set in UpdateTrain
         at the same time.  That caused the error Craig Weekes reported in November 2010 where 2 trains exited at the same time, and later the TrainVector
         iterates in reverse to erase the second train to have gone (when the first train to have gone comes before the second in TrainVector),
         but afterwards ReplotTrains iterates forwards and therefore replots the first train to have gone and therefore sets the TrainIDOnElement value
         to the exited train, with nothing to reset it.  Hovering the mouse over that element with train information enabled causes an error because
         the track element thinks the train is still there, whereas it is missing from the TrainVector.  BUT subsequently (in v2.11.1) changed RePlotTrains
         so it doesn't plot trains with TrainGone set, but left this is as does no harm

         Had another error notified by Kevin Smith on 02/01/22 where a train was manually removed in the same clock cycle as a train exited, and this caused
         the same error as above.  Did a lot of experimenting but eventually cured it with two changes, first as above in RePlotTrains, and also below adding
         a break; command after one TrainHasGone() dealt with.  There were introduced in v2.11.1 & seems ok now

         These changes should deal with any number of TrainGone flags set in the same clock cycle - from exiting, manual removal, or joins
         */
            if(TrainAdded || TrainVectorAt(35, x).HasTrainGone())
            {
                break; //only one exited train will be dealt with at a time (see below) so no point looking further
            }
        }
        // set warning flags
        CrashWarning = false;
        DerailWarning = false;
        SPADWarning = false;
        CallOnWarning = false;
        SignalStopWarning = false;
        BufferAttentionWarning = false;
        TrainFailedWarning = false;
        for(int x = TrainVector.size() - 1; x >= 0; x--) // reverse because of erase
        {
            TTrain &Train = TrainVectorAt(34, x);
            if(Train.Crashed)
            // can't use background colours for crashed & derailed because same colour
            {
                CrashWarning = true;
            }
            else if(Train.Derailed)
            // can't use background colours for crashed & derailed because same colour
            {
                DerailWarning = true;
            }
            else if(Train.BackgroundColour == clSPADBackground)
            // use colour as that changes as soon as passes signal
            {
                SPADWarning = true;
            }
            else if(Train.BackgroundColour == clTrainFailedBackground)
            {
                TrainFailedWarning = true;
            }
            else if(Train.BackgroundColour == clCallOnBackground)
            // use colour as also stopped at signal
            {
                CallOnWarning = true;
            }
            else if(Train.BackgroundColour == clSignalStopBackground)
            // use colour to distinguish from call-on
            {
                SignalStopWarning = true;
            }
            else if(Train.BackgroundColour == clBufferAttentionNeeded)
            // use colour to distinguish from ordinary buffer stop
            {
                BufferAttentionWarning = true;
            }
            if(Train.HasTrainGone())
            {
                AnsiString Loc = "";
                bool ElementFound = false;
                TTrackElement TE;
                if(Train.LagElement > -1)
                {
                    TE = Track->TrackElementAt(531, Train.LagElement);
                    ElementFound = true;
                }
                else if(Train.MidElement > -1)
                {
                    TE = Track->TrackElementAt(779, Train.MidElement);
                    ElementFound = true;
                }
                else if(Train.LeadElement > -1)
                {
                    TE = Track->TrackElementAt(780, Train.LeadElement);
                    ElementFound = true;
                }
                if(ElementFound)
                {
                    if(TE.ActiveTrackElementName != "")
                    {
                        Loc = TE.ActiveTrackElementName + ", track element " + TE.ElementID;
                    }
                    else
                    {
                        Loc = "track element " + TE.ElementID;
                    }
                }
                TActionVectorEntry *AVEntryPtr = Train.ActionVectorEntryPtr;
                if((Train.SignallerRemoved) || (Train.JoinedOtherTrainFlag))
                // need above first because may also have ActionVectorEntryPtr == "Fer"
                {
                    Train.UnplotTrain(9);
                    // added at v1.3.0 to reset signals after train removed from an autosigsroute
                    if(SignallerTrainRemovedOnAutoSigsRoute)
                    {
                        AllRoutes->SignallerRemovedTrainAutoRoute.SetRouteSignals(9);
                        SignallerTrainRemovedOnAutoSigsRoute = false;
                    }
                    // end of addition
                    AllRoutes->RebuildRailwayFlag = true;
                    // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode, to replot LCs
                    // correctly after a crash
                }
                else if(AVEntryPtr->Command == "Fer")
                {
                    bool CorrectExit = false;
                    if(!AVEntryPtr->ExitList.empty())
                    {
                        for(TNumListIterator ELIT = AVEntryPtr->ExitList.begin(); ELIT != AVEntryPtr->ExitList.end(); ELIT++)
                        {
                            if(*ELIT == Train.LagElement)
                            {
                                CorrectExit = true;
                            }
                        }
                    }
                    if(CorrectExit)
                    {
                        Train.LogAction(19, Train.HeadCode, "", Leave, Loc, AVEntryPtr->EventTime, AVEntryPtr->Warning);
                    }
                    else
                    {
                        LogActionError(38, Train.HeadCode, "", FailIncorrectExit, Loc);
                    }
                }
                else
                {
                    if(!AVEntryPtr->SignallerControl)
                    {
                        LogActionError(26, Train.HeadCode, "", FailUnexpectedExitRailway, Loc);
                        Train.SendMissedActionLogs(2, -2, AVEntryPtr);
                        // -2 is marker for send messages for all remaining actions except Fer if present
                    }
                    else
                    {
                        Train.LogAction(31, Train.HeadCode, "", SignallerLeave, Loc, TDateTime(0), false); // false for Warning
                    }
                }
                Utilities->CumulativeDelayedRandMinsAllTrains += Train.CumulativeDelayedRandMinsOneTrain; //added at v2.13.0 for random delays
                Train.TrainDataEntryPtr->TrainOperatingDataVector.at(Train.RepeatNumber).RunningEntry = Exited;
                Train.DeleteTrain(1);
                TrainVector.erase(TrainVector.begin() + x);
                ReplotTrains(1, Display); //to reset ElementIDs for remaining trains when have removed a train
                                          //NB: won't plot any trains with TrainGone flag set (changed at v2.11.1)
                break; //added at v2.11.1 to ensure that only one train with TrainGone set is dealt with in one clock cycle
            }
        }
    }
    else
    {
        // reset all flags in case last train removed with flag set
        CrashWarning = false;
        DerailWarning = false;
        SPADWarning = false;
        CallOnWarning = false;
        SignalStopWarning = false;
        BufferAttentionWarning = false;
        TrainFailedWarning = false;
    }
    // update OpTimeToActMultimap
    if((OpTimeToActUpdateCounter == 0) && TrainController->OpActionPanelVisible) // new v2.2.0
    {
        RebuildOpTimeToActMultimap(0);
        // clears entries then adds values for running trains then for continuation entries
        RebuildTimeToExitMultiMap(0);
        //added for multiplayer for running trains only
    }
    Utilities->Clock2Stopped = ClockState;
    Utilities->CallLogPop(723);
}

// ---------------------------------------------------------------------------
void TTrainController::FinishedOperation(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",FinishedOperation");
    if(!TrainVector.empty())
    {
        for(int x = TrainVector.size() - 1; x >= 0; x--)
        {
            TrainVectorAt(50, x).DeleteTrain(2);
        }
        TrainVector.clear();
    }
    if(!TrainDataVector.empty())
    {
        for(unsigned int x = 0; x < TrainDataVector.size(); x++)
        {
            TTrainDataEntry &TDEntry = TrainDataVector.at(x);
            for(int y = 0; y < TDEntry.NumberOfTrains; y++)
            {
                TTrainOperatingData &TOD = TDEntry.TrainOperatingDataVector.at(y);
                TOD.RunningEntry = NotStarted;
                TOD.TrainID = -1;
                TOD.EventReported = NoEvent;
            }
        }
    }
    Display->GetOutputLog1()->Caption = "";
    Display->GetOutputLog2()->Caption = "";
    Display->GetOutputLog3()->Caption = "";
    Display->GetOutputLog4()->Caption = "";
    Display->GetOutputLog5()->Caption = "";
    Display->GetOutputLog6()->Caption = "";
    Display->GetOutputLog7()->Caption = "";
    Display->GetOutputLog8()->Caption = "";
    Display->GetOutputLog9()->Caption = "";
    Display->GetOutputLog10()->Caption = "";
    Utilities->CallLogPop(1352);
}

// ---------------------------------------------------------------------------

void TTrainController::ReplotTrains(int Caller, TDisplay *Disp)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ReplotTrains");
    if(!TrainVector.empty())
    {
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
            if(!TrainVectorAt(84, x).HasTrainGone()) //added at v2.11.0 to prevent plotting a train pending removal & particularly to prevent TrainElementID's being reinstated
            {                                        //see Kevin Smith error information for details
                TrainVectorAt(51, x).PlotTrain(4, Disp);
            }
        }
    }
    Utilities->CallLogPop(724);
}

// ---------------------------------------------------------------------------

void TTrainController::WriteTrainsToImage(int Caller, Graphics::TBitmap *Bitmap)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",WriteTrainsToImage");
    if(!TrainVector.empty())
    {
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
            TrainVectorAt(61, x).WriteTrainToImage(0, Bitmap);
        }
    }
    Utilities->CallLogPop(1707);
}

// ---------------------------------------------------------------------------

void TTrainController::UnplotTrains(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UnplotTrains");
    if(!TrainVector.empty())
    {
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
            TrainVectorAt(52, x).UnplotTrain(10);
        }
    }
    Track->ResetAllTrainIDsAndFailedPointOrigSpeedLimits(0);
    Utilities->CallLogPop(725);
}

// ---------------------------------------------------------------------------

bool TTrainController::AddTrain(int Caller, int RearPosition, int FrontPosition, AnsiString HeadCode, int StartSpeed, int Mass, double MaxRunningSpeed,
                                double MaxBrakeRate, double PowerAtRail, AnsiString ModeStr, TTrainDataEntry *TrainDataEntryPtr, int RepeatNumber, int IncrementalMinutes,
                                int IncrementalDigits, int SignallerSpeed, bool SignallerControl, TActionEventType &EventType)
{
    LogEvent(AnsiString(Caller) + ",AddTrain," + AnsiString(RearPosition) + "," + AnsiString(FrontPosition) + "," + HeadCode + "," + AnsiString(StartSpeed) +
             "," + AnsiString(Mass) + "," + ModeStr);
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",AddTrain," + AnsiString(RearPosition) + "," + AnsiString(FrontPosition) +
                                 "," + HeadCode + "," + AnsiString(StartSpeed) + "," + AnsiString(Mass) + "," + ModeStr); //at v2.11.1 dropped later headcode - was listed twice

    int RearExitPos = -1;

    for(int x = 0; x < 4; x++)
    {
        if(Track->TrackElementAt(519, RearPosition).Conn[x] == FrontPosition)
        {
            RearExitPos = x;
        }
    }
    if(RearExitPos == -1)
    {
        throw Exception("Error, RearExit == -1 in AddTrain");
    }
    bool ReportFlag = true;

    // used to stop repeated messages from CheckStartAllowable when split failed
    if(TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported != NoEvent)
    {
        ReportFlag = false;
    }
    if(!CheckStartAllowable(0, RearPosition, RearExitPos, HeadCode, ReportFlag, EventType))
    {
        // messages sent to performance log in CheckStartAllowable if ReportFlag true
        TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = EventType;
        Utilities->CallLogPop(938);
        return(false);
    }
    TrainDataEntryPtr->TrainOperatingDataVector.at(RepeatNumber).EventReported = NoEvent;
    TTrainMode TrainMode = NoMode;

    if(ModeStr == "Timetable")
    {
        TrainMode = Timetable;
    }
    // all else gives 'None', 'Signaller' set within program

    if(MaxRunningSpeed < 10)
    {
        MaxRunningSpeed = 10; // added at v0.6 to avoid low max speeds
    }
    if(SignallerSpeed < 10)
    {
        SignallerSpeed = 10; // added at v0.6 to avoid low max speeds
    }
    TTrain *NewTrain = new TTrain(0, RearPosition, RearExitPos, HeadCode, StartSpeed, Mass, MaxRunningSpeed, MaxBrakeRate, PowerAtRail, TrainMode,
                                  TrainDataEntryPtr, RepeatNumber, IncrementalMinutes, IncrementalDigits, SignallerSpeed);

    LogEvent("AddTrainSupplemental: Service Ref = " + TrainDataEntryPtr->ServiceReference + ", TrainID = " + AnsiString(NewTrain->TrainID)); //new at v2.11.1 so can relate headcode to ID

    NewTrain->ActionVectorEntryPtr = &(TrainDataEntryPtr->ActionVector.at(0));
    // initialise here rather than in TTrain constructor as create trains
    // with Null TrainDataEntryPtr when loading session trains
    if(SignallerControl)
    {
        NewTrain->TimetableFinished = true;
        NewTrain->SignallerStoppingFlag = false;
        NewTrain->TrainMode = Signaller;
        if(NewTrain->MaxRunningSpeed > NewTrain->SignallerMaxSpeed)
        {
            NewTrain->MaxRunningSpeed = NewTrain->SignallerMaxSpeed;
        }
        RailGraphics->ChangeForegroundColour(17, NewTrain->HeadCodePosition[0], NewTrain->FrontCodePtr, clFrontCodeSignaller, NewTrain->BackgroundColour);
    }
    // deal with starting conditions:-
    // unlocated Snt: just report entry & advance pointer
    // located Snt or Sfs: set station conditions as would if had reached stop point in Update(), & advance the ActionVectorEntryPtr
    // Sns doesn't need a new train
    if(NewTrain->ActionVectorEntryPtr->LocationName != "")
    // covers all above located starts
    // if location of Snt was a station (that is set as LocationName, i.e. not just any station) that isn't next departure station then
    // wouldn't have accepted the timetable
    {
        // first check if LeadElement (can't access LeadElement directly yet as not set, use FrontPosition instead) is buffers, note that
        // StoppedAtBuffers is set in UpdateTrain()
        if(Track->TrackElementAt(520, FrontPosition).TrackType == Buffers)
        // buffer end must be ahead of train or would have failed start position check
        {
            NewTrain->StoppedAtLocation = true;
            NewTrain->PlotStartPosition(0);
            NewTrain->PlotTrainWithNewBackgroundColour(13, clStationStopBackground, Display); // pale green
            NewTrain->LogAction(20, NewTrain->HeadCode, "", Create, NewTrain->ActionVectorEntryPtr->LocationName, NewTrain->ActionVectorEntryPtr->EventTime,
                                NewTrain->ActionVectorEntryPtr->Warning);
            if(!SignallerControl) // don't advance if SignalControlEntry
            {
                NewTrain->ActionVectorEntryPtr++;
                // should be a command, could be a location departure but if so can't depart so set 'Hold' anyway
            }
            NewTrain->LastActionTime = TTClockTime;
        }
        // else a through station stop
        else
        {
            NewTrain->StoppedAtLocation = true;
            NewTrain->PlotStartPosition(10);
            NewTrain->PlotTrainWithNewBackgroundColour(18, clStationStopBackground, Display); // pale green
            NewTrain->LogAction(21, NewTrain->HeadCode, "", Create, NewTrain->ActionVectorEntryPtr->LocationName, NewTrain->ActionVectorEntryPtr->EventTime,
                                NewTrain->ActionVectorEntryPtr->Warning);
            if(!SignallerControl) // don't advance if SignalControlEntry
            {
                NewTrain->ActionVectorEntryPtr++;
            }
            NewTrain->LastActionTime = TTClockTime;
        }
    }
    else // unlocated entry (i.e. not a stop entry, but could still be at a named location)
    {
        NewTrain->PlotStartPosition(11);
        TTrackElement TE = Track->TrackElementAt(530, NewTrain->RearStartElement);
        AnsiString Loc = "";
        if(TE.ActiveTrackElementName != "")
        {
            Loc = TE.ActiveTrackElementName + ", track element " + TE.ElementID;
        }
        else
        {
            Loc = "track element " + TE.ElementID;
        }
        if(TE.TrackType == Continuation)
        {
            NewTrain->LogAction(22, NewTrain->HeadCode, "", Enter, Loc, NewTrain->ActionVectorEntryPtr->EventTime, NewTrain->ActionVectorEntryPtr->Warning);
        }
        else
        {
            NewTrain->LogAction(23, NewTrain->HeadCode, "", Create, Loc, NewTrain->ActionVectorEntryPtr->EventTime, NewTrain->ActionVectorEntryPtr->Warning);
        }
        if(!SignallerControl) // don't advance if SignalControlEntry
        {
            NewTrain->ActionVectorEntryPtr++;
        }
        NewTrain->LastActionTime = TTClockTime;
        // no need to set LastActionTime for an unlocated entry
    }
    // cancel a wrong-direction route if either element of train starts on one
    if(NewTrain->LeadElement > -1)
    {
        NewTrain->CheckAndCancelRouteForWrongEndEntry(3, NewTrain->LeadElement, NewTrain->LeadEntryPos);
    }
    if(NewTrain->MidElement > -1)
    {
        NewTrain->CheckAndCancelRouteForWrongEndEntry(4, NewTrain->MidElement, NewTrain->MidEntryPos);
    }
    // set signals for a right-direction autosigs route for either element of train on one
    // erase elements back to start for a non-autosigs route & check if an autosigs route immediately behind it, and if so set its signals
    // note that all but autosigs routes become part of a single route, so there can only be an autosigs route behind the non-autosigs route
    int RouteNumber = -1;
    bool SignalsSet = false;

    if(NewTrain->LeadElement > -1)
    {
        if(AllRoutes->GetRouteTypeAndNumber(13, NewTrain->LeadElement, NewTrain->LeadEntryPos, RouteNumber) == TAllRoutes::AutoSigsRoute)
        {
            // below added in place of SetRouteSignals in v2.4.0 as don't want to set signals from start of route for a new train addition
            int RouteStartPosition;
            TAllRoutes::TRouteElementPair FirstPair, SecondPair;
            FirstPair = AllRoutes->GetRouteElementDataFromRoute2MultiMap(21, Track->TrackElementAt(955, FrontPosition).HLoc,
                                                                         Track->TrackElementAt(956, FrontPosition).VLoc, SecondPair);
            if(FirstPair.first == RouteNumber)
            {
                RouteStartPosition = FirstPair.second;
            }
            else if(SecondPair.first == RouteNumber)
            {
                RouteStartPosition = SecondPair.second;
            }
            else
            {
                throw Exception("Error, RouteNumber not found in Route2MultiMap in 1st of 2 calls to SetAllRearwardsSignals in AddTrain");
            }
            AllRoutes->SetAllRearwardsSignals(10, 0, RouteNumber, RouteStartPosition);
            SignalsSet = true;
            // AllRoutes->GetFixedRouteAt(, RouteNumber).SetRouteSignals();  above substituted in v2.4.0
        }
        else if(RouteNumber > -1) // non-autosigsroute
        {
            TPrefDirElement TempPDE = AllRoutes->GetFixedRouteAt(181, RouteNumber).GetFixedPrefDirElementAt(194, 0);
            int FirstTVPos = TempPDE.GetTrackVectorPosition();
            int FirstELinkPos = TempPDE.GetELinkPos();
            while(TempPDE.GetTrackVectorPosition() != (unsigned int)(NewTrain->LeadElement))
            {
                AllRoutes->RemoveRouteElement(16, TempPDE.HLoc, TempPDE.VLoc, TempPDE.GetELink());
                TempPDE = AllRoutes->GetFixedRouteAt(182, RouteNumber).GetFixedPrefDirElementAt(195, 0);
            }
            if(TempPDE.GetTrackVectorPosition() == (unsigned int)(NewTrain->LeadElement))
            {
                AllRoutes->RemoveRouteElement(17, TempPDE.HLoc, TempPDE.VLoc, TempPDE.GetELink());
                // remove the last element under LeadElement
            }
            AllRoutes->RebuildRailwayFlag = true;
            // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode
            // now deal with a rear linked autosigs route
            if(Track->TrackElementAt(820, FirstTVPos).Conn[FirstELinkPos] > -1)
            {
                int LinkedRouteNumber = -1;
                if(AllRoutes->GetRouteTypeAndNumber(17, Track->TrackElementAt(821, FirstTVPos).Conn[FirstELinkPos],
                                                    Track->TrackElementAt(822, FirstTVPos).ConnLinkPos[FirstELinkPos], LinkedRouteNumber) == TAllRoutes::AutoSigsRoute)
                {
                    AllRoutes->GetFixedRouteAt(169, LinkedRouteNumber).SetRouteSignals(0);
                    // this is ok as here we are setting signals from the start of the route
                }
            }
            SignalsSet = true;
        }
    }
    if(NewTrain->MidElement > -1)
    // if entering at a continuation MidElement == -1
    {
        // this is included in case a train starts with LeadElement on no route and MidElement on a route
        if(!SignalsSet)
        {
            RouteNumber = -1;
            if(AllRoutes->GetRouteTypeAndNumber(14, NewTrain->MidElement, NewTrain->MidEntryPos, RouteNumber) == TAllRoutes::AutoSigsRoute)
            {
                // below added in place of SetRouteSignals in v2.4.0 as don't want to set signals from start of route for a new train addition
                int RouteStartPosition;
                TAllRoutes::TRouteElementPair FirstPair, SecondPair;
                FirstPair = AllRoutes->GetRouteElementDataFromRoute2MultiMap(22, Track->TrackElementAt(957, RearPosition).HLoc,
                                                                             Track->TrackElementAt(958, RearPosition).VLoc, SecondPair);
                if(FirstPair.first == RouteNumber)
                {
                    RouteStartPosition = FirstPair.second;
                }
                else if(SecondPair.first == RouteNumber)
                {
                    RouteStartPosition = SecondPair.second;
                }
                else
                {
                    throw Exception("Error, RouteNumber not found in Route2MultiMap in 2nd of 2 calls to SetAllRearwardsSignals in AddTrain");
                }
                AllRoutes->SetAllRearwardsSignals(11, 0, RouteNumber, RouteStartPosition);
                SignalsSet = true;
                // AllRoutes->GetFixedRouteAt(, RouteNumber).SetRouteSignals();  above substituted in v2.4.0
            }
            else if(RouteNumber > -1) // non-autosigsroute
            {
                TPrefDirElement TempPDE = AllRoutes->GetFixedRouteAt(184, RouteNumber).GetFixedPrefDirElementAt(196, 0);
                int FirstTVPos = TempPDE.GetTrackVectorPosition();
                int FirstELinkPos = TempPDE.GetELinkPos();
                while(TempPDE.GetTrackVectorPosition() != (unsigned int)(NewTrain->MidElement))
                {
                    AllRoutes->RemoveRouteElement(18, TempPDE.HLoc, TempPDE.VLoc, TempPDE.GetELink());
                    TempPDE = AllRoutes->GetFixedRouteAt(185, RouteNumber).GetFixedPrefDirElementAt(197, 0);
                }
                if(TempPDE.GetTrackVectorPosition() == (unsigned int)(NewTrain->MidElement))
                {
                    AllRoutes->RemoveRouteElement(19, TempPDE.HLoc, TempPDE.VLoc, TempPDE.GetELink());
                    // remove the last element under LeadElement
                }
                AllRoutes->RebuildRailwayFlag = true;
                // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode
                // now deal with a rear linked autosigs route
                if(Track->TrackElementAt(823, FirstTVPos).Conn[FirstELinkPos] > -1)
                {
                    int LinkedRouteNumber = -1;
                    if(AllRoutes->GetRouteTypeAndNumber(19, Track->TrackElementAt(824, FirstTVPos).Conn[FirstELinkPos],
                                                        Track->TrackElementAt(825, FirstTVPos).ConnLinkPos[FirstELinkPos], LinkedRouteNumber) == TAllRoutes::AutoSigsRoute)
                    {
                        AllRoutes->GetFixedRouteAt(170, LinkedRouteNumber).SetRouteSignals(1);
                        // this is ok as now we are setting signals from the start of the route
                    }
                }
            }
        }
    }
    TrainVector.push_back(*NewTrain);
    Utilities->CallLogPop(731);
    return(true);
}

// ---------------------------------------------------------------------------

int TTrainController::EntryPos(int Caller, int TrainIDIn, int TrackVectorNumber)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",EntryPos," + AnsiString(TrainIDIn) + "," +
                                 AnsiString(TrackVectorNumber));
    int VecPos = -1;

    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        if(TrainVectorAt(1, x).TrainID == TrainIDIn)
        {
            VecPos = x;
        }
    }
    if(VecPos == -1)
    {
        throw Exception("Error, VecPos not set in EntryPos");
    }
    if(TrainVectorAt(2, VecPos).LeadElement == TrackVectorNumber)
    {
        Utilities->CallLogPop(734);
        return(TrainVectorAt(3, VecPos).LeadEntryPos);
    }
    else if(TrainVectorAt(4, VecPos).MidElement == TrackVectorNumber)
    {
        Utilities->CallLogPop(735);
        return(TrainVectorAt(5, VecPos).MidEntryPos);
    }
    else if(TrainVectorAt(6, VecPos).LagElement == TrackVectorNumber)
    {
        Utilities->CallLogPop(736);
        return(TrainVectorAt(7, VecPos).LagEntryPos);
    }
    Utilities->CallLogPop(737);
    return(-1);
}

// ---------------------------------------------------------------------------

TTrain &TTrainController::TrainVectorAtIdent(int Caller, int TrainID)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainVectorAtIdent," + AnsiString(TrainID));
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        if(TrainVectorAt(53, x).TrainID == TrainID)
        {
            Utilities->CallLogPop(738);
            return(TrainVectorAt(54, x));
        }
    }
    throw Exception("Error - No Train identified in TrainVectorAtIdent with ID = " + AnsiString(TrainID));
}

// ---------------------------------------------------------------------------

bool TTrainController::TrainExistsAtIdent(int Caller, int TrainID)
// return true if find the train (added at v2.4.0 as can select a removed train in
// ActionsDueListBox before it updates - reported by LiWinDom in error report 23/04/20)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainExistsAtIdent," + AnsiString(TrainID));
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        if(TrainVectorAt(69, x).TrainID == TrainID)
        {
            Utilities->CallLogPop(2152);
            return(true);
        }
    }
    Utilities->CallLogPop(2153);
    return(false);
}

// ---------------------------------------------------------------------------

TDateTime TTrainController::GetControllerTrainTime(int Caller, TDateTime Time, int RepeatNumber, int IncrementalMinutes)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetControllerTrainTime," + AnsiString(RepeatNumber) + "," +
                                 Utilities->Format96HHMMSS(Time));
    TDateTime RepeatTime = TrainController->GetRepeatTime(47, Time, RepeatNumber, IncrementalMinutes);

    Utilities->CallLogPop(2061);
    return(RepeatTime);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::ContinuationEntryFloatingTTString(int Caller, TTrainDataEntry *TTDEPtr, int RepNum, int IncMins, int IncDig)
// Enter with Ptr pointing to first action to be listed (i.e. next action)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ContinuationEntryFloatingTTString" + "," + TTDEPtr->HeadCode);
    AnsiString RetStr = "", PartStr = "";
    int Count = 0;
    TActionVectorIterator Ptr = TTDEPtr->ActionVector.begin();

    Ptr--; // because incremented at start of loop
    do
    {
        Ptr++;
        if((Ptr->Command != "") && (Ptr->Command[1] == 'S'))
        {
            continue; // move past the starting entry
        }
        if((Ptr->FormatType == Repeat) || Ptr >= TTDEPtr->ActionVector.end())
        {
            break;
        }
        if(Ptr->SignallerControl)
        {
            RetStr = "Train under signaller control";
            break;
        }
        if(Ptr->FormatType == TimeTimeLoc)
        {
            if(Ptr->ArrivalTime == Ptr->DepartureTime)
            {
                PartStr = Utilities->Format96HHMM(GetControllerTrainTime(0, Ptr->ArrivalTime, RepNum, IncMins)) + ": Arrive & depart from " + Ptr->LocationName;
            }
            else
            {
                PartStr = Utilities->Format96HHMM(GetControllerTrainTime(1, Ptr->ArrivalTime, RepNum, IncMins)) + ": Arrive at " + Ptr->LocationName + '\n' +
                    Utilities->Format96HHMM(GetControllerTrainTime(2, Ptr->DepartureTime, RepNum, IncMins)) + ": Depart from " + Ptr->LocationName;
                Count++; // because there are 2 entries
            }
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime != TDateTime(-1)))
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(3, Ptr->ArrivalTime, RepNum, IncMins)) + ": Arrive at " + Ptr->LocationName;
        }
        else if((Ptr->FormatType == TimeLoc) && (Ptr->ArrivalTime == TDateTime(-1)))
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(4, Ptr->DepartureTime, RepNum, IncMins)) + ": Depart from " + Ptr->LocationName;
        }
        else if(Ptr->FormatType == PassTime) // new
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(5, Ptr->EventTime, RepNum, IncMins)) + ": Pass " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fns")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(6, Ptr->EventTime, RepNum, IncMins)) + ": Form new service " +
                TrainController->GetRepeatHeadCode(46, Ptr->OtherHeadCode, RepNum, IncDig) + " at " + Ptr->LocationName;
            PartStr = ControllerGetNewServiceDepartureInfo(11, Ptr, RepNum, TTDEPtr, Ptr->LinkedTrainEntryPtr, IncMins, PartStr); //if there is a next service this adds the new service departure time to PartStr
        }
        else if(Ptr->Command == "F-nshs")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(7, Ptr->EventTime, RepNum, IncMins)) + ": Form new service " +
                Ptr->NonRepeatingShuttleLinkHeadCode + " at " + Ptr->LocationName;
            PartStr = ControllerGetNewServiceDepartureInfo(13, Ptr, 0, TTDEPtr, Ptr->LinkedTrainEntryPtr, IncMins, PartStr); //if there is a next service this adds the new service departure time to RetStr
            //note that use LinkedTrainEntryPtr and not NonRepeatingShuttleLinkEntryPtr because the forward link from the feeder is LinkedTrainEntryPtr.
            //NonRepeatingShuttleLinkEntryPtr is in the shuttle's ActionVector to point back to the feeder.
            //NonRepeatingShuttleLinkEntryPtr is used below from the last shuttle as the forward link to the finishing service
        }
//Since this is a new continuation entry service it can't be Fns-sh or Frh-sh but leave these in for consistency with TTrain::FloatingTimetableString
        else if((Ptr->Command == "Fns-sh") && (RepNum < (TTDEPtr->NumberOfTrains - 1))) // not the last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(8, Ptr->EventTime, RepNum, IncMins)) + ": Form new service " +
                TrainController->GetRepeatHeadCode(47, Ptr->OtherHeadCode, RepNum + 1, IncDig) + " at " + Ptr->LocationName;
            // use RepNum+1 because it's the repeat number of the NEXT shuttle service that is relevant
            PartStr = ControllerGetNewServiceDepartureInfo(15, Ptr, RepNum + 1, TTDEPtr, Ptr->LinkedTrainEntryPtr, IncMins, PartStr); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Fns-sh") && (RepNum >= (TTDEPtr->NumberOfTrains - 1))) // last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(9, Ptr->EventTime, RepNum, IncMins)) + ": Form new service " +
                Ptr->NonRepeatingShuttleLinkHeadCode, +" at " + Ptr->LocationName;
            PartStr = ControllerGetNewServiceDepartureInfo(17, Ptr, 0, TTDEPtr, Ptr->NonRepeatingShuttleLinkEntryPtr, IncMins, PartStr); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepNum < (TTDEPtr->NumberOfTrains - 1))) // not the last repeat number
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(10, Ptr->EventTime, RepNum, IncMins)) + ": Form new service " +
                TrainController->GetRepeatHeadCode(48, Ptr->OtherHeadCode, RepNum + 1, IncDig) + " at " + Ptr->LocationName;
            // use RepNum+1 because it's the repeat number of the NEXT shuttle service that is relevant
            PartStr = ControllerGetNewServiceDepartureInfo(19, Ptr, RepNum + 1, TTDEPtr, Ptr->LinkedTrainEntryPtr, IncMins, PartStr); //if there is a next service this adds the new service departure time to RetStr
        }
        else if((Ptr->Command == "Frh-sh") && (RepNum >= (TTDEPtr->NumberOfTrains - 1))) // last repeat number
        {
            PartStr = "Terminate at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Frh")
        {
            PartStr = "Terminate at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "Fer")
        {
            AnsiString AllowedExits;
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(11, Ptr->EventTime, RepNum, IncMins)) + ": Exit railway" +
                TrainController->GetExitLocationAndAt(3, Ptr->ExitList, AllowedExits) + AllowedExits;
        }
        else if(Ptr->Command == "Fjo")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(12, Ptr->EventTime, RepNum, IncMins)) + ": Join " + TrainController->GetRepeatHeadCode(49,
                                                                                                                                                            Ptr->OtherHeadCode, RepNum, IncDig) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "jbo")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(13, Ptr->EventTime, RepNum, IncMins)) + ": Joined by " + TrainController->GetRepeatHeadCode
                    (50, Ptr->OtherHeadCode, RepNum, IncDig) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "fsp")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(14, Ptr->EventTime, RepNum, IncMins)) + ": Front split to " +
                TrainController->GetRepeatHeadCode(51, Ptr->OtherHeadCode, RepNum, IncDig) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "rsp")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(15, Ptr->EventTime, RepNum, IncMins)) + ": Rear split to " +
                TrainController->GetRepeatHeadCode(52, Ptr->OtherHeadCode, RepNum, IncDig) + " at " + Ptr->LocationName;
        }
        else if(Ptr->Command == "cdt")
        {
            PartStr = Utilities->Format96HHMM(GetControllerTrainTime(16, Ptr->EventTime, RepNum, IncMins)) + ": Change direction at " + Ptr->LocationName;
        }
        if(RetStr != "")
        {
            RetStr = RetStr + '\n' + PartStr;
        }
        else
        {
            RetStr = PartStr;
        }
        Count++;
    }
    while(Ptr < TTDEPtr->ActionVector.end() && (Count < 33) && ((Ptr->Command == "") || ((Ptr->Command != "") && (Ptr->Command[1] != 'F'))));
    // limit of 33 allows a max of 34 entries (may have gone from 32 to 34 because of a TimeTimeLoc), which with track and train status gives
    // a max of 48 lines, at 13 pixels each, = 624 pixels & screen height has 641 so will fit comfortably.  Also 34 timetable entries is as far
    // forward as anyone should wish to see without looking at the full timetable
    Utilities->CallLogPop(2072);
    return(RetStr);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::ControllerGetNewServiceDepartureInfo(int Caller, TActionVectorIterator Ptr, int RptNum, TTrainDataEntry *TDEPtr, TTrainDataEntry *LinkedTrainDataPtr, int IncrementalMinutes, AnsiString RetStr)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString(Ptr - TDEPtr->ActionVector.begin()) + ","
                                 + AnsiString(RptNum) + ",ControllerGetNewServiceDepartureInfo," + TDEPtr->HeadCode);
    AnsiString DepTime = "", EventTime = "";
    bool CDTFlag = false; //reports if train changes direction before departs
    TActionVector NewServiceAV = LinkedTrainDataPtr->ActionVector;
    AnsiString CurrentLocation = NewServiceAV.at(0).LocationName; //added at v2.12.0 to show departure direction
    AnsiString TowardsLocation = ""; //added at v2.12.0 to show departure direction
    for(TActionVectorIterator AVI = NewServiceAV.begin(); AVI < NewServiceAV.end(); AVI++) //added at v2.12.0 to obtain departure direction
    {
        if((AVI->LocationName != CurrentLocation) && (AVI->LocationName != "") && (TowardsLocation == ""))
        {
            TowardsLocation = AVI->LocationName;
        }
        else if((AVI->Command == "Fer") && (TowardsLocation == "") && !AVI->ExitList.empty())
        {
            TTrackElement TE = Track->TrackElementAt(1453, (AVI->ExitList.front()));
            if(TE.ActiveTrackElementName != "")
            {
                TowardsLocation = TE.ActiveTrackElementName;
            }
            else
            {
                TowardsLocation = AnsiString("track element ID ") + TE.ElementID;
            }
        }
    }
    for(TActionVectorIterator AVI = NewServiceAV.begin(); AVI < NewServiceAV.end(); AVI++)
    {
        if(AVI->Command == "cdt")
        {
            CDTFlag = !CDTFlag; //toggles flag - allows for there being more than one cdt before departure
            continue;
        }
        if((AVI->Command == "fsp") || (AVI->Command == "rsp"))
        {
            EventTime = Utilities->Format96HHMM(TrainController->GetControllerTrainTime(21, AVI->EventTime, RptNum, IncrementalMinutes));
            RetStr += "\nNew service splits at " + EventTime;
            Utilities->CallLogPop(2237);
            return(RetStr);
        }
        if(AVI->Command == "jbo")
        {
            EventTime = Utilities->Format96HHMM(TrainController->GetControllerTrainTime(22, AVI->EventTime, RptNum, IncrementalMinutes));
            RetStr += "\nNew service joined by " + AVI->OtherHeadCode + " at " + EventTime;
            Utilities->CallLogPop(2238);
            return(RetStr);
        }
        if((AVI->FormatType == TimeLoc) && (AVI->DepartureTime > TDateTime(-1))) //departure time set
        {
            DepTime = Utilities->Format96HHMM(TrainController->GetControllerTrainTime(23, AVI->DepartureTime, RptNum, IncrementalMinutes));
            if(CDTFlag)
            {
                if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                {
                    RetStr += "\nNew service changes direction then departs towards " + TowardsLocation + " at " + DepTime;
                }
                else
                {
                    RetStr += "\nNew service changes direction then departs at " + DepTime;
                }
            }
            else
            {
                if(TowardsLocation != "") //added at v2.12.0 to show departure direction
                {
                    RetStr += "\nNew service departs towards " + TowardsLocation + " at " + DepTime;
                }
                else
                {
                    RetStr += "\nNew service departs at " + DepTime;
                }
            }
            Utilities->CallLogPop(2239);
            return(RetStr);
        }
    }
    Utilities->CallLogPop(2223);
    return(RetStr);
}

// ---------------------------------------------------------------------------
// $$$$$$$$$$$$$$$$$$$$$$ Start of Timetable Functions $$$$$$$$$$$$$$$$$$$$$$$$
/*
  Note:  The terms 'action' and 'entry' have been used freely for individual code lines within services in comments & in variable names, but
  for messages and in the manual and help files the term Entry is reserved for a complete service or train (i.e. an entry in the timetable),
  and 'event' is reserved for and individual code line within a service.  Repeats use the term 'item' if they use any at all.

  In references to 'HeadCode' can have an optional prefix - up to 4 additional characters that can be anything, so long as last 4 digits
  represent the headcode.  This allows links to be uniquely identified regardless of the headcode - so can have same headcodes as often as
  user wishes

  Prior to start time, anything except a line beginning with a time [...leading spaces...] HH:MM is ignored - can be
  descriptive text or anything user wishes
  A time on its own line [HH:MM], with or without leading spaces, but with anything following it before the CR (which will
  be ignored) is taken as the timetable start time.
  Thereafter there must be text on every line in the timetable, as the first blank line (or end of file) will be taken as the end of the
  timetable.  Text can follow the 'end of timetable' blank line if the user wishes.
  A line within the timetable beginning with '*', with or without leading spaces, is ignored.  Such lines can add text
  within the timetable if required.
  Timetable entries consist of one line per headcode (i.e. per service, not necessarily per train, as one train can run several different
  services)
  Each line starts with HeadCode & full train information for a new train (Snt or Snt-sh), or, for a continuing service
  (Sfs, Sns, Sns-sh or Sns-fsh), can have (a) Headcode only or (b) HeadCode + Description, nothing else

  All leading & trailing spaces before & after a line or any entry in a line are stripped off - these can be included to make reading a
  text timetable file easier

  form:-
  HeadCode[;Description (plain text, no commas or semicolons)][;StartSpeed(kph); MaxRunningSpeed(kph); Mass(tonnes, prog converts to kg);
  MaxBrakeRate(tonnes force, prog converts to m/s/s); & gross power(kW, prog converts to power at rail in w)
  then multiple entries, separated by commas, of the form:-

  HH:MM;Snt;RearStartIdent FrontStartIdent                    }StartNew                }
  HH:MM;Snt-sh;RearStartIdent FrontStartIdent;Fsh HeadCode    }SNTShuttle              }
  HH:MM;Sns-sh;Fxx-sh HeadCode;F-nshs HeadCode (non-repeating)}SNSShuttle              }

  HH:MM;Command;HeadCode (Sfs Sns jbo fsp rsp Fns Fjo Frh-sh) }TimeCmdHeadCode         }  Train action entries
  HH:MM;F-nshs;NonRepeatingShuttleLinkHeadCode                }FNSNonRepeatToShuttle   }
  HH:MM;Sns-fsh;NonRepeatingShuttleLinkHeadCode               }SNSNonRepeatFromShuttle }

  HH:MM;Command (cdt)                                         }TimeCmd                 }
  HH:MM;Location (arr & dep)                                  }TimeLoc                 }
  HH:MM;HH:MM;Location                                        }TimeTimeLoc             }
  HH:MM;pas;Location                                          }PassTime                }
  HH:MM;Fns-sh;Snx-sh HeadCode;Sns-fsh HeadCode (non-rep)     }FSHNewService           }
  HH:MM;Fer;set of allowable IDs                              }ExitRailway             }
  Command   (Frh only)                                        }FinRemHere              }

  R;mm;dd;nn.                                                  Repeat                      Repeat entry

  Formats:

  Command only:                               Frh
  Time;Command:                               cdt
  Time;Command;Headcode:                      Sfs Sns jbo fsp rsp Fns Fjo Frh-sh F-nshs Sns-fsh
  Time;Command;2 Element IDs:                 Snt
  Time;Comand;n Element IDs:                  Fer
  Time;Command;rep Headcode;nonrep Headcode:  Sns-sh Fns-sh
  Time;Command;2 Element IDs;Headcode         Snt-sh
  Time;Command;Location                       pas
  Time;Location                               Arr Dep
  Time;Time;Location                          Arr & dep together

  9  Single entries:    Snt (located or unlocated); pas; cdt; TimeLoc arr & dep; TimeTimeLoc; Fer; Frh

  9  1x Linked entries: Non-shuttle:  fsp or rsp -> Sfs; Fns -> Sns; Fjo -> jbo; times must match, headcodes must match
  Shuttle: F-nshs -> Sns-sh: times match, F-nshs HeadCode matches Sns-sh 2nd Headcode;
  Fns-sh -> Sns-fsh: Fns-sh time + all repeats = Sns-fsh time, Fns-sh 2nd headcode matches Sns-fsh Headcode

  4 2x Linked entries, all shuttles:

  Frh-sh -> Snt-sh:  Frh-sh time = Snt-sh time + 1 repeat while repeating, Frh-sh Headcode = Snt-sh Headcode;
  -> Sns-sh:  Frh-sh time = Sns-sh time + 1 repeat while repeating, Frh-sh Headcode = Sns-sh 1st Headcode;
  -> Remain Here (at finish location after all repeats)
  Fns-sh -> Snt-sh:  Frh-sh time = Snt-sh time + 1 repeat while repeating, Fns-sh 1st Headcode = Snt-sh Headcode
  -> Sns-sh:  Frh-sh time = Sns-sh time + 1 repeat while repeating, Fns-sh 1st Headcode = Sns-sh 1st Headcode

  Allowable successors:-

  Successor state     Type

  Snt located         AtLoc         )          Snt AtLoc successors:  TimeLoc dep/jbo/fsp/rsp/cdt/Frh/Fns/Fjo/Frh-sh/Fns-sh/F-nshs;
  Snt Unlocated       Moving        )          Snt Moving successors: TimeLoc arr/TimeTimeLoc/pas/Fer;
  Sfs                 AtLoc         )
  Sns                 AtLoc         ) Start
  Sns-fsh             AtLoc         )
  Snt-sh              AtLoc         )
  Sns-sh              AtLoc         )

  pas                 Moving                      )
  jbo                 AtLoc                       )
  fsp                 AtLoc                       )
  rsp                 AtLoc                       ) Intermediate
  cdt                 AtLoc                       )
  TimeLoc arr         Moving (bef), AtLoc (aft)   )
  TimeLoc dep         AtLoc  (bef), Moving (aft)  )
  TimeTimeLoc         Moving                      )

  Fns                 Repeat/Nothing)
  Fjo                 Repeat/Nothing)
  Frh                 Repeat/Nothing)
  Fer                 Repeat/Nothing) Finish
  Frh-sh              Repeat        )
  Fns-sh              Repeat        )
  F-nshs              Nothing       )

  Descriptions:
  Snt                 New train
  Sfs                 New service from split
  Sns                 New service from another service
  Sns-fsh             New non-repeating service from a shuttle service
  Snt-sh              New shuttle train at a timetabled stop
  Sns-sh              New shuttle service from a feeder service

  pas                 Pass
  jbo                 Be joined by another train
  fsp                 Front split
  rsp                 Rear split
  cdt                 Change direction of train
  TimeLoc arr         Arrival
  TimeLoc dep         Departure
  TimeTimeLoc         Arrival and departure

  Fns                 Finish & form a new service
  Fjo                 Finish & join another train
  Frh                 Finish & remain here
  Fer                 Finish & exit railway
  Frh-sh              Finish & repeat shuttle, finally remain here
  Fns-sh              Finish & repeat shuttle, finally form a non-repeating service
  F-nshs              Finish & form a shuttle feeder service
*/

bool TTrainController::TimetableIntegrityCheck(int Caller, char *FileName, bool GiveMessages, bool CheckLocationsExistInRailway) // true for success
{
    // Error messages mainly given in called functions, five are given here - empty file; inability to find a start time; timetable containing
    // a line that is too long; timetable containing too few lines; and timetable failed to open.
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TimetableIntegrityCheck," + AnsiString(FileName));
    // new for v0.2b
    // compile ActiveTrackElementNameMap
    TTrack::TActiveTrackElementNameMapEntry ActiveTrackElementNameMapEntry;

    Track->ActiveTrackElementNameMap.clear();
    for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
    {
        // if((Track->TrackElementAt(, x).ActiveTrackElementName != "") && (Track->TrackElementAt(, x).TrackType != Continuation))
        if((Track->TrackElementAt(1033, x).ActiveTrackElementName != "") && (Track->ContinuationNameMap.find(Track->TrackElementAt(1034, x).ActiveTrackElementName))
           == Track->ContinuationNameMap.end())
        {
            // exclude any name that appears in a continuation, error message given in tt validation if try to include such a name in a tt
            ActiveTrackElementNameMapEntry.first = Track->TrackElementAt(1035, x).ActiveTrackElementName;
            ActiveTrackElementNameMapEntry.second = 0; // this is a dummy value
            Track->ActiveTrackElementNameMap.insert(ActiveTrackElementNameMapEntry);
        }
    }
    Track->ActiveTrackElementNameMapCompiledFlag = true;
    // end of new section
    std::ifstream TTBLFile(FileName, std::ios_base::binary);

    // binary mode so the "\r\n" pairs stay as they are rather than being entered as '\n'
    if(TTBLFile.is_open())
    {
        char *TrainTimetableString = new char[10000];
        // enough for over 200 stations, should be adequate!
        bool EndOfFile = false;
        int Count = 0;
        // counts 'relevant' lines, i.e ignores any before the start time on its own line
        TTBLFile.getline(TrainTimetableString, 10000, '\0');
        // delimiter is '\0' as it's an AnsiString
        if(TTBLFile.eof() && (TrainTimetableString[0] == '\0'))
        // file empty - stores a null in 1st position if doesn't load any characters
        {
            // may still have eof even if read a line (no CRLF at end), and
            // if so need to process it
            TimetableMessage(GiveMessages, "Timetable invalid - file empty");
            TTBLFile.close();
            delete[] TrainTimetableString;
            Utilities->CallLogPop(1611);
            return(false);
        }
        AnsiString OneLine(TrainTimetableString);
        bool FinalCallFalse = false;
        while((Count == 0) && !ProcessOneTimetableLine(5, Count, OneLine, EndOfFile, FinalCallFalse, GiveMessages, CheckLocationsExistInRailway))
        // get rid of lines before the start time
        {
            // ProcessOneTimetableLine returns true for a valid start time, an EndOfFile &/or a blank entry
            TTBLFile.getline(TrainTimetableString, 10000, '\0');
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0'))
            // stores a null in 1st position if doesn't load any characters
            {
                // may still have eof even if read a line (no CRLF at end), and
                // if so need to process it
                TimetableMessage(GiveMessages, "Timetable invalid - unable to find a valid start time on its own line");
                TTBLFile.close();
                delete[] TrainTimetableString;
                Utilities->CallLogPop(772);
                return(false);
            }
            OneLine = AnsiString(TrainTimetableString);
        }
        // here when have accepted the start time
        Count++; // increment past the start time
        while(!EndOfFile)
        {
            TTBLFile.getline(TrainTimetableString, 10000, '\0');
            // get next line after start time
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0'))
            // stores a null in 1st position if doesn't load any characters
            {
                // may still have eof even if read a line (no CRLF at end), and
                // if so need to process it
                EndOfFile = true;
                OneLine = "";
            }
            else
            {
                OneLine = AnsiString(TrainTimetableString);
            }
            if(OneLine.Length() > 9999)
            {
                TimetableMessage(GiveMessages, "Timetable contains a line that is too long - 10,000 or more characters!");
                TTBLFile.close();
                delete[] TrainTimetableString;
                Utilities->CallLogPop(789);
                return(false);
            }
            bool FinalCallFalse = false;
            if(!ProcessOneTimetableLine(6, Count, OneLine, EndOfFile, FinalCallFalse, GiveMessages, CheckLocationsExistInRailway))
            // false for FinalCall - just checking at this stage
            {
                TTBLFile.close();
                delete[] TrainTimetableString;
                Utilities->CallLogPop(770);
                return(false);
            }
            if(EndOfFile && (Count < 2))
            // Timetable must contain at least two relevant lines, one for start time and at least one train
            {
                TimetableMessage(GiveMessages, "Timetable has too few or no relevant entries - must have a start time on its own line and at least one train");
                TTBLFile.close();
                delete[] TrainTimetableString;
                Utilities->CallLogPop(771);
                return(false);
            }
            Count++;
        }
        delete[] TrainTimetableString;
        TTBLFile.close();
    } // if(TTBLFile.is_open())
    else
    {
        TimetableMessage(GiveMessages, "Failed to open timetable file, make sure it's spelled correctly, it exists and isn't open in another application");
        Utilities->CallLogPop(2154);
        return(false);
    }
    Utilities->CallLogPop(753);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::ProcessOneTimetableLine(int Caller, int Count, AnsiString OneLine, bool &EndOfFile, bool FinalCall, bool GiveMessages,
                                               bool CheckLocationsExistInRailway) // return true for success

/* Format:
          Prior to start time, anything except a line beginning with a time [...leading spaces...] HH:MM is ignored - can be
          descriptive text or anything user wishes
          A time on its own line [HH:MM], with or without leading spaces, but with anything following it before the CR (which will
          be ignored) is taken as the timetable start time.
          Thereafter there must be text on every line in the timetable, as the first blank line (or end of file) will be taken as the end of the
          timetable.  Text can follow the 'end of timetable' blank line if the user wishes.
          A line within the timetable beginning with '*', with or without leading spaces, is ignored.  Such lines can add text
          within the timetable if required.
          Timetable entries consist of one line per headcode (i.e. per service, not necessarily per train, as one train can run several different
          services)
          Each line starts with HeadCode & full train information for a new train (Snt or Snt-sh), or, for a continuing service
          (Sfs, Sns, Sns-sh or Sns-fsh), can have (a) Headcode only or (b) HeadCode + Description, nothing else

          All leading & trailing spaces before & after a line or any entry in a line are stripped off - these can be included to make reading a
          text timetable file easier

          form:-
          HeadCode[;Description (plain text, no commas or semicolons)][;StartSpeed(kph); MaxRunningSpeed(kph); Mass(tonnes, prog converts to kg);
          MaxBrakeRate(tonnes force, prog converts to m/s/s); & gross power(kW, prog converts to power at rail in w)
          then multiple entries, separated by commas, of the form:-

          Format                                                       FormatType
          [W]HH:MM;Command (cdt)                                         }TimeCmd                 }
          [W]HH:MM;Fer;set of allowable IDs                              }ExitRailway             }
          [W]HH:MM;pas;Location                                          }PassTime                }
          [W]HH:MM;Snt;RearStartIdent FrontStartIdent                    }StartNew                }
          [W]HH:MM;Command;HeadCode (Sfs Sns jbo fsp rsp Fns Fjo Frh-sh) }TimeCmdHeadCode         }
          [W]HH:MM;F-nshs;non-repeating headcode                         }FNSNonRepeatToShuttle   }
          [W]HH:MM;Sns-fsh;NonRepeatingShuttleLinkHeadCode               }SNSNonRepeatFromShuttle }  Train action entries
          [W]HH:MM;Snt-sh;RearStartIdent FrontStartIdent;FSH HeadCode    }SNTShuttle              }
          [W]HH:MM;Sns-sh;FSH HeadCode;F-nshs HeadCode (non-repeating)   }SNSShuttle              }
          [W]HH:MM;Fns-sh;Details                                        }FSHNewService           }
          [W]HH:MM;Location (arr & dep)                                  }TimeLoc                 }
          [W]HH:MM;HH:MM;Location                                        }TimeTimeLoc             }
          Command   (Frh only)                                           }FinRemHere              }

          R;mm;dd;nn.                                                  Repeat                    Repeat entry

          Two times represent arrival & departure, without any other events between (if arrival and departure times are the same
          then departure is 30 sec after arrival), single time represents (a) event time; (b) arrival time if train not already
          at location; or (c) departure time if train already at location (including train started at location either as a new
          train or as a continuation service train at that location).  All lines must contain a start entry and a finish entry,
          the finish being the last unless there is a repeat entry.  The repeat entry begins with 'R', then the incremental
          minutes, incremental train headcode last 2 digits, and number of repeats.

          Shuttle entries are where can loop back to an earlier Snt-sh or Sns-sh entry from a Frh-sh or Fns-sh (Finish Shuttle)
          entry.  Here the shuttle start can have two entries, one from a set position (Snt-sh, must be located) or from a F-nshs
          (Sns-sh) - with NO repeat from this source, and from a Fxx-sh, with repeats.  After all shuttle repeats Frh-sh remains
          where it is, and Fns-sh links to a new service (via an Sns entry), but there must be no repeats in this new service
          (it's for a shuttle train to return to depot at end of services)

          Command/Location & details are as follows:-

          Although headcodes can be duplicated, all joins, splits, new services etc give other headcode from both trains' povs, and
          these have to match once only, i.e. if 2E44 splits to 2E45 then it can't split to 2E45 anywhere else, and 2E45 must give
          2E44 in its Sfs entry.  All these are checked.
          ***add note re shuttles & their use of otherheadcodes + non-repeating headcodes***

          Start commands:-
          Snt (StartNew) = Start New Train, i.e. create new train, details = rearstartident, space, frontstartident (can't confuse
          with loc as a start entry can't have a location as details)
          Sfs (TimeCmdHeadCode) = Start From Split, create a new train that has split from another train (& listed in other train's
          timetable line), details = other headcode - (can't confuse with loc as start can't be a loc)
          Sns (TimeCmdHeadCode) = Start, headcode change from earlier service - no need to create train as already exists, it just
          changes its relevant information, details = old headcode (can't confuse with loc as start can't be a loc)
          Snt-sh (SNTShuttle) = Start New Train, i.e. create new train, details = rearstartident, space, frontstartident (can't
          confuse with loc as start can't be a loc) then the Fsh-XX service headcode (OtherHeadCode can't be same headcode)
          Sns-sh (SNSShuttle) = Start, headcode change from earlier service - no need to create train as already exists, it just
          changes its relevant information, details = the FSH-XX service headcode (OtherHeadCode, can't be same headcode)
          followed by the non-repeating F-nshs headcode (NonRepeatingShuttleLinkHeadCode)
          Sns-fsh (SNSNonRepeatFromShuttle) = Start as a non-repeating service from a shuttle service that has finished all its
          repeats, details = NonRepeatingShuttleLinkHeadCode for the corresponding shuttle Fns-sh service

          Intermediate commands:-
          Time - Location (TimeLoc), can be arrival or departure depending on context
          Time Time location (TimeTimeLoc), arrival and departure
          Location Name (exactly as used in the railway) in TimeLoc & TimeTimeLoc means that the train is required to stop at the location
          pas (PassTime), Time;pas;Location
          jbo (TimeCmdHeadCode) = Joined By Other = joined by other train, details = new headcode (await other train - may be delayed).  Note that the
          joining train's finish details must correspond or the file check will fail
          fsp (TimeCmdHeadCode) = Front Split = a new train splits away from front of this train, both trains in same direction, details = new headcode (create
          new train - that train's starting information must correspond)
          rsp (TimeCmdHeadCode) = Rear Split = a new train splits away from rear of this train, both trains in same direction, details = new headcode  (create
          new train - that train's starting information must correspond)
          cdt (TimeCmd) = Change Direction of Train = change direction, no details needed & no train creation

          Finish commands:-
          Fns (TimeCmdHeadCode) = Finish New Service = finish, form new service in same direction, details = new headcode (no train
          creation)
          F-nshs (FNSShuttle) = Finish New Service (Shuttle) = finish, form new shuttle service in same direction, details =
          shuttle headcode (no train creation)
          Fjo (TimeCmdHeadCode) = Finish Join Other = finish, join other train (which must be on an adjacent element, either end -
          may have to wait for it), details = new headcode (delete train)
          Frh (FinRemHere) = Finish Remain Here = stay here indefinitely, no details & no time needed
          Fer (ExitRailway) = Finish, exit railway (i.e at a continuation) - details = set of allowable exit IDs
          Frh-sh (TimeCmdHeadCode) = Finish then restart as a shuttle using Snt-sh or Sns-sh, when all shuttle repeats done remain
          here
          Fns-sh (FSHNewService) = Finish then restart as a shuttle using Snt-sh or Sns-sh, when all shuttle repeats done form new
          service via Sns-fsh using the NonRepeatingShuttleLinkHeadCode

          Repeat:-
          R;mm;dd;nn (Repeat) where mm = minute increment, dd = 2nd 2 headcode digit increment & nn = no. of repeats (no max as can duplicate
          headcodes - it is up to user to avoid duplicates if he/she wishes to.

          Checks carried out with error messages in this function:-
          At least one comma in a service line (it's based on a .csv file)
          No entries following train information;
          At least one comma in remainder after train information (i.e at least a start and a finish entry);
          SplitEntry returns false in an intermediate entry - message repeats the entry for information;
          First entry not a start entry;
          Train information incomplete before a start entry;
          Entry follows a finish entry but doesn't begin with 'R';
          SplitEntry returns false in a finish entry - message repeats the entry for information;
          Last action entry isn't a finish entry.

          Function returns false with no message if:-
          Timetable start time invalid (no message is given for an invalid time as the line is assumed to be an irrelevant line; if no start
          time is found at all then an error message is given in the calling function);
          SplitTrainInfo returns false (message given in called function);
          SplitRepeat returns false (message given in called function).
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ProcessOneTimetableLine," + AnsiString(Count) + "," + OneLine + "," +
                                 AnsiString((short)FinalCall) + "," + AnsiString((short)CheckLocationsExistInRailway));
    TTrainDataEntry TempTrainDataEntry;

    EndOfFile = false;
    StripSpaces(0, OneLine);
    // strip both leading and trailing spaces at ends of line and spaces before and after all commas and
    // semicolons within the line
    ServiceReference = "";
    if(OneLine != "")
    {
        if(OneLine[1] != '*')
        {
            int SCPos = OneLine.Pos(';');
            if(SCPos == 0)
            {
                ServiceReference = OneLine.SubString(1, 8);
            }
            else
            {
                ServiceReference = OneLine.SubString(1, (SCPos - 1));
            }
        }
    }
    bool AllCommas = true;

    for(int x = 1; x < OneLine.Length() + 1; x++) // check for nothing but commas (may be all commas if created from Excel) or a blank line
    {
        if(OneLine[x] != ',')
        {
            AllCommas = false;
        }
    }
    if(AllCommas || (OneLine == ""))
    {
        if(Count > 0)
        {
            EndOfFile = true;
            // returns true for a blank line - treated as end of file
            Utilities->CallLogPop(1018);
            return(true);
        }
        else // count == 0 so not yet found a start time, no message to be given
        {
            Utilities->CallLogPop(754);
            return(false);
        }
    }
    AnsiString First = "", Second = "", Third = "", Fourth = "";
    int RearStartOrRepeatMins = 0, FrontStartOrRepeatDigits = 0, NumberOfRepeats = 0;
    TDateTime EventTime(0), ArrivalTime(0), DepartureTime(0);
    TDateTime StartTime(0);
    TNumList ExitList;
    bool Warning = false;

    if(Count == 0) // no start time found yet
    {
/* dropped at v0.6b
          AnyHeadCodeValid = false;
          if(OneLine.SubString(6,5) == ";0000")
          {
          AnyHeadCodeValid = true;
          }
*/
        if(!CheckTimeValidity(0, OneLine, StartTime))
        {
            // no message is given for an invalid time as it's assumed to be an irrelevant line
            // if no start time is found at all then an error message is given in the calling function
            // AnyHeadCodeValid = false;
            Utilities->CallLogPop(755);
            return(false);
        }
        if(FinalCall) // here if start time valid
        {
            TTClockTime = StartTime;
            TimetableStartTime = StartTime;
        }
    }
    else
    {
        AnsiString TrainInfoStr = "", HeadCode = "", Description = "";
        int StartSpeed = 0, MaxRunningSpeed = 0, Mass = 0;
        double MaxBrakeRate = 0;
        double PowerAtRail = 0;
        int SignallerSpeed = 0;
        if(OneLine[1] == '*')
        {
            Utilities->CallLogPop(1581);
            return(true);
            // ignore any line beginning with '*' but return true as there is no error
        }
        int Pos = OneLine.Pos(',');
        if(Pos == 0)
        {
            int SubStringLength = 20;
            if(OneLine.Length() < 20)
            {
                SubStringLength = OneLine.Length();
            }
            TimetableMessage(GiveMessages, "Error in timetable - entry incomplete: see '" + OneLine.SubString(1, SubStringLength) + "'....");
            Utilities->CallLogPop(766);
            return(false);
        }
        TrainInfoStr = OneLine.SubString(1, Pos - 1);
        if(!SplitTrainInfo(0, TrainInfoStr, HeadCode, Description, StartSpeed, MaxRunningSpeed, Mass, MaxBrakeRate, PowerAtRail, SignallerSpeed,
                           GiveMessages)) // error messages given in SplitTrainInfo
        {
            Utilities->CallLogPop(773);
            return(false);
        }
        if(FinalCall)
        {
            // store Train info - conversions done in SplitTrainInfo
            // only headcode mandatory for continuing services
            TempTrainDataEntry.HeadCode = HeadCode;
            TempTrainDataEntry.ServiceReference = HeadCode;
            TempTrainDataEntry.Description = Description;
            TempTrainDataEntry.StartSpeed = StartSpeed;
            TempTrainDataEntry.Mass = Mass;
            TempTrainDataEntry.MaxRunningSpeed = MaxRunningSpeed;
            TempTrainDataEntry.MaxBrakeRate = MaxBrakeRate;
            TempTrainDataEntry.PowerAtRail = PowerAtRail;
            TempTrainDataEntry.SignallerSpeed = SignallerSpeed;
            TTrainOperatingData TempTrainOperatingData;
            TempTrainDataEntry.TrainOperatingDataVector.push_back(TempTrainOperatingData); // push empty vector for now
        }
        AnsiString NewRemainder = OneLine.SubString(Pos + 1, OneLine.Length() - Pos);
        // now left with series of entries for this train, but there may be a string of commas at the end of the line if created by Excel
        // so strip them off
        while(NewRemainder[NewRemainder.Length()] == ',')
        {
            if(NewRemainder.Length() > 1)
            {
                NewRemainder = NewRemainder.SubString(1, NewRemainder.Length() - 1);
            }
            else
            {
                NewRemainder = "";
                break;
            }
        }
        // check if zero length & fail if so
        if(NewRemainder == "")
        {
            TimetableMessage(GiveMessages, "Error in timetable - no events following train: '" + OneLine + "'");
            Utilities->CallLogPop(769);
            return(false);
        }
        // now have one more entry than there are commas
        int CommaCount = 0;
        for(int x = 1; x < NewRemainder.Length() + 1; x++)
        {
            if(NewRemainder[x] == ',')
            {
                CommaCount++;
            }
        } // must have at least 1 comma, for start & finish entries, unless train is entered under signaller control
        if(CommaCount == 0)
        {
            if((NewRemainder.SubString(7, 3) != "Snt") || (NewRemainder[NewRemainder.Length()] != 'S'))
            {
                int SubStringLength = 20;
                if(OneLine.Length() < 20)
                {
                    SubStringLength = OneLine.Length();
                }
                TimetableMessage(GiveMessages,
                                 "Error in timetable - must have at least a start and a finish event for a train that is not started under signaller control - see line beginning: '" +
                                 OneLine.SubString(1, SubStringLength) + "'....");
                Utilities->CallLogPop(783);
                return(false);
            }
        }
        AnsiString OneEntry = "";
        TTimetableFormatType FormatType;
        TTimetableSequenceType SequenceType;
        TTimetableLocationType LocationType;
        TTimetableShuttleLinkType ShuttleLinkType;
        bool FinishFlag = false;
        bool NewTrain = false;//added at v2.14.0 to record created trains for later zero power checks
        for(int x = 0; x < CommaCount + 1; x++)
        {
            if((CommaCount == 0) || (x < CommaCount))
            // i.e. train entered under signaller control with no repeats, or entry is not the last,
            // in which case there's a comma & finish element or repeat still to come this entry could
            // be a finish but can't be a repeat
            {
                if(CommaCount == 0)
                {
                    OneEntry = NewRemainder;
                    NewRemainder = "";
                }
                else
                {
                    Pos = NewRemainder.Pos(',');
                    OneEntry = NewRemainder.SubString(1, Pos - 1);
                    NewRemainder = NewRemainder.SubString(Pos + 1, NewRemainder.Length() - Pos);
                }
                First = "";
                Second = "";
                Third = "";
                Fourth = "";
                RearStartOrRepeatMins = 0;
                FrontStartOrRepeatDigits = 0;
                NumberOfRepeats = 0;
                if(!SplitEntry(0, OneEntry, GiveMessages, CheckLocationsExistInRailway, First, Second, Third, Fourth, RearStartOrRepeatMins,
                               FrontStartOrRepeatDigits, FormatType, LocationType, SequenceType, ShuttleLinkType, ExitList, Warning))
                {
                    TimetableMessage(GiveMessages, "Error in timetable - Event: '" + OneEntry + "'");
                    Utilities->CallLogPop(756);
                    return(false);
                }
                if((Second == "Snt") || (Second == "Snt-sh")) //added at v2.14.0, see above
                {
                    NewTrain = true;
                }
                // check if warning for Frh or Fjo & reject
                if(Warning && (Second == "Frh"))
                {
                    TimetableMessage(GiveMessages, "Error in line - '" + OneEntry + "': warnings cannot be given for 'Frh' events");
                    Utilities->CallLogPop(1793);
                    return(false);
                }
                if(Warning && (Second == "Fjo"))
                {
                    TimetableMessage(GiveMessages, "Error in line - '" + OneEntry +
                                     "': warnings cannot be given for 'Fjo' events, for a train join warning add a 'W' prefix to the 'jbo' event");
                    Utilities->CallLogPop(1794);
                    return(false);
                }
                //below added at v2.14.0 to prevent unpowered trains attempting to be joined by (Second == jbo), split (Second -- fsp or rsp),
                //or change direction.  Form a new service dealt with below for zero power as it's a finish event.
                if(NewTrain && (PowerAtRail < 1) && (Second == "jbo"))
                {
                    TimetableMessage(GiveMessages, "Error in line - '" + OneEntry +
                                     "': a train created without power can't 'be joined by' another train (i.e. can't include command 'jbo'), "
                                     "use command 'Fjo' (i.e. 'join' another train) instead immediately after the line containing 'Snt', and use "
                                     "command 'jbo' for the train it is to join.");
                    Utilities->CallLogPop(2545);
                    return(false);
                }
                if(NewTrain && (PowerAtRail < 1) && ((Second == "fsp") || (Second == "rsp")))
                {
                    TimetableMessage(GiveMessages, "Error in line - '" + OneEntry +
                                     "': a train created without power can't split.");
                    Utilities->CallLogPop(2546);
                    return(false);
                }
                if(NewTrain && (PowerAtRail < 1) && (Second == "cdt"))
                {
                    TimetableMessage(GiveMessages, "Error in line - '" + OneEntry +
                                     "': a train created without power can't change direction under timetable control.");
                    Utilities->CallLogPop(2547);
                    return(false);
                }
                //end of new additions
                if(x == 0) // should be start event
                {
                    if(SequenceType != StartSequence)
                    {
                        TimetableMessage(GiveMessages, "Error in timetable - First event not a start event: '" + OneEntry + "'");
                        Utilities->CallLogPop(784);
                        return(false);
                    }
                    if((Second == "Snt") && (Fourth == 'S') && (NewRemainder != ""))
                    {
                        if(NewRemainder[1] != 'R')
                        {
                            TimetableMessage(GiveMessages,
                                             "Error in timetable - the only event that can follow a train created under signaller control is a repeat, see '" +
                                             OneEntry + "'");
                            Utilities->CallLogPop(787);
                            return(false);
                        }
                    }
                    if((Second == "Snt") || (Second == "Snt-sh"))
                    // need full train information including non-default values for at least HeadCode, Description,
                    // MaxRunningSpeed, Mass, MaxBrakeRate, & PowerAtRail
                    {
                        if((HeadCode == "") || (Description == "") || (MaxRunningSpeed == 0) || (Mass == 0) || (MaxBrakeRate == 0)) // ||
                        // (PowerAtRail == 0)) allowed 0 for power at v2.4.0
                        {
                            TimetableMessage(GiveMessages, "Error in timetable - train information incomplete before 'Snt' or 'Snt-sh' start event: '" +
                                             OneEntry + "'");
                            Utilities->CallLogPop(1783);
                            return(false);
                        }
                    }
                    if((Second == "Sfs") || (Second == "Sns") || (Second == "Sns-sh") || (Second == "Sns-fsh"))
                    // service continuation - need at least non-default value for HeadCode
                    {
                        if(HeadCode == "")
                        {
                            TimetableMessage(GiveMessages, "Error in timetable - headcode missing before 'Sfs', 'Sns', 'Sns-sh' or 'Sns-fsh' start event: '" +
                                             OneEntry + "'");
                            Utilities->CallLogPop(788);
                            return(false);
                        }
                        if((StartSpeed != 0) || (MaxRunningSpeed != 0) || (Mass != 0) || (MaxBrakeRate != 0) || (PowerAtRail != 0))
                        {
                            TimetableMessage(GiveMessages,
                                             "Error in timetable - information additional to a headcode & optional description given before 'Sfs', 'Sns', 'Sns-sh' or 'Sns-fsh' start event: '" +
                                             OneEntry + "'");
                            Utilities->CallLogPop(843);
                            return(false);
                        }
                    }
                }
                if(SequenceType == FinishSequence)
                {
                    FinishFlag = true;
                    // marker for only permitted additional entry being a repeat, only needed if the
                    // finish entry is not the last entry
                }
                if(FinalCall)
                {
                    // interpret & add to ActionVector
                    TDateTime TempTime;
                    TActionVectorEntry ActionVectorEntry;
                    ActionVectorEntry.FormatType = FormatType;
                    ActionVectorEntry.LocationType = LocationType;
                    ActionVectorEntry.SequenceType = SequenceType;
                    ActionVectorEntry.ShuttleLinkType = ShuttleLinkType;
                    ActionVectorEntry.Warning = Warning;
                    if(FormatType == TimeLoc)
                    {
                        if(CheckTimeValidity(1, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        } // these will all be true as final call

                        ActionVectorEntry.LocationName = Second;
                    }
                    else if(FormatType == PassTime) // new
                    {
                        if(CheckTimeValidity(17, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.LocationName = Third;
                    }
                    else if(FormatType == TimeTimeLoc)
                    {
                        if(CheckTimeValidity(2, First, ActionVectorEntry.ArrivalTime))
                        {
                            ;
                        }
                        if(CheckTimeValidity(3, Second, ActionVectorEntry.DepartureTime))
                        {
                            ;
                        }
                        ActionVectorEntry.LocationName = Third;
                    }
                    else if(FormatType == TimeCmd)
                    {
                        if(CheckTimeValidity(4, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                    }
                    else if(FormatType == ExitRailway)
                    {
                        if(CheckTimeValidity(18, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.ExitList = ExitList;
                    }
                    else if(FormatType == StartNew)
                    {
                        if(CheckTimeValidity(5, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.RearStartOrRepeatMins = RearStartOrRepeatMins;
                        ActionVectorEntry.FrontStartOrRepeatDigits = FrontStartOrRepeatDigits;
                        if(Fourth == 'S')
                        {
                            ActionVectorEntry.SignallerControl = true;
                        }
                    }
                    else if(FormatType == SNTShuttle)
                    {
                        if(CheckTimeValidity(6, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.RearStartOrRepeatMins = RearStartOrRepeatMins;
                        ActionVectorEntry.FrontStartOrRepeatDigits = FrontStartOrRepeatDigits;
                        ActionVectorEntry.OtherHeadCode = Fourth;
                    }
                    else if(FormatType == SNSShuttle)
                    {
                        if(CheckTimeValidity(7, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.OtherHeadCode = Third;
                        ActionVectorEntry.NonRepeatingShuttleLinkHeadCode = Fourth;
                    }
                    else if(FormatType == TimeCmdHeadCode)
                    {
                        if(CheckTimeValidity(8, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.OtherHeadCode = Third;
                    }
                    else if((FormatType == FNSNonRepeatToShuttle) || (FormatType == SNSNonRepeatFromShuttle))
                    {
                        if(CheckTimeValidity(9, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.NonRepeatingShuttleLinkHeadCode = Third;
                    }
                    else if(FormatType == FSHNewService)
                    {
                        if(CheckTimeValidity(10, First, ActionVectorEntry.EventTime))
                        {
                            ;
                        }
                        ActionVectorEntry.Command = Second;
                        ActionVectorEntry.OtherHeadCode = Third;
                        ActionVectorEntry.NonRepeatingShuttleLinkHeadCode = Fourth;
                    }
                    else if(FormatType == FinRemHere)
                    {
                        ActionVectorEntry.Command = Second;
                    }
                    TempTrainDataEntry.ActionVector.push_back(ActionVectorEntry);
                }
            }
            else // last entry, & not entered under signaller control with no repeats, i.e. could be finish or repeat
            {
                OneEntry = NewRemainder;
                First = "";
                Second = "";
                Third = "";
                Fourth = "";
                RearStartOrRepeatMins = 0;
                FrontStartOrRepeatDigits = 0;
                NumberOfRepeats = 0;
                if((FinishFlag) && (OneEntry[1] != 'R'))
                // already had a finish entry
                {
                    TimetableMessage(GiveMessages, "Error in timetable - Last event = '" + OneEntry + "'. An earlier finish event has been found with something other than a repeat following it - only a repeat can follow a finish event.");
                    Utilities->CallLogPop(79);
                    return(false);
                }
                if(OneEntry[1] != 'R') // must be finish
                {
                    if(!SplitEntry(1, OneEntry, GiveMessages, CheckLocationsExistInRailway, First, Second, Third, Fourth, RearStartOrRepeatMins,
                                   FrontStartOrRepeatDigits, FormatType, LocationType, SequenceType, ShuttleLinkType, ExitList, Warning))
                    {
                        TimetableMessage(GiveMessages, "Error in timetable - Event: '" + OneEntry + "'");
                        Utilities->CallLogPop(757);
                        return(false);
                    }
                    //below added at v2.14.0 to prevent unpowered trains attempting to form a new service.
                    if(NewTrain && (PowerAtRail < 1) && ((Second == "Fns") || (Second == "Frh-sh") || (Second == "Fns-sh") || (Second == "F-nshs")))
                    {
                        TimetableMessage(GiveMessages, "Error in line - '" + OneEntry +
                                         "': a train created without power can't form a new service.");
                        Utilities->CallLogPop(2548);
                        return(false);
                    }
                    //end of new additions
                    if(SequenceType != FinishSequence)
                    {
                        TimetableMessage(GiveMessages, "Error in timetable - last event should be a finish: '" + OneEntry + "'");
                        Utilities->CallLogPop(785);
                        return(false);
                    }
                    if(FinalCall)
                    {
                        // interpret & add to ActionVector
                        TDateTime TempTime;
                        TActionVectorEntry ActionVectorEntry;
                        ActionVectorEntry.FormatType = FormatType;
                        ActionVectorEntry.LocationType = LocationType;
                        ActionVectorEntry.SequenceType = SequenceType;
                        ActionVectorEntry.ShuttleLinkType = ShuttleLinkType;
                        ActionVectorEntry.Warning = Warning;
                        if(FormatType == TimeCmd)
                        {
                            if(CheckTimeValidity(11, First, ActionVectorEntry.EventTime))
                            {
                                ;
                            }
                            ActionVectorEntry.Command = Second;
                        }
                        else if(FormatType == TimeCmdHeadCode)
                        {
                            if(CheckTimeValidity(12, First, ActionVectorEntry.EventTime))
                            {
                                ;
                            }
                            ActionVectorEntry.Command = Second;
                            ActionVectorEntry.OtherHeadCode = Third;
                        }
                        else if(FormatType == FNSNonRepeatToShuttle)
                        {
                            if(CheckTimeValidity(13, First, ActionVectorEntry.EventTime))
                            {
                                ;
                            }
                            ActionVectorEntry.Command = Second;
                            ActionVectorEntry.NonRepeatingShuttleLinkHeadCode = Third;
                        }
                        else if(FormatType == FSHNewService)
                        {
                            if(CheckTimeValidity(14, First, ActionVectorEntry.EventTime))
                            {
                                ;
                            }
                            ActionVectorEntry.Command = Second;
                            ActionVectorEntry.OtherHeadCode = Third;
                            ActionVectorEntry.NonRepeatingShuttleLinkHeadCode = Fourth;
                        }
                        else if(FormatType == ExitRailway)
                        {
                            if(CheckTimeValidity(19, First, ActionVectorEntry.EventTime))
                            {
                                ;
                            }
                            ActionVectorEntry.Command = Second;
                            ActionVectorEntry.ExitList = ExitList;
                        }
                        else if(FormatType == FinRemHere)
                        {
                            ActionVectorEntry.Command = Second;
                        }
                        TempTrainDataEntry.ActionVector.push_back(ActionVectorEntry);
                    }
                }
                else // repeat
                {
                    if(!SplitRepeat(0, OneEntry, RearStartOrRepeatMins, FrontStartOrRepeatDigits, NumberOfRepeats, GiveMessages))
                    {
                        Utilities->CallLogPop(786);
                        // error messages given in SplitRepeat
                        return(false);
                    }
                    if(FinalCall)
                    {
                        TActionVectorEntry ActionVectorEntry;
                        ActionVectorEntry.FormatType = Repeat;
                        ActionVectorEntry.LocationType = LocTypeForRepeatEntry;
                        ActionVectorEntry.SequenceType = SequTypeForRepeatEntry;
                        ActionVectorEntry.ShuttleLinkType = ShuttleLinkTypeForRepeatEntry;
                        ActionVectorEntry.RearStartOrRepeatMins = RearStartOrRepeatMins;
                        ActionVectorEntry.FrontStartOrRepeatDigits = FrontStartOrRepeatDigits;
                        ActionVectorEntry.NumberOfRepeats = NumberOfRepeats;
                        TempTrainDataEntry.ActionVector.push_back(ActionVectorEntry);
                    }
                }
            }
        }
        if(FinalCall)
        {
            TrainDataVector.push_back(TempTrainDataEntry);
        }
    }
    Utilities->CallLogPop(80);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::Last2CharactersBothDigits(int Caller, AnsiString HeadCode)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",Last2CharactersBothDigits," + HeadCode);
    if((HeadCode[HeadCode.Length() - 1] < '0') || (HeadCode[HeadCode.Length() - 1] > '9'))
    {
        Utilities->CallLogPop(1890);
        return(false);
    }
    if((HeadCode[HeadCode.Length()] < '0') || (HeadCode[HeadCode.Length()] > '9'))
    {
        Utilities->CallLogPop(1891);
        return(false);
    }
    Utilities->CallLogPop(1892);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckTimeValidity(int Caller, AnsiString TimeStr, TDateTime &Time)
// 1st 5 chars must be HH:MM, anything else will be ignored
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckTimeValidity," + TimeStr);
    if(TimeStr.Length() < 5)
    {
        Utilities->CallLogPop(926);
        return(false);
    }
    if((TimeStr[1] < '0') || (TimeStr[1] > '9'))
    {
        Utilities->CallLogPop(927);
        return(false);
    }
    if((TimeStr[2] < '0') || (TimeStr[2] > '9'))
    {
        Utilities->CallLogPop(928);
        return(false);
    }
    if(TimeStr[3] != ':')
    {
        Utilities->CallLogPop(929);
        return(false);
    }
    if((TimeStr[4] < '0') || (TimeStr[4] > '5'))
    {
        Utilities->CallLogPop(930);
        return(false);
    }
    if((TimeStr[5] < '0') || (TimeStr[5] > '9'))
    {
        Utilities->CallLogPop(931);
        return(false);
    }
    while(TimeStr.Length() > 5)
    {
        TimeStr = TimeStr.SubString(1, TimeStr.Length() - 1);
    }
    double WholeHours = (AnsiString(TimeStr[1]) + AnsiString(TimeStr[2])).ToDouble();
    double FracHour = ((AnsiString(TimeStr[4]) + AnsiString(TimeStr[5])).ToDouble()) / 60.0;

    if((WholeHours + FracHour) >= 95.98334)
    {
        Utilities->CallLogPop(1817);
        return(false); // > 95h 59m
    }
    Time = TDateTime((WholeHours + FracHour) / 24);
    Utilities->CallLogPop(932);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::SplitEntry(int Caller, AnsiString OneEntry, bool GiveMessages, bool CheckLocationsExistInRailway, AnsiString &First, AnsiString &Second,
                                  AnsiString &Third, AnsiString &Fourth, int &RearStartOrRepeatMins, int &FrontStartOrRepeatDigits, TTimetableFormatType &FormatType,
                                  TTimetableLocationType &LocationType, TTimetableSequenceType &SequenceType, TTimetableShuttleLinkType &ShuttleLinkType, TNumList &ExitList, bool &Warning)
/* This is a train action entry from a single line of the timetable, i.e. not train information and not a repeat entry.
          Return false for failure.
          See description above under ProcessOneTimetableLinefor details of train action entries
          NB all types set except LocationType for Sns as may be located or not
*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SplitEntry," + OneEntry);
    Warning = false;
    TDateTime TempTime;

    if(OneEntry.Length() > 0)
    {
        if(OneEntry[1] == 'W') // warning
        {
            Warning = true;
            OneEntry = OneEntry.SubString(2, OneEntry.Length() - 1);
            // strip it off
        }
    }
    if(OneEntry == "Frh")
    {
        FormatType = FinRemHere;
        SequenceType = FinishSequence;
        LocationType = AtLocation;
        ShuttleLinkType = NotAShuttleLink;
        Second = "Frh";
        Utilities->CallLogPop(1016);
        return(true);
    }
    if(OneEntry.Length() < 7)
    {
        Utilities->CallLogPop(907);
        return(false); // 'HH:MM;' + at least a one-letter location name
    }
    int Pos = OneEntry.Pos(';'); // first segment delimiter

    if(Pos != 6)
    {
        Utilities->CallLogPop(908);
        return(false);
        // no delimiter or delimiter not in position 6, has to be a time so fail
    }
    First = OneEntry.SubString(1, 5); // has to be a time
    if(!CheckTimeValidity(16, First, TempTime))
    {
        Utilities->CallLogPop(909);
        return(false);
    }
    AnsiString Remainder = OneEntry.SubString(Pos + 1, OneEntry.Length() - Pos);

    if((Remainder[1] >= '0') && (Remainder[1] <= '9'))
    // next segment is a time so this is a TimeTimeLoc & 3rd seg has to be a location to be valid
    {
        if(Remainder.Length() < 7)
        {
            Utilities->CallLogPop(910);
            return(false); // 'HH:MM;' + at least a one-letter location name
        }
        Pos = Remainder.Pos(';'); // second segment delimiter
        if(Pos == 0)
        {
            Utilities->CallLogPop(911);
            return(false);
            // no delimiter, has to be one between departure time & location
        }
        Second = Remainder.SubString(1, 5); // has to be a time
        if(!CheckTimeValidity(15, Second, TempTime))
        {
            Utilities->CallLogPop(912);
            return(false);
        }
        Third = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
        if(!CheckLocationValidity(0, Third, GiveMessages, CheckLocationsExistInRailway))
        {
            Utilities->CallLogPop(913);
            return(false);
        }
        FormatType = TimeTimeLoc;
        SequenceType = IntermediateSequence;
        LocationType = AtLocation;
        ShuttleLinkType = NotAShuttleLink;
        Utilities->CallLogPop(914);
        return(true);
    }
    Pos = Remainder.Pos(';'); // second segment delimiter
    if(Pos == 0) // no third segment so second must be a location, or cdt
    {
        Second = Remainder;
        if(Second == "cdt")
        {
            FormatType = TimeCmd;
            ShuttleLinkType = NotAShuttleLink;
            LocationType = AtLocation;
            SequenceType = IntermediateSequence;
            Utilities->CallLogPop(915);
            return(true);
        }
        if(!CheckLocationValidity(1, Second, GiveMessages, CheckLocationsExistInRailway))
        {
            Utilities->CallLogPop(916);
            return(false);
        }
        else
        {
            FormatType = TimeLoc;
            LocationType = AtLocation;
            SequenceType = IntermediateSequence;
            ShuttleLinkType = NotAShuttleLink;
            Utilities->CallLogPop(917);
            return(true);
        }
    }
    // here if second segment is a command, with a third & maybe fourthanalysis segments as details
    if((Pos != 4) && (Pos != 7) && (Pos != 8))
    {
        Utilities->CallLogPop(918);
        return(false);
        // no third segement or not in position 4 or 7, & should be since all commands are 3, 6 or 7 letters
    }
    Second = Remainder.SubString(1, Pos - 1); // command

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    // details
    Pos = Remainder.Pos(';'); // third segment delimiter
    if(Pos == 0)
    {
        Third = Remainder;
    }
    else
    {
        Third = Remainder.SubString(1, Pos - 1);
        Fourth = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    }
    if((Second == "Snt") || (Second == "Snt-sh"))
    // third has to be 2 element idents with a space between
    {
        int SpacePos = Third.Pos(' ');
        if(SpacePos == 0)
        {
            Utilities->CallLogPop(919);
            return(false); // no space
        }
        AnsiString RearStartStr = Third.SubString(1, SpacePos - 1);
        AnsiString FrontStartStr = Third.SubString(SpacePos + 1, Third.Length() - SpacePos);
        // int RearPosition=0, FrontPosition=0, RearExitPos=0;
        if(CheckLocationsExistInRailway)
        {
            if(!CheckStartPositionValidity(0, RearStartStr, FrontStartStr, GiveMessages))
            {
                Utilities->CallLogPop(920);
                return(false);
            }
            RearStartOrRepeatMins = Track->GetTrackVectorPositionFromString(3, RearStartStr, GiveMessages);
            FrontStartOrRepeatDigits = Track->GetTrackVectorPositionFromString(4, FrontStartStr, GiveMessages);
        }
        if(Second == "Snt")
        {
            FormatType = StartNew;
            SequenceType = StartSequence;
            LocationType = NoLocation;
            // can't be set until know whether located or not - done in SecondPassActions
            ShuttleLinkType = NotAShuttleLink;
        }
        else // Snt-sh
        {
            FormatType = SNTShuttle;
            LocationType = AtLocation;
            SequenceType = StartSequence;
            ShuttleLinkType = ShuttleLink;
            if(!CheckHeadCodeValidity(0, GiveMessages, Fourth))
            {
                Utilities->CallLogPop(1038);
                return(false);
            }
        }
        Utilities->CallLogPop(921);
        return(true);
    }
    if(Second == "Sns-sh") // third & fourth have to be headcodes
    {
        FormatType = SNSShuttle;
        LocationType = AtLocation;
        SequenceType = StartSequence;
        ShuttleLinkType = ShuttleLink;
        if(!CheckHeadCodeValidity(1, GiveMessages, Third))
        {
            Utilities->CallLogPop(1039);
            return(false);
        }
        if(!CheckHeadCodeValidity(2, GiveMessages, Fourth))
        {
            Utilities->CallLogPop(1040);
            return(false);
        }
        Utilities->CallLogPop(1041);
        return(true);
    }
    if(Second == "F-nshs")
    {
        FormatType = FNSNonRepeatToShuttle;
        LocationType = AtLocation;
        SequenceType = FinishSequence;
        ShuttleLinkType = ShuttleLink;
        if(!CheckHeadCodeValidity(3, GiveMessages, Third))
        {
            Utilities->CallLogPop(1047);
            return(false);
        }
        Utilities->CallLogPop(1048);
        return(true);
    }
    if(Second == "Sns-fsh")
    {
        FormatType = SNSNonRepeatFromShuttle;
        LocationType = AtLocation;
        SequenceType = StartSequence;
        ShuttleLinkType = ShuttleLink;
        if(!CheckHeadCodeValidity(4, GiveMessages, Third))
        {
            Utilities->CallLogPop(1098);
            return(false);
        }
        Utilities->CallLogPop(1099);
        return(true);
    }
    if(Second == "Fns-sh") // third & fourth have to be headcodes
    {
        FormatType = FSHNewService;
        LocationType = AtLocation;
        SequenceType = FinishSequence;
        ShuttleLinkType = ShuttleLink;
        if(!CheckHeadCodeValidity(5, GiveMessages, Third))
        {
            Utilities->CallLogPop(1050);
            return(false);
        }
        if(!CheckHeadCodeValidity(6, GiveMessages, Fourth))
        {
            Utilities->CallLogPop(1051);
            return(false);
        }
        Utilities->CallLogPop(1052);
        return(true);
    }
    // new segment for 'pas'
    if(Second == "pas") // third has to be a location
    {
        FormatType = PassTime;
        LocationType = EnRoute;
        SequenceType = IntermediateSequence;
        ShuttleLinkType = NotAShuttleLink;
        if(!CheckLocationValidity(2, Third, GiveMessages, CheckLocationsExistInRailway))
        {
            Utilities->CallLogPop(1515);
            return(false);
        }
        Utilities->CallLogPop(1516);
        return(true);
    }
    // new segment for revised 'Fer'
    if(Second == "Fer")
    // third has to be a set of IDs separated by spaces, and at least 1
    {
        FormatType = ExitRailway;
        LocationType = EnRoute;
        SequenceType = FinishSequence;
        ShuttleLinkType = NotAShuttleLink;
        if(CheckLocationsExistInRailway)
        {
            if(!CheckAndPopulateListOfIDs(0, Third, ExitList, GiveMessages))
            {
                Utilities->CallLogPop(1519);
                return(false);
            }
        }
        Utilities->CallLogPop(1520);
        return(true);
    }
    // all remainder must be TimeCmdHeadCode types to be valid
    if((Second != "Fns") && (Second != "Fjo") && (Second != "jbo") && (Second != "fsp") && (Second != "rsp") && (Second != "Sfs") && (Second != "Sns") &&
       (Second != "Frh-sh"))
    {
        Utilities->CallLogPop(922);
        return(false); // all TimeCmdHeadCode types
    }
    if(!CheckHeadCodeValidity(7, GiveMessages, Third))
    {
        Utilities->CallLogPop(923);
        return(false);
    }
    FormatType = TimeCmdHeadCode;
    LocationType = AtLocation;
    if(Second == "Frh-sh")
    {
        ShuttleLinkType = ShuttleLink;
    }
    else
    {
        ShuttleLinkType = NotAShuttleLink;
    }
    if((Second == "Fns") || (Second == "Fjo") || (Second == "Frh-sh"))
    {
        SequenceType = FinishSequence;
    }
    if((Second == "jbo") || (Second == "fsp") || (Second == "rsp"))
    {
        SequenceType = IntermediateSequence;
    }
    if((Second == "Sfs") || (Second == "Sns"))
    {
        SequenceType = StartSequence;
    }
    Utilities->CallLogPop(924);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckLocationValidity(int Caller, AnsiString LocStr, bool GiveMessages, bool CheckLocationsExistInRailway)
{
    // check that the location name exists in the railway (only if CheckLocationsExistInRailway is true), doesn't begin with a number
    // and contains no special characters
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckLocationValidity," + LocStr);
    if(LocStr == "")
    {
        Utilities->CallLogPop(1353);
        return(false); // has to have at least one character
    }
    if((LocStr[1] >= '0') && (LocStr[1] <= '9'))
    {
        Utilities->CallLogPop(1354);
        return(false); // can't begin with a number
    }
    for(int x = 1; x < LocStr.Length() + 1; x++)
    {
        if(LocStr[x] < ' ')
        {
            Utilities->CallLogPop(1355);
            return(false); // contains a special character
        }
        if(LocStr[x] > 'z')
        {
            Utilities->CallLogPop(1356);
            return(false); // contains a character outside the standard ASCII set
        }
    }
    // check exists in railway location list if CheckLocationsExistInRailway is true
    if(CheckLocationsExistInRailway)
    {
        if(!Track->TimetabledLocationNameAllocated(3, LocStr))
        {
            TimetableMessage(GiveMessages, "Location name '" + LocStr +
                             "' appears in the timetable but is not a valid name.  To be valid the name must be a stopping location and apply to one or more platforms " +
                             "(not concourses on their own), or to track at a blue non-station named location.  BUT NOTE THAT trains can't stop at continuations so a name " +
                             "that includes a continuation will not be valid.");
            Utilities->CallLogPop(1357);
            return(false);
        }
    }
    Utilities->CallLogPop(1358);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckHeadCodeValidity(int Caller, bool GiveMessages, AnsiString HeadCode)
{
    // if(!AnyHeadCodeValid) up to 8 characters total & last 4 characters must be NLNN where N = number and L = capital or small letter
    // if(AnyHeadCodeValid) up to 8 characters total, last 2 chars must be digits & last but 2 can be any alphanumeric, upper or lower case
    // NOTE: As of v0.6b AnyHeadCodeValid dropped, all headcodes are unrestricted
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + AnsiString((short)GiveMessages) + ",CheckHeadCodeValidity," +
                                 HeadCode);
    if((HeadCode.Length() < 4) || (HeadCode.Length() > 8))
    {
        TimetableMessage(GiveMessages, "Headcode error in '" + HeadCode +
                         "', length must be between 4 and 8 characters, and last 4 must be a legitimate headcode. This error can also be caused by omitting a service reference after Sns, Snt-sh, Sns-sh, Fns, Fns-sh or Frh-sh");
        Utilities->CallLogPop(1359);
        return(false);
    }
    // firstly allow any printable character (ASCII >= CHAR(32) & <= CHAR(126)), as these allowed in 1st 4 characters
    for(int x = 1; x < (HeadCode.Length() + 1); x++)
    {
        if((HeadCode[x] < ' ') || (HeadCode[x] > '~'))
        {
            TimetableMessage(GiveMessages, "Non-printable character in headcode '" + HeadCode + "'");
            Utilities->CallLogPop(1895);
            return(false);
        }
    }
    // secondly ensure the true Headcode only has letters or digits
    for(int x = 3; x >= 0; x--)
    {
        if(((HeadCode[HeadCode.Length() - x] < 'A') || (HeadCode[HeadCode.Length() - x] > 'Z')) && ((HeadCode[HeadCode.Length() - x] < 'a') ||
                                                                                                    (HeadCode[HeadCode.Length() - x] > 'z')) && ((HeadCode[HeadCode.Length() - x] < '0') || (HeadCode[HeadCode.Length() - x] > '9')))
        {
            TimetableMessage(GiveMessages, "Headcode error in '" + HeadCode + "', headcode must consist of letters and digits only");
            Utilities->CallLogPop(1790);
            return(false);
        }
    }
    Utilities->CallLogPop(1364);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckAndPopulateListOfIDs(int Caller, AnsiString IDSet, TNumList &ExitList, bool GiveMessages)
// set of track element IDs, separated by spaces, and at least 1 present
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckAndPopulateListOfIDs," + IDSet);  //had wrong title, changed at v2.13.0
    ExitList.clear();
    AnsiString CurrentID = "";

    if(IDSet.Length() == 0)
    {
        TimetableMessage(GiveMessages, "Must have at least one exit element ID following 'Fer'");
        Utilities->CallLogPop(1521);
        return(false);
    }
    for(int x = 1; x <= IDSet.Length(); x++)
    {
        char C = IDSet[x];
        if(((C < '0') || (C > '9')) && (C != ' ') && (C != 'N') && (C != '-'))
        {
            TimetableMessage(GiveMessages, "Illegal character in the set of element IDs following 'Fer' in '" + IDSet + "'");
            Utilities->CallLogPop(1522);
            return(false);
        }
/*  don't use, error checks in GetTrackVectorPositionFromString instead
        if(C == '-')  //this section added at v2.13.0 because of Amon Sadler's error file submitted 24/03/22
        {
            if((x==1) || (x == IDSet.Length()))
            {
                TimetableMessage(GiveMessages, "Illegal minus character ('-') in the set of element IDs following 'Fer' in '" + IDSet + "'");
                Utilities->CallLogPop(2479);
                return(false);
            }
            if((IDSet[x-1] < '0') || (IDSet[x-1] > '9') || (IDSet[x+1] < '0') || (IDSet[x+1] > '9'))
            {
                TimetableMessage(GiveMessages, "Illegal minus character ('-') in the set of element IDs following 'Fer' in '" + IDSet + "'");
                Utilities->CallLogPop(2480);
                return(false);
            }
        }
*/
    }
    int Pos = IDSet.Pos(' '); // look for the first space

    while(true)
    {
        if(Pos == 0)
        {
            CurrentID = IDSet;
            IDSet = "";
        }
        else
        {
            CurrentID = IDSet.SubString(1, Pos - 1);
            IDSet = IDSet.SubString(Pos + 1, IDSet.Length() - Pos);
        }
        int VecPos = Track->GetTrackVectorPositionFromString(7, CurrentID, GiveMessages);
        if(VecPos == -1)
        {
            Utilities->CallLogPop(1523);
            return(false); // messages given in GetTrackVectorPositionFromString
        }
        else
        {
            if(Track->TrackElementAt(722, VecPos).TrackType != Continuation)
            {
                TimetableMessage(GiveMessages, "The element ID '" + CurrentID + "' following 'Fer' is not an exit");
                Utilities->CallLogPop(1524);
                return(false);
            }
            else
            {
                // first check for duplicates
                if(!ExitList.empty())
                {
                    for(TNumListIterator ELIT = ExitList.begin(); ELIT != ExitList.end(); ELIT++)
                    {
                        if(*ELIT == VecPos)
                        {
                            TimetableMessage(GiveMessages, "The element ID '" + CurrentID + "' following 'Fer' duplicates an earlier element");
                            Utilities->CallLogPop(1532);
                            return(false);
                        }
                    }
                }
                // of OK add it to the list
                ExitList.push_back(VecPos);
            }
        }
        if(IDSet == "")
        {
            Utilities->CallLogPop(1525);
            return(true);
        }
        else
        {
            Pos = IDSet.Pos(' '); // look for the next space
        }
    } // while(true)
}

// ---------------------------------------------------------------------------
bool TTrainController::SplitTrainInfo(int Caller, AnsiString TrainInfoStr, AnsiString &HeadCode, AnsiString &Description, int &StartSpeed, int &MaxRunningSpeed,
                                      int &Mass, double &MaxBrakeRate, double &PowerAtRail, int &SignallerSpeed, bool GiveMessages)
// 7 or 8 items for a new train (6 or 7 semicolons), for a continuing service only need headcode, though can have a description, if other
// data entered for continuing service then will be ignored - message given to warn user, checks appropriate number of items and validity
// of each item
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SplitTrainInfo," + TrainInfoStr);
    int Pos = 0;
    AnsiString Remainder = "";
    int SemiColonCount = 0;

    for(int x = 1; x < TrainInfoStr.Length() + 1; x++)
    {
        if(TrainInfoStr[x] == ';')
        {
            SemiColonCount++;
        }
    }
    if((SemiColonCount != 6) && (SemiColonCount != 7) && (SemiColonCount != 1) && (SemiColonCount != 0))
    {
        TimetableMessage(GiveMessages, "Error in train information in '" + TrainInfoStr +
                         "'.  Should be headcode + optional description for a continuing service;" +
                         " or headcode, description, start speed, max running speed, mass, brake force, power (and optional signaller max. speed) for a new service");
        Utilities->CallLogPop(880);
        return(false);
    }
    if(SemiColonCount == 0)
    {
        HeadCode = TrainInfoStr;
        if(!CheckHeadCodeValidity(8, GiveMessages, HeadCode))
        {
            Utilities->CallLogPop(881);
            return(false);
        }
        Utilities->CallLogPop(882);
        return(true);
    }
    if(SemiColonCount == 1) // headcode & description only
    {
        Pos = TrainInfoStr.Pos(';'); // 1st delimiter
        HeadCode = TrainInfoStr.SubString(1, Pos - 1);
        Description = TrainInfoStr.SubString(Pos + 1, TrainInfoStr.Length() - Pos);
        if(!CheckHeadCodeValidity(9, GiveMessages, HeadCode))
        {
            Utilities->CallLogPop(883);
            return(false);
        }
        if(Description == "")
        {
            TimetableMessage(GiveMessages, "Train description missing in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(884);
            return(false);
        }
        if(Description.Length() > 60)
        {
            TimetableMessage(GiveMessages, "Train description too long, limit of 60 characters '" + TrainInfoStr + "'");
            Utilities->CallLogPop(1157);
            return(false);
        }
        for(int x = 1; x < Description.Length() + 1; x++)
        {
            if((Description[x] < ' ') || (Description[x] > '~'))
            {
                TimetableMessage(GiveMessages, "Train description contains invalid characters in '" + TrainInfoStr + "'");
                Utilities->CallLogPop(885);
                return(false);
            }
        }
        Utilities->CallLogPop(886);
        return(true);
    }
    // if here must have 6 or 7 semicolons
    Pos = TrainInfoStr.Pos(';'); // 1st delimiter
    HeadCode = TrainInfoStr.SubString(1, Pos - 1);
    Remainder = TrainInfoStr.SubString(Pos + 1, TrainInfoStr.Length() - Pos);
    if(!CheckHeadCodeValidity(10, GiveMessages, HeadCode))
    {
        Utilities->CallLogPop(887);
        return(false);
    }
    Pos = Remainder.Pos(';'); // 2nd delimiter
    Description = Remainder.SubString(1, Pos - 1);
    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(Description == "")
    {
        TimetableMessage(GiveMessages, "Train description missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(888);
        return(false);
    }
    if(Description.Length() > 60)
    {
        TimetableMessage(GiveMessages, "Train description too long, limit of 60 characters '" + TrainInfoStr + "'");
        Utilities->CallLogPop(1158);
        return(false);
    }
    for(int x = 1; x < Description.Length() + 1; x++)
    {
        if((Description[x] < ' ') || (Description[x] > 126))
        {
            TimetableMessage(GiveMessages, "Train description contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(889);
            return(false);
        }
    }
    Pos = Remainder.Pos(';'); // 3rd delimiter
    AnsiString StartSpeedStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(StartSpeedStr == "")
    {
        TimetableMessage(GiveMessages, "Train starting speed missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(890);
        return(false);
    }
    for(int x = 1; x < StartSpeedStr.Length() + 1; x++)
    {
        if((StartSpeedStr[x] < '0') || (StartSpeedStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Train start speed contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(891);
            return(false);
        }
    }
    StartSpeed = StartSpeedStr.ToInt();
    if(StartSpeed > TTrain::MaximumSpeedLimit) // 400kph = 250mph
    {
        StartSpeed = TTrain::MaximumSpeedLimit;
        if(!SSHigh) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train starting speed > 400km/h in '" + TrainInfoStr + "'.  Setting it to 400km/h");
            SSHigh = true;
        }
    }
    Pos = Remainder.Pos(';'); // 4th delimiter
    AnsiString MaxRunningSpeedStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(MaxRunningSpeedStr == "")
    {
        TimetableMessage(GiveMessages, "Train maximum running speed missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(892);
        return(false);
    }
    for(int x = 1; x < MaxRunningSpeedStr.Length() + 1; x++)
    {
        if((MaxRunningSpeedStr[x] < '0') || (MaxRunningSpeedStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Train maximum running speed contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(893);
            return(false);
        }
    }
    MaxRunningSpeed = MaxRunningSpeedStr.ToInt();
    if(MaxRunningSpeed > TTrain::MaximumSpeedLimit) // 400kph = 250mph
    {
        MaxRunningSpeed = TTrain::MaximumSpeedLimit;
        if(!MRSHigh) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train maximum running speed > 400km/h in '" + TrainInfoStr + "'.  Setting it to 400km/h");
            MRSHigh = true;
        }
    }
    if(MaxRunningSpeed < 10)
    // changed at v0.6 to prevent low max speeds - can cause problems in SetTrainMovementValues
    {
        MaxRunningSpeed = 10;
        if(!MRSLow) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train maximum running speed can't be less than 10km/h in '" + TrainInfoStr + "', it will be set to 10km/h");
            MRSLow = true;
        }
    }
    Pos = Remainder.Pos(';'); // 5th delimiter
    AnsiString MassStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(MassStr == "")
    {
        TimetableMessage(GiveMessages, "Train mass missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(895);
        return(false);
    }
    for(int x = 1; x < MassStr.Length() + 1; x++)
    {
        if((MassStr[x] < '0') || (MassStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Train mass contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(896);
            return(false);
        }
    }
    Mass = MassStr.ToInt() * 1000; // convert tonnes to kg
    if(Mass > TTrain::MaximumMassLimit) // 10,000tonnes
    {
        Mass = TTrain::MaximumMassLimit;
        if(!MassHigh) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train mass > 10,000 tonnes in '" + TrainInfoStr + "'.  Setting it to 10,000 tonnes");
            MassHigh = true;
        }
    }
    if(Mass == 0)
    {
        TimetableMessage(GiveMessages, "Train mass zero in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(897);
        return(false);
    }
    Pos = Remainder.Pos(';'); // 6th delimiter
    AnsiString MaxBrakeForceStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(MaxBrakeForceStr == "")
    {
        TimetableMessage(GiveMessages, "Train braking force missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(898);
        return(false);
    }
    for(int x = 1; x < (MaxBrakeForceStr.Length() + 1); x++)
    {
        if((MaxBrakeForceStr[x] != '.') && ((MaxBrakeForceStr[x] < '0') || (MaxBrakeForceStr[x] > '9')))
        {
            TimetableMessage(GiveMessages, "Train braking force contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(899);
            return(false);
        }
    }
    double MaxBrakeForce = MaxBrakeForceStr.ToDouble() * 1000;

    // convert to kg force
    if((MaxBrakeForce / Mass) > 1) // gives 'g' braking - 9.81m/s/s
    {
        MaxBrakeForce = Mass;
        if(!BFHigh) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train braking force too high in '" + TrainInfoStr + "'.  Setting it to the same as the train mass");
            BFHigh = true;
        }
    }
    if((MaxBrakeForce / Mass) < 0.01)
    {
        MaxBrakeForce = Mass * 0.01;
        if(!BFLow) // added at v2.4.0
        {
            TimetableMessage(GiveMessages, "Train braking force too low in '" + TrainInfoStr + "'.  Setting it to 1% of the train mass");
            BFLow = true;
        }
    }
    // convert to m/s/s
    MaxBrakeRate = MaxBrakeForce / Mass * 9.81;
    // now may have just a power entry or power and signaller max. speed
    AnsiString GrossPowerStr = "", SignallerSpeedStr = "";

    if(SemiColonCount == 6)
    {
        GrossPowerStr = Remainder;
        SignallerSpeedStr = "30"; // default value
    }
    else // must be 7
    {
        Pos = Remainder.Pos(';'); // 7th delimiter
        GrossPowerStr = Remainder.SubString(1, Pos - 1);
        SignallerSpeedStr = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    }
    // deal with GrossPower
    if(GrossPowerStr == "")
    {
        TimetableMessage(GiveMessages, "Train power missing in '" + TrainInfoStr + "'");
        Utilities->CallLogPop(901);
        return(false);
    }
    for(int x = 1; x < GrossPowerStr.Length() + 1; x++)
    {
        if((GrossPowerStr[x] < '0') || (GrossPowerStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Train power contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(902);
            return(false);
        }
    }

    double GrossPower = GrossPowerStr.ToInt() * 1000; // convert to W

    if(GrossPower > TTrain::MaximumPowerLimit) // 100MW
    {
        GrossPower = TTrain::MaximumPowerLimit;
        if(!PwrHigh)
        {
            TimetableMessage(GiveMessages, "Train power > 100,000kW in '" + TrainInfoStr + "'.  Setting it to 100,000kW");
            PwrHigh = true;
        }
    }
    else if(GrossPower == 0) // changed at v2.4.0
    {
        GrossPower = 0.1;
        // can't be zero or AValue is zero and then have divide by zero error, so set to 0.1W so acceleration tiny (though should be intercepted before accel calculated)
    }
    else if((GrossPower > 0) && (GrossPower < 10000))
    // added at v2.4.0 to ensure min power of 8kW at rail unless zero (otherwise could have too low AValues
    {
        GrossPower = 10000;
    }
    PowerAtRail = GrossPower * 0.8;
    // apply ratio of 80% for rail to gross power (seems about average from an internet search)

    // deal with SignallerSpeed
    if(SignallerSpeedStr == "")
    {
        TimetableMessage(GiveMessages, "Signaller speed not set in '" + TrainInfoStr + "', either set a value or remove the extra semicolon");
        Utilities->CallLogPop(1771);
        return(false);
    }
    for(int x = 1; x < SignallerSpeedStr.Length() + 1; x++)
    {
        if((SignallerSpeedStr[x] < '0') || (SignallerSpeedStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Signaller speed contains invalid characters in '" + TrainInfoStr + "'");
            Utilities->CallLogPop(1769);
            return(false);
        }
    }
    SignallerSpeed = SignallerSpeedStr.ToInt();
    if(SignallerSpeed > TTrain::MaximumSpeedLimit)
    {
        SignallerSpeed = TTrain::MaximumSpeedLimit;
        if(!SigSHigh)
        {
            TimetableMessage(GiveMessages, "Signaller speed > 400km/h in '" + TrainInfoStr + "'.  Setting it to 400km/h");
            SigSHigh = true;
        }
    }
    if(SignallerSpeed < 10)
    // changed at v0.6 to prevent low max speeds - can cause problems in SetTrainMovementValues
    {
        SignallerSpeed = 10;
        if(!SigSLow)
        {
            TimetableMessage(GiveMessages, "Signaller speed can't be less than 10km/h in '" + TrainInfoStr + "', it will be set to 10km/h");
            SigSLow = true;
        }
        // Utilities->CallLogPop(1770);
        // return false;
    }
    Utilities->CallLogPop(904);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::SplitRepeat(int Caller, AnsiString OneEntry, int &RearStartOrRepeatMins, int &FrontStartOrRepeatDigits, int &NumberOfRepeats,
                                   bool GiveMessages)
{
    // Format must be: R;mm;dd;nn  mm may be 1, 2 or more digits, dd may be 1 or 2 digits, nn may be 1, 2 or more digits
    // function checks validity of each item and returns false for error
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SplitRepeat," + OneEntry);
    if(OneEntry.Length() < 7)
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - should be 'R;m;d;n'");
        Utilities->CallLogPop(865);
        return(false);
    }
    int SemiColonCount = 0;

    for(int x = 1; x < OneEntry.Length() + 1; x++)
    {
        if(OneEntry[x] == ';')
        {
            SemiColonCount++;
        }
    }
    if(SemiColonCount != 3)
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - should be 'R;m;d;n'");
        Utilities->CallLogPop(866);
        return(false);
    }
    if((OneEntry[1] != 'R') || (OneEntry[2] != ';'))
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - should be 'R;m;d;n'");
        Utilities->CallLogPop(867);
        return(false);
    }
    AnsiString Remainder = OneEntry.SubString(3, OneEntry.Length() - 2);
    // strip off R;

    int Pos = 0;

    Pos = Remainder.Pos(';');
    AnsiString MinutesStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(MinutesStr == "")
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - minute increment segment missing");
        Utilities->CallLogPop(868);
        return(false);
    }
    if(MinutesStr.Length() > 3)
    // added for v2.3.1 following Albie Vowles' reported error in repeat value 03/02/20
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - minute value too high, maximum value is 999");
        Utilities->CallLogPop(2119);
        return(false);
    }
    for(int x = 1; x < MinutesStr.Length() + 1; x++)
    {
        if((MinutesStr[x] < '0') || (MinutesStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - non-digit character in minute increment segment");
            Utilities->CallLogPop(869);
            return(false);
        }
    }
    RearStartOrRepeatMins = MinutesStr.ToInt();
    if(RearStartOrRepeatMins == 0)
    {
        TimetableMessage(GiveMessages, "Repeat minute increment is zero in:  '" + OneEntry + "' - can't have a zero value");
        Utilities->CallLogPop(870);
        return(false);
    }
    Pos = Remainder.Pos(';');
    AnsiString DigitsStr = Remainder.SubString(1, Pos - 1);

    Remainder = Remainder.SubString(Pos + 1, Remainder.Length() - Pos);
    if(DigitsStr == "")
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - headcode increment segment missing");
        Utilities->CallLogPop(871);
        return(false);
    }
    for(int x = 1; x < DigitsStr.Length() + 1; x++)
    {
        if((DigitsStr[x] < '0') || (DigitsStr[x] > '9'))
        {
            TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - non-digit character in headcode increment segment");
            Utilities->CallLogPop(872);
            return(false);
        }
    }
    if(DigitsStr.Length() > 2)
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - maximum number of digits for headcode increment is 2");
        Utilities->CallLogPop(873);
        return(false);
    }
    FrontStartOrRepeatDigits = DigitsStr.ToInt();
/* allow zero digit increments so HC can stay same for repeated services - for many suburban services the headcode digits relate to the
      route rather than the service
      if(FrontStartOrRepeatDigits == 0)
      {
      TimetableMessage(GiveMessages, "Repeat headcode increment is zero in:  '" + OneEntry + "' - can't have a zero value");
      Utilities->CallLogPop(874);
      return false;
      }
*/
    if(!Last2CharactersBothDigits(0, ServiceReference) && (FrontStartOrRepeatDigits > 0))
    // new for v0.6b for unrestricted headcodes
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry +
                         "' - a repeating service with incrementing digits must have digits as its last two headcode characters");
        Utilities->CallLogPop(1889);
        return(false);
    }
    AnsiString NumberStr = Remainder;

    if(NumberStr == "")
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - number of repeats missing");
        Utilities->CallLogPop(875);
        return(false);
    }
    if(NumberStr.Length() > 4)
    // added for v2.3.1 following Albie Vowles' reported error 03/02/20
    {
        TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - repeat value too high, no timetabled event can exceed 95 hours & 59 minutes");
        Utilities->CallLogPop(2118);
        return(false);
    }
    for(int x = 1; x < NumberStr.Length() + 1; x++)
    {
        if((NumberStr[x] < '0') || (NumberStr[x] > '9'))
        // catches negative numbers
        {
            TimetableMessage(GiveMessages, "Error in repeat: '" + OneEntry + "' - non-digit character in number of repeats");
            Utilities->CallLogPop(876);
            return(false);
        }
    }
    NumberOfRepeats = NumberStr.ToInt();
    if(NumberOfRepeats == 0)
    {
        TimetableMessage(GiveMessages, "Number of repeats is zero in:  '" + OneEntry + "' - if no repeats are needed the repeat should be omitted");
        Utilities->CallLogPop(877);
        return(false);
    }
    Utilities->CallLogPop(878);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::SecondPassActions(int Caller, bool GiveMessages, bool &TwoLocationFlag) //TwoLocationFlag added at v2.9.1
/* Note that here the TrainDataVector has been compiled with FinalCall true in ProcessOneTimetableLine so work on the
           vector rather than the timetable
           Note also that for unlocated Snt entries the LocationType hasn't yet been set

           Many of the errors caught here duplicate those in the preliminary checks, but leave in for completeness

           For info:-
           class TActionVectorEntry //contains a single train action - repeat entry is also of this class though no train action is taken for it
           {
           public:
           AnsiString LocationName, Command, OtherHeadCode, NonRepeatingShuttleLinkHeadCode; ///< string values for timetabled event entries, null
           ///< on creation
           bool SignallerControl; ///< indicates a train that is defined by the timetable as under signaller control
           bool Warning; ///< if set triggers an alert in the warning panel when the action is reached
           int NumberOfRepeats; ///< the number of repeating services
           int RearStartOrRepeatMins, FrontStartOrRepeatDigits; ///< dual-purpose variables used for the TrackVectorPositions of the rear and front
           ///< train starting elements (for Snt) or for repeat minute & digit values in repeat entries
           TDateTime EventTime, ArrivalTime, DepartureTime; ///< relevant times at which the action is timetabled, zeroed on creation so change
           ///< to -1 as a marker for 'not set'
           TNumList ExitList; ///< the list of valid train exit TrackVector positions for 'Fer' entries (empty to begin with)
           TTimetableFormatType FormatType; ///< defines the timetable action type
           TTimetableLocationType LocationType; ///< indicates where the train is when the relevant action occurs
           TTimetableSequenceType SequenceType; ///< indicates where in the sequence of codes the action lies
           TTimetableShuttleLinkType ShuttleLinkType; ///< indicates whether or not the action relates to a shuttle service link
           TTrainDataEntry *LinkedTrainEntryPtr; ///< link pointer for use between fsp/rsp & Sfs; Fjo & jbo; Fns & Sns; & all shuttle to shuttle
           ///< links
           TTrainDataEntry *NonRepeatingShuttleLinkEntryPtr; ///< pointer used by shuttles for the non-shuttle train links, in & out, the
           ///< corresponding non-shuttle linked trains use LinkedTrainEntryPtr

           // inline function

           /// Constructor, sets all values to default states
           TActionVectorEntry() {
           RearStartOrRepeatMins=0; FrontStartOrRepeatDigits=0; NumberOfRepeats=0; FormatType=NoFormat;
           SequenceType=NoSequence; LocationType=NoLocation; ShuttleLinkType=NoShuttleLink, EventTime=TDateTime(-1);
           ArrivalTime=TDateTime(-1); DepartureTime=TDateTime(-1); LinkedTrainEntryPtr=0; NonRepeatingShuttleLinkEntryPtr=0;
           Warning = false; SignallerControl = false;
           }
           };

           typedef std::vector<TActionVectorEntry> TActionVector;//contains all actions for a single train

           class TTrainDataEntry //contains all data for a single train - copied into train object when becomes active
           {
           public:
           AnsiString HeadCode, ServiceReference, Description; ///< headcode is the first train's headcode, rest are calculated from repeat
           ///< information; ServiceReference is the full (up to 8 characters) reference
           ///< from the timetable (added at V0.6b)
           double MaxBrakeRate; ///< in metres/sec/sec
           double MaxRunningSpeed; ///< in km/h
           double PowerAtRail; ///< in Watts (taken as 80% of the train's Gross Power, i.e. that entered by the user)
           int Mass; ///< in kg
           int NumberOfTrains; ///< number of repeats + 1
           int SignallerSpeed; ///< in km/h for use when under signaller control
           int StartSpeed; ///< in km/h
           TActionVector ActionVector; ///< all the actions for the train
           TTrainOperatingDataVector TrainOperatingDataVector; ///< operating information for the train including all its repeats

           //inline function

           /// Constructor with default values
           TTrainDataEntry()
           {
           StartSpeed=0; MaxRunningSpeed=0; NumberOfTrains=0;
           }
           };

           Allowable successors:-
           Snt unlocated ->  Fer, TimeLoc (arr), TimeTimeLoc, (new) pas; No others
           Snt located -> No starts, no finishes except Frh & Fjo (as of v2.0.0), no repeat, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK
           Snt-sh -> No starts, finishes, repeats, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK
           Sfs ->  No starts, finishes, repeats, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK (must have a TimeLoc departure somewhere in sequence to
           set location, else fails)
           Sns ->  No starts, finishes, repeats, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK (must have a TimeLoc departure somewhere in sequence to
           set location, else fails)
           Sns-sh -> No starts, finishes, repeats, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK (must have a TimeLoc departure somewhere in sequence to
           set location, else fails)
           Sns-fsh -> No starts, finishes, repeats, pas or TimeTimeLoc; any other cmd or TimeLoc (dep) OK (must have a TimeLoc departure somewhere in sequence to
           set location, else fails)
           Fns ->  R only
           F-nshs ->  Nothing (no repeats permitted)
           Fjo ->  R only
           Frh ->  R only
           Fer ->  R only
           Frh-sh ->  R only
           Fns-sh ->  R only
           jbo ->  No starts, finishes, repeats, splits, pas or TimeTimeLoc; TimeLoc (dep), jbo or cdt OK
           fsp ->  No starts, repeats, Fer, pas or TimeTimeLoc; TimeLoc (dep) or any other OK
           rsp ->  No starts, repeats, Fer, pas or TimeTimeLoc; TimeLoc (dep) or any other OK
           cdt ->  No starts, repeats, Fer, pas or TimeTimeLoc; TimeLoc (dep) or any other OK
           TimeLoc (arr) ->  No starts, repeats, Fer, pas or TimeTimeLoc; TimeLoc (dep) or any other OK
           TimeLoc (dep) ->  Fer, TimeLoc (arr), or TimeTimeLoc, (new) pas OK, no others
           TimeTimeLoc ->  Fer, TimeLoc (arr), or TimeTimeLoc, (new) pas OK, no others
           (new) pas -> Fer, TimeLoc (arr), or TimeTimeLoc, (new) pas OK, no others
           Repeat ->  Nothing

           There must be a TimeLoc arrival (or a Sns start at location) in a sequence so successive cmd locations can be set
           Check all Snt's & set Locations if located (located = zero start speed, either element at a location (but if rear element
           is a continuation then treated as unlocated), and location listed in the next TimeLoc entry, though needn't be immediately after)
           If Snt entry at a location specified in a following TimeLoc entry but start speed > 0 give error message
           Check all times increase or stay same through ActionVector
           Cycle through all entries in vector setting arr & dep times based on above list
           Add locations to all relevant cmd entries based on earlier arrival location (or earlier reference for Sfs & Sns)
           Check locations match the arr & dep TimeLoc entries
           Check same location doesn't appear twice before a cdt except for separate arr & dep TimeLocs
           Make above valid succession checks
           Check all splits have matching Sfs headcodes (both ways), add locations to SFSs & check times same
           Check all new service headcodes (Sns) have matching headcodes (both ways), add locations to SNHs & check times same
           Check a split to 'x' doesn't again split to 'x' (anywhere, not just for one train, since headcodes can be duplicated)
           Check each Fns has matching Sns headcodes (both ways), add locations to SNHs & check times same
           Check all joins have matching headcodes (both ways), locations & times & don't occur in same sequence
           Check each joined by train not joined by same train again (anywhere, not just for one train, since headcodes can be duplicated)
           Set train info for Sfs & Sns entries
           Check each repeat entry exactly matches any included joins or splits (user has to enter it to show that really wants it)
           Check at least one platform long enough for a split (only need 2 lengths) & disallow if not, need length of 2 & 1 extra
           element at each end, or length of 3 & 1 extra element at either end
           Check all TimeLocs have either Arr or Dep times set and EventTime == -1
           Check all Cmds have EventTime set & Arr & Dep times = -1
           Check all Sfs & Sns entries followed somewhere in sequence by a TimeLoc departure
           Check all locations except unlocated Snts, Fers and Repeats have a LocationName

           Give messages in function if errors detected and clear the vector.  Return false for failure.
*/

/* Earlier checks:-
           Checks carried out with error messages in this function:-
           At least one comma in the line (it's based on a csv file);
           No entries following train information;
           At least one comma in remainder after train information (i.e at least a start and a finish entry);
           SplitEntry returns false in an intermediate entry - message repeats the entry for information;
           First entry not a start entry;
           Train information incomplete before a start entry;
           Entry follows a finish entry but doesn't begin with 'R';
           SplitEntry returns false in a finish entry - message repeats the entry for information;
           Last action entry isn't a finish entry.

           Function returns false with no message if:-
           Timetable start time invalid (no message is given for an invalid time as the line is assumed to be an irrelevant line; if no start
           time is found at all then an error message is given in the calling function);
           SplitTrainInfo returns false (message given in called function);
           SplitRepeat returns false (message given in called function).

Double crosslink (shuttle) table: [OtherHeadCode, NonRepeatingShuttleLinkHeadCode, LinkedTrainEntryPtr, NonRepeatingShuttleLinkEntryPtr] <-- these for easier searching for this table

Command   Format                    OtherHead                        NonRepeating-  LinkedTrain- NonRepeating-   Decsription
                                    Code                             ShuttleLink-   EntryPtr     ShuttleLink
                                                                     HeadCode                    EntryPtr

Snt-sh  SNTShuttle                  Y (rtn shuttle)                  N              Y (rtn sh)   N               Simple shuttle - no feeder service
Frh-sh  TimeCmdHeadCode             Y (outwd shuttle)                N              Y (outwd sh) N               Simple shuttle - no finishing service
F-nshs  FNSNonRepeatToShuttle       N (shld be Y for outwd shuttle)  Y (shld be N)  Y (correct)  N (correct)     Feeder service link to shuttle
Sns-sh  SNSShuttle                  Y (rtn shuttle)                  Y (feeder)     Y (rtn)      Y (fdr)         Shuttle link from feeder service
Sns-fsh SNSNonRepeatFromShuttle     N (shld be Y for rtn shuttle)    Y (shld be N)  Y (correct)  N (correct)     Finishing service link from shuttle
Fns-sh  FSHNewService               Y (outwd shuttle)                Y (finishing)  Y (outwd sh) Y (finish)      Shuttle link to finishing service

Note:  Any shuttle start can have any finish - feeder and finish, neither, feeder but no finish & vice versa.

*/{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SecondPassActions,");
    if(TrainDataVector.empty())
    {
        SecondPassMessage(GiveMessages, "Error in timetable - there appear to be no train services in the timetable, it must contain at least one");
        TrainDataVector.clear();
        Utilities->CallLogPop(1832);
        return(false);
    }
/* new preliminary checks for v0.2b without changing anything, carry each out separately:-
      1) must have at least one actionvector entry
      2) if first actionvector entry not SignallerControl then must have at least one more actionvector entry
      3) if first actionvector entry is SignallerControl then must have no more actionvector entries except a repeat
      4) first entry must be a start;
      4a) if first entry is Snt and not signallercontrol and second is a finish then it must be at a location with zero start speed
      5) a start must be the first entry;
      6) a repeat entry must be the last;
      7) for other than SignallerControl the last entry must be repeat or finish; if last entry is a repeat the last but one must be a finish;
      8) a finish entry must be the last or last but one, and if last but one the last must be a repeat
      Other successor errors will be caught later as all 'throws' changed to messages prior to the bulk of the sucessor checks
*/

    TwoLocationList.clear(); //empty the list to begin with, added at v2.9.1
    TwoLocationFlag = false; //added at v2.9.1
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (1)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TrainDataVector.at(x).ActionVector.empty())
        {
            SecondPassMessage(GiveMessages, "Error in timetable - the following service has no listed events, there must be at least one: " + TDEntry.HeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1833);
            return(false);
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (2)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        TActionVectorEntry AVEntry0 = TrainDataVector.at(x).ActionVector.at(0);
        if(!(AVEntry0.SignallerControl))
        {
            if(TrainDataVector.at(x).ActionVector.size() == 1)
            {
                SecondPassMessage(GiveMessages, "Error in timetable - service must have a start event and at least one other for: " + TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(1822);
                return(false);
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (3)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        TActionVectorEntry AVEntry0 = TrainDataVector.at(x).ActionVector.at(0);
        if(AVEntry0.SignallerControl)
        {
            if(TrainDataVector.at(x).ActionVector.size() > 2)
            {
                SecondPassMessage(GiveMessages,
                                  "Error in timetable - a signaller control service can have no more than one item (a repeat) after the start event, see: " +
                                  TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(1837);
                return(false);
            }
            if(TrainDataVector.at(x).ActionVector.size() > 1)
            {
                TActionVectorEntry AVEntry1 = TrainDataVector.at(x).ActionVector.at(1);
                if(AVEntry1.FormatType != Repeat)
                {
                    SecondPassMessage(GiveMessages,
                                      "Error in timetable - a signaller control service cannot have any other than a repeat after the start event, see: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1838);
                    return(false);
                }
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (4)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        TActionVectorEntry AVEntry0 = TrainDataVector.at(x).ActionVector.at(0);
        if(AVEntry0.SequenceType != StartSequence)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - the first event must be a start for: " + TDEntry.HeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1824);
            return(false);
        }
        if((AVEntry0.Command == "Snt") && !(AVEntry0.SignallerControl))
        // 4a  added at v2.0.0. This is only a rough check, Fer only valid for an unlocated Snt
        // and others for a located Snt, but those checks done later
        {
            TActionVectorEntry AVEntry1 = TrainDataVector.at(x).ActionVector.at(1);
            // must be a second entry if first not signallercontrol
            if((AVEntry1.SequenceType == FinishSequence) && ((AVEntry1.Command == "Fns-sh") || (AVEntry1.Command == "Frh-sh")))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - finish events Fns-sh and Frh-sh not permitted immediately after an Snt entry for: " +
                                  TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(2046);
                return(false);
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (5)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.SequenceType == StartSequence) && (y != 0))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - a start event is present that is not the first event for: " + TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(1825);
                return(false);
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (6)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.FormatType == Repeat) && (y != (TrainDataVector.at(x).ActionVector.size() - 1)))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - a repeat is present that is not the last item for: " + TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(1826);
                return(false);
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (7)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((y == 0) && AVEntry.SignallerControl)
            {
                break;
            }
            if(y == (TrainDataVector.at(x).ActionVector.size() - 1))
            {
                if((AVEntry.FormatType != Repeat) && (AVEntry.SequenceType != FinishSequence))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - the last item must be either a finish event or a repeat for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1827);
                    return(false);
                }
                if(AVEntry.FormatType == Repeat)
                {
                    const TActionVectorEntry &LastAVEntry = TrainDataVector.at(x).ActionVector.at(y - 1);
                    if(LastAVEntry.SequenceType != FinishSequence)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - the last event before the repeat must be a finish for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(1828);
                        return(false);
                    }
                }
            }
        }
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // (8)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.SequenceType == FinishSequence)
            {
                if((y != (TrainDataVector.at(x).ActionVector.size() - 1)) && (y != (TrainDataVector.at(x).ActionVector.size() - 2)))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a finish event must be either the last or last but one for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1829);
                    return(false);
                }
                if(y == (TrainDataVector.at(x).ActionVector.size() - 2))
                {
                    if(TrainDataVector.at(x).ActionVector.at(y + 1).FormatType != Repeat)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - the only event that can follow a finish event is a repeat for: " +
                                          TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(1830);
                        return(false);
                    }
                }
            }
        }
    }

    // end of new preliminary checks

    // check ActionVector present and check start event successor validity
    // For Snt & Snt-sh set location if stopped, don't set any times yet
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        TActionVectorEntry & AVEntry0 = TrainDataVector.at(x).ActionVector.at(0);
        // use reference so can change internals where necessary
        if((AVEntry0.Command == "Snt") || (AVEntry0.Command == "Snt-sh"))
        {
            AnsiString LocationName = "";
            if(IsSNTEntryLocated(0, TDEntry, LocationName))
            // it is at a location
            {
                if(TDEntry.StartSpeed == 0) // stopped
                {
                    AVEntry0.LocationName = LocationName;
                    AVEntry0.LocationType = AtLocation;
                    // check successor validity for located Snt that isn't a SignallerControl entry
                    if(!AVEntry0.SignallerControl)
                    {
                        const TActionVectorEntry &AVEntry1 = TrainDataVector.at(x).ActionVector.at(1);
                        // at least 2 entries present checked in integrity check so (1) valid
                        if(!AtLocSuccessor(AVEntry1))
                        {
                            // Frh following Snt-sh will return false in location check, so no need to check here
                            SecondPassMessage(GiveMessages, "Error in timetable - stopped 'Snt' or 'Snt-sh' followed by an illegal event for: " +
                                              TDEntry.HeadCode + ". The event isn't valid for a stationary train.");
                            TrainDataVector.clear();
                            Utilities->CallLogPop(523);
                            return(false);
                        }
                    }
                }
                else
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - 'Snt' or 'Snt-sh' event at stop location but start speed not zero for: " +
                                      TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(791);
                    return(false);
                }
            }
            else // check not Snt-sh & carry out successor validity checks for unlocated Snt that isn't a SignallerControl entry
            {
                if(AVEntry0.Command == "Snt-sh")
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - 'Snt-sh' event not at stop location for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1042);
                    return(false);
                }
                AVEntry0.LocationType = EnRoute;
                if(!AVEntry0.SignallerControl)
                {
                    const TActionVectorEntry &AVEntry1 = TrainDataVector.at(x).ActionVector.at(1);
                    // at least 2 entries checked in integrity check so (1) valid
                    if(!MovingSuccessor(AVEntry1))
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - unlocated 'Snt' not followed by 'Fer', 'pas' or an arrival for: " +
                                          TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(790);
                        return(false);
                    }
                }
            }
        }
        // check other start successors
        else if(AVEntry0.SequenceType == StartSequence)
        {
            const TActionVectorEntry &AVEntry1 = TrainDataVector.at(x).ActionVector.at(1);
            // at least 2 entries present checked in integrity check so (1) valid
            if(!AtLocSuccessor(AVEntry1))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - 'Sfs', 'Sns', 'Sns-sh' or 'Sns-fsh' followed by an illegal event for: " +
                                  TDEntry.HeadCode + ". The event isn't valid for a stationary train.");
                TrainDataVector.clear();
                Utilities->CallLogPop(793);
                return(false);
            }
        }
    }

    // set Sfs, Sns, Sns-sh & 'Sns-fsh' locations same as following TimeLoc departure entry location, if no departure before end of sequence give error message
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        bool FoundFlag = false;
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        TActionVectorEntry & AVEntry = TrainDataVector.at(x).ActionVector.at(0);
        // use reference so can change internals
        if((AVEntry.Command == "Sfs") || (AVEntry.Command == "Sns") || (AVEntry.Command == "Sns-sh") || (AVEntry.Command == "Sns-fsh"))
        {
            for(unsigned int y = 1; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry2.FormatType == TimeLoc)
                {
                    FoundFlag = true;
                    AVEntry.LocationName = AVEntry2.LocationName;
                    break;
                }
            }
            if(!FoundFlag)
            {
                SecondPassMessage(GiveMessages, "Error in timetable - no location departure following an 'Sfs', 'Sns', 'Sns-sh'or 'Sns-fsh' event for: " +
                                  TDEntry.HeadCode);
                TrainDataVector.clear();
                Utilities->CallLogPop(851);
                return(false);
            }
        }
    }

    // set all cmd locations based on earlier location name in TimeLoc arrival or Sfs/Sns/Sns-sh/Sns-fsh/located Snt/Snt-sh locations
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.FormatType == TimeLoc) || ((AVEntry.SequenceType == StartSequence) && (AVEntry.LocationType == AtLocation)))
            {
                if(AVEntry.LocationName == "")
                // if TimeLoc turns out to be a TimeLoc departure then will emerge & be rejected in successor checks for TimeLocs
                {
                    SecondPassMessage(GiveMessages, "Error in timetable for " + TDEntry.HeadCode +
                                      ": an event should have had a location name associated with it but it could not be found");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1831);
                    return(false);
                    // throw Exception("Error, entry location null in TimeLoc/Sfs/Sns/Sns-sh/Sns-fsh/Snt-sh/located Snt for Train: " + TDEntry.HeadCode);
                }
                for(unsigned int z = y + 1; z < TrainDataVector.at(x).ActionVector.size(); z++)
                {
                    TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(z);
                    // use reference so can change internals where necessary
                    if((AVEntry2.Command != "") && (AVEntry2.LocationType == AtLocation))
                    {
                        AVEntry2.LocationName = AVEntry.LocationName;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }
    // all location names now set

    // check remaining successor validity except for TimeLoc arr & dep since those times not set yet
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.SequenceType == FinishSequence) && (AVEntry.Command != "F-nshs"))
            {
                if(y < (TrainDataVector.at(x).ActionVector.size() - 1))
                // i.e at least one more, must be a repeat
                {
                    if(TrainDataVector.at(x).ActionVector.at(y + 1).FormatType != Repeat)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - only a repeat can follow a finish entry for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(798);
                        return(false);
                    }
                }
            }
            if(AVEntry.Command == "F-nshs")
            {
                if(y != (TrainDataVector.at(x).ActionVector.size() - 1))
                // i.e has to be the last
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - F-nshs (shuttle link) must be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1049);
                    return(false);
                }
            }
            if(AVEntry.Command == "pas")
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a 'pas' can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1518);
                    return(false);
                }
            }
            if(AVEntry.Command == "jbo")
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a 'jbo' can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(800);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!AtLocSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a jbo event is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a stationary train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(801);
                    return(false);
                }
            }
            if((AVEntry.Command == "fsp") || (AVEntry.Command == "rsp"))
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a train split can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(802);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!AtLocSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a train split is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a stationary train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(803);
                    return(false);
                }
            }
            if(AVEntry.Command == "cdt")
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a 'cdt' can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(804);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!AtLocSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a 'cdt' is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a stationary train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(805);
                    return(false);
                }
            }
            if(AVEntry.FormatType == TimeTimeLoc)
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival and departure can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(806);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!MovingSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival and departure is followed by an illegal event for: " +
                                      TDEntry.HeadCode + ". The event isn't valid for a moving train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(807);
                    return(false);
                }
            }
            if(AVEntry.FormatType == PassTime)
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a pass time can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1530);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!MovingSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a pass time is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a moving train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1531);
                    return(false);
                }
            }
            if(AVEntry.FormatType == Repeat)
            {
                if(y != (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a repeat is not the last item for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(808);
                    return(false);
                }
            }
        }
    }

    // set arrival & departure times for TimeLocs & set their EventTimes to -1
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        bool LastEntryIsAnArrival = false;
        const TTrainDataEntry & TDEntry = TrainDataVector.at(x);
        // first deal with unlocated Snt entries - so next entry (TimeLoc or TimeTimeLoc) is an arrival, all else stopped so the next TimeLoc is a departure
        const TActionVectorEntry &AVEntry0 = TrainDataVector.at(x).ActionVector.at(0);
        if((AVEntry0.Command == "Snt") && (AVEntry0.LocationType == EnRoute))
        // StartSpeed may or may not be 0, but train will move forwards (if capable of doing so), & next TimeLoc will be an arrival, whether or not after one or more TimeTimeLocs
        {
            LastEntryIsAnArrival = false;
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.FormatType == TimeLoc)
                {
                    if((AVEntry.ArrivalTime > TDateTime(-1)) || (AVEntry.DepartureTime > TDateTime(-1)) || (AVEntry.EventTime == TDateTime(-1)))
                    {
                        throw Exception("Timetable error, TimeLoc times not as initially set for " + TDEntry.HeadCode);
                    }
                    if(LastEntryIsAnArrival)
                    {
                        AVEntry.DepartureTime = AVEntry.EventTime;
                        AVEntry.EventTime = TDateTime(-1);
                        LastEntryIsAnArrival = false;
                    }
                    else // last entry a departure
                    {
                        AVEntry.ArrivalTime = AVEntry.EventTime;
                        AVEntry.EventTime = TDateTime(-1);
                        LastEntryIsAnArrival = true;
                    }
                }
            }
        }
        else // all others stopped at beginning
        {
            LastEntryIsAnArrival = true;
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.FormatType == TimeLoc)
                {
                    if((AVEntry.ArrivalTime > TDateTime(-1)) || (AVEntry.DepartureTime > TDateTime(-1)) || (AVEntry.EventTime == TDateTime(-1)))
                    {
                        throw Exception("Timetable error, TimeLoc times not as initially set for " + TDEntry.HeadCode);
                    }
                    if(LastEntryIsAnArrival)
                    {
                        AVEntry.DepartureTime = AVEntry.EventTime;
                        AVEntry.EventTime = TDateTime(-1);
                        LastEntryIsAnArrival = false;
                    }
                    else // last entry a departure
                    {
                        AVEntry.ArrivalTime = AVEntry.EventTime;
                        AVEntry.EventTime = TDateTime(-1);
                        LastEntryIsAnArrival = true;
                    }
                }
            }
        }
    }
    // perform remaining successor checks for TimeLocs
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.FormatType == TimeLoc) && (AVEntry.ArrivalTime >= TDateTime(0))) // arrival
            // TimeLoc (arr) ->  No starts, repeats, Fer or TimeTimeLoc; TimeLoc (dep) or any other OK
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(809);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!AtLocSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a stationary train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(810);
                    return(false);
                }
            }
            if((AVEntry.FormatType == TimeLoc) && (AVEntry.DepartureTime >= TDateTime(0))) // departure
            // TimeLoc (dep) ->  Fer, TimeLoc (arr), TimeTimeLoc, (new) pas OK, no others
            {
                if(y >= (TrainDataVector.at(x).ActionVector.size() - 1))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed departure can't be the last event for: " + TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(811);
                    return(false);
                }
                const TActionVectorEntry &AVEntry2 = TrainDataVector.at(x).ActionVector.at(y + 1);
                if(!MovingSuccessor(AVEntry2))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed departure is followed by an illegal event for: " + TDEntry.HeadCode +
                                      ". The event isn't valid for a moving train.");
                    TrainDataVector.clear();
                    Utilities->CallLogPop(812);
                    return(false);
                }
            }
        }
    }

    // check all TimeLocs have either Arr or Dep time set and EventTime == -1, all Cmds have EventTime set & Arr & Dep times == -1,
    // & repeats have no times set
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.FormatType == TimeLoc)
            {
                if(AVEntry.EventTime != TDateTime(-1))
                {
                    throw Exception("Timetable error, TimeLoc entry has EventTime not -1 for " + TDEntry.HeadCode);
                }
                if((AVEntry.ArrivalTime == TDateTime(-1)) && (AVEntry.DepartureTime == TDateTime(-1)))
                {
                    throw Exception("Timetable error, TimeLoc entry has neither arrival nor departure time set for " + TDEntry.HeadCode);
                }
            }
            if(AVEntry.FormatType == TimeTimeLoc)
            {
                if(AVEntry.EventTime != TDateTime(-1))
                {
                    throw Exception("Timetable error, TimeTimeLoc entry has EventTime not -1 for " + TDEntry.HeadCode);
                }
                if((AVEntry.ArrivalTime == TDateTime(-1)) || (AVEntry.DepartureTime == TDateTime(-1)))
                {
                    throw Exception("Timetable error, TimeTimeLoc entry has either arrival or departure time not set for " + TDEntry.HeadCode);
                }
            }
            if((AVEntry.FormatType == TimeCmd) || (AVEntry.FormatType == TimeCmdHeadCode) || (AVEntry.FormatType == StartNew) ||
               (AVEntry.FormatType == SNTShuttle) || (AVEntry.FormatType == SNSShuttle) || (AVEntry.FormatType == FNSNonRepeatToShuttle) ||
               (AVEntry.FormatType == FSHNewService) || (AVEntry.FormatType == PassTime))
            {
                if(AVEntry.EventTime == TDateTime(-1))
                {
                    throw Exception("Timetable error, Cmd or PassTime entry has EventTime not set for " + TDEntry.HeadCode);
                }
                if((AVEntry.ArrivalTime != TDateTime(-1)) || (AVEntry.DepartureTime != TDateTime(-1)))
                {
                    throw Exception("Timetable error, Cmd or PassTime entry has either arrival or departure time set for " + TDEntry.HeadCode);
                }
            }
            if(AVEntry.FormatType == Repeat)
            {
                if((AVEntry.EventTime != TDateTime(-1)) || (AVEntry.ArrivalTime != TDateTime(-1)) || (AVEntry.DepartureTime != TDateTime(-1)))
                {
                    throw Exception("Timetable error, Repeat entry has a time set for " + TDEntry.HeadCode);
                }
            }
        }
    }

    // check times stay same or increase, note that can have time of 0 if include midnight
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        TDateTime CurrentTime = TTClockTime; // the timetable start time
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.FormatType == Repeat)
            {
                break;
            }
            if(AVEntry.FormatType == FinRemHere)
            {
                break;
            }
            if(AVEntry.FormatType == TimeTimeLoc)
            {
                if(AVEntry.DepartureTime < AVEntry.ArrivalTime)
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival and departure has a later arrival than departure time for: " +
                                      TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(813);
                    return(false);
                }
                if(AVEntry.ArrivalTime < CurrentTime)
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a timed arrival and departure has too early an arrival time for: " +
                                      TDEntry.HeadCode);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(814);
                    return(false);
                }
                CurrentTime = AVEntry.DepartureTime;
                continue;
            }
            if(AVEntry.FormatType == TimeLoc)
            {
                if(AVEntry.ArrivalTime >= TDateTime(0))
                {
                    if(AVEntry.ArrivalTime < CurrentTime)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a timed location event has a time that is too early for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(815);
                        return(false);
                    }
                    CurrentTime = AVEntry.ArrivalTime;
                }
                else
                {
                    if(AVEntry.DepartureTime < CurrentTime)
                    // both may be 0 legitimately so must allow for this
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a timed location event has a time that is too early for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(816);
                        return(false);
                    }
                    CurrentTime = AVEntry.DepartureTime;
                }
                continue;
            }
            if(AVEntry.EventTime < CurrentTime)
            // all others have EventTime set
            {
                SecondPassMessage(GiveMessages, "Error in timetable - a train event has a time that is set too early for: " + TDEntry.HeadCode +
                                  ", may be before timetable start time");
                TrainDataVector.clear();
                Utilities->CallLogPop(835);
                return(false);
            }
            CurrentTime = AVEntry.EventTime;
            continue;
        }
    }

    // check locations consistent
    AnsiString LastLocationName = "";

    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        bool LastEntryIsAnArrival = false;
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        // first deal with moving Snt entries (all else stopped)
        if((TrainDataVector.at(x).ActionVector.at(0).Command == "Snt") && (TrainDataVector.at(x).ActionVector.at(0).LocationType == EnRoute))
        {
            LastEntryIsAnArrival = false;
            LastLocationName = TrainDataVector.at(x).ActionVector.at(0).LocationName; // should be ""
            if(LastLocationName != "")
            {
                throw Exception("Timetable error, moving Snt entry has LocationName set for " + TDEntry.HeadCode);
            }
            for(unsigned int y = 1; y < TrainDataVector.at(x).ActionVector.size();
                y++) // note that immediate successor to a moving Snt can only be a Moving type
            {
                // if it's a SignallerControl entry then the condition isn't met
                const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.FormatType == Repeat)
                {
                    break; // repeat = reached end (+allows repeat after signaller controlled entry)
                }
                else if((AVEntry.FormatType == TimeCmdHeadCode) || (AVEntry.FormatType == FNSNonRepeatToShuttle))
                {
                    if(AVEntry.LocationName != LastLocationName)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a location event is inconsistent for: " + TDEntry.HeadCode + " && " +
                                          AVEntry.Command);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(823);
                        return(false);
                    }
                }
                else if(AVEntry.FormatType == TimeCmd)
                // cdt is the only TimeCmd
                {
                    if(AVEntry.LocationName != LastLocationName)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a location event is inconsistent for: " + TDEntry.HeadCode + " && " +
                                          AVEntry.Command);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(824);
                        return(false);
                    }
                }
                else if(AVEntry.FormatType == TimeTimeLoc)
                {
                    if((AVEntry.LocationName == LastLocationName) && /*!TwoOrMoreLocationsWarningGiven && */ TTEditPanelVisible) //changed at v2.6.0 to allow loops & consecutive same locs
                    // last entry must be a departure or would have failed earlier
                    {
                        TwoLocationList.insert(TwoLocationList.end(), TDEntry.ServiceReference); //added at v2.9.1
                        TwoLocationFlag = true;
//                        ShowMessage("Two or more locations are the same without a change of direction between them.  Please correct if this is an error.\n\nThis warning will not be shown again.");
//                        TwoOrMoreLocationsWarningGiven = true;
                    }
                    LastLocationName = AVEntry.LocationName;
                    LastEntryIsAnArrival = false;
                }
                else if(AVEntry.FormatType == TimeLoc)
                {
                    if(LastEntryIsAnArrival && (AVEntry.LocationName != LastLocationName))
                    {
                        SecondPassMessage(GiveMessages,
                                          "Error in timetable - a location event for a timed departure is different from the arrival location for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(826);
                        return(false);
                    }
                    else if(!LastEntryIsAnArrival && (AVEntry.LocationName == LastLocationName))
                    {
                        SecondPassMessage(GiveMessages,
                                          "Error in timetable - a location event for a timed arrival is the same as the earlier departure location for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(827);
                        return(false);
                    }
                    LastLocationName = AVEntry.LocationName;
                    LastEntryIsAnArrival = !LastEntryIsAnArrival;
                }
            }
        }
        else // all stationary starting entries
        {
            LastEntryIsAnArrival = true;
            LastLocationName = TrainDataVector.at(x).ActionVector.at(0).LocationName;
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.FormatType == Repeat)
                {
                    break;
                }
                else if((AVEntry.FormatType == TimeCmdHeadCode) || (AVEntry.FormatType == FNSNonRepeatToShuttle))
                // no need to add anything for shuttle starts since they are at loc (0) anyway
                {
                    if(AVEntry.LocationName != LastLocationName)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a location event is inconsistent for: " + TDEntry.HeadCode + " && " +
                                          AVEntry.Command);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(828);
                        return(false);
                    }
                }
                else if(AVEntry.FormatType == TimeCmd)
                // cdt is the only TimeCmd
                {
                    if(AVEntry.LocationName != LastLocationName)
                    {
                        SecondPassMessage(GiveMessages, "Error in timetable - a location event is inconsistent for: " + TDEntry.HeadCode + " && " +
                                          AVEntry.Command);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(829);
                        return(false);
                    }
                }
                else if(AVEntry.FormatType == TimeTimeLoc)
                {
                    if((AVEntry.LocationName == LastLocationName) && /*!TwoOrMoreLocationsWarningGiven && */ TTEditPanelVisible) //changed at v2.6.0 to allow loops & consecutive same locs
                    // last entry must be a departure or would have failed earlier
                    {
                        TwoLocationList.insert(TwoLocationList.end(), TDEntry.ServiceReference); //added at v2.9.1
                        TwoLocationFlag = true;
//                        ShowMessage("Two or more locations are the same without a change of direction between them.  Please correct if this is an error.\n\nThis warning will not be shown again.");
//                        TwoOrMoreLocationsWarningGiven = true;
                    }
                    LastLocationName = AVEntry.LocationName;
                    LastEntryIsAnArrival = false;
                }
                else if(AVEntry.FormatType == TimeLoc)
                {
                    if(LastEntryIsAnArrival && (AVEntry.LocationName != LastLocationName))
                    {
                        SecondPassMessage(GiveMessages,
                                          "Error in timetable - a location event for a timed departure is different from the arrival location for: " + TDEntry.HeadCode);
                        TrainDataVector.clear();
                        Utilities->CallLogPop(831);
                        return(false);
                    }
                    if(!LastEntryIsAnArrival && (AVEntry.LocationName == LastLocationName) && !TwoOrMoreLocationsWarningGiven)
                    {
                        SecondPassMessage(GiveMessages,
                                          "A location event for a timed arrival is the same as the earlier departure location for: " + TDEntry.HeadCode + ". Please correct if this is an error.\n\nThis warning will not be shown again.");
                        TwoOrMoreLocationsWarningGiven = true;
//                        TrainDataVector.clear();
//                        Utilities->CallLogPop(832);
//                        return false;
                    }
                    LastLocationName = AVEntry.LocationName;
                    LastEntryIsAnArrival = !LastEntryIsAnArrival;
                }
            }
        }
    }

    // Check same location doesn't appear twice before a cdt except for separate arr & dep TimeLocs (just a potential error warning given in v2.6.0)
    // i.e. same location can appear in any number of consecutive entries but once changed couldn't repeat before a direction change prior to v2.6.0
    AnsiString LocationNameToBeChecked = "";

    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry & TDEntry = TrainDataVector.at(x);
        unsigned int y = 0;
        const TActionVectorEntry &AVEntry0 = TDEntry.ActionVector.at(0);
        // first discard unlocated Snt entries as they don't have location name set
        if((AVEntry0.Command == "Snt") && (AVEntry0.LocationType == EnRoute))
        {
            y = 1;
        }
        while(y < TDEntry.ActionVector.size())
        // need to check each location name separately in turn, skipped for SignallerControl entries
        {
            if((TDEntry.ActionVector.at(y).Command == "Fer") || (TDEntry.ActionVector.at(y).FormatType == Repeat))
            {
                break; // out of the 'while' loop since have reached the end & 'Fer' & 'Repeat' have no location name set
            }
            LocationNameToBeChecked = TDEntry.ActionVector.at(y).LocationName;
            for(unsigned int z = y; z < TDEntry.ActionVector.size(); z++)
            {
                const TActionVectorEntry &AVEntry = TDEntry.ActionVector.at(z);
                if((AVEntry.Command == "Fer") || (AVEntry.FormatType == Repeat))
                {
                    break; // out of the 'z' loop since have reached the end & 'Fer' & 'Repeat' have no location name set
                }
                if(AVEntry.Command == "cdt")
                {
                    break; // out of the 'z' loop since the check is only valid up to a change of direction
                }
                if(AVEntry.LocationName == LocationNameToBeChecked)
                {
                    continue; // keep going while name same
                }
                if(AVEntry.LocationName != LocationNameToBeChecked)
                // if name different check forwards to see if repeats
                {
                    for(unsigned int a = z; a < TDEntry.ActionVector.size(); a++)
                    {
                        if(TDEntry.ActionVector.at(a).Command == "cdt")
                        {
                            break; // out of the 'a' & 'z' loops since the check is only valid up to a change of direction
                        }
                        if((TDEntry.ActionVector.at(a).LocationName == LocationNameToBeChecked) && /*!TwoOrMoreLocationsWarningGiven && */ TTEditPanelVisible) //changed at v2.6.0 to allow loops & consecutive same locs
                        {
                            TwoLocationList.insert(TwoLocationList.end(), TDEntry.ServiceReference); //added at v2.9.1
                            TwoLocationFlag = true;
//                            ShowMessage("Two or more locations are the same without a change of direction between them.  Please correct if this is an error.\n\nThis warning will not be shown again.");
//                            TwoOrMoreLocationsWarningGiven = true;
                        }
                    }
                    break; // out of the 'z' loop since have checked 'a' as far as need to
                }
            }
            y++;
        }
    }
    if(TwoLocationFlag)
    {
        TwoLocationList.sort(); //need to sort first in alphabetical order to ensure all duplictes removed
        TwoLocationList.unique(); //remove duplicates
    }

    // check all locations except unlocated 'Snt' & 'Fer' have LocationName set
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.LocationName == "") && (AVEntry.Command != "Snt") && (AVEntry.Command != "Fer") && (AVEntry.FormatType != Repeat))
            {
                throw Exception("Error, non- 'Snt', 'Fer' or Repeat entry doesn't have a location name set for " + TDEntry.HeadCode);
            }
            AnsiString LocName = "";
            // dummy, only used so can call IsSNTEntryLocated
            if((AVEntry.Command == "Snt") && (IsSNTEntryLocated(1, TrainDataVector.at(x), LocName)))
            {
                if(AVEntry.LocationName == "")
                {
                    throw Exception("Error, 'Snt' entry at a stop location doesn't have a location name set for " + TDEntry.HeadCode);
                }
            }
            if((AVEntry.Command == "Snt") && !(IsSNTEntryLocated(2, TrainDataVector.at(x), LocName)))
            {
                if(AVEntry.LocationName != "")
                {
                    throw Exception("Error, 'Snt' unlocated entry has a location name set for " + TDEntry.HeadCode);
                }
            }
        }
    }

/* Check a split to 'x' doesn't again split to 'x' (anywhere, not just for one train, since headcodes can be duplicated)
      Check each joined by train not joined by same train again (anywhere, not just for one train, since headcodes can be duplicated)
      Check each change of headcode not repeated anywhere else (anywhere, not just for one train, since headcodes can be duplicated)

      i.e. check everywhere where there is an 'OtherHeadCode' that it matches once only with its reference (both ways) + set
      the OtherHeadCodeStartingEntryPtr pointers where appropriate + train information for splits & new services

      BUT need to separate the shuttles from non-shuttles, because can have two trains reference each other in both forms,
      eg 2F44 Sns-sh ends in Fns to 2F45, & Sns 2F45 ends in Fns-sh to 2F44.  Here 2F45 is the 'OtherHeadCode' for both
      Sns-sh & Fns in train 2F44, & 2F44 is the 'OtherHeadCode' for both Sns & Fns-sh in train 2F45.
*/
    for(unsigned int x = 0; x < TrainDataVector.size(); x++) // new test to ensure no duplicate links at all, other checks ensure none for shuttles,
    {
        // non-shuttles & non-repeating links separately, but don't check that there isn't a
        // duplicate between a non-repeating shuttle and another - leave original tests in as
        // these also set the pointers
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.OtherHeadCode != "")
            {
                if(!CheckForDuplicateCrossReferences(0, TDEntry.HeadCode, AVEntry.OtherHeadCode, GiveMessages))
                {
                    Utilities->CallLogPop(1584);
                    return(false); // error message given in called function
                }
            }
            if(AVEntry.NonRepeatingShuttleLinkHeadCode != "")
            {
                if(!CheckForDuplicateCrossReferences(1, TDEntry.HeadCode, AVEntry.NonRepeatingShuttleLinkHeadCode, GiveMessages))
                {
                    Utilities->CallLogPop(1585);
                    return(false); // error message given in called function
                }
            }
        }
    }

    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.Command != "Sns-sh") && (AVEntry.Command != "Snt-sh") && (AVEntry.Command != "Fns-sh") && (AVEntry.Command != "Frh-sh"))
            {
                if(AVEntry.OtherHeadCode != "")
                {
                    if(!CheckCrossReferencesAndSetData(0, TDEntry.HeadCode, AVEntry.OtherHeadCode, false, GiveMessages))
                    // false = non-shuttle
                    {
                        Utilities->CallLogPop(864);
                        return(false); // error message given in called function
                    }
                }
            }
        }
    }

    // now repeat the check just for the shuttles
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.Command == "Sns-sh") || (AVEntry.Command == "Snt-sh") || (AVEntry.Command == "Fns-sh") || (AVEntry.Command == "Frh-sh"))
            {
                if(AVEntry.OtherHeadCode != "")
                {
                    if(!CheckCrossReferencesAndSetData(1, TDEntry.HeadCode, AVEntry.OtherHeadCode, true, GiveMessages))
                    // true = shuttle
                    {
                        Utilities->CallLogPop(1100);
                        return(false); // error message given in called function
                    }
                }
            }
        }
    }

    // check for proper non-repeating link cross references and that they have no repeats & that times are consistent
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.NonRepeatingShuttleLinkHeadCode != "")
            {
                if(!CheckNonRepeatingShuttleLinksAndSetData(0, TDEntry.HeadCode, AVEntry.NonRepeatingShuttleLinkHeadCode, GiveMessages))
                {
                    Utilities->CallLogPop(1060);
                    return(false); // error message given in called function
                }
            }
        }
    }

    // check that each shuttle start ends either in Fns or Fxx-sh (though a single service can't end in Fxx-sh), and that
    // when the Fxx-sh is reached it references the original start and not another shuttle - not allowed to link two shuttles,
    // don't ever need to and as designed would skip repeats
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if((AVEntry.Command == "Sns-sh") || (AVEntry.Command == "Snt-sh"))
            {
                if(!CheckShuttleServiceIntegrity(0, &(TrainDataVector.at(x)), GiveMessages))
                {
                    Utilities->CallLogPop(1090);
                    return(false); // error message given in called function
                }
            }
        }
    }

    // check all entries have all types set to something
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            if(AVEntry.FormatType == NoFormat)
            {
                throw Exception("Error - timetable ActionVector entry no. " + AnsiString(y) + " has FormatType unset for: " + TDEntry.HeadCode);
            }
            else if(AVEntry.SequenceType == NoSequence)
            {
                throw Exception("Error - timetable ActionVector entry no. " + AnsiString(y) + " has SequenceType unset for: " + TDEntry.HeadCode);
            }
            else if(AVEntry.LocationType == NoLocation)
            {
                throw Exception("Error - timetable ActionVector entry no. " + AnsiString(y) + " has LocationType unset for: " + TDEntry.HeadCode);
            }
            else if(AVEntry.ShuttleLinkType == NoShuttleLink)
            {
                throw Exception("Error - timetable ActionVector entry no. " + AnsiString(y) + " has ShuttleLinkType unset for: " + TDEntry.HeadCode);
            }
        }
    }

    // all OK if reach here, so set up the TrainOperatingDataVector (already has one entry) & NumberOfTrains
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        TTrainDataEntry & TDEntry = TrainDataVector.at(x);
        // non-const reference so can alter content
        TTrainOperatingData TData;
        const TActionVectorEntry &LastAVEntry = TDEntry.ActionVector.at(TDEntry.ActionVector.size() - 1);
        if(LastAVEntry.FormatType == Repeat) // check if a repeat
        {
/*
              class TTrainOperatingData
              {
              public:
              int TrainID; - default, set at construction
              TActionEventType EventReported; used during operation
              TRunningEntry RunningEntry; - default, set at construction
              TTrainOperatingData() {TrainID = -1; EventReported= NoEvent; RunningEntry=NotStarted;} //constructor, values set to defaults
              };
*/
            TDEntry.NumberOfTrains = LastAVEntry.NumberOfRepeats + 1;
            for(int y = 1; y < TDEntry.NumberOfTrains; y++)
            {
                TDEntry.TrainOperatingDataVector.push_back(TData);
            }
        }
        else
        {
            TDEntry.NumberOfTrains = 1;
        }
    }

    // check that don't include any Continuation names
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            AnsiString LocName = TrainDataVector.at(x).ActionVector.at(y).LocationName;
            AnsiString HC = TrainDataVector.at(x).HeadCode;
            if(LocName != "")
            {
                if(Track->ContinuationNameMap.find(LocName) != Track->ContinuationNameMap.end())
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - continuation names (" + LocName + ") must not be included, see service " + HC);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1578);
                    return(false);
                }
            }
        }
    }

    // check that all repeat times below 96h
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        int NumRepeats = (TrainDataVector.at(x).NumberOfTrains) - 1;
        int IncMinutes = 0;
        if(TrainDataVector.at(x).ActionVector.at(TrainDataVector.at(x).ActionVector.size() - 1).FormatType == Repeat)
        {
            IncMinutes = TrainDataVector.at(x).ActionVector.at(TrainDataVector.at(x).ActionVector.size() - 1).RearStartOrRepeatMins;
        }
        else
        {
            continue; // basic times already checked in CheckTimeValidity
        }
        AnsiString HC = TrainDataVector.at(x).HeadCode;
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            if((double)TrainDataVector.at(x).ActionVector.at(y).EventTime > -1)
            {
                if(((double)GetRepeatTime(32, TrainDataVector.at(x).ActionVector.at(y).EventTime, NumRepeats, IncMinutes) >= 3.9994))
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a repeat time exceeds 95h 59m, see service " + HC); // 3d 23h 59m = 3.9993055556
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1818);
                    return(false);
                }
            }
            if((double)TrainDataVector.at(x).ActionVector.at(y).ArrivalTime > -1)
            {
                if(((double)GetRepeatTime(33, TrainDataVector.at(x).ActionVector.at(y).EventTime, NumRepeats, IncMinutes) >= 3.9994))
                // 3d 23h 59m = 3.9993055556
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a repeat entry time exceeds 95h 59m, see service " + HC);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1819);
                    return(false);
                }
            }
            if((double)TrainDataVector.at(x).ActionVector.at(y).DepartureTime > -1)
            {
                if(((double)GetRepeatTime(34, TrainDataVector.at(x).ActionVector.at(y).EventTime, NumRepeats, IncMinutes) >= 3.9994))
                // 3d 23h 59m = 3.9993055556
                {
                    SecondPassMessage(GiveMessages, "Error in timetable - a repeat entry time exceeds 95h 59m, see service " + HC);
                    TrainDataVector.clear();
                    Utilities->CallLogPop(1820);
                    return(false);
                }
            }
        }
    }

    // Now that all set up change any extended headcodes back to ordinary headcodes
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        StripExcessFromHeadCode(0, TrainDataVector.at(x).HeadCode);
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            StripExcessFromHeadCode(1, TrainDataVector.at(x).ActionVector.at(y).OtherHeadCode);
            StripExcessFromHeadCode(2, TrainDataVector.at(x).ActionVector.at(y).NonRepeatingShuttleLinkHeadCode);
        }
    }

    // SaveTrainDataVectorToFile(0);//for testing purposes
    BuildContinuationTrainExpectationMultiMap(0);
    Utilities->CallLogPop(782);
    return(true);
}

// ---------------------------------------------------------------------------
// Moving successors: TimeLoc arr/TimeTimeLoc/pas/Fer;
bool TTrainController::MovingSuccessor(const TActionVectorEntry &AVEntry)
{
    return ((AVEntry.FormatType == TimeLoc) || (AVEntry.FormatType == TimeTimeLoc) || (AVEntry.Command == "pas") || (AVEntry.Command == "Fer"));
}

// ---------------------------------------------------------------------------
// AtLoc successors:  TimeLoc dep/jbo/fsp/rsp/cdt/Frh/Fns/Fjo/Frh-sh/Fns-sh/F-nshs;
bool TTrainController::AtLocSuccessor(const TActionVectorEntry &AVEntry)
{
    return ((AVEntry.FormatType == TimeLoc) || (AVEntry.Command == "jbo") || (AVEntry.Command == "fsp") || (AVEntry.Command == "rsp") ||
            (AVEntry.Command == "cdt") || (AVEntry.Command == "Frh") || (AVEntry.Command == "Fns") || (AVEntry.Command == "Fjo") || (AVEntry.Command == "Frh-sh") ||
            (AVEntry.Command == "Fns-sh") || (AVEntry.Command == "F-nshs"));
}

// ---------------------------------------------------------------------------

void TTrainController::StripExcessFromHeadCode(int Caller, AnsiString &HeadCode)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",StripExcessFromHeadCode," + HeadCode);
    if(HeadCode.Length() > 4) // ignore otherwise
    {
        HeadCode = HeadCode.SubString(HeadCode.Length() - 3, 4);
    }
    Utilities->CallLogPop(1593);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckForDuplicateCrossReferences(int Caller, AnsiString MainHeadCode, AnsiString SecondHeadCode, bool GiveMessages)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckForDuplicateCrossReferences," + MainHeadCode + "," +
                                 SecondHeadCode);
    int ForwardCount = 0;
    int ReverseCount = 0;

    if(MainHeadCode == SecondHeadCode)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - Service " + MainHeadCode + " has an event that references itself");
        TrainDataVector.clear();
        Utilities->CallLogPop(1594);
        return(false);
    }
    // forward check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == MainHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.OtherHeadCode == SecondHeadCode)
                {
                    ForwardCount++;
                }
                if(AVEntry.NonRepeatingShuttleLinkHeadCode == SecondHeadCode)
                // need own check in case both 'Other' & 'NonRepeating' have same headcode
                {
                    ForwardCount++;
                }
            }
        }
    }
    if(ForwardCount == 0)
    // this is an exception because the headcodes are selected in the same order as the forward check
    {
        throw Exception("Error, ForwardCount == 0 in CheckForDuplicateCrossReferences after called with found values");
    }
    if(ForwardCount > 2)
    // can have 2 if one is Sns-sh linking from another leg of the shuttle, and Fns links out to that same leg
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than two references to " + SecondHeadCode + " from a train whose headcode is " +
                          MainHeadCode + ". Check the service cross references from each service, and check whether one or other service is listed twice or more.");
        TrainDataVector.clear();
        Utilities->CallLogPop(1587);
        return(false);
    }
    // reverse check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == SecondHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                const TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.OtherHeadCode == MainHeadCode)
                {
                    ReverseCount++;
                }
                if(AVEntry.NonRepeatingShuttleLinkHeadCode == MainHeadCode)
                {
                    ReverseCount++;
                }
            }
        }
    }

    if(ReverseCount == 0)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - cross reference missing in either " + MainHeadCode + " or " + SecondHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(1588);
        return(false);
    }
    if(ReverseCount > 2)
    // can have 2 if one is a second shuttle leg with a link in from Fns, and it links out to the same service with Fxx-sh
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than two references to " + MainHeadCode + " from a train whose headcode is " +
                          SecondHeadCode + ". Check the service cross references from each service, and check whether one or other service is listed twice or more.");
        TrainDataVector.clear();
        Utilities->CallLogPop(1589);
        return(false);
    }
    if(ForwardCount != ReverseCount)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - " + MainHeadCode + " has a different number of references to " + SecondHeadCode +
                          " than the other way round");
        TrainDataVector.clear();
        Utilities->CallLogPop(1610);
        return(false);
    }
    Utilities->CallLogPop(1590);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckCrossReferencesAndSetData(int Caller, AnsiString MainHeadCode, AnsiString OtherHeadCode, bool Shuttle, bool GiveMessages)
/* Return false for no find or more than one find, check correct types of link
          First run through all trains whose headcode is the MainHeadCode (may be > 1) & for each entry whose
          'other' is OtherHeadCode increment a forward counter.  Keep a pointer to the 'OtherHeadCode' entry for use later
          Must be exactly 1 forward count.  NB Forward relates to MainHeadCode
          Then do the same in reverse.
          Using the pointers check the event times, then check that the locations & commands match - if main is a split then other must be Sfs;
          if main is Fns other must be Sns; if main is jbo other must be Fjo.
          Also check platform lengths OK for a split location (call to Track function for this - at least one platform at location has to be long
          enough).  If all succeeds so far set the relevant OtherHeadCodeStartingEntryPtr to the new service starting point + train information
          for Sfs & Sns services.  Finally check the repeat entries if present are consistent

          Check all except the NonRepeatingShuttleLinkHeadCodes, which only occur from F-nshs to Sns-sh, and from Fns-sh to
          Sns-fsh.  All others should check out OK, but check shuttles & non-shuttles separately.

          /NB prohibit main & other headcodes being same, causes probs in failing to recognise locations
*/

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckCrossReferencesAndSetData," + MainHeadCode + "," + OtherHeadCode);
    int ForwardCount = 0;
    int ReverseCount = 0;
    unsigned int ForwardTDVectorNumber, ReverseTDVectorNumber;
    TActionVectorEntry *ReverseEntryPtr = 0, *ForwardEntryPtr = 0;
    TTrainDataEntry *MainTrainDataPtr = 0;
    TTrainDataEntry *OtherTrainDataPtr = 0;

    // forward check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == MainHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(!Shuttle && (AVEntry.Command != "Sns-sh") && (AVEntry.Command != "Snt-sh") && (AVEntry.Command != "Fns-sh") && (AVEntry.Command != "Frh-sh"))
                {
                    if(AVEntry.OtherHeadCode == OtherHeadCode)
                    {
                        MainTrainDataPtr = &TrainDataVector.at(x);
                        ForwardEntryPtr = &AVEntry;
                        ForwardCount++;
                        ForwardTDVectorNumber = x;
                    }
                }
                else if(Shuttle && ((AVEntry.Command == "Sns-sh") || (AVEntry.Command == "Snt-sh") || (AVEntry.Command == "Fns-sh") ||
                                    (AVEntry.Command == "Frh-sh")))
                {
                    if(AVEntry.OtherHeadCode == OtherHeadCode)
                    {
                        MainTrainDataPtr = &TrainDataVector.at(x);
                        ForwardEntryPtr = &AVEntry;
                        ForwardCount++;
                        ForwardTDVectorNumber = x;
                    }
                }
            }
        }
    }
    if(ForwardCount == 0)
    // this is an exception because the headcodes are selected in the same order as the forward check
    {
        throw Exception("Error, ForwardCount == 0 in CheckCrossReferencesAndSetData after called with found values");
    }
    if(ForwardCount > 1)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than one reference to " + OtherHeadCode + " from a train whose headcode is " +
                          MainHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(836);
        return(false);
    }
    // reverse check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == OtherHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(!Shuttle && (AVEntry.Command != "Sns-sh") && (AVEntry.Command != "Snt-sh") && (AVEntry.Command != "Fns-sh") && (AVEntry.Command != "Frh-sh"))
                {
                    if(AVEntry.OtherHeadCode == MainHeadCode)
                    {
                        OtherTrainDataPtr = &TrainDataVector.at(x);
                        ReverseCount++;
                        ReverseEntryPtr = &AVEntry;
                        ReverseTDVectorNumber = x;
                    }
                }
                else if(Shuttle && ((AVEntry.Command == "Sns-sh") || (AVEntry.Command == "Snt-sh") || (AVEntry.Command == "Fns-sh") || (AVEntry.Command == "Frh-sh")))
                {
                    if(AVEntry.OtherHeadCode == MainHeadCode)
                    {
                        OtherTrainDataPtr = &TrainDataVector.at(x);
                        ReverseCount++;
                        ReverseEntryPtr = &AVEntry;
                        ReverseTDVectorNumber = x;
                    }
                }
            }
        }
    }

    if(ReverseCount == 0)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - cross reference missing in either " + MainHeadCode + " or " + OtherHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(837);
        return(false);
    }
    if(ReverseCount > 1)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than one reference to " + MainHeadCode + " from a train whose headcode is " +
                          OtherHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(838);
        return(false);
    }
    // these will all be false for !Shuttle
    bool ForwardShuttleStart = ((ForwardEntryPtr->Command == "Sns-sh") || (ForwardEntryPtr->Command == "Snt-sh"));
    bool ForwardShuttleFinish = ((ForwardEntryPtr->Command == "Fns-sh") || (ForwardEntryPtr->Command == "Frh-sh"));
    bool ReverseShuttleStart = ((ReverseEntryPtr->Command == "Sns-sh") || (ReverseEntryPtr->Command == "Snt-sh"));
    bool ReverseShuttleFinish = ((ReverseEntryPtr->Command == "Fns-sh") || (ReverseEntryPtr->Command == "Frh-sh"));

    if(Shuttle && MainTrainDataPtr->ActionVector.back().FormatType != Repeat)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - shuttle train " + MainHeadCode + " does not have a repeat");
        TrainDataVector.clear();
        Utilities->CallLogPop(1058);
        return(false);
    }
    if(Shuttle && OtherTrainDataPtr->ActionVector.back().FormatType != Repeat)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - shuttle train " + OtherHeadCode + " does not have a repeat");
        TrainDataVector.clear();
        Utilities->CallLogPop(1059);
        return(false);
    }
    if(ForwardEntryPtr->LocationName == "")
    {
        SecondPassMessage(GiveMessages, "Error in timetable - location error in cross referenced trains " + MainHeadCode + " and " + OtherHeadCode +
                          ".  One or other service does not have a location set");
        TrainDataVector.clear();
        Utilities->CallLogPop(526);
        return(false);
    }
    if(ReverseEntryPtr->LocationName == "")
    {
        SecondPassMessage(GiveMessages, "Error in timetable - location error in cross referenced trains " + MainHeadCode + " and " + OtherHeadCode +
                          ".  One or other service does not have a location set");
        TrainDataVector.clear();
        Utilities->CallLogPop(527);
        return(false);
    }
    if(ForwardEntryPtr->LocationName != ReverseEntryPtr->LocationName)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - cross referenced train " + OtherHeadCode +
                          " is at a different location to the referencing train " + MainHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(842);
        return(false);
    }
    // ignore shuttle repeat links for first time check
    if(!Shuttle)
    {
        if(ForwardEntryPtr->EventTime != ReverseEntryPtr->EventTime)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - cross referenced train " + OtherHeadCode +
                              " has a different event time to the referencing train " + MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(525);
            return(false);
        }
    }
    // need to allow for repeat times multiplying up by repeating time for shuttle repeat links
    // no need to check from reverse to forward as already checked links consistent, and if include will send message twice
    if(ForwardShuttleStart && ReverseShuttleFinish)
    // Shuttle must be true if these are true
    {
        if(!CheckShuttleRepeatTime(0, ForwardEntryPtr->EventTime, ReverseEntryPtr->EventTime, OtherTrainDataPtr->ActionVector.back().RearStartOrRepeatMins))
        {
            SecondPassMessage(GiveMessages, "Error in timetable - shuttle service " + MainHeadCode +
                              " first repeat restart time not consistent with finish service " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1055);
            return(false);
        }
    }
    if((ReverseEntryPtr->Command == "Sfs") || (ReverseEntryPtr->Command == "Sns"))
    // doesn't matter about ForwardEntryPtr being Sfs/Sns as called for every occurrence of an 'OtherHeadCode' so won't escape
    {
        if(ReverseTDVectorNumber == ForwardTDVectorNumber)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - an 'Sfs' or 'Sns' event (" + OtherHeadCode +
                              ") appears in the same sequence as the corresponding linked event " + MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(528);
            return(false);
        }
    }
    if(ReverseEntryPtr->Command == "Fjo")
    // doesn't matter about ForwardEntryPtr being Fjo as called for every occurrence of an 'OtherHeadCode' so won't escape
    {
        if(ReverseTDVectorNumber == ForwardTDVectorNumber)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - an 'Fjo' event (" + OtherHeadCode +
                              ") appears in the same sequence as the corresponding linked event " + MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(862);
            return(false);
        }
    }
    if(ReverseEntryPtr->Command == "Fns")
    // doesn't matter about ForwardEntryPtr being Fns as called for every occurrence of an 'OtherHeadCode' so won't escape
    {
        if(ReverseTDVectorNumber == ForwardTDVectorNumber)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - an 'Fns' event (" + OtherHeadCode +
                              ") appears in the same sequence as the corresponding linked event " + MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(529);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "Sfs")
    {
        if((ReverseEntryPtr->Command != "fsp") && (ReverseEntryPtr->Command != "rsp"))
        {
            SecondPassMessage(GiveMessages,
                              "Error in timetable - unable to find a corresponding split train event for the train that starts from a split whose headcode is " +
                              MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(530);
            return(false);
        }
    }
    if((ForwardEntryPtr->Command == "fsp") || (ForwardEntryPtr->Command == "rsp"))
    {
        if(ReverseEntryPtr->Command != "Sfs")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'Sfs' event for the train split whose headcode is " +
                              MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(839);
            return(false);
        }
        else
        {
            if(!(Track->TimetabledLocationNameAllocated(4, ForwardEntryPtr->LocationName)))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - can't find timetabled location '" + ForwardEntryPtr->LocationName + "' in railway - perhaps there are concourses without platforms?");
                TrainDataVector.clear();
                Utilities->CallLogPop(849);
                return(false);
            }
            if(!(Track->OneNamedLocationElementAtLocation(0, ForwardEntryPtr->LocationName)))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - can't find any named location elements at '" + ForwardEntryPtr->LocationName + "' - perhaps there are concourses without platforms?");
                TrainDataVector.clear();
                Utilities->CallLogPop(850);
                return(false);
            }
            if(!(Track->OneNamedLocationLongEnoughForSplit(0, ForwardEntryPtr->LocationName)))
            {
                SecondPassMessage(GiveMessages, "Error in timetable - location too short to split a train at " + ForwardEntryPtr->LocationName);
                TrainDataVector.clear();
                Utilities->CallLogPop(846);
                return(false);
            }
            ForwardEntryPtr->LinkedTrainEntryPtr = OtherTrainDataPtr;
            ReverseEntryPtr->LinkedTrainEntryPtr = MainTrainDataPtr;
            if(OtherTrainDataPtr->Description == "")
            {
                OtherTrainDataPtr->Description = MainTrainDataPtr->Description;
            }
            // NB: May not be set if main train is a service continuation without a description, if so can't do much about it but doesn't affect operation, just the train information display
            OtherTrainDataPtr->MaxRunningSpeed = MainTrainDataPtr->MaxRunningSpeed;
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
        }
    }
    if(ForwardEntryPtr->Command == "Sns")
    {
        if(ReverseEntryPtr->Command != "Fns")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'Fns' event for the 'Sns' train whose headcode is " +
                              MainHeadCode + " and is formed from a service with headcode " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(531);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "Fns")
    {
        if(ReverseEntryPtr->Command != "Sns")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'Sns' event for the train whose headcode is " + MainHeadCode +
                              " and forms a new service with headcode " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(840);
            return(false);
        }
        else
        {
            ForwardEntryPtr->LinkedTrainEntryPtr = OtherTrainDataPtr;
            ReverseEntryPtr->LinkedTrainEntryPtr = MainTrainDataPtr;
            if(OtherTrainDataPtr->Description == "")
            {
                OtherTrainDataPtr->Description = MainTrainDataPtr->Description;
            }
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
            OtherTrainDataPtr->MaxRunningSpeed = MainTrainDataPtr->MaxRunningSpeed;
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
        }
    }
    if(ForwardEntryPtr->Command == "jbo")
    {
        if(ReverseEntryPtr->Command != "Fjo")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'Fjo' event for the train whose headcode is " + MainHeadCode +
                              " and is joined by a train with headcode " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(841);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "Fjo")
    {
        if(ReverseEntryPtr->Command != "jbo")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'jbo' event for the train whose headcode is " + MainHeadCode +
                              " and joins a train with headcode " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(532);
            return(false);
        }
        else
        {
            ForwardEntryPtr->LinkedTrainEntryPtr = OtherTrainDataPtr;
            ReverseEntryPtr->LinkedTrainEntryPtr = MainTrainDataPtr;
            if((MainTrainDataPtr->MaxRunningSpeed > 5) && (MainTrainDataPtr->MaxRunningSpeed < OtherTrainDataPtr->MaxRunningSpeed))
            {
                OtherTrainDataPtr->MaxRunningSpeed = MainTrainDataPtr->MaxRunningSpeed;
            }
            // added test for > 5 [5 used instead of 0 because of possible floating point errors - though unlikely] above at v1.3.1 because the train will have a zero MaxRunningSpeed if it continues from another service - its max speed is set when it takes over from the other service
            // notified of this problem by Ian Walker in his email of 25/03/13.  Probably redundant anyway because the max speed is reduced at the changeover if the 'joined by' train's max speed is less.
        }
    }
    if(ForwardShuttleStart)
    // (ForwardEntryPtr->Command == "Sns-sh") || (ForwardEntryPtr->Command == "Snt-sh"))
    {
        if(!ReverseShuttleFinish)
        // (ReverseEntryPtr->Command != "Fns-sh") && (ReverseEntryPtr->Command != "Frh-sh"))
        {
            SecondPassMessage(GiveMessages, "Error in timetable - incorrect shuttle link to train whose headcode is " + MainHeadCode +
                              " from train whose headcode is " + OtherHeadCode + ", has to be Fns-sh, Frh-sh");
            TrainDataVector.clear();
            Utilities->CallLogPop(1056);
            return(false);
        }
    }
    if(ReverseShuttleStart)
    // (ReverseEntryPtr->Command == "Sns-sh") || (ReverseEntryPtr->Command == "Snt-sh"))
    {
        if(!ForwardShuttleFinish)
        // (ForwardEntryPtr->Command != "Fns-sh") && (ForwardEntryPtr->Command != "Frh-sh"))
        {
            SecondPassMessage(GiveMessages, "Error in timetable - incorrect shuttle link to train whose headcode is " + OtherHeadCode +
                              " from train whose headcode is " + MainHeadCode + ", has to be Fns-sh, Frh-sh");
            TrainDataVector.clear();
            Utilities->CallLogPop(1057);
            return(false);
        }
        else
        {
            ForwardEntryPtr->LinkedTrainEntryPtr = OtherTrainDataPtr;
            ReverseEntryPtr->LinkedTrainEntryPtr = MainTrainDataPtr;
/* don't need LinkedTrainEntryPtr for 'OtherTrain' & don't need data transfer as this is done in the
              non-repeating link for Sns-sh & is provided at the outset for Snt-sh
*/
        }
    }
    // check repeat information consistent if present
    // note that won't be affected by the non-repeating shuttle links as these are in NonRepeatingShuttleLinkHeadCode
    // and those not accessed here

    // still need to check the non-repeating links and that they have no repeats - do that outside this function
    bool MainRepeat = false, OtherRepeat = false;
    TActionVectorEntry MainRepeatEntry, OtherRepeatEntry;

    if(MainTrainDataPtr->ActionVector.at(MainTrainDataPtr->ActionVector.size() - 1).FormatType == Repeat)
    {
        MainRepeat = true;
        MainRepeatEntry = MainTrainDataPtr->ActionVector.at(MainTrainDataPtr->ActionVector.size() - 1);
    }
    if(OtherTrainDataPtr->ActionVector.at(OtherTrainDataPtr->ActionVector.size() - 1).FormatType == Repeat)
    {
        OtherRepeat = true;
        OtherRepeatEntry = OtherTrainDataPtr->ActionVector.at(OtherTrainDataPtr->ActionVector.size() - 1);
    }
    if((MainRepeat && !OtherRepeat) || (!MainRepeat && OtherRepeat))
    {
        SecondPassMessage(GiveMessages, "Error in timetable - only one repeat is provided for the train whose headcode is " + MainHeadCode +
                          " and the associated train with headcode " + OtherHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(844);
        return(false);
    }
    if(MainRepeat && OtherRepeat)
    {
        if((MainRepeatEntry.EventTime != OtherRepeatEntry.EventTime) || (MainRepeatEntry.RearStartOrRepeatMins != OtherRepeatEntry.RearStartOrRepeatMins) ||
           (MainRepeatEntry.FrontStartOrRepeatDigits != OtherRepeatEntry.FrontStartOrRepeatDigits) ||
           (MainRepeatEntry.NumberOfRepeats != OtherRepeatEntry.NumberOfRepeats))
        {
            SecondPassMessage(GiveMessages, "Error in timetable - repeat items don't correspond for the train whose headcode is " + MainHeadCode +
                              " and the associated train with headcode " + OtherHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(845);
            return(false);
        }
    }
    Utilities->CallLogPop(863);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrainController::StripSpaces(int Caller, AnsiString &Input)
// strip both leading and trailing spaces at ends of text and spaces before and after all commas and semicolons within the text
{
    // strip spaces from extreme ends of input
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",StripSpaces," + AnsiString(Input));
    if(Input == "")
    {
        Utilities->CallLogPop(856);
        return;
    }
    while(Input[1] == ' ')
    {
        if(Input.Length() > 1)
        {
            Input = Input.SubString(2, Input.Length() - 1);
        }
        else
        {
            Input = "";
            Utilities->CallLogPop(857);
            return;
        }
    }
    if(Input == "")
    {
        Utilities->CallLogPop(858);
        return;
    }
    while(Input[Input.Length()] == ' ')
    {
        if(Input.Length() > 1)
        {
            Input = Input.SubString(1, Input.Length() - 1);
        }
        else
        {
            Input = "";
            Utilities->CallLogPop(859);
            return;
        }
    }
    // now strip spaces immediately after all commas and semicolons within the text
    AnsiString Output = "";
    bool DelimiterFound = false;

    for(int x = 1; x < Input.Length() + 1; x++)
    {
        if(DelimiterFound)
        {
            if(Input[x] == ' ')
            {
                continue;
            }
        }
        if((Input[x] != ',') && (Input[x] != ';'))
        {
            DelimiterFound = false;
            Output = Output + Input[x];
        }
        else
        {
            DelimiterFound = true;
            Output = Output + Input[x];
        }
    }
    if(Output == "")
    {
        Input = "";
        Utilities->CallLogPop(860);
        return;
    }
    // now strip spaces immediately before all commas and semicolons within the text
    Input = Output;
    Output = "";
    DelimiterFound = false;
    for(int x = Input.Length(); x > 0; x--)
    {
        if(DelimiterFound)
        {
            if(Input[x] == ' ')
            {
                continue;
            }
        }
        if((Input[x] != ',') && (Input[x] != ';'))
        {
            DelimiterFound = false;
            Output = AnsiString(Input[x]) + Output;
        }
        else
        {
            DelimiterFound = true;
            Output = AnsiString(Input[x]) + Output;
        }
    }
    Input = Output;
    Utilities->CallLogPop(861);
}

// ---------------------------------------------------------------------------

bool TTrainController::IsSNTEntryLocated(int Caller, const TTrainDataEntry &TDEntry, AnsiString &LocationName)
// checks if an Snt or Snt-sh entry with zero starting speed is followed (somewhere, not necessarily immediately) by a TimeLoc & has the same LocationName
// and if so returns true.  Also returns true for Snt, not Snt-sh, if at least 1 start element is a location & the entry is either
// a signaller control entry & speed is zero or it is followed immediately by Frh or Fjo (mod at v2.0.0 for empty stock pickup).
// Always return false for entry at a continuation (may be named but not a stop location).  Note that no successor validity checks
// are done in this function, they must be done elsewhere.
//a starting speed > 0 always returns false
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsSNTEntryLocated," + AnsiString(TDEntry.HeadCode));
    const TActionVectorEntry &AVEntry0 = TDEntry.ActionVector.at(0);
    LocationName = "";
    if(TDEntry.StartSpeed > 0)
    {
        Utilities->CallLogPop(1784);
        return(false);
    }
    if((AVEntry0.Command != "Snt") && (AVEntry0.Command != "Snt-sh"))
    {
        throw Exception("Error, first entry not 'Snt' or 'Snt-sh' in IsSNTEntryLocated");
    }
    if(Track->TrackElementAt(506, AVEntry0.RearStartOrRepeatMins).TrackType == Continuation)
    {
        Utilities->CallLogPop(852);
        return(false);
    }
    AnsiString LocRear = Track->TrackElementAt(507, AVEntry0.RearStartOrRepeatMins).ActiveTrackElementName;
    AnsiString LocFront = Track->TrackElementAt(508, AVEntry0.FrontStartOrRepeatDigits).ActiveTrackElementName;

    if(LocRear != "")
    {
        LocationName = LocRear;
    }
    else
    {
        LocationName = LocFront;
    }
    if(LocationName == "")
    {
        Utilities->CallLogPop(1036);
        return(false);
    }
    if(AVEntry0.SignallerControl)
    {
        Utilities->CallLogPop(1773);
        return(true);
    }
// here if not a signaller start entry so must be at least one more entry, and it is at a location

//Ok                          Not ok          continue

//Frh if Snt                  Frh-sh          cdt
//Fns if Snt                  Fns-sh          fsp or rsp
//Fjo if Snt                  TimeTimeLoc     jbo
//F-nshs if Snt               pas
//TimeLoc dep                 Fer
//                            TimeLoc arr

    for(unsigned int y = 0; y < TDEntry.ActionVector.size(); y++)
    {
        const TActionVectorEntry &AVEntry = TDEntry.ActionVector.at(y);
        if(((AVEntry.Command == "Frh") || (AVEntry.Command == "Fjo") || (AVEntry.Command == "F-nshs") || (AVEntry.Command == "Fns")) && (AVEntry0.Command == "Snt")) // added Fjo at v2.0.0 for empty stock
        {
            Utilities->CallLogPop(1037);
            return(true);
        }
        if((AVEntry.FormatType == TimeLoc) && (AVEntry.LocationName == LocationName)) //will be a departure if same name- times not set yet so can't use them to confirm
        {
            Utilities->CallLogPop(2442);
            return(true);
        }
        if((AVEntry.FormatType == TimeLoc) && (AVEntry.LocationName != LocationName)) //arrival, not located
        {
            Utilities->CallLogPop(2438);
            return(false);
        }
        if((AVEntry.Command == "Fer") || (AVEntry.Command == "pas") || (AVEntry.Command == "Fns-sh") || (AVEntry.Command == "Frh-sh") || (AVEntry.FormatType == TimeTimeLoc))
        {
            Utilities->CallLogPop(854);
            return(false);
        }
        if((AVEntry.Command == "cdt") || (AVEntry.Command == "fsp") || (AVEntry.Command == "rsp") || (AVEntry.Command == "jbo"))
        {
            continue;
        }
    }
    Utilities->CallLogPop(855);
    return(false);

}

// ---------------------------------------------------------------------------

bool TTrainController::CheckStartPositionValidity(int Caller, AnsiString RearElementStr, AnsiString FrontElementStr, bool GiveMessages)
{
    // checks that the new train start elements are valid - both exist & are connected, and that not
    // attempting to start on a diverging leg (i.e. one segment on points & other on element connected to diverging leg)
    // & not starting with front on a continuation
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckStartPositionValidity," + RearElementStr + "," + FrontElementStr);
    int RearPosition = 0, FrontPosition = 0, RearExitPos = 0;

    RearPosition = Track->GetTrackVectorPositionFromString(5, RearElementStr, GiveMessages);
    if(RearPosition < 0)
    // error message given in GetTrackVectorPositionFromString
    {
        Utilities->CallLogPop(759);
        return(false);
    }
    FrontPosition = Track->GetTrackVectorPositionFromString(6, FrontElementStr, GiveMessages);
    if(FrontPosition < 0)
    // error message given in GetTrackVectorPositionFromString
    {
        Utilities->CallLogPop(760);
        return(false);
    }
    TTrackElement RearTrackElement = Track->TrackElementAt(490, RearPosition);
    TTrackElement FrontTrackElement = Track->TrackElementAt(491, FrontPosition);
    TTrackType RearType = RearTrackElement.TrackType, FrontType = FrontTrackElement.TrackType;

    // check front & rear connected
    for(int x = 0; x < 4; x++)
    {
        if(RearTrackElement.Conn[x] == FrontPosition)
        {
            RearExitPos = x;
            break;
        }
        if(x == 3)
        {
            TimetableMessage(GiveMessages, "Front element: " + FrontTrackElement.ElementID + " not linked to rear element: " + RearTrackElement.ElementID);
            Utilities->CallLogPop(762);
            return(false);
        }
    }
    // check not starting with front on a continuation
    if(FrontType == Continuation)
    {
        TimetableMessage(GiveMessages, "Front of train attempting to start on a continuation at: " + FrontElementStr);
        Utilities->CallLogPop(937);
        return(false);
    }
    // check not starting on a level crossing
    if(Track->IsLCAtHV(43, FrontTrackElement.HLoc, FrontTrackElement.VLoc))
    {
        TimetableMessage(GiveMessages, "Train attempting to start on a level crossing at: " + FrontElementStr);
        Utilities->CallLogPop(1951);
        return(false);
    }
    if(Track->IsLCAtHV(44, RearTrackElement.HLoc, RearTrackElement.VLoc))
    {
        TimetableMessage(GiveMessages, "Train attempting to start on a level crossing at: " + RearElementStr);
        Utilities->CallLogPop(1952);
        return(false);
    }
    // check if trying to start on diverging leg of points
    if((RearType == Points) && (RearExitPos == 3))
    {
        TimetableMessage(GiveMessages, "Front of train attempting to start on element connected to diverging points at: " + RearElementStr);
        Utilities->CallLogPop(936);
        return(false);
    }
    if((FrontType == Points) && (RearTrackElement.ConnLinkPos[RearExitPos] == 3))
    {
        TimetableMessage(GiveMessages, "Rear of train attempting to start on element connected to diverging points at: " + FrontElementStr);
        Utilities->CallLogPop(1808);
        return(false);
    }
    Utilities->CallLogPop(905);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckStartAllowable(int Caller, int RearPosition, int RearExitPos, AnsiString HeadCode, bool ReportFlag, TActionEventType &EventType)
// Rear & front element validity already checked in CheckStartPositionValidity
// This checks for points in correct orientation, no train at start position and not starting on a locked route
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckStartAllowable," + AnsiString(RearPosition) + "," +
                                 AnsiString(RearExitPos));
    TTrackElement RearTrackElement = Track->TrackElementAt(517, RearPosition);

    if(RearTrackElement.TrackType == Continuation)
    {
        EventType = FailTrainEntry;
    }
    else
    {
        EventType = FailCreateTrain;
    }
    int FrontPosition = RearTrackElement.Conn[RearExitPos];
    TTrackElement FrontTrackElement = Track->TrackElementAt(798, FrontPosition);
    int FrontEntryPos = RearTrackElement.ConnLinkPos[RearExitPos];
    TTrackType RearType = RearTrackElement.TrackType;
    TTrackType FrontType = FrontTrackElement.TrackType;
    AnsiString RearName, FrontName;

    if(RearTrackElement.ActiveTrackElementName != "")
    {
        RearName = RearTrackElement.ActiveTrackElementName;
    }
    else
    {
        RearName = RearTrackElement.ElementID;
    }
    if(FrontTrackElement.ActiveTrackElementName != "")
    {
        FrontName = FrontTrackElement.ActiveTrackElementName;
    }
    else
    {
        FrontName = FrontTrackElement.ElementID;
    }
    TPrefDirElement PrefDirElement; // needed for next function but not used
    int LockedVectorNumber; // needed for next function but not used

    if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(12, FrontPosition, FrontEntryPos, PrefDirElement, LockedVectorNumber))
    {
        if(ReportFlag)
        {
            if(EventType == FailCreateTrain)
            {
                EventType = FailCreateLockedRoute;
            }
            else
            {
                EventType = FailEnterLockedRoute;
            }
            LogActionError(47, HeadCode, "", EventType, FrontName);
        }
        Utilities->CallLogPop(940);
        return(false);
    }
    if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(13, RearPosition, RearExitPos, PrefDirElement, LockedVectorNumber))
    {
        if(ReportFlag)
        {
            if(EventType == FailCreateTrain)
            {
                EventType = FailCreateLockedRoute;
            }
            else
            {
                EventType = FailEnterLockedRoute;
            }
            LogActionError(48, HeadCode, "", EventType, RearName);
        }
        Utilities->CallLogPop(1809);
        return(false);
    }
    if((RearType != Bridge) && (RearTrackElement.TrainIDOnElement > -1))
    {
        if(ReportFlag)
        {
            LogActionError(27, HeadCode, "", EventType, RearName);
        }
        Utilities->CallLogPop(1810);
        return(false);
    }
    if((FrontType != Bridge) && (FrontTrackElement.TrainIDOnElement > -1))
    {
        if(ReportFlag)
        {
            if(EventType == FailCreateTrain)
            {
                LogActionError(28, HeadCode, "", EventType, FrontName);
            }
            else
            {
                LogActionError(43, HeadCode, "", EventType, RearName);
            }
        }
        Utilities->CallLogPop(941);
        return(false);
    }
    if(RearType == Bridge)
    {
        if((RearExitPos > 1) && (RearTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 > -1))
        {
            if(ReportFlag)
            {
                LogActionError(29, HeadCode, "", EventType, RearName);
            }
            Utilities->CallLogPop(942);
            return(false);
        }
        if((RearExitPos < 2) && (RearTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 > -1))
        {
            if(ReportFlag)
            {
                LogActionError(30, HeadCode, "", EventType, RearName);
            }
            Utilities->CallLogPop(943);
            return(false);
        }
    }
    if(FrontType == Bridge)
    {
        if((FrontEntryPos > 1) && (FrontTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 > -1))
        {
            if(ReportFlag)
            {
                if(EventType == FailCreateTrain)
                {
                    LogActionError(31, HeadCode, "", EventType, FrontName);
                }
                else
                {
                    LogActionError(44, HeadCode, "", EventType, RearName);
                }
            }
            Utilities->CallLogPop(944);
            return(false);
        }
        if((FrontEntryPos < 2) && (FrontTrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 > -1))
        {
            if(ReportFlag)
            {
                if(EventType == FailCreateTrain)
                {
                    LogActionError(45, HeadCode, "", EventType, FrontName);
                }
                else
                {
                    LogActionError(46, HeadCode, "", EventType, RearName);
                }
            }
            Utilities->CallLogPop(945);
            return(false);
        }
    }
    EventType = FailCreatePoints;
    if(RearType == Points)
    {
        if(RearTrackElement.Attribute == 1)
        {
            if(ReportFlag)
            {
                LogActionError(33, HeadCode, "", FailCreatePoints, RearName);
            }
            Utilities->CallLogPop(933);
            return(false);
        }
    }
    if(FrontType == Points)
    {
        if(FrontTrackElement.Attribute == 1)
        {
            if(ReportFlag)
            {
                LogActionError(34, HeadCode, "", FailCreatePoints, FrontName);
            }
            Utilities->CallLogPop(934);
            return(false);
        }
    }

    //this section added at v2.9.1 to prevent entry for a train when there's a route set against it
    int HLoc = Track->TrackElementAt(1027, RearPosition).HLoc;
    int VLoc = Track->TrackElementAt(1028, RearPosition).VLoc;
    int ELink = Track->TrackElementAt(1029, RearPosition).Link[RearExitPos]; //if route entry corresponds to RearExitPos then it's set against the train
    int RouteNumber; //not used
    if(Track->TrackElementAt(1030, RearPosition).TrackType == Continuation)
    {
        if(AllRoutes->FindRouteNumberFromRoute2MultiMapNoErrors(8, HLoc, VLoc, ELink, RouteNumber))
        {
            EventType = FailEntryRouteSetAgainst;
            if(ReportFlag)
            {
                LogActionError(63, HeadCode, "", EventType, RearName);
            }
            Utilities->CallLogPop(2317);
            return(false);
        }
    }
    Utilities->CallLogPop(939);
    return(true);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::GetRepeatHeadCode(int Caller, AnsiString BaseHeadCode, int RepeatNumber, int IncDigits)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetRepeatHeadCode," + BaseHeadCode + "," + AnsiString(RepeatNumber) +
                                 "," + AnsiString(IncDigits));
    if(!Last2CharactersBothDigits(1, BaseHeadCode) && (IncDigits > 0))
    {
        throw Exception("Error, last 2 characters not both digits and IncDigits > 0 in GetRepeatHeadCode");
    }
    if(!Last2CharactersBothDigits(2, BaseHeadCode))
    {
        Utilities->CallLogPop(1893);
        return(BaseHeadCode);
    }
    int BaseDigits = BaseHeadCode.SubString(3, 2).ToInt();
    int NextRepeatDigits = BaseDigits + (IncDigits * RepeatNumber);

    while(NextRepeatDigits >= 100)
    {
        NextRepeatDigits -= 100; // rolls over after 99
    }
    AnsiString NextRepeatDigitsStr = AnsiString(NextRepeatDigits);

    if(NextRepeatDigitsStr.Length() < 2)
    {
        NextRepeatDigitsStr = AnsiString('0') + NextRepeatDigitsStr;
    }
    AnsiString NextRepeatHeadCode = BaseHeadCode.SubString(1, 2) + NextRepeatDigitsStr;

    Utilities->CallLogPop(1365);
    return(NextRepeatHeadCode);
}

// ---------------------------------------------------------------------------

TDateTime TTrainController::GetRepeatTime(int Caller, TDateTime BasicTime, int RepeatNumber, int IncMinutes)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetRepeatTime," + AnsiString(double(BasicTime)) + "," +
                                 AnsiString(RepeatNumber) + "," + AnsiString(IncMinutes));
    TDateTime NextRepeatTime = BasicTime + TDateTime(((double)(RepeatNumber * IncMinutes)) / 1440.0); // 1440 = no. of minutes in 24h
    Utilities->CallLogPop(1366);
    return(NextRepeatTime);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckShuttleRepeatTime(int Caller, TDateTime ForwardEventTime, TDateTime ReverseEventTime, int RepeatMinutes)
// For success the ForwardEventTime + repeat time should == ReverseEventTime (allow 10secs either way since converting to doubles)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckShuttleRepeatTime," + AnsiString(double(ForwardEventTime)) + "," +
                                 AnsiString(double(ReverseEventTime)) + "," + AnsiString(RepeatMinutes));
    int ForwardSecs = int(double(ForwardEventTime) * 86400);
    int ReverseSecs = int(double(ReverseEventTime) * 86400);
    int RepeatSecs = RepeatMinutes * 60;

    if((ForwardSecs > (ReverseSecs - RepeatSecs + 10)) || (ForwardSecs < (ReverseSecs - RepeatSecs - 10)))
    {
        Utilities->CallLogPop(1367);
        return(false);
    }
    else
    {
        Utilities->CallLogPop(1368);
        return(true);
    }
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckNonRepeatingShuttleLinksAndSetData(int Caller, AnsiString MainHeadCode, AnsiString NonRepeatingHeadCode, bool GiveMessages)
// check for proper non-repeating link cross references and that they have no repeats & that times are consistent

/* Double crosslink (shuttle) table:
Command   Format                    OtherHead                        NonRepeating-  LinkTrain-   NonRepeating-   Decsription
                                    Code                             ShuttleLink-   EntryPtr     ShuttleLink-
                                                                     HeadCode                    EntryPtr

Snt-sh  SNTShuttle                  Y (rtn shuttle)                  N              Y (rtn sh)   N               Simple shuttle - no feeder service
Frh-sh  TimeCmdHeadCode             Y (outwd shuttle)                N              Y (outwd sh) N               Simple shuttle - no finishing service
F-nshs  FNSNonRepeatToShuttle       N (shld be Y for outwd shuttle)  Y (shld be N)  Y (correct)  N (correct)     Feeder service link to shuttle
Sns-sh  SNSShuttle                  Y (rtn shuttle)                  Y (feeder)     Y (rtn)      Y (fdr)         Shuttle link from feeder service
Sns-fsh SNSNonRepeatFromShuttle     N (shld be Y for rtn shuttle)    Y (shld be N)  Y (correct)  N (correct)     Finishing service link from shuttle
Fns-sh  FSHNewService               Y (outwd shuttle)                Y (finishing)  Y (outwd sh) Y (finish)      Shuttle link to finishing service

Note:  Any shuttle start can have any finish - feeder and finish, neither, feeder but no finish & vice versa.
*/

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckNonRepeatingShuttleLinksAndSetData," + MainHeadCode + "," +
                                 NonRepeatingHeadCode);
    int ForwardCount = 0;
    int ReverseCount = 0;
    unsigned int ForwardTDVectorNumber, ReverseTDVectorNumber;
    TActionVectorEntry *ReverseEntryPtr = 0, *ForwardEntryPtr = 0;
    // Forward corresponds to Main, Reverse to Other
    TTrainDataEntry *MainTrainDataPtr = 0;
    TTrainDataEntry *OtherTrainDataPtr = 0;

    // forward check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == MainHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.NonRepeatingShuttleLinkHeadCode == NonRepeatingHeadCode)
                {
                    MainTrainDataPtr = &TrainDataVector.at(x);
                    ForwardEntryPtr = &AVEntry;
                    ForwardCount++;
                    ForwardTDVectorNumber = x;
                }
            }
        }
    }
    if(ForwardCount == 0)
    // this is an exception because the headcodes are selected in the same order as the forward check
    {
        throw Exception("Error, ForwardCount == 0 in CheckNonRepeatingShuttleLinksAndSetData after called with found values");
    }
    if(ForwardCount > 1)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than one reference to " + NonRepeatingHeadCode + " from a train whose headcode is " +
                          MainHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(1061);
        return(false);
    }
    // reverse check
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        if(TDEntry.HeadCode == NonRepeatingHeadCode)
        {
            for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
            {
                TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
                if(AVEntry.NonRepeatingShuttleLinkHeadCode == MainHeadCode)
                {
                    OtherTrainDataPtr = &TrainDataVector.at(x);
                    ReverseCount++;
                    ReverseEntryPtr = &AVEntry;
                    ReverseTDVectorNumber = x;
                }
            }
        }
    }

    if(ReverseCount == 0)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - cross reference missing in either " + MainHeadCode + " or " + NonRepeatingHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(1062);
        return(false);
    }
    if(ReverseCount > 1)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - found more than one reference to " + MainHeadCode + " from a train whose headcode is " +
                          NonRepeatingHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(1063);
        return(false);
    }
    if(((ForwardEntryPtr->Command == "F-nshs") || (ForwardEntryPtr->Command == "Sns-fsh")) && (MainTrainDataPtr->ActionVector.back().FormatType == Repeat))
    {
        SecondPassMessage(GiveMessages, "Error in timetable - shuttle connecting train " + MainHeadCode + " shouldn't have a repeat");
        TrainDataVector.clear();
        Utilities->CallLogPop(1064);
        return(false);
    }
    if((ForwardEntryPtr->Command != "F-nshs") && (ForwardEntryPtr->Command != "Sns-fsh") && (MainTrainDataPtr->ActionVector.back().FormatType != Repeat))
    {
        SecondPassMessage(GiveMessages, "Error in timetable - shuttle train " + MainHeadCode + " does not have a repeat item");
        TrainDataVector.clear();
        Utilities->CallLogPop(1065);
        return(false);
    }
    if(ForwardEntryPtr->LocationName == "")
    {
        SecondPassMessage(GiveMessages, "Error in timetable - location error in cross referenced trains " + MainHeadCode + " and " + NonRepeatingHeadCode +
                          ".  One or other service does not have a location set");
        TrainDataVector.clear();
        Utilities->CallLogPop(1066);
        return(false);
    }
    if(ReverseEntryPtr->LocationName == "")
    {
        SecondPassMessage(GiveMessages, "Error in timetable - location error in cross referenced trains " + MainHeadCode + " and " + NonRepeatingHeadCode +
                          ".  One or other service does not have a location set");
        TrainDataVector.clear();
        Utilities->CallLogPop(1067);
        return(false);
    }
    if(ForwardEntryPtr->LocationName != ReverseEntryPtr->LocationName)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - cross referenced train " + NonRepeatingHeadCode +
                          " is at a different location to the referencing train " + MainHeadCode);
        TrainDataVector.clear();
        Utilities->CallLogPop(1068);
        return(false);
    }
    if(ForwardEntryPtr->Command == "F-nshs")
    // i.e. the non repeating link into the shuttle service
    {
        if(ForwardEntryPtr->EventTime != ReverseEntryPtr->EventTime)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - shuttle in-link service " + MainHeadCode +
                              " finish time not consistent with start time of shuttle service " + NonRepeatingHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1069);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "Fns-sh")
    // i.e. the non repeating link out from the shuttle service
    {
        if(!CheckNonRepeatingShuttleLinkTime(0, ForwardEntryPtr->EventTime, ReverseEntryPtr->EventTime,
                                             MainTrainDataPtr->ActionVector.back().RearStartOrRepeatMins, MainTrainDataPtr->ActionVector.back().NumberOfRepeats))
        {
            SecondPassMessage(GiveMessages, "Error in timetable - service " + NonRepeatingHeadCode + ", which links out from shuttle service " + MainHeadCode +
                              ", has the wrong start time.  It should correspond to the finish time of the last shuttle.");
            TrainDataVector.clear();
            Utilities->CallLogPop(1070);
            return(false);
        }
    }
    if((ForwardEntryPtr->Command == "F-nshs") || (ForwardEntryPtr->Command == "Sns-fsh"))
    // i.e. a non repeating link to or from the shuttle service
    {
        if(ReverseTDVectorNumber == ForwardTDVectorNumber)
        {
            SecondPassMessage(GiveMessages, "Error in timetable - the non repeating link service " + NonRepeatingHeadCode +
                              " appears in the same sequence as the corresponding shuttle service " + MainHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1071);
            return(false);
        }
    }
/* it's allowed to have a different description
      if((ForwardEntryPtr->Command == "F-nshs") || (ForwardEntryPtr->Command == "Sns-fsh"))//i.e. a non repeating link to or from the shuttle service
      {
          if((MainTrainDataPtr->Description != "") && (OtherTrainDataPtr->Description != "") && (MainTrainDataPtr->Description != OtherTrainDataPtr->Description))
          {
              SecondPassMessage(GiveMessages, "Error in timetable - the non repeating link service " + NonRepeatingHeadCode + " has a different description to the corresponding shuttle service " + MainHeadCode);
              TrainDataVector.clear();
              Utilities->CallLogPop(1072);
              return false;
          }
      }
*/
    if(ForwardEntryPtr->Command == "Sns-sh")
    {
        if(ReverseEntryPtr->Command != "F-nshs")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'F-nshs' event for the 'Sns-sh' train whose headcode is " +
                              MainHeadCode + " and is a new shuttle service formed from the service with headcode " + NonRepeatingHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1073);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "F-nshs")
    {
        if(ReverseEntryPtr->Command != "Sns-sh")
        {
            SecondPassMessage(GiveMessages, "Error in timetable - unable to find a corresponding 'Sns-sh' event for the 'F-nshs' train whose headcode is " +
                              MainHeadCode + " and forms a new shuttle service with headcode " + NonRepeatingHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1074);
            return(false);
        }
        else
        {
            ForwardEntryPtr->LinkedTrainEntryPtr = OtherTrainDataPtr;
            ReverseEntryPtr->NonRepeatingShuttleLinkEntryPtr = MainTrainDataPtr;
            if(OtherTrainDataPtr->Description == "")
            {
                OtherTrainDataPtr->Description = MainTrainDataPtr->Description;
            }
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
            OtherTrainDataPtr->MaxRunningSpeed = MainTrainDataPtr->MaxRunningSpeed;
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
        }
    }
    if(ForwardEntryPtr->Command == "Sns-fsh")
    {
        if(ReverseEntryPtr->Command != "Fns-sh")
        {
            SecondPassMessage(GiveMessages,
                              "Error in timetable - unable to find a corresponding 'Fns-sh' event for the 'Sns-fsh' non-shuttle service whose headcode is " + MainHeadCode +
                              " formed from a shuttle service with headcode " + NonRepeatingHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1075);
            return(false);
        }
    }
    if(ForwardEntryPtr->Command == "Fns-sh")
    {
        if(ReverseEntryPtr->Command != "Sns-fsh")
        {
            SecondPassMessage(GiveMessages,
                              "Error in timetable - unable to find a corresponding 'Sns-fsh' event for the 'Fns-sh' shuttle service whose headcode is " + MainHeadCode +
                              " and forms a new non-shuttle service with headcode " + NonRepeatingHeadCode);
            TrainDataVector.clear();
            Utilities->CallLogPop(1076);
            return(false);
        }
        else
        {
            ForwardEntryPtr->NonRepeatingShuttleLinkEntryPtr = OtherTrainDataPtr;
            // links to the non-repeating non-shuttle linked service
            ReverseEntryPtr->LinkedTrainEntryPtr = MainTrainDataPtr;
            // needed for creating formatted timetable
            if(OtherTrainDataPtr->Description == "")
            {
                OtherTrainDataPtr->Description = MainTrainDataPtr->Description;
            }
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
            OtherTrainDataPtr->MaxRunningSpeed = MainTrainDataPtr->MaxRunningSpeed;
            // Probably redundant as this is continued from the earlier service when the changeover happens (also may not be set here yet if a service continuation)
        }
    }
    Utilities->CallLogPop(1077);
    return(true);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckNonRepeatingShuttleLinkTime(int Caller, TDateTime ForwardEventTime, TDateTime ReverseEventTime, int RepeatMinutes, int RepeatNumber)
// Forward train is the finish shuttle entry 'Fns-sh'.
// The Reverse (new non-repeating service) time must == Forward time + (RepeatMins * RepeatNumber) but allow 10 secs either side
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckNonRepeatingShuttleLinkTime," + AnsiString(double(ForwardEventTime))
                                 + "," + AnsiString(double(ReverseEventTime)) + "," + AnsiString(RepeatMinutes) + "," + AnsiString(RepeatNumber));
    int ForwardSecs = int(double(ForwardEventTime) * 86400);
    int ReverseSecs = int(double(ReverseEventTime) * 86400);
    int RepeatSecs = RepeatMinutes * RepeatNumber * 60;

    if((ReverseSecs > (ForwardSecs + RepeatSecs + 10)) || (ReverseSecs < (ForwardSecs + RepeatSecs - 10)))
    {
        Utilities->CallLogPop(1369);
        return(false);
    }
    else
    {
        Utilities->CallLogPop(1370);
        return(true);
    }
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckShuttleServiceIntegrity(int Caller, TTrainDataEntry *TDEntryPtr, bool GiveMessages)
// check that each shuttle start ends either in Fns or Fxx-sh (though a single service can't end in Fxx-sh), and that
// when the Fxx-sh is reached it references the original start and not another shuttle - not allowed to link two shuttles,
// don't ever need to and as designed would skip repeats.

// enter with TDEntry a shuttle start - Snt-sh or Sns-sh
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckShuttleServiceIntegrity," + AnsiString(TDEntryPtr->HeadCode));
    if(TDEntryPtr->ActionVector.back().FormatType != Repeat)
    {
        throw Exception("Error - last entry in " + TDEntryPtr->HeadCode + " service is not a repeat - should have already found this error");
    }
    TTrainDataEntry *ShuttleStartAddress = TDEntryPtr;
    AnsiString OriginalHeadCode = TDEntryPtr->HeadCode;
    AnsiString LastActionCommand = (TDEntryPtr->ActionVector.end() - 2)->Command;

    if((LastActionCommand != "Fns") && (LastActionCommand != "Fns-sh") && (LastActionCommand != "Frh-sh"))
    {
        SecondPassMessage(GiveMessages, "Error in timetable - last event in shuttle service " + TDEntryPtr->HeadCode + " is not 'Fns', 'Fns-sh' or 'Frh-sh'");
        TrainDataVector.clear();
        Utilities->CallLogPop(1091);
        return(false);
    }
    while(LastActionCommand == "Fns")
    {
        TDEntryPtr = (TDEntryPtr->ActionVector.end() - 2)->LinkedTrainEntryPtr;
        LastActionCommand = (TDEntryPtr->ActionVector.end() - 2)->Command;
        if((LastActionCommand != "Fns") && (LastActionCommand != "Fns-sh") && (LastActionCommand != "Frh-sh"))
        {
            SecondPassMessage(GiveMessages,
                              "Error in timetable - last event in a continuation shuttle service (i.e links back to a shuttle) whose headcode is " + TDEntryPtr->HeadCode +
                              " is not 'Fns', 'Fns-sh' or 'Frh-sh'");
            TrainDataVector.clear();
            Utilities->CallLogPop(1092);
            return(false);
        }
    }
    // exit the 'while' with LastActionCommand FSH-XX
    if((TDEntryPtr->ActionVector.end() - 2)->LinkedTrainEntryPtr != ShuttleStartAddress)
    {
        SecondPassMessage(GiveMessages, "Error in timetable - the event that ends service " + TDEntryPtr->HeadCode +
                          " is a shuttle finish, but it doesn't link back to the start of the original shuttle starting service " + OriginalHeadCode +
                          ".  The linking of two or more shuttles is not permitted.");
        TrainDataVector.clear();
        Utilities->CallLogPop(1093);
        return(false);
    }
    Utilities->CallLogPop(1094);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrainController::TimetableMessage(bool GiveMessages, AnsiString Message)
{
    if(!GiveMessages)
    {
        return;
    }
    // if(ServiceReference == "") ShowMessage(Message);
    if(!CheckHeadCodeValidity(12, false, ServiceReference))
    {
        ShowMessage(Message);
    }
    // changed from above at v2.3.0 as a meaningless value for 'Timetable invalid - unable to find a valid start time on its own line' (uses last entry text)
    // false means don't give messages within the function
    else
    {
        ShowMessage("Service " + ServiceReference + ": " + Message);
    }
}

// ---------------------------------------------------------------------------

void TTrainController::SecondPassMessage(bool GiveMessages, AnsiString Message)
{
    if(!GiveMessages)
    {
        return;
    }
    ShowMessage(Message);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::MinsToAnsiTime(int Input) //added at v2.15.0
{
    TrainController->LogEvent("MinsToAnsiTime");
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MinsToAnsiTime," + Input);
    int Mins = Input, Hrs = 0;
    while(Mins > 59)
    {
        Mins -= 60;
        Hrs++;
    }
    AnsiString AnsiMins = AnsiString(Mins);
    if(AnsiMins.Length() == 1)
    {
        AnsiMins = "0" + AnsiMins;
    }
    AnsiString AnsiHrs = AnsiString(Hrs);
    if(AnsiHrs.Length() == 1)
    {
        AnsiHrs = "0" + AnsiHrs;
    }
    Utilities->CallLogPop(2577);
    return(AnsiHrs + ':' + AnsiMins);
}

// $$$$$$$$$$$$$$$$$$$$$$$ End of Timetable Functions $$$$$$$$$$$$$$$$$$$$$$$
// ---------------------------------------------------------------------------

void TTrainController::LogActionError(int Caller, AnsiString HeadCode, AnsiString OtherHeadCode, TActionEventType ActionEventType, AnsiString LocationID)
// FailTrainEntry: 06:00:10 HELD: 2F43 can't enter railway, train obstructing entry position 57-N5
// FailCreateTrain: 06:00:10 HELD: 2F43 can't be created, train obstructing start position 57-N5
// FailCreateLockedRoute:  06:00:10 HELD: 2F43 can't be created on a locked route - start position 57-N5
// FailEnterLockedRoute:  06:00:10 HELD: 2F43 can't enter on a locked route - start position 57-N5
// FailCreatePoints: 06:00:10 HELD: 2F43 can't be created, points set to diverge at start position 57-N5
// FailUnexpectedExitRailway: 06:00:10 ERROR: 2F43 left railway unexpectedly at position 57-N5
// FailIncorrectExit: 06:00:10 ERROR: 2F43 left railway at an incorrect exit at position 57-N5
// FailSPAD: 06:00:10 ERROR: 2F43 PASSED SIGNAL AT DANGER at position 57-N5
// FailLockedRoute: 06:00:10 ERROR: SPAD Risk! Signals reset ahead of train, at position 57-N5
// FailLocTooShort: 06:00:10 ERROR: 2F43 failed to split - location too short at Essex Road
// FailSplitDueToOtherTrain: 06:00:10 HELD: 2F43 unable to split - another train is obstructing at Essex Road
// FailCrashed: 06:00:10: ERROR: 2F43 CRASHED INTO 3F43 at position 46-N7
// FailDerailed: 06:00:10: ERROR: 2F43 DERAILED at position 46-N7
// FailUnexpectedBuffers: 06:00:10: ERROR: 2F43 stopped at buffers unexpectedly at position 46-N7
// FailMissedArrival: 06:00:10: ERROR: 2F43 failed to stop at Essex Road;
// FailMissedSplit: 06:00:10: ERROR: 2F43 failed to split at Essex Road
// FailMissedJBO: 06:00:10: ERROR: 2F43 failed to be joined by join other train at Essex Road
// FailMissedJoinOther:  06:00:10: ERROR: 2F43 failed to join other train at Essex Road
// FailMissedTerminate:  06:00:10: ERROR: 2F43 failed to terminate at Essex Road
// FailMissedNewService:  06:00:10: ERROR: 2F43 failed to form new service at Essex Road
// FailMissedExitRailway:  06:00:10: ERROR: 2F43 failed to exit railway
// FailMissedChangeDirection:  06:00:10: ERROR: 2F43 failed to change direction at Essex Road
// FailMissedPass:  06:00:10: ERROR: 2F43 failed to pass Essex Road
// FailBuffersPreventingStart:  06:00:10: ERROR: 2F43 facing buffers and unable to start at Essex Road
// FailBufferCrash:  06:00:10: ERROR: 2F43 CRASHED INTO BUFFERS at 46-N7
// FailLevelCrossingCrash:  06:00:10: ERROR: 2F43 CRASHED INTO ROAD TRAFFIC AT A LEVEL CROSSING at 46-N7
// RouteForceCancelled:  06:00:10: ERROR: 2F43 forced a route cancellation by occupying it incorrectly at 46-N7
// WaitingForJBO:  06:00:10: WARNING: 2F43 waiting to join 3F43 at Essex Road
// WaitingForFJO:  06:00:10: WARNING: 2F43 waiting to be joined by 3F43 at Essex Road
// FailEntryRouteSetAgainst:   06:00:10: WARNING: 2F43 can't enter railway, route set against it at entry position 57-N5         //added at v2.9.1
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LogActionError," + HeadCode + "," + OtherHeadCode + "," +
                                 AnsiString(ActionEventType) + "," + LocationID);
    AnsiString BaseLog = "", Prefix = "", ErrorLog = "", WarningStr = "";

    TDateTime ActualTime = TrainController->TTClockTime; //moved from lower down at v2.9.1
    AnsiString TimeAndHeadCode = Utilities->Format96HHMMSS(ActualTime) + ": " + HeadCode; //added at v2.9.1 to give more info to user

    Prefix = " ERROR: ";
    if(ActionEventType == FailTrainEntry)
    {
        Prefix = " HELD: ";
        ErrorLog = " can't enter railway, train obstructing entry position ";
        WarningStr = " can't enter railway, train obstructing entry position ";
        Display->WarningLog(1, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailEntryRouteSetAgainst)  //added at v2.9.1
    {
        Prefix = " HELD: ";
        ErrorLog = " can't enter railway, route set against it at entry position ";
        WarningStr = " can't enter railway, route set against it at entry position ";
        Display->WarningLog(10, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailCreateTrain)
    {
        Prefix = " HELD: ";
        ErrorLog = " can't be created, train obstructing ";
        WarningStr = " can't be created, train obstructing ";
        Display->WarningLog(2, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailCreateLockedRoute)
    {
        Prefix = " HELD: ";
        ErrorLog = " can't be created on a locked route at ";
        WarningStr = " can't be created on a locked route at ";
        Display->WarningLog(4, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailEnterLockedRoute)
    {
        Prefix = " HELD: ";
        ErrorLog = " can't enter on a locked route at ";
        WarningStr = " can't enter on a locked route at ";
        Display->WarningLog(5, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailCreatePoints)
    {
        Prefix = " HELD: ";
        ErrorLog = " can't be created, diverging points at ";
        WarningStr = " can't be created, diverging points at ";
        Display->WarningLog(3, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailUnexpectedExitRailway)
    {
        ErrorLog = " left railway unexpectedly at ";
        UnexpectedExits++;
    }
    else if(ActionEventType == FailIncorrectExit)
    {
        ErrorLog = " left railway at an incorrect exit at ";
        IncorrectExits++;
    }
    else if(ActionEventType == FailLocTooShort)
    {
        ErrorLog = " failed to split - location too short at ";
        WarningStr = " failed to split, location too short at ";
        Display->WarningLog(6, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailSplitDueToOtherTrain)
    {
        Prefix = " HELD: ";
        ErrorLog = " unable to split - other train obstructing at ";
        WarningStr = " unable to split - other train obstructing at ";
        Display->WarningLog(7, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == FailUnexpectedBuffers)
    {
        ErrorLog = " stopped at buffers unexpectedly at position ";
    }
    else if(ActionEventType == FailMissedArrival)
    {
        ErrorLog = " failed to stop at ";
        MissedStops++;
    }
    else if(ActionEventType == FailMissedSplit)
    {
        ErrorLog = " failed to split at ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedJBO)
    {
        ErrorLog = " failed to be joined by other train at ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedJoinOther)
    {
        ErrorLog = " failed to join other train at ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedTerminate)
    {
        ErrorLog = " failed to terminate at ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedNewService)
    {
        ErrorLog = " failed to form new service at ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedExitRailway)
    {
        ErrorLog = " failed to exit railway ";
        OtherMissedEvents++;
    }
    else if(ActionEventType == FailMissedChangeDirection)
    {
        ErrorLog = " failed to change direction at ";
//        OtherMissedEvents++;   //dropped at v2.12.0 as cdt shouldn't count
    }
    else if(ActionEventType == FailMissedPass)
    {
        ErrorLog = " failed to pass ";
//        OtherMissedEvents++;  //dropped at v2.12.0 as missed pass shouldn't count
    }
    else if(ActionEventType == FailBuffersPreventingStart)
    {
        ErrorLog = " facing buffers and unable to start at ";
    }
    else if(ActionEventType == FailDerailed)
    {
        ErrorLog = " DERAILED at position ";
        Prefix = " DERAILMENT: ";
        Derailments++;
    }
    else if(ActionEventType == FailBufferCrash)
    {
        ErrorLog = " CRASHED INTO BUFFERS at ";
        Prefix = " CRASH: ";
        CrashedTrains++;
    }
    else if(ActionEventType == FailLevelCrossingCrash)
    {
        ErrorLog = " CRASHED INTO ROAD TRAFFIC AT A LEVEL CROSSING at ";
        Prefix = " CRASH: ";
        CrashedTrains++;
    }
    else if(ActionEventType == FailCrashed)
    {
        ErrorLog = " CRASHED INTO " + OtherHeadCode + " at position ";
        Prefix = " CRASH: ";
        CrashedTrains++;
        CrashedTrains++;
    }
    else if(ActionEventType == FailSPAD)
    {
        ErrorLog = " PASSED SIGNAL AT DANGER at position ";
        Prefix = " SPAD: ";
        SPADEvents++;
    }
    else if(ActionEventType == FailLockedRoute)
    {
        ErrorLog = "Signals reset ahead of train, route cancelled at position ";
        Prefix = " SPAD RISK: ";
        SPADRisks++;
    }
    else if(ActionEventType == RouteForceCancelled)
    {
        ErrorLog = " forced a route cancellation by occupying it incorrectly at ";
    }
    else if(ActionEventType == WaitingForJBO)
    {
        Prefix = " WARNING: ";
        ErrorLog = " waiting to join " + OtherHeadCode + " at ";
        WarningStr = " waiting to join " + OtherHeadCode + " at ";
        Display->WarningLog(8, TimeAndHeadCode + WarningStr + LocationID);
    }
    else if(ActionEventType == WaitingForFJO)
    {
        Prefix = " WARNING: ";
        ErrorLog = " waiting to be joined by " + OtherHeadCode + " at ";
        WarningStr = " waiting to be joined by " + OtherHeadCode + " at ";
        Display->WarningLog(9, TimeAndHeadCode + WarningStr + LocationID);
    }

    BaseLog = Utilities->Format96HHMMSS(ActualTime) + Prefix + HeadCode;
    PerfLogForm->PerformanceLog(4, BaseLog + ErrorLog + LocationID);
    Utilities->CallLogPop(1371);
}

// ---------------------------------------------------------------------------

void TTrainController::SaveTrainDataVectorToFile(int Caller)
{
/*    //for testing purposes
      TrainDataEntry
      AnsiString HeadCode, Description;//null on creation
      int StartSpeed, MaxRunningSpeed;//both kph
      int RepeatNumber;
      TActionVector ActionVector;
      TTrainOperatingDataVector TrainOperatingDataVector;//no of repeats + 1
      TTrainDataEntry() {StartSpeed=0; MaxRunningSpeed=0; RepeatNumber=0;}

      ActionVectorEntry
      TTimetableEntryType FormatType;
      TDateTime EventTime, ArrivalTime, DepartureTime;//zeroed on creation so change to -1 as a marker for 'not set'
      AnsiString LocationName, Command, OtherHeadCode;//null on creation
      TActionVectorEntry *OtherHeadCodeStartingEntryPtr;
      int RearStartOrRepeatMins, FrontStartOrRepeatDigits;
      int RepeatNumber;

      TrainOperatingData
      int Mass, MaxBrakeRate, PowerAtRail;//kg;m/s/s;W
      int TrainID;
      TRunningEntry RunningEntry;
      TDateTime StartTime;
      AnsiString HeadCode;
*/
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveTrainDataVectorToFile");
    std::ofstream OutFile("TrainData.csv");

    if(OutFile == 0)
    {
        ShowMessage("Output file TrainData.csv failed to open");
        Utilities->CallLogPop(1372);
        return;
    }
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        const TTrainDataEntry &TDEntry = TrainDataVector.at(x);
        OutFile << "HeadCode" << ',' << "Description" << ',' << "StartSpeed" << ',' << "MaxRunningSpeed" << ',' << "NumberOfTrains" << '\n' << '\n';

        OutFile << TDEntry.HeadCode.c_str() << ',' << TDEntry.Description.c_str()
        << ',' << TDEntry.StartSpeed << ',' << TDEntry.MaxRunningSpeed << ',' << TDEntry.NumberOfTrains << '\n' << '\n';

        OutFile << ',' << "FormatType" << ',' << "EventTime" << ',' << "ArrivalTime" << ',' << "DepartureTime" << ',' << "LocationName" << ',' << "Command" <<
        ',' << "OtherHeadCode" << ',' << "LinkedTrainEntryPtr" << ',' << "RearStartOrRepeatMins" << ',' << "FrontStartOrRepeatDigits" << ',' <<
        "RepeatNumber" << '\n' << '\n';
        for(unsigned int y = 0; y < TrainDataVector.at(x).ActionVector.size(); y++)
        {
            TActionVectorEntry &AVEntry = TrainDataVector.at(x).ActionVector.at(y);
            AnsiString TimetableEntryTypeStr;
            // NoFormat, TimeLoc, TimeTimeLoc, TimeCmd, StartNew, TimeCmdHeadCode, FinRemHere, FNSNonRepeatToShuttle, SNTShuttle, SNSShuttle, SNSNonRepeatFromShuttle, FSHNewService, Repeat
            switch(AVEntry.FormatType)
            {
            case 0:
            {
                TimetableEntryTypeStr = "NoFormat";
                break;
            }

            case 1:
            {
                TimetableEntryTypeStr = "TimeLoc";
                break;
            }

            case 2:
            {
                TimetableEntryTypeStr = "TimeTimeLoc";
                break;
            }

            case 3:
            {
                TimetableEntryTypeStr = "TimeCmd";
                break;
            }

            case 4:
            {
                TimetableEntryTypeStr = "StartNew";
                break;
            }

            case 5:
            {
                TimetableEntryTypeStr = "TimeCmdHeadCode";
                break;
            }

            case 6:
            {
                TimetableEntryTypeStr = "FinRemHere";
                break;
            }

            case 7:
            {
                TimetableEntryTypeStr = "FNSShuttle";
                break;
            }

            case 8:
            {
                TimetableEntryTypeStr = "SNTShuttle";
                break;
            }

            case 9:
            {
                TimetableEntryTypeStr = "SNSShuttle";
                break;
            }

            case 10:
            {
                TimetableEntryTypeStr = "SNSNonRepeatFromShuttle";
                break;
            }

            case 11:
            {
                TimetableEntryTypeStr = "FSHNewService";
                break;
            }

            case 12:
            {
                TimetableEntryTypeStr = "Repeat";
                break;
            }

            default:
            {
                TimetableEntryTypeStr = "Default";
                break;
            }
            }
            OutFile << ',' << TimetableEntryTypeStr.c_str() << ',' << Utilities->Format96HHMM(AVEntry.EventTime).c_str() << ',' << Utilities->Format96HHMM
                (AVEntry.ArrivalTime).c_str() << ',' << Utilities->Format96HHMM(AVEntry.DepartureTime).c_str() << ',' << AVEntry.LocationName.c_str()
            << ',' << AVEntry.Command.c_str() << ',' << AVEntry.OtherHeadCode.c_str()
            << ',' << AVEntry.LinkedTrainEntryPtr << ',' << AVEntry.RearStartOrRepeatMins << ',' << AVEntry.FrontStartOrRepeatDigits << ',' <<
            AVEntry.NumberOfRepeats << '\n';
        }
        OutFile << '\n';
        OutFile << ',' << ',' << "Mass" << ',' << "MaxBrakeRate" << ',' << "PowerAtRail" << ',' << "TrainID" << ',' << "RunningEntry" << '\n' << '\n';
        for(unsigned int y = 0; y < TrainDataVector.at(x).TrainOperatingDataVector.size(); y++)
        {
            TTrainOperatingData TOD = TrainDataVector.at(x).TrainOperatingDataVector.at(y);
            AnsiString RunningEntryStr;
            // NotStarted, Running, Exited
            switch(TOD.RunningEntry)
            {
            case 0:
            {
                RunningEntryStr = "NotStarted";
                break;
            }

            case 1:
            {
                RunningEntryStr = "Running";
                break;
            }

            case 2:
            {
                RunningEntryStr = "Exited";
                break;
            }
            }
            OutFile << ',' << ',' << TOD.TrainID << ',' << RunningEntryStr.c_str() << ',' << '\n';
        }
        OutFile << '\n';
    }
    OutFile.close();
    Utilities->CallLogPop(1373);
}

// ---------------------------------------------------------------------------

void TTrainController::StopTTClockMessage(int Caller, AnsiString Message)
// ShowMessage stops everything so this function used where a message is needed when may be in Operating mode.
// The timetable Restart and BaseTimes are reset so the timetable clock stops & restarts when 'OK' button pressed (in ClockTimer2 when StopTTClockFlag is false)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",StopTTClockMessage," + Message);
    StopTTClockFlag = true;    // so TTClock stopped during MasterClockTimer function
    RestartTime = TTClockTime;
    ShowMessage(Message);
    BaseTime = TDateTime::CurrentDateTime();
    StopTTClockFlag = false;
    Utilities->CallLogPop(1374);
}

// ---------------------------------------------------------------------------

void TTrainController::SaveSessionTrains(int Caller, std::ofstream &SessionFile)
// save *TrainDataEntryPtr & *ActionVectorEntryPtr as integer offsets
// from the start of the relevant vectors.  Can't save the pointer values
// as these will be different each time the vectors are created
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveSessionTrains");
    Utilities->SaveFileInt(SessionFile, TrainVector.size());
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        TrainVectorAt(55, x).SaveOneSessionTrain(0, SessionFile);
    }
    Utilities->CallLogPop(1375);
}

// ---------------------------------------------------------------------------

void TTrainController::LoadSessionTrains(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadSessionTrains");
    int NumberOfTrains = Utilities->LoadFileInt(SessionFile);
    TTrain *NewTrain = new TTrain(1, 0, 0, "", 0, 1, 0, 0, 0, (TTrainMode)0, 0, 0, 0, 0, 0); // have to have >0 for mass, else have divide
                                                                                             // by zero error in calculating AValue, use 1
    for(int x = 0; x < NumberOfTrains; x++)
    {
        *NewTrain = TTrain(2, 0, 0, "", 0, 1, 0, 0, 0, (TTrainMode)0, 0, 0, 0, 0, 0); // have to have >0 for mass, else have divide
        // by zero error in calculating AValue, use 1
        NewTrain->LoadOneSessionTrain(0, SessionFile);
        if((NewTrain->EntrySpeed < 1) && (NewTrain->PowerAtRail < 1))
        // added at v2.4.0. have to include as that value not stored in session file
        {
            NewTrain->StoppedWithoutPower = true;
        }
        TrainVector.push_back(*NewTrain);
        LastTrainLoaded = x;
    }
    delete NewTrain;
    Utilities->CallLogPop(1376);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckSessionTrains(int Caller, std::ifstream &InFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckSessionTrains");
    int NumberOfTrains;

    if(!Utilities->CheckAndReadFileInt(InFile, 0, 10000, NumberOfTrains))
    {
        Utilities->CallLogPop(1377);
        return(false);
    }
    for(int x = 0; x < NumberOfTrains; x++)
    {
        if(!(TTrain::CheckOneSessionTrain(InFile)))
        {
            Utilities->CallLogPop(1378);
            return(false);
        }
    }
    Utilities->CallLogPop(1379);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrainController::SaveSessionLockedRoutes(int Caller, std::ofstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveSessionLockedRoutes");
    Utilities->SaveFileInt(SessionFile, AllRoutes->LockedRouteVector.size());
    for(unsigned int x = 0; x < AllRoutes->LockedRouteVector.size(); x++)
    {
        Utilities->SaveFileInt(SessionFile, AllRoutes->LockedRouteVector.at(x).RouteNumber);
        Utilities->SaveFileInt(SessionFile, AllRoutes->LockedRouteVector.at(x).RearTrackVectorPosition);
        Utilities->SaveFileInt(SessionFile, AllRoutes->LockedRouteVector.at(x).LastTrackVectorPosition);
        Utilities->SaveFileInt(SessionFile, AllRoutes->LockedRouteVector.at(x).LastXLinkPos);
        Utilities->SaveFileDouble(SessionFile, double(AllRoutes->LockedRouteVector.at(x).LockStartTime));
    }
    Utilities->CallLogPop(1380);
}

// ---------------------------------------------------------------------------

void TTrainController::LoadSessionLockedRoutes(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadSessionLockedRoutes");
    TAllRoutes::TLockedRouteClass LockedRouteObject;
    int LockedRouteVectorSize = Utilities->LoadFileInt(SessionFile);

    for(int x = 0; x < LockedRouteVectorSize; x++)
    {
        LockedRouteObject.RouteNumber = Utilities->LoadFileInt(SessionFile);
        LockedRouteObject.RearTrackVectorPosition = Utilities->LoadFileInt(SessionFile);
        LockedRouteObject.LastTrackVectorPosition = Utilities->LoadFileInt(SessionFile);
        LockedRouteObject.LastXLinkPos = Utilities->LoadFileInt(SessionFile);
        double LockStartTimeDouble = Utilities->LoadFileDouble(SessionFile);
        LockedRouteObject.LockStartTime = TDateTime(LockStartTimeDouble);
        AllRoutes->LockedRouteVector.push_back(LockedRouteObject);
    }
    Utilities->CallLogPop(1381);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckSessionLockedRoutes(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckSessionLockedRoutes");
    int LockedRouteVectorSize;

    if(!Utilities->CheckAndReadFileInt(SessionFile, 0, 10000, LockedRouteVectorSize))
    {
        Utilities->CallLogPop(1382);
        return(false);
    }
    for(int x = 0; x < LockedRouteVectorSize; x++)
    {
        if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
        {
            Utilities->CallLogPop(1383);
            return(false);
        }
        if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
        {
            Utilities->CallLogPop(1384);
            return(false);
        }
        if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
        {
            Utilities->CallLogPop(1385);
            return(false);
        }
        if(!Utilities->CheckFileInt(SessionFile, 0, 3))
        {
            Utilities->CallLogPop(1386);
            return(false);
        }
        if(!Utilities->CheckFileDouble(SessionFile))
        {
            Utilities->CallLogPop(1387);
            return(false);
        }
    }
    Utilities->CallLogPop(1388);
    return(true);
}

// ---------------------------------------------------------------------------

void TTrainController::SaveSessionContinuationAutoSigEntries(int Caller, std::ofstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveSessionContinuationAutoSigEntries");
    Utilities->SaveFileInt(SessionFile, ContinuationAutoSigVector.size());
    for(unsigned int x = 0; x < ContinuationAutoSigVector.size(); x++)
    {
        Utilities->SaveFileInt(SessionFile, ContinuationAutoSigVector.at(x).RouteNumber);
        Utilities->SaveFileInt(SessionFile, ContinuationAutoSigVector.at(x).AccessNumber);
        Utilities->SaveFileDouble(SessionFile, ContinuationAutoSigVector.at(x).FirstDelay);
        Utilities->SaveFileDouble(SessionFile, ContinuationAutoSigVector.at(x).SecondDelay);
        Utilities->SaveFileDouble(SessionFile, ContinuationAutoSigVector.at(x).ThirdDelay);
        Utilities->SaveFileDouble(SessionFile, double(ContinuationAutoSigVector.at(x).PassoutTime));
    }
    Utilities->CallLogPop(1389);
}

// ---------------------------------------------------------------------------

void TTrainController::LoadSessionContinuationAutoSigEntries(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadSessionContinuationAutoSigEntries");
    TContinuationAutoSigEntry ContinuationAutoSigObject;
    int ContinuationAutoSigVectorSize = Utilities->LoadFileInt(SessionFile);

    for(int x = 0; x < ContinuationAutoSigVectorSize; x++)
    {
        ContinuationAutoSigObject.RouteNumber = Utilities->LoadFileInt(SessionFile);
        ContinuationAutoSigObject.AccessNumber = Utilities->LoadFileInt(SessionFile);
        ContinuationAutoSigObject.FirstDelay = Utilities->LoadFileDouble(SessionFile);
        ContinuationAutoSigObject.SecondDelay = Utilities->LoadFileDouble(SessionFile);
        ContinuationAutoSigObject.ThirdDelay = Utilities->LoadFileDouble(SessionFile);
        double PassoutTimeDouble = Utilities->LoadFileDouble(SessionFile);
        ContinuationAutoSigObject.PassoutTime = TDateTime(PassoutTimeDouble);
        ContinuationAutoSigVector.push_back(ContinuationAutoSigObject);
    }
    Utilities->CallLogPop(1390);
}

// ---------------------------------------------------------------------------

bool TTrainController::CheckSessionContinuationAutoSigEntries(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckSessionContinuationAutoSigEntries");
    int ContinuationAutoSigVectorSize;

    if(!Utilities->CheckAndReadFileInt(SessionFile, 0, 10000, ContinuationAutoSigVectorSize))
    {
        Utilities->CallLogPop(1391);
        return(false);
    }
    for(int x = 0; x < ContinuationAutoSigVectorSize; x++)
    {
        if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
        {
            Utilities->CallLogPop(1392);
            return(false);
        }
        if(!Utilities->CheckFileInt(SessionFile, 0, 3))
        {
            Utilities->CallLogPop(1393);
            return(false);
        }
        if(!Utilities->CheckFileDouble(SessionFile))
        {
            Utilities->CallLogPop(1405);
            return(false);
        }
        if(!Utilities->CheckFileDouble(SessionFile))
        {
            Utilities->CallLogPop(1406);
            return(false);
        }
        if(!Utilities->CheckFileDouble(SessionFile))
        {
            Utilities->CallLogPop(1407);
            return(false);
        }
        if(!Utilities->CheckFileDouble(SessionFile))
        {
            Utilities->CallLogPop(1394);
            return(false);
        }
    }
    Utilities->CallLogPop(1395);
    return(true);
}

// ---------------------------------------------------------------------------

/*
  class TContinuationTrainExpectationEntry  //for expected trains at continuation entries
  {
  public:
  AnsiString Description; ///< service description
  AnsiString HeadCode; ///< service headcode
  int RepeatNumber; ///< service RepeatNumber
  int IncrementalMinutes; ///< Repeat separation in minutes
  int IncrementalDigits; ///< Repeat headcode separation
  int VectorPosition; ///< TrackVectorPosition for the continuation element
  TTrainDataEntry *TrainDataEntryPtr; ///< points to the service entry in the timetable's TrainDataVector
  };


  typedef std::multimap<TDateTime,TContinuationTrainExpectationEntry> TContinuationTrainExpectationMultiMap;
  typedef pair<TDateTime, TContinuationTrainExpectationEntry> TContinuationTrainExpectationMultiMapPair;
*/

void TTrainController::BuildContinuationTrainExpectationMultiMap(int Caller)
// build this into timetable load so session loading can use it too
// being a multimap it automatically sorts in ascending EventTime order
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",BuildContinuationTrainExpectationMultiMap");
    ContinuationTrainExpectationMultiMap.clear();
    // need to clear as this called twice when load a session
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        TTrainDataEntry & TDEntry = TrainDataVector.at(x);
        const TActionVectorEntry &AVFirstEntry = TDEntry.ActionVector.at(0);
        const TActionVectorEntry &AVLastEntry = TDEntry.ActionVector.at(TDEntry.ActionVector.size() - 1);

        if(AVFirstEntry.Command == "Snt")
        // new train (no need to include Snt-sh since they can't start at a continuation)
        {
            TContinuationTrainExpectationMultiMapPair CTEMMP;
            if(Track->TrackElementAt(665, AVFirstEntry.RearStartOrRepeatMins).TrackType == Continuation)
            {
                TContinuationTrainExpectationEntry CTEEntry;
                CTEEntry.VectorPosition = AVFirstEntry.RearStartOrRepeatMins;
                // retains this value for all repeats
                CTEEntry.RepeatNumber = 0; // for first entry
                CTEEntry.TrainDataEntryPtr = &TDEntry;
                // retains this value for all repeats
                CTEEntry.HeadCode = TDEntry.HeadCode;
                CTEEntry.Description = TDEntry.Description;
                CTEEntry.IncrementalMinutes = 0;
                CTEEntry.IncrementalDigits = 0;
                if(AVLastEntry.FormatType == Repeat)
                {
                    CTEEntry.IncrementalMinutes = AVLastEntry.RearStartOrRepeatMins;
                    // retains this value or 0 for all repeats
                    CTEEntry.IncrementalDigits = AVLastEntry.FrontStartOrRepeatDigits;
                    // retains this value or 0 for all repeats
                }
                CTEMMP.first = AVFirstEntry.EventTime;
                CTEMMP.second = CTEEntry;
                ContinuationTrainExpectationMultiMap.insert(CTEMMP);
                // base entry
                if(TDEntry.NumberOfTrains > 1)
                {
                    if(AVLastEntry.FormatType != Repeat)
                    {
                        throw Exception("Error, Last ActionVectorEntry not a repeat in BuildContinuationTrainExpectationMultiMap");
                    }
                    for(int y = 1; y < TDEntry.NumberOfTrains; y++)
                    {
                        CTEEntry.RepeatNumber = y;
                        CTEEntry.HeadCode = GetRepeatHeadCode(23, TDEntry.HeadCode, y, AVLastEntry.FrontStartOrRepeatDigits);
                        // CTEEntry.VectorPosition stays same
                        CTEMMP.first = GetRepeatTime(3, AVFirstEntry.EventTime, y, AVLastEntry.RearStartOrRepeatMins);
                        CTEMMP.second = CTEEntry;
                        ContinuationTrainExpectationMultiMap.insert(CTEMMP);
                    }
                }
            }
        }
    }
    Utilities->CallLogPop(1396);
}

// ---------------------------------------------------------------------------

void TTrainController::PlotAllTrainsInZoomOutMode(int Caller, bool Flash)
{
    // called when WarningFlashCount == 0 or when press zoomout button
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",PlotTrainsInZoomOutMode");
    if(!Display->ZoomOutFlag)
    {
        Utilities->CallLogPop(1156);
        return;
    }
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        // plot blanks & track for all train, even if to be overplotted, since when flashing need to overplot all anyway
        // if OldPlotElement[x] == -1 then ignore (not plotted)
        TrainVectorAt(56, x).UnplotTrainInZoomOutMode(1);
        TrainVectorAt(57, x).PlotTrainInZoomOutMode(0, Flash);
    }
    Display->Update();
    // need to keep this since Update() not called for PlotSmallOutput as too slow
    Utilities->CallLogPop(742);
}

// ---------------------------------------------------------------------------

TTrain &TTrainController::TrainVectorAt(int Caller, int VecPos)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrainVectorAt," + AnsiString(VecPos));
    if((VecPos < 0) || (VecPos >= (int)TrainVector.size()))
    {
        throw Exception("Out of Range Error, vector size: " + AnsiString(TrainVector.size()) + ", VecPos: " + AnsiString(VecPos) + " in TrainVectorAt");
    }
    Utilities->CallLogPop(740);
    return(TrainVector.at(VecPos));
}

// ---------------------------------------------------------------------------

void TTrainController::CreateFormattedTimetable(int Caller, AnsiString RailwayTitle, AnsiString TimetableTitle, AnsiString CurDir)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CreateFormattedTimetable");
    AnsiString RetStr = "", PartStr = "";


/*
       Have description & mass etc for train at top - header, then array of actions

    class TActionVectorEntry
    {
    public:
        AnsiString LocationName, Command, OtherHeadCode, NonRepeatingShuttleLinkHeadCode;
    ///< string values for timetabled event entries, null on creation
        bool SignallerControl;
    ///< indicates a train that is defined by the timetable as under signaller control
        bool Warning;
    ///< if set triggers an alert in the warning panel when the action is reached
        int NumberOfRepeats;
    ///< the number of repeating services
        int RearStartOrRepeatMins, FrontStartOrRepeatDigits;
    ///< dual-purpose variables used for the TrackVectorPositions of the rear and front train starting elements (for Snt) or for repeat minute & digit values in repeat entries
        TDateTime EventTime, ArrivalTime, DepartureTime;
    ///< relevant times at which the action is timetabled, zeroed on creation so change to -1 as a marker for 'not set'
        TNumList ExitList;
    ///< the list of valid train exit TrackVector positions for 'Fer' entries (empty to begin with)
        TTimetableFormatType FormatType;
    ///< defines the timetable action type
        TTimetableLocationType LocationType;
    ///< indicates where the train is when the relevant action occurs
        TTimetableSequenceType SequenceType;
    ///< indicates where in the sequence of codes the action lies
        TTimetableShuttleLinkType ShuttleLinkType;
    ///< indicates whether or not the action relates to a shuttle service link
        TTrainDataEntry *LinkedTrainEntryPtr;
    ///< link pointer for use between fsp/rsp & Sfs; Fjo & jbo; Fns & Sns; & all shuttle to shuttle links
        TTrainDataEntry *NonRepeatingShuttleLinkEntryPtr;
    ///< pointer used by shuttles for the non-shuttle train links, in & out, the corresponding non-shuttle linked trains use LinkedTrainEntryPtr

       typedef std::vector<TActionVectorEntry> TActionVector;//contains all actions for a single train

       enum TRunningEntry {NotStarted, Running, Exited};//contains status info for each train

    class TTrainOperatingData
    {
    public:
        int TrainID;
        TActionEventType EventReported;
        TRunningEntry RunningEntry;

       //inline function
       TTrainOperatingData() {TrainID = -1; EventReported= NoEvent; RunningEntry=NotStarted;}//ID -1 = marker for not running
       };

       typedef std::vector<TTrainOperatingData> TTrainOperatingDataVector;

    class TTrainDataEntry
    {
    public:
        AnsiString HeadCode, ServiceReference, Description;
    ///< headcode is the first train's headcode, rest are calculated from repeat information; ServiceReference is the full (up to 8 characters) reference from the timetable (added at V0.6b)
        double MaxBrakeRate;
    ///< in metres/sec/sec
        double MaxRunningSpeed;
    ///< in km/h
        double PowerAtRail;
    ///< in Watts (taken as 80% of the train's Gross Power, i.e. that entered by the user)
        int Mass;
    ///< in kg
        int NumberOfTrains;
    ///< number of repeats + 1
        int SignallerSpeed;
    ///< in km/h for use when under signaller control
        int StartSpeed;
    ///< in km/h
        TActionVector ActionVector;
    ///< all the actions for the train
        TTrainOperatingDataVector TrainOperatingDataVector;
    ///< operating information for the train including all its repeats

       //inline function
       TTrainDataEntry() {StartSpeed=0; MaxRunningSpeed=0; NumberOfTrains=0;}
       };

       typedef std::vector<TTrainDataEntry> TTrainDataVector;//object is a member of TTrainController & contains the whole timetable

       //formatted timetable types
       class TOneTrainFormattedEntry
       {
       AnsiString Action;//includes location if relevanr
       AnsiString Time;
       };

       typedef std::vector<TOneTrainFormattedEntry> TOneFormattedTrainVector;

       class TOneCompleteFormattedTrain//headcode + list of actions
       {
       public:
       AnsiString HeadCode;
       TOneFormattedTrainVector OneFormattedTrainVector;
       };

       typedef std::vector<TOneCompleteFormattedTrain> TOneCompleteFormattedTrainVector;//list af all repeats

       class TTrainFormattedInformation//contains all information for a single TT entry (including repeats)
       {
       public:
       AnsiString Header;//description, mass, power, brake rate etc
       int NumberOfTrains;// number of repeats + 1
       TOneCompleteFormattedTrainVector OneCompleteFormattedTrainVector;//list af all repeats
       };


       typedef std::vector<TTrainFormattedInformation> TAllFormattedTrains;//all timetable in formatted form
       //end of formatted timetable types

*/

    AnsiString TTFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");

    // format "16/06/2009 20:55:17"
    // avoid characters in filename:=   / \ : * ? " < > |
    TTFileName = CurDir + "\\Formatted timetables\\Timetable " + TTFileName + "; " + RailwayTitle + "; " + TimetableTitle + ".csv";

    AnsiString ShortTTName = "";

    for(int x = TTFileName.Length(); x > 0; x--)
    {
        if(TTFileName[x] == '\\')
        {
            ShortTTName = TTFileName.SubString(x + 1, TTFileName.Length() - x - 4);
            break;
        }
    }

    ShowMessage("Creates two timetables named " + ShortTTName +
                " in the 'Formatted timetables' folder, one in service order in '.csv' format, and one in chronological order in '.txt' format");

    Screen->Cursor = TCursor(-11); // Hourglass

    AnsiString FormatNoDPStr = "#######0";
    AnsiString TableTitle = "", TimetableTimeStr = "", MassStr = "", PowerStr = "", BrakeStr = "", MaxSpeedStr = "", FirstHeadCode = "", Header = "";

    TimetableTimeStr = Utilities->Format96HHMM(TrainController->TimetableStartTime);
    TableTitle = "Railway: " + RailwayTitle + "; Timetable: " + TimetableTitle + ";  Start time: " + TimetableTimeStr;
    TAllFormattedTrains *AllTTTrains = new TAllFormattedTrains;

    // all timetable in formatted form
    //create the AllTTTrains vector
    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        MassStr = "", PowerStr = "", BrakeStr = "", MaxSpeedStr = "";
        const TTrainDataEntry &TrainDataEntry = TrainDataVector.at(x);
        if(TrainDataEntry.Mass > 0)
        {
            MassStr = "; Mass " + AnsiString::FormatFloat(FormatNoDPStr, ((double)TrainDataEntry.Mass) / 1000) + "Te; ";
        }
        if(TrainDataEntry.PowerAtRail > 0)
        {
            PowerStr = "Power " + AnsiString::FormatFloat(FormatNoDPStr, TrainDataEntry.PowerAtRail / 1000 / 0.8) + "kW; ";
        }
        if(TrainDataEntry.MaxBrakeRate > 0)
        {
            BrakeStr = "Brake force " + AnsiString::FormatFloat(FormatNoDPStr, (TrainDataEntry.MaxBrakeRate * TrainDataEntry.Mass / 9810)) + "Te; ";
        }
        if(TrainDataEntry.MaxRunningSpeed > 0)
        {
            MaxSpeedStr = "Maximum speed " + AnsiString::FormatFloat(FormatNoDPStr, TrainDataEntry.MaxRunningSpeed) + " km/h";
        }
        FirstHeadCode = TrainDataEntry.HeadCode;
        int IncDigits = 0, IncMinutes = 0;
        const TActionVector &ActionVector = TrainDataEntry.ActionVector;
        if(!ActionVector.empty())
        {
            if(ActionVector.at(ActionVector.size() - 1).FormatType == Repeat)
            {
                IncDigits = ActionVector.at(ActionVector.size() - 1).FrontStartOrRepeatDigits;
                IncMinutes = ActionVector.at(ActionVector.size() - 1).RearStartOrRepeatMins;
            }
        }
        TTrainFormattedInformation OneTTLine;
        // contains all information for a single TT entry (including repeats)
        for(int y = 0; y < TrainDataEntry.NumberOfTrains; y++)
        {
            OneTTLine.Header = "";
            if((TrainDataEntry.Description != "") && (MassStr != ""))
            {
                OneTTLine.Header = TrainDataEntry.Description + MassStr + PowerStr + BrakeStr + MaxSpeedStr;
            }
            else if(TrainDataEntry.Description != "")
            {
                OneTTLine.Header = TrainDataEntry.Description;
            }
            OneTTLine.NumberOfTrains = TrainDataEntry.NumberOfTrains;
            TOneCompleteFormattedTrain OneTTTrain; // headcode + list of actions
            for(unsigned int z = 0; z < ActionVector.size(); z++)
            {
                TOneTrainFormattedEntry OneTTEntry;
                OneTTTrain.HeadCode = GetRepeatHeadCode(24, FirstHeadCode, y, IncDigits);
                TActionVectorEntry ActionVectorEntry = ActionVector.at(z);
                AnsiString PartStr = "", TimeStr = "";
/*
                  enum TTimetableFormatType {NoFormat, TimeLoc, TimeTimeLoc, TimeCmd, StartNew, TimeCmdHeadCode, FinRemHere,
                  FNSNonRepeatToShuttle, SNTShuttle, SNSShuttle, SNSNonRepeatFromShuttle, FSHNewService, Repeat, PassTime,
                  ExitRailway};
                  enum TTimetableSequenceType {NoSequence, StartSequence, FinishSequence, IntermediateSequence, SequTypeForRepeatEntry};
                  enum TTimetableLocationType {NoLocation, AtLocation, EnRoute, LocTypeForRepeatEntry};
                  enum TTimetableShuttleLinkType {NoShuttleLink, NotAShuttleLink, ShuttleLink, ShuttleLinkTypeForRepeatEntry};
*/
                if(ActionVectorEntry.SequenceType == StartSequence)
                {
                    if(ActionVectorEntry.FormatType == StartNew)
                    {
                        if(ActionVectorEntry.LocationName != "")
                        {
                            if(Track->TrackElementAt(742, ActionVectorEntry.RearStartOrRepeatMins).TrackType == Continuation)
                            {
                                PartStr = "Enters at " + ActionVectorEntry.LocationName;
                            }
                            else
                            {
                                PartStr = "Created at " + ActionVectorEntry.LocationName;
                            }
                        }
                        else // may be a named continuation or other element, and if so report that
                        {
                            AnsiString LocName = Track->TrackElementAt(739, ActionVectorEntry.RearStartOrRepeatMins).ActiveTrackElementName;
                            if(Track->TrackElementAt(740, ActionVectorEntry.RearStartOrRepeatMins).TrackType == Continuation)
                            {
                                if(LocName != "")
                                {
                                    PartStr = "Enters at " + LocName;
                                }
                                else // use rear position if it's a continuation
                                {
                                    PartStr = "Enters at " + Track->TrackElementAt(737, ActionVectorEntry.RearStartOrRepeatMins).ElementID;
                                }
                            }
                            else // not a continuation
                            {
                                if(LocName != "")
                                // if not a continuation then LocName should be same as ActionVectorEntry.LocationName
                                // but include anyway
                                {
                                    PartStr = "Created at " + LocName;
                                }
                                else // use rear position again
                                {
                                    PartStr = "Created at " + Track->TrackElementAt(741, ActionVectorEntry.RearStartOrRepeatMins).ElementID;
                                }
                            }
                        }
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(20, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.FormatType == SNTShuttle)
                    {
                        if(y == 0) // first train
                        {
                            PartStr = "Enters at " + ActionVectorEntry.LocationName;
                            TimeStr = Utilities->Format96HHMM(GetRepeatTime(21, ActionVectorEntry.EventTime, y, IncMinutes));
                        }
                        else
                        {
                            PartStr = "Repeat shuttle service at " + ActionVectorEntry.LocationName + " from ";
                            TimeStr = GetRepeatHeadCode(45, ActionVectorEntry.OtherHeadCode, y - 1, IncDigits) + " at " +
                                Utilities->Format96HHMM(GetRepeatTime(26, ActionVectorEntry.EventTime, y, IncMinutes));
                        } // y-1 for headcode above since it is the last repeat value that the train is from

                    }
                    else if(ActionVectorEntry.Command == "Sfs")
                    {
                        PartStr = "New service at " + ActionVectorEntry.LocationName + " split from";
                        TimeStr = GetRepeatHeadCode(33, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(24, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "Sns")
                    {
                        PartStr = "New service at " + ActionVectorEntry.LocationName + " from";
                        TimeStr = GetRepeatHeadCode(34, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(25, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.FormatType == SNSShuttle)
                    {
                        if(y == 0) // first entry from shuttle
                        {
                            PartStr = "New service at " + ActionVectorEntry.LocationName + " from";
                            TimeStr = ActionVectorEntry.NonRepeatingShuttleLinkHeadCode + " at " +
                                Utilities->Format96HHMM(GetRepeatTime(27, ActionVectorEntry.EventTime, y, IncMinutes));
                        }
                        else
                        {
                            PartStr = "Repeat shuttle service at " + ActionVectorEntry.LocationName + " from ";
                            TimeStr = GetRepeatHeadCode(35, ActionVectorEntry.OtherHeadCode, y - 1, IncDigits) + " at " +
                                Utilities->Format96HHMM(GetRepeatTime(22, ActionVectorEntry.EventTime, y, IncMinutes));
                        } // y-1 for headcode above since it is the last repeat value that the train is from

                    }
                    else if(ActionVectorEntry.FormatType == SNSNonRepeatFromShuttle)
                    {
                        PartStr = "New service at " + ActionVectorEntry.LocationName + " from";
                        // need repeat for the non-repeating headcode as it's the last train of the repeating shuttle
                        TTrainDataEntry *TDE = ActionVectorEntry.LinkedTrainEntryPtr;
                        AnsiString FirstHeadCode = TDE->HeadCode;
                        int LastRepeatNumber = TDE->NumberOfTrains - 1;
                        // a shuttle has to have at least 1 repeat
                        int IncrementalDigits = TDE->ActionVector.at(TDE->ActionVector.size() - 1).FrontStartOrRepeatDigits;
                        TimeStr = GetRepeatHeadCode(36, FirstHeadCode, LastRepeatNumber, IncrementalDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(23, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                }
                else if(ActionVectorEntry.SequenceType == IntermediateSequence)
                {
                    if(ActionVectorEntry.FormatType == TimeTimeLoc)
                    {
                        // here need 2 entries if times different so push the first right away & the second later
                        // if times same just give the arrival entry
                        if(ActionVectorEntry.DepartureTime != ActionVectorEntry.ArrivalTime)
                        {
                            PartStr = "Arrives at " + ActionVectorEntry.LocationName;
                            TimeStr = Utilities->Format96HHMM(GetRepeatTime(4, ActionVectorEntry.ArrivalTime, y, IncMinutes));
                            OneTTEntry.Action = PartStr;
                            OneTTEntry.Time = TimeStr;
                            OneTTTrain.OneFormattedTrainVector.push_back(OneTTEntry);
                            PartStr = "Departs from " + ActionVectorEntry.LocationName;
                            TimeStr = Utilities->Format96HHMM(GetRepeatTime(5, ActionVectorEntry.DepartureTime, y, IncMinutes));
                        }
                        else
                        {
                            PartStr = "Arrives & departs " + ActionVectorEntry.LocationName;
                            TimeStr = Utilities->Format96HHMM(GetRepeatTime(29, ActionVectorEntry.ArrivalTime, y, IncMinutes));
                        }
                    }
                    else if((ActionVectorEntry.FormatType == TimeLoc) && (ActionVectorEntry.ArrivalTime != TDateTime(-1)))
                    {
                        PartStr = "Arrives at " + ActionVectorEntry.LocationName;
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(6, ActionVectorEntry.ArrivalTime, y, IncMinutes));
                    }
                    else if((ActionVectorEntry.FormatType == TimeLoc) && (ActionVectorEntry.ArrivalTime == TDateTime(-1)))
                    {
                        PartStr = "Departs from " + ActionVectorEntry.LocationName;
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(7, ActionVectorEntry.DepartureTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.FormatType == PassTime)
                    {
                        PartStr = "Passes " + ActionVectorEntry.LocationName;
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(8, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "jbo")
                    {
                        PartStr = "Joined at " + ActionVectorEntry.LocationName + " by";
                        TimeStr = GetRepeatHeadCode(37, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(9, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "fsp")
                    {
                        PartStr = "Splits from front at " + ActionVectorEntry.LocationName + " to form";
                        TimeStr = GetRepeatHeadCode(38, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(10, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "rsp")
                    {
                        PartStr = "Splits from rear at " + ActionVectorEntry.LocationName + " to form";
                        TimeStr = GetRepeatHeadCode(39, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(11, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "cdt")
                    {
                        PartStr = "Changes direction at " + ActionVectorEntry.LocationName;
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(12, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                }
                else if(ActionVectorEntry.SequenceType == FinishSequence)
                {
                    if(ActionVectorEntry.Command == "Fns")
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " forms new service";
                        TimeStr = GetRepeatHeadCode(40, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(13, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "F-nshs")
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " forms new service";
                        TimeStr = ActionVectorEntry.NonRepeatingShuttleLinkHeadCode + " at " + Utilities->Format96HHMM
                                (GetRepeatTime(17, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if((ActionVectorEntry.Command == "Fns-sh") && (y < (TrainDataEntry.NumberOfTrains - 1)))
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " forms new service ";
                        TimeStr = GetRepeatHeadCode(41, ActionVectorEntry.OtherHeadCode, y + 1, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(14, ActionVectorEntry.EventTime, y, IncMinutes));
                        // y+1 because it's the NEXT service repeat number that is relevant
                    }
                    else if((ActionVectorEntry.Command == "Fns-sh") && (y >= (TrainDataEntry.NumberOfTrains - 1)))
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " forms new service";
                        TimeStr = ActionVectorEntry.NonRepeatingShuttleLinkHeadCode + " at " + Utilities->Format96HHMM
                                (GetRepeatTime(15, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if((ActionVectorEntry.Command == "Frh-sh") && (y < (TrainDataEntry.NumberOfTrains - 1)))
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " forms new service";
                        TimeStr = GetRepeatHeadCode(43, ActionVectorEntry.OtherHeadCode, y + 1, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(16, ActionVectorEntry.EventTime, y, IncMinutes));
                        // y+1 because it's the NEXT service repeat number that is relevant
                    }
                    else if((ActionVectorEntry.Command == "Frh-sh") && (y >= (TrainDataEntry.NumberOfTrains - 1)))
                    {
                        PartStr = "Terminates shuttle service at " + ActionVectorEntry.LocationName;
                        // only used in chronological tt
                        TimeStr = "End at " + Utilities->Format96HHMM(GetRepeatTime(28, ActionVectorEntry.EventTime, y, IncMinutes));
                        // the "End at " is stripped out of the chronological tt but displayed in the traditional tt
                    }
                    else if(ActionVectorEntry.Command == "Frh")
                    {
                        PartStr = "Terminates at " + ActionVectorEntry.LocationName;
                        // need here to examine the time of the preceding entry, may be ArrivalTime if TimeLoc, or EventTime otherwise
                        if(z > 0)
                        // should be for finish entry but include check for safety
                        {
                            if(ActionVector.at(z - 1).EventTime != TDateTime(-1))
                            {
                                TimeStr = Utilities->Format96HHMM(GetRepeatTime(30, ActionVector.at(z - 1).EventTime, y, IncMinutes));
                            }
                            else if(ActionVector.at(z - 1).ArrivalTime != TDateTime(-1))
                            {
                                TimeStr = Utilities->Format96HHMM(GetRepeatTime(31, ActionVector.at(z - 1).ArrivalTime, y, IncMinutes));
                            }
                            else
                            {
                                TimeStr = "     "; // shouldn't ever get here
                            }
                        }
                    }
                    else if(ActionVectorEntry.Command == "Fer")
                    {
                        AnsiString AllowedExits;
                        PartStr = "Exits railway" + GetExitLocationAndAt(0, ActionVectorEntry.ExitList, AllowedExits) + AllowedExits;
                        TimeStr = Utilities->Format96HHMM(GetRepeatTime(18, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                    else if(ActionVectorEntry.Command == "Fjo")
                    {
                        PartStr = "At " + ActionVectorEntry.LocationName + " joins";
                        TimeStr = GetRepeatHeadCode(44, ActionVectorEntry.OtherHeadCode, y, IncDigits) + " at " +
                            Utilities->Format96HHMM(GetRepeatTime(19, ActionVectorEntry.EventTime, y, IncMinutes));
                    }
                }
                else if(ActionVectorEntry.SequenceType == SequTypeForRepeatEntry)
                {
                    continue; // no entry needed for a repeat
                }
                OneTTEntry.Action = PartStr;
                OneTTEntry.Time = TimeStr;
                OneTTTrain.OneFormattedTrainVector.push_back(OneTTEntry);
                // one per action
            }
            OneTTLine.OneCompleteFormattedTrainVector.push_back(OneTTTrain);
            // one per repeat
        }
        AllTTTrains->push_back(OneTTLine); // one per repeating train
    }
    // AllTTTrains vector now complete

    std::ofstream TTFile(TTFileName.c_str()); //formatted timetable

    if(TTFile == 0)
    {
        StopTTClockMessage(64, "Formatted timetable file failed to open - can't be created");
        delete AllTTTrains;
        Utilities->CallLogPop(1567);
        return;
    }
/* formatted timetable types
      class TOneTrainFormattedEntry
      {
      AnsiString Action;//includes location if relevant
      AnsiString Time;
      };

      typedef std::vector<TOneTrainFormattedEntry> TOneFormattedTrainVector;

      class TOneCompleteFormattedTrain//headcode + list of actions
      {
      public:
      AnsiString HeadCode;
      TOneFormattedTrainVector OneFormattedTrainVector;
      };

      typedef std::vector<TOneCompleteFormattedTrain> TOneCompleteFormattedTrainVector;//list af all repeats

      class TTrainFormattedInformation//contains all information for a single TT entry (including repeats)
      {
      public:
      AnsiString Header;//description, mass, power, brake rate etc
      int NumberOfTrains;// number of repeats + 1
      TOneCompleteFormattedTrainVector OneCompleteFormattedTrainVector;//list af all repeats
      };

      typedef std::vector<TTrainFormattedInformation> TAllFormattedTrains;//all timetable in formatted form
      //end of formatted timetable types
*/

    // new layout using multiple rows
    TTFile << TableTitle.c_str() << '\n' << '\n';
    for(unsigned int x = 0; x < AllTTTrains->size(); x++)
    {
        TTFile << AllTTTrains->at(x).Header.c_str();
        TTFile << '\n';
        TTFile << ','; // for the blank line above the action list
        for(int y = 0; y < AllTTTrains->at(x).NumberOfTrains; y++) // number of repeating trains
        {
            if(y < (AllTTTrains->at(x).NumberOfTrains - 1))
            {
                TTFile << AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).HeadCode.c_str() << ',';
            }
            else
            {
                TTFile << AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).HeadCode.c_str();
            }
        }
        TTFile << '\n' << '\n';

        for(unsigned int z = 0; z < AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(0).OneFormattedTrainVector.size(); z++)
        {
            TTFile << AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(0).OneFormattedTrainVector.at(z).Action.c_str() << ',';
            for(int y = 0; y < AllTTTrains->at(x).NumberOfTrains; y++) // number of repeating trains
            {
                if(y < (AllTTTrains->at(x).NumberOfTrains - 1))
                {
                    TTFile << AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).OneFormattedTrainVector.at(z).Time.c_str() << ',';
                }
                else
                {
                    TTFile << AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).OneFormattedTrainVector.at(z).Time.c_str();
                }
            }
            TTFile << '\n';
        }
        TTFile << '\n' << '\n';
    }

    TTFile.close();

    AnsiString TTFileName2 = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");

    TTFileName2 = CurDir + "\\Formatted timetables\\Timetable " + TTFileName2 + "; " + RailwayTitle + "; " + TimetableTitle + ".txt";

    std::ofstream TTFile2(TTFileName2.c_str()); //chronological timetable

    if(TTFile2 == 0)
    {
        StopTTClockMessage(67, "Chronological timetable file failed to open - can't be created");
        delete AllTTTrains;
        Utilities->CallLogPop(1710);
        return;
    }
    typedef std::multimap<AnsiString, AnsiString>TAnsiMultiMap;
    std::multimap<AnsiString, AnsiString>::iterator AMMIT;
    std::pair<AnsiString, AnsiString>AnsiMultiMapEntry;

    TAnsiMultiMap *TAMM = new TAnsiMultiMap;
    LastTTTime = "";   //records the very last time in the timetable - used in analysis file for Frh entries

    // multimap of AnsiStrings with TimeString as key (to sort automatically)

    TTFile2 << TableTitle.c_str() << '\n' << '\n';
    for(unsigned int x = 0; x < AllTTTrains->size(); x++)
    {
        for(int y = 0; y < AllTTTrains->at(x).NumberOfTrains; y++) // number of repeating trains
        {
            for(unsigned int z = 0; z < AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).OneFormattedTrainVector.size(); z++)
            {
                bool GiveMessagesFalse = false;
                AnsiString TimeString = AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).OneFormattedTrainVector.at(z).Time;
                AnsiString HeadCodeString = AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).HeadCode;
                AnsiString ActionString = AllTTTrains->at(x).OneCompleteFormattedTrainVector.at(y).OneFormattedTrainVector.at(z).Action;
                if(CheckHeadCodeValidity(11, GiveMessagesFalse, TimeString.SubString(1, 4)))
                // 'NXNN at HH:MM'  (will return true if H/C as integ check passed)
                {
                    // fails for HH:MM because of ':' or 'End at HH:MM' because of ' '
                    AnsiString OtherHeadCode = TimeString.SubString(1, 4);
                    TimeString = TimeString.SubString(9, 5);
                    ActionString += " " + OtherHeadCode;
                }
                if(TimeString.SubString(1, 7) == "End at ")
                // for Frh-sh final entry
                {
                    TimeString = TimeString.SubString(8, 5);
                }
                AnsiString OneLine = TimeString + ' ' + HeadCodeString + ' ' + ActionString + '\n';
                AnsiMultiMapEntry.first = TimeString;
                AnsiMultiMapEntry.second = OneLine;
                TAMM->insert(AnsiMultiMapEntry);
            }
        }
    }

    for(AMMIT = TAMM->begin(); AMMIT != TAMM->end(); AMMIT++)
    {
        TTFile2 << (AMMIT->second).c_str();
    }
    delete AllTTTrains;
    delete TAMM;
    TTFile2.close();
    Utilities->CallLogPop(1580);
}

// ---------------------------------------------------------------------------

bool TTrainController::CreateTTAnalysisFile(int Caller, AnsiString RailwayTitle, AnsiString TimetableTitle, AnsiString CurDir, bool ArrChecked, bool DepChecked,
                                            bool AtLocChecked, bool DirChecked, int ArrRange, int DepRange)
{

    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CreateTTAnalysisFile");
    bool AnalysisError = false;
    AnsiString SequenceLog = "SequenceLog\n";

/* Double crosslink (shuttle) table:

Command   Format                    OtherHead                        NonRepeating-  LinkTrain-   NonRepeating-   Decsription
                                    Code                             ShuttleLink-   EntryPtr     ShuttleLink-
                                                                     HeadCode                    EntryPtr

Snt-sh  SNTShuttle                  Y (rtn shuttle)                  N              Y (rtn sh)   N               Simple shuttle - no feeder service
Frh-sh  TimeCmdHeadCode             Y (outwd shuttle)                N              Y (outwd sh) N               Simple shuttle - no finishing service
F-nshs  FNSNonRepeatToShuttle       N (shld be Y for outwd shuttle)  Y (shld be N)  Y (correct)  N (correct)     Feeder service link to shuttle
Sns-sh  SNSShuttle                  Y (rtn shuttle)                  Y (feeder)     Y (rtn)      Y (fdr)         Shuttle link from feeder service
Sns-fsh SNSNonRepeatFromShuttle     N (shld be Y for rtn shuttle)    Y (shld be N)  Y (correct)  N (correct)     Finishing service link from shuttle
Fns-sh  FSHNewService               Y (outwd shuttle)                Y (finishing)  Y (outwd sh) Y (finish)      Shuttle link to finishing service

Note:  Any shuttle start can have any finish - feeder and finish, neither, feeder but no finish & vice versa.
*/

    try
    {
        //New section at v2.5.0 for tt conflict analysis
        /*
            typedef std::list<AnsiString> TServiceCallingLocsList;
            typedef std::map<AnsiString, TServiceCallingLocsList> TAllServiceCallingLocsMap;

    /// Class used for timetable conflict file compilation
        struct TLocServiceTimes
        {
            AnsiString Location;
            AnsiString ServiceAndRepeatNum;
            AnsiString AtLocTime;
            AnsiString ArrTime;
            AnsiString DepTime;
            AnsiString FrhMarker;
        };
        typedef std::vector<TLocServiceTimes> TLocServiceTimesVector;
        */

        //first have to check through all the services and give each one a unique name, or the analysis won't recognise differences between services that have the same reference
        //to do that need a new TrainDataVector as don't want to change anything in the original.  TrainDataVectorCopy is used for building AllServiceCallingLocsMap & LocServiceTimesVector

//create TrainDataVectorCopy and populate service refs with /1, /2 etc
        TrainDataVectorCopy = TrainDataVector; //don't need it on heap as TrainController is on the heap.  Didn't need others in CreatFormattedTimetables but leave as is.
        TTrainDataVector::iterator TDVIt, TDVCopyIt;
        int Suffix = 0;
        int IteratorNumber = 0;
        AnsiString AnsiSuffix = "";
        for(TDVIt = TrainDataVector.begin(); TDVIt != TrainDataVector.end() - 1; TDVIt++)
        {
            IteratorNumber++;  //first value in loop is 1
            Suffix = 0;
            for(TDVCopyIt = TrainDataVectorCopy.begin() + IteratorNumber; TDVCopyIt != TrainDataVectorCopy.end(); TDVCopyIt++)
            {
                if(TDVCopyIt->HeadCode == TDVIt->HeadCode)
                {
                    Suffix++;                        //first value is 1
                    AnsiSuffix = AnsiString(Suffix);
                    TDVCopyIt->ServiceReference = TDVIt->HeadCode + "/" + AnsiSuffix; //set both the HeadCode + any forward slashes and numbers, this is because sometimes
                    TDVCopyIt->HeadCode = TDVIt->HeadCode + "/" + AnsiSuffix;         //service refs are used and sometimes H/Cs, so need them to be the same,
                }                                                                     //they are all unique at this point anyway
            }
        }
//now make all linked pointers in ActionVectorEntries point to links in the vector copy (still point to original vector at this stage)
//and set the linked headcodes to the correct values - all unique at this point
        int Increment = 0, SlashPos;
        TActionVectorIterator AVEIt;
        AnsiString LinkedHeadCode;

        for(TDVCopyIt = TrainDataVectorCopy.begin(); TDVCopyIt != TrainDataVectorCopy.end(); TDVCopyIt++)
        {
            for(AVEIt = TDVCopyIt->ActionVector.begin(); AVEIt != TDVCopyIt->ActionVector.end(); AVEIt++)
            {
                if(AVEIt->LinkedTrainEntryPtr != NULL)
                {
                    Increment = AVEIt->LinkedTrainEntryPtr - &TrainDataVector.at(0);
                    AVEIt->LinkedTrainEntryPtr = &TrainDataVectorCopy.at(0) + Increment;
                    //now set AVEIt->OtherHeadCode to the linked headcodes with /1, /2 etc
                    //but note that these ARE HeadCodes and not service refs, so need to strip off any prefixes from the linked service refs
                    LinkedHeadCode = (*AVEIt->LinkedTrainEntryPtr).ServiceReference;
                    //now count from back until reach a '/' character or a non-integer character, if reach non-integer first then no '/' present at end of H/c (but may be one earlier as a prefix)
                    SlashPos = 0;
                    for(int x = LinkedHeadCode.Length(); x > 0; x--)
                    {
                        if(LinkedHeadCode[x] == '/')
                        {
                            SlashPos = LinkedHeadCode.Length() - x + 1;
                            break;
                        }
                        else if((LinkedHeadCode[x] != '0') && (LinkedHeadCode[x] != '1') && (LinkedHeadCode[x] != '2') && (LinkedHeadCode[x] != '3') &&
                                (LinkedHeadCode[x] != '4') && (LinkedHeadCode[x] != '5') && (LinkedHeadCode[x] != '6') && (LinkedHeadCode[x] != '7') &&
                                (LinkedHeadCode[x] != '8') && (LinkedHeadCode[x] != '8'))
                        {
                            break;
                        }
                    }
                    //now strip off any prefix
                    AVEIt->OtherHeadCode = LinkedHeadCode.SubString(LinkedHeadCode.Length() - 3 - SlashPos, 4 + SlashPos);
                }
                else
                {
                    AVEIt->OtherHeadCode = "";
                }
                if(AVEIt->NonRepeatingShuttleLinkEntryPtr != NULL)
                {
                    Increment = AVEIt->NonRepeatingShuttleLinkEntryPtr - &TrainDataVector.at(0);
                    AVEIt->NonRepeatingShuttleLinkEntryPtr = &TrainDataVectorCopy.at(0) + Increment;
                    //now set AVEIt->NonRepeatingShuttleLinkHeadCode to the linked headcodes with /1, /2 etc
                    //but note that these ARE HeadCodes and not service refs, so need to strip off any prefixes from the linked service refs
                    LinkedHeadCode = (*AVEIt->NonRepeatingShuttleLinkEntryPtr).ServiceReference;
                    //now count from back until reach a '/' character or a non-integer character, if reach non-integer first then no '/' present at end of H/c (but may be one earlier as a prefix)
                    SlashPos = 0;
                    for(int x = LinkedHeadCode.Length(); x > 0; x--)
                    {
                        if(LinkedHeadCode[x] == '/')
                        {
                            SlashPos = LinkedHeadCode.Length() - x + 1;
                            break;
                        }
                        else if((LinkedHeadCode[x] != '0') && (LinkedHeadCode[x] != '1') && (LinkedHeadCode[x] != '2') && (LinkedHeadCode[x] != '3') &&
                                (LinkedHeadCode[x] != '4') && (LinkedHeadCode[x] != '5') && (LinkedHeadCode[x] != '6') && (LinkedHeadCode[x] != '7') &&
                                (LinkedHeadCode[x] != '8') && (LinkedHeadCode[x] != '8'))
                        {
                            break;
                        }
                    }
                    //now strip off any prefix
                    AVEIt->NonRepeatingShuttleLinkHeadCode = LinkedHeadCode.SubString(LinkedHeadCode.Length() - 3 - SlashPos, 4 + SlashPos);
                }
                else
                {
                    AVEIt->NonRepeatingShuttleLinkHeadCode = "";
                }
            }
        }
        //from here only TrainDataVectorCopy used
        SequenceLog += "1\n";
        //build AllServiceCallingLocsMap, it only uses the base service reference (with /1, /2 etc suffixes) as later times are calculated from the repeat number
        TServiceCallingLocsList ServiceCallingLocsList;
        std::pair<AnsiString, TServiceCallingLocsList> AllServiceCallingLocsEntry;
        for(unsigned int x = 0; x < TrainDataVectorCopy.size(); x++)
        {
            const TTrainDataEntry &TrainDataEntry = TrainDataVectorCopy.at(x);
            const TActionVector &ActionVector = TrainDataEntry.ActionVector;
            AllServiceCallingLocsEntry.first = TrainDataEntry.ServiceReference;
            ServiceCallingLocsList.clear();
            if(ActionVector.empty())
            {
                continue;
            }
            if(ActionVector.at(0).SignallerControl)
            {
                continue;
            }
            for(unsigned int z = 0; z < ActionVector.size(); z++)
            {
                TActionVectorEntry AVE = ActionVector.at(z);
                if(AVE.FormatType == StartNew)
                {
                    if(AVE.LocationType == AtLocation) //located Snt
                    {
                        ServiceCallingLocsList.push_back(AVE.LocationName);
                    }
                    else //unlocated Snt (could be entering at continuation)
                    {
                        TTrackElement TE = Track->TrackElementAt(994, AVE.RearStartOrRepeatMins);
                        if(TE.ActiveTrackElementName != "")
                        {
                            ServiceCallingLocsList.push_back(TE.ActiveTrackElementName);
                        }
                        else
                        {
                            int HLoc = TE.HLoc;
                            int VLoc = TE.VLoc;
                            AnsiString HString;
                            AnsiString VString;
                            if(HLoc < 0)
                            {
                                HString = AnsiString('N') + AnsiString(HLoc).SubString(2, AnsiString(HLoc).Length() - 1); //strip off '-'
                            }
                            else
                            {
                                HString = AnsiString(HLoc);
                            }
                            if(VLoc < 0)
                            {
                                VString = AnsiString('N') + AnsiString(VLoc).SubString(2, AnsiString(VLoc).Length() - 1); //strip off '-'
                            }
                            else
                            {
                                VString = AnsiString(VLoc);
                            }
                            ServiceCallingLocsList.push_back(HString + '-' + VString);
                        }
                    }
                }
                else if(AVE.SequenceType == StartSequence) //other start entries, all located
                {
                    ServiceCallingLocsList.push_back(AVE.LocationName);
                }
                else if(AVE.FormatType == TimeLoc) //z must be > 0
                {
                    if(ServiceCallingLocsList.back() != AVE.LocationName)
                    {
                        ServiceCallingLocsList.push_back(AVE.LocationName); //may be listed twice in succession so only want one entry
                    }
                }
                else if(AVE.FormatType == PassTime)
                {
                    ServiceCallingLocsList.push_back(AVE.LocationName);
                }
                else if(AVE.FormatType == TimeTimeLoc)
                {
                    ServiceCallingLocsList.push_back(AVE.LocationName);
                }
                else if(AVE.Command == "cdt") //list if not next to start or finish
                {
                    if(ActionVector.at(z-1).SequenceType == StartSequence)
                    {
                        continue;
                    }
                    else if(ActionVector.at(z+1).SequenceType == FinishSequence) //although deal with Fer entries cdt (train stopped) can't precede FER (train moving)
                    {
                        continue;
                    }
                    else
                    {
                        AnsiString TimeString = Utilities->Format96HHMM(AVE.EventTime);
                        ServiceCallingLocsList.push_back("%%%" + TimeString); //%%% is a marker - unlikely that any locations will begin with this & easy to check to identify a time
                    }
                }
                else if(AVE.FormatType == ExitRailway) //Fer
                {
                    TTrackElement TE = Track->TrackElementAt(995, AVE.ExitList.front());
                    AnsiString LName = TE.ActiveTrackElementName;
                    if(LName != "")
                    {
                        ServiceCallingLocsList.push_back(LName);
                    }
                    else
                    {
                        int HLoc = TE.HLoc;
                        int VLoc = TE.VLoc;
                        AnsiString HString;
                        AnsiString VString;
                        if(HLoc < 0)
                        {
                            HString = AnsiString('N') + AnsiString(HLoc).SubString(2, AnsiString(HLoc).Length() - 1); //strip off '-'
                        }
                        else
                        {
                            HString = AnsiString(HLoc);
                        }
                        if(VLoc < 0)
                        {
                            VString = AnsiString('N') + AnsiString(VLoc).SubString(2, AnsiString(VLoc).Length() - 1); //strip off '-'
                        }
                        else
                        {
                            VString = AnsiString(VLoc);
                        }
                        ServiceCallingLocsList.push_back(HString + '-' + VString);
                    }
                }
            }
            AllServiceCallingLocsEntry.second = ServiceCallingLocsList;
            AllServiceCallingLocsMap.insert(AllServiceCallingLocsEntry);
        }
        //AllServiceCallingLocsMap built
        SequenceLog += "2\n";
/*
//  this sequence is to test the validity of AllServiceCallingLocsMap
        AnsiString TestFile = CurDir + "\\Formatted timetables\\TestFile; " + RailwayTitle + "; " + TimetableTitle + ".txt";
        std::ofstream Test(TestFile.c_str());

        if(TestFile == 0)
        {
            ShowMessage("TestFile failed to open - can't be created");
            Utilities->CallLogPop();
            return false;
        }

        for(TAllServiceCallingLocsMap::iterator ASCLIt = AllServiceCallingLocsMap.begin(); ASCLIt != AllServiceCallingLocsMap.end(); ASCLIt++)
        {
            Test << ASCLIt->first << '\n'; //service ref
            for(TServiceCallingLocsList::iterator SCLIt = ASCLIt->second.begin(); SCLIt != ASCLIt->second.end(); SCLIt++)
            {
                Test << *SCLIt << '\n';
            }
            Test << "\n\n";
        }
        Test.close();
        Utilities->CallLogPop();
        return true;
*/
        //initialise variables before calc LastTTTime & build LocServiceTimesVector
        if(TrainDataVectorCopy.empty())
        {
            ShowMessage("Unable to create a program-readable timetable - please check the timetable file validity");
            Utilities->CallLogPop(2209);
            return(false);
        }
        TLocServiceTimes TLSTEntry;
        TLocServiceTimesVector LocServiceTimesVector; //will be on heap as TrainController is on the heap
        bool NumPlatsAtThisLocCalculated = false, ArrivalsPrinted = false, DeparturesPrinted = false, AtLocsPrinted =  false;
        AnsiString PreviousService = "", PreviousServiceAndRepeatNumTotalOutput = "", BasicTime = "", MinuteString = "", LastAnsiTime = "";
        int NumTrains = 0, NumPlats = 0, LastFrhCount =  0, FrhCount = 0, NumTrainsAtLoc = 0;
        LastTTTime = "";
        SequenceLog += "3\n";
        //calculate LastTTTime
        for(unsigned int x = 0; x < TrainDataVectorCopy.size(); x++)
        {
            TTrainDataEntry &TrainDataEntry = TrainDataVectorCopy.at(x);
            TActionVector &ActionVector = TrainDataEntry.ActionVector;
            TActionVectorIterator AVLast = ActionVector.end() - 1; //points to last entry
            TDateTime LastTDTime;
            int IncMinutes = 0;
            NumTrains = TrainDataEntry.NumberOfTrains;
            if(ActionVector.empty())
            {
                continue;
            }
            if(ActionVector.at(0).SignallerControl)
            {
                continue;
            }
            if(AVLast->FormatType == Repeat)
            {
                IncMinutes = ActionVector.at(ActionVector.size() - 1).RearStartOrRepeatMins;
                AVLast--; //now points to the command before the repeat
            }
            if(AVLast->FormatType == FinRemHere) //not 'else if' as may have both a repeat and an Frh
            {
                AVLast--; //points to last timed entry
            }
            //here AVLast points to last entry with a time
            if(AVLast->ArrivalTime != TDateTime(-1))
            {
                LastTDTime = AVLast->ArrivalTime;
            }
            else if(AVLast->EventTime != TDateTime(-1)) //can't be a departure time
            {
                LastTDTime = AVLast->EventTime;
            }
            else
            {
                continue; //shouldn't ever reach here but if do then skip this service
            }
            if(NumTrains == 1)
            {
                LastAnsiTime = Utilities->Format96HHMM(LastTDTime);
            }
            else
            {
                LastAnsiTime = Utilities->Format96HHMM(GetRepeatTime(59, LastTDTime, NumTrains - 1, IncMinutes));
            }
            if(LastAnsiTime > LastTTTime)
            {
                LastTTTime = LastAnsiTime;
            }
        }
        SequenceLog += "4\n";
//build LocServiceTimesVector

/*
        struct TLocServiceTimes
        {
            AnsiString Location;
            AnsiString ServiceAndRepeatNum;
            AnsiString AtLocTime;
            AnsiString ArrTime;
            AnsiString DepTime;
            AnsiString FrhMarker;
        };
        typedef std::vector<TLocServiceTimes> TLocServiceTimesVector;

This works as follows:
ServiceAndRepeatNum is taken from the TrainDataVectorCopy as it is the same for all actionvector entries
Location is taken from ActionVectorEntry.LocationName if there is one, or from the H & V locations if not (e.g. at an unnamed Fer)
AtLocTime is always entered either on its own or with ArrTime or DepTime as appropriate

Every action for every train is examined and times entered as follows:-
a) a located Snt: entry time becomes the AtLocTime, and all subsequent minutes entered too up to but not including a departure or a finish
b) an unlocated Snt: entry time becomes DepTime
c) all other start entries: entry time becomes AtLoc, and all subsequent minutes entered too up to but not including a departure or a finish
d) TimeLoc Arr: entry time becomes ArrTime, and all subsequent minutes entered too up to but not including a departure or a finish
e) TimeLoc Dep: entry time becomes DepTime, checks if DepTime same as earlier ArrTime and if so all times go in as one entry
f) TimeTimeLoc: Arrival time entered as ArrTime, a check if Arr & Dep same and if so go in as one entry, else all minutes between entered as AtLocs then DepTime
g) ExitRailway (Fer): check if located and use LocationName if so. else use H & V positions, time becomes AtLocTime
h) Frh: use the earlier vector time as the AtLocTime and set FrhMarker, and enter all minutes to end of timetable as AtLocs
i) Frh-sh: for the last train use time as AtLocTime, set FrhMarker, and enter all minutes to end of timetable as AtLocs
j) all other finish entries (all link to another service) are ignored as will be listed for the linked service
*/
        for(unsigned int x = 0; x < TrainDataVectorCopy.size(); x++)
        {
            const TTrainDataEntry &TrainDataEntry = TrainDataVectorCopy.at(x);
            const TActionVector &ActionVector = TrainDataEntry.ActionVector;
            AnsiString ServiceRef = TrainDataEntry.ServiceReference;
            int IncMinutes = 0;
            NumTrains = TrainDataEntry.NumberOfTrains;
            if(ActionVector.empty())
            {
                continue;
            }
            if(ActionVector.at(0).SignallerControl)
            {
                continue;
            }
            if(ActionVector.at(ActionVector.size() - 1).FormatType == Repeat)
            {
                IncMinutes = ActionVector.at(ActionVector.size() - 1).RearStartOrRepeatMins;
            }
            for(int y = 0; y < NumTrains; y++) //y is the repeat number
            {
                if(NumTrains == 1)
                {
                    TLSTEntry.ServiceAndRepeatNum = ServiceRef;
                }
                else if(y == 0)
                {
                    TLSTEntry.ServiceAndRepeatNum = ServiceRef + " (First service)";
                }
                else
                {
                    TLSTEntry.ServiceAndRepeatNum = ServiceRef + " (Repeat " + AnsiString(y) + ")";
                }
                for(unsigned int z = 0; z < ActionVector.size(); z++)
                {
                    TActionVectorEntry AVE = ActionVector.at(z);
                    TLSTEntry.AtLocTime = "";
                    TLSTEntry.ArrTime = "";
                    TLSTEntry.DepTime = "";
                    TLSTEntry.Location = "";
                    TLSTEntry.FrhMarker = "";

                    if(AVE.FormatType == StartNew) //Snt only
                    {
                        if(AVE.LocationType == AtLocation) //located Snt, class time as AtLocTime
                        {
                            TLSTEntry.Location = AVE.LocationName;
                            TLSTEntry.AtLocTime = Utilities->Format96HHMM(GetRepeatTime(58, AVE.EventTime, y, IncMinutes));
                            LocServiceTimesVector.push_back(TLSTEntry);

                            //now look forwards until find a departure or a Fns, Fns-sh etc & add in all the minutes up to but not including the dep or finish times
                            AnsiString IncTime = "", FoundStopTime = "";           //these handled in later checks
                            for(unsigned int a = z + 1; a < ActionVector.size(); a++)
                            {
                                if(ActionVector.at(a).FormatType == TimeLoc) //must be a departure
                                {
                                    FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(62, ActionVector.at(a).DepartureTime, y, IncMinutes));
                                    break;
                                }
                                if(ActionVector.at(a).SequenceType == FinishSequence) //finish catered in a later test
                                {
                                    FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(63, ActionVector.at(a).EventTime, y, IncMinutes));
                                    break;
                                }
                            }
                            if(FoundStopTime == "")
                            {
                                throw Exception("Failure to determine FoundStopTime for located Snt");
                            }
                            int WhileCount = 0;
                            while(true)
                            {
                                //add minutes until reach FoundStopTime but don't add that time
                                WhileCount++;
                                IncTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                                TLSTEntry.AtLocTime = IncTime; //all entered times will be AtLocs
                                TLSTEntry.DepTime = "";
                                TLSTEntry.ArrTime = "";
                                if(IncTime >= FoundStopTime) //don't add that time
                                {
                                    break;
                                }
                                LocServiceTimesVector.push_back(TLSTEntry);
                                if(WhileCount > 2000)
                                {
                                    throw Exception("While loop failed to break in 2000 loops for located Snt");
                                }
                            }
                        }
                        else //unlocated Snt, use the EventTime as DepTime for this vector
                        {
                            TTrackElement TE = Track->TrackElementAt(993, AVE.RearStartOrRepeatMins);
                            if(TE.ActiveTrackElementName != "")
                            {
                                TLSTEntry.Location = TE.ActiveTrackElementName;
                            }
                            else
                            {
                                int HLoc = TE.HLoc;
                                int VLoc = TE.VLoc;
                                AnsiString HString;
                                AnsiString VString;
                                if(HLoc < 0)
                                {
                                    HString = AnsiString('N') + AnsiString(HLoc).SubString(2, AnsiString(HLoc).Length() - 1); //strip off '-'
                                }
                                else
                                {
                                    HString = AnsiString(HLoc);
                                }
                                if(VLoc < 0)
                                {
                                    VString = AnsiString('N') + AnsiString(VLoc).SubString(2, AnsiString(VLoc).Length() - 1); //strip off '-'
                                }
                                else
                                {
                                    VString = AnsiString(VLoc);
                                }
                                TLSTEntry.Location = HString + '-' + VString;
                            }
                            TLSTEntry.DepTime = Utilities->Format96HHMM(GetRepeatTime(49, AVE.EventTime, y, IncMinutes));
                            TLSTEntry.AtLocTime = TLSTEntry.DepTime;
                            LocServiceTimesVector.push_back(TLSTEntry);
                        }
                    }

                    else if(AVE.SequenceType == StartSequence) //other start entries, all located
                    {
                        TLSTEntry.Location = AVE.LocationName;
                        TLSTEntry.AtLocTime = Utilities->Format96HHMM(GetRepeatTime(50, AVE.EventTime, y, IncMinutes));
                        LocServiceTimesVector.push_back(TLSTEntry);
                        //now look forwards until find a departure or a Fns, Fns-sh etc & add in all the minutes up to but not including the dep or finish times
                        AnsiString IncTime = "", FoundStopTime = "";           //these handled in other checks
                        for(unsigned int a = z + 1; a < ActionVector.size(); a++)
                        {
                            if(ActionVector.at(a).FormatType == TimeLoc) //must be a departure
                            {
                                FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(64, ActionVector.at(a).DepartureTime, y, IncMinutes));
                                break;
                            }
                            if(ActionVector.at(a).SequenceType == FinishSequence) //finish catered in a later test
                            {
                                FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(65, ActionVector.at(a).EventTime, y, IncMinutes));
                                break;
                            }
                        }
                        if(FoundStopTime == "")
                        {
                            throw Exception("Failure to determine FoundStopTime for SequenceType == StartSequence");
                        }
                        int WhileCount = 0;
                        while(true)
                        {
                            //add minutes until reach FoundStopTime but don't add that time
                            WhileCount++;
                            IncTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                            TLSTEntry.AtLocTime = IncTime; //all entered times will be AtLocs
                            TLSTEntry.DepTime = "";
                            TLSTEntry.ArrTime = "";
                            if(IncTime >= FoundStopTime) //don't add that time
                            {
                                break;
                            }
                            LocServiceTimesVector.push_back(TLSTEntry);
                            if(WhileCount > 2000)
                            {
                                throw Exception("While loop failed to break in 2000 loops for SequenceType == StartSequence");
                            }
                        }
                    }

                    else if(AVE.FormatType == TimeLoc) //could be arr or dep, if arrival add in all mins to the departure or finish
                    {
                        TLSTEntry.Location = AVE.LocationName;
                        if(AVE.ArrivalTime > TDateTime(-1)) //one or other set, not both, in this case arrival
                        {
                            bool SkipAddingMinutes = false;
                            TLSTEntry.ArrTime = Utilities->Format96HHMM(GetRepeatTime(51, AVE.ArrivalTime, y, IncMinutes));
                            TLSTEntry.AtLocTime = TLSTEntry.ArrTime;
                            LocServiceTimesVector.push_back(TLSTEntry); //Arr and AtLoc added (may be popped if dep time found to be same at next TimeLoc)
                            //now look forwards until find a departure or a Fns, Fns-sh etc & add in all the minutes up to but not including the dep or finish times
                            AnsiString IncTime = "", FoundStopTime = "";           //these handled in other checks
                            for(unsigned int a = z + 1; a < ActionVector.size(); a++)
                            {
                                if(ActionVector.at(a).FormatType == TimeLoc) //must be a departure
                                {
                                    FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(66, ActionVector.at(a).DepartureTime, y, IncMinutes));
                                    break;
                                }
                                if(ActionVector.at(a).SequenceType == FinishSequence) //finish catered for in a later test
                                {
                                    FoundStopTime = Utilities->Format96HHMM(GetRepeatTime(67, ActionVector.at(a).EventTime, y, IncMinutes));
                                    if((a <= (z + 2)) && (FoundStopTime == TLSTEntry.ArrTime) && ((ActionVector.at(a).LinkedTrainEntryPtr != NULL) || (ActionVector.at(a).NonRepeatingShuttleLinkEntryPtr != NULL)))
                                    //finish immediately after arrival at same time, and a forward linked service. Added at v2.6.0 to prevent two linked trains being listed at same location
                                    //at v2.10.0 changed (a == z + 1) to (a <= (z + 2)) as can have a cdt between, this allows for that
                                    {
                                        LocServiceTimesVector.pop_back(); //pop the entry as the linked train will be listed at the relevant time and don't want to list both
                                        SkipAddingMinutes = true;
                                    }
                                    break;
                                }
                            }
                            if(FoundStopTime == "")
                            {
                                throw Exception("Failure to determine FoundStopTime for SequenceType == StartSequence");
                            }
                            if(!SkipAddingMinutes)
                            {
                                int WhileCount = 0;
                                while(true)
                                {
                                    //add minutes until reach FoundStopTime but don't add that time
                                    WhileCount++;
                                    IncTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                                    TLSTEntry.AtLocTime = IncTime; //all entered times will be AtLocs
                                    TLSTEntry.DepTime = "";
                                    TLSTEntry.ArrTime = "";
                                    if(IncTime >= FoundStopTime) //don't add that time
                                    {
                                        break;
                                    }
                                    LocServiceTimesVector.push_back(TLSTEntry);
                                    if(WhileCount > 2000)
                                    {
                                        throw Exception("While loop failed to break in 2000 loops for SequenceType == StartSequence");
                                    }
                                }
                            }
                        }
                        else if(AVE.DepartureTime > TDateTime(-1)) //need to check if the arrival time (which should already be listed) is same and if so put all times on one line
                        {
                            TLSTEntry.DepTime = Utilities->Format96HHMM(GetRepeatTime(52, AVE.DepartureTime, y, IncMinutes));
                            TLSTEntry.AtLocTime = TLSTEntry.DepTime;
                            if((TLSTEntry.Location == LocServiceTimesVector.back().Location) && (TLSTEntry.ServiceAndRepeatNum == LocServiceTimesVector.back().ServiceAndRepeatNum)) //if not it's a new service
                            {
                                if(TLSTEntry.DepTime == LocServiceTimesVector.back().ArrTime)
                                {
                                    TLSTEntry.ArrTime = LocServiceTimesVector.back().ArrTime;
                                    LocServiceTimesVector.pop_back();
                                    LocServiceTimesVector.push_back(TLSTEntry); //Arr, Dep and AtLoc added in place of earlier Arr entry.
                                }
                                else //just add the dep & atloc times
                                {
                                    TLSTEntry.ArrTime = "";
                                    LocServiceTimesVector.push_back(TLSTEntry);
                                }
                            }
                            else //just add the dep & atloc times
                            {
                                TLSTEntry.ArrTime = "";
                                LocServiceTimesVector.push_back(TLSTEntry);
                            }
                        }
                    }

                    else if(AVE.FormatType == TimeTimeLoc)
                    {
                        TLSTEntry.Location = AVE.LocationName;
                        if(AVE.ArrivalTime > TDateTime(-1)) //should be
                        {
                            TLSTEntry.ArrTime = Utilities->Format96HHMM(GetRepeatTime(53, AVE.ArrivalTime, y, IncMinutes));
                            TLSTEntry.AtLocTime = TLSTEntry.ArrTime;
                        }
                        if(AVE.DepartureTime > TDateTime(-1)) //should be
                        {
                            TLSTEntry.DepTime = Utilities->Format96HHMM(GetRepeatTime(54, AVE.DepartureTime, y, IncMinutes));
                        }
                        if(TLSTEntry.ArrTime == TLSTEntry.DepTime)
                        {
                            LocServiceTimesVector.push_back(TLSTEntry);
                        }
                        else
                        {
                            AnsiString TempDepTime = TLSTEntry.DepTime; //save it temporarily
                            TLSTEntry.DepTime = "";
                            LocServiceTimesVector.push_back(TLSTEntry); //push just the arrival and AtLoc times
                            TLSTEntry.ArrTime = ""; //done with this now
                            while(TLSTEntry.AtLocTime < TempDepTime)
                            {
                                TLSTEntry.AtLocTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                                if(TLSTEntry.AtLocTime == TempDepTime)
                                {
                                    TLSTEntry.DepTime = TempDepTime; //restore value
                                    LocServiceTimesVector.push_back(TLSTEntry); //push the AtLoc and Dep times - will finish loop after this
                                }
                                else
                                {
                                    LocServiceTimesVector.push_back(TLSTEntry); //push the AtLoc time on its own
                                }
                            }
                        }
                    }

                    else if(AVE.FormatType == PassTime)  //added at v2.9.1
                    { //adds 2 entries, 1st with PassTime as ArrTime and AtLocTime, 2nd with PassTime as AtLocTime & DepTime
                        TLSTEntry.Location = AVE.LocationName;;
                        TLSTEntry.AtLocTime = Utilities->Format96HHMM(GetRepeatTime(73, AVE.EventTime, y, IncMinutes));
                        TLSTEntry.ArrTime = TLSTEntry.AtLocTime; //DepTime already set to null
                        LocServiceTimesVector.push_back(TLSTEntry); //1st entry
                        TLSTEntry.ArrTime = ""; //need to reset this to null
                        TLSTEntry.DepTime = TLSTEntry.AtLocTime;
                        LocServiceTimesVector.push_back(TLSTEntry); //2nd entry
                    }

                    else if(AVE.FormatType == ExitRailway) //Fer
                    {
                        TLSTEntry.AtLocTime = Utilities->Format96HHMM(GetRepeatTime(55, AVE.EventTime, y, IncMinutes));
                        //don't know which exit will be used during operation so use the first in ExitList, if several with different names then will
                        //be wrong, but can't guess from here & most will have same name
                        AnsiString LName = Track->TrackElementAt(990, AVE.ExitList.front()).ActiveTrackElementName;
                        if(LName != "")
                        {
                            TLSTEntry.Location = LName;
                        }
                        else
                        {
                            int HLoc = Track->TrackElementAt(991, AVE.ExitList.front()).HLoc;
                            int VLoc = Track->TrackElementAt(992, AVE.ExitList.front()).VLoc;
                            AnsiString HString;
                            AnsiString VString;
                            if(HLoc < 0)
                            {
                                HString = AnsiString('N') + AnsiString(HLoc).SubString(2, AnsiString(HLoc).Length() - 1); //strip off '-'
                            }
                            else
                            {
                                HString = AnsiString(HLoc);
                            }
                            if(VLoc < 0)
                            {
                                VString = AnsiString('N') + AnsiString(VLoc).SubString(2, AnsiString(VLoc).Length() - 1); //strip off '-'
                            }
                            else
                            {
                                VString = AnsiString(VLoc);
                            }
                            TLSTEntry.Location = HString + '-' + VString;
                        }
                        LocServiceTimesVector.push_back(TLSTEntry); //just use the exit time as AtLocTime
                    }

                    else if(AVE.FormatType == FinRemHere)  //Frh, not Frh-sh, that dealt with next
                    {
                        AnsiString FrhTime;
                        if(ActionVector.at(z - 1).ArrivalTime != TDateTime(-1))
                        {
                            FrhTime = Utilities->Format96HHMM(GetRepeatTime(56, ActionVector.at(z - 1).ArrivalTime, y, IncMinutes));
                        }
                        else if(ActionVector.at(z - 1).EventTime != TDateTime(-1))
                        {
                            FrhTime = Utilities->Format96HHMM(GetRepeatTime(57, ActionVector.at(z - 1).EventTime, y, IncMinutes));
                        }
                        TLSTEntry.AtLocTime = FrhTime; //use the last entry time as the first recorded time
                        TLSTEntry.Location = AVE.LocationName;
                        AnsiString IncTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                        TLSTEntry.FrhMarker = "Frh";
                        LocServiceTimesVector.push_back(TLSTEntry);
                        TLSTEntry.FrhMarker = "";
                        //add all times from next minute to end of timetable
                        while(IncTime <= LastTTTime)
                        {
                            TLSTEntry.AtLocTime = IncTime;
                            LocServiceTimesVector.push_back(TLSTEntry);
                            IncTime = Utilities->IncrementAnsiTimeOneMinute(IncTime);
                        }
                    }

                    else if(AVE.Command == "Frh-sh") //do nothing if links to other shuttle but treat as Frh when remaining here
                    {
                        if(y == NumTrains - 1) //last repeat, it remains here when accessed for the last train
                        {
                            TLSTEntry.AtLocTime = Utilities->Format96HHMM(GetRepeatTime(68, AVE.EventTime, y, IncMinutes));
                            TLSTEntry.Location = AVE.LocationName;
                            AnsiString IncTime = Utilities->IncrementAnsiTimeOneMinute(TLSTEntry.AtLocTime);
                            TLSTEntry.FrhMarker = "Frh";
                            LocServiceTimesVector.push_back(TLSTEntry);
                            TLSTEntry.FrhMarker = "";
                            //add all times from next minute to end of timetable
                            while(IncTime <= LastTTTime)
                            {
                                TLSTEntry.AtLocTime = IncTime;
                                LocServiceTimesVector.push_back(TLSTEntry);
                                IncTime = Utilities->IncrementAnsiTimeOneMinute(IncTime);
                            }
                        }
                    }

                    else if(AVE.SequenceType == FinishSequence)  //other finish types - all located & all link to another service
                    {
                        //nothing is done here as the entry will be listed at this time under the new service reference
                    }
                }
            }
        }
        SequenceLog += "5\n";
        //now sort in location order
        std::sort(LocServiceTimesVector.begin(), LocServiceTimesVector.end(), &LocServiceTimesLocationSort); //LocServiceTimesLocationSort is a function pointer
        //LocServiceTimesVector now complete & sorted in location order

/*
//start of debugging section
//create LocServiceTimesVector output file for debugging purposes
        AnsiString LSTVTestFile = CurDir + "\\Formatted timetables\\LSTVTestFile; " + RailwayTitle + "; " + TimetableTitle + ".txt";
        std::ofstream LSTVFile(LSTVTestFile.c_str());
        for(TLocServiceTimesVector::iterator LSTVIt = LocServiceTimesVector.begin(); LSTVIt != LocServiceTimesVector.end(); LSTVIt++)
        {
            LSTVFile << LSTVIt->Location + '\n';
            LSTVFile << LSTVIt->ServiceAndRepeatNum + '\n';
            LSTVFile << "AtLocTime = " + LSTVIt->AtLocTime + '\n';
            LSTVFile << "ArrTime = " + LSTVIt->ArrTime + '\n';
            LSTVFile << "DepTime = " + LSTVIt->DepTime + '\n';
            if(LSTVIt->FrhMarker == "")
            {
                LSTVFile << "Not Frh\n";
            }
            else
            {
                LSTVFile << LSTVIt->FrhMarker + '\n';
            }
            LSTVFile << '\n';
        }
        LSTVFile.close();
        Utilities->CallLogPop();
        return(true);
//end of debugging section
*/
        //declare pointers for use in printouts
        TLocServiceTimesVector::iterator Ptr1, Ptr2;

        //set up the output file
        AnsiString TTFileName3 = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        TTFileName3 = CurDir + "\\Formatted timetables\\Conflict Analysis " + TTFileName3 + "; " + RailwayTitle + "; " + TimetableTitle + ".csv";

        std::ofstream TTFile3(TTFileName3.c_str());

        if(TTFile3 == 0)
        {
            ShowMessage("Conflict Analysis file failed to open - can't be created");
            Utilities->CallLogPop(2210);
            return(false);
        }
        if(LocServiceTimesVector.empty())
        {
            ShowMessage("No timetabled services found");
            TTFile3.close();
            DeleteFile(TTFileName3);
            Utilities->CallLogPop(2211);
            return(false);
        }
        TTFile3 << "Timetable analysis for timetable: '" + TimetableTitle + "' in conjunction with railway: '" + RailwayTitle + "'\n";
        TTFile3 << "See user manual or on-screen help section 5.12 for detailed information.\n\n\n";
        SequenceLog += "6\n";

/*
//print out TrainDataVectorCopy & TrainDataVector for debugging purposes, TrainDataVectorCopy first

// Double crosslink (shuttle) table:
//Command   Format                    OtherHead                        NonRepeating-  LinkTrain-   NonRepeating-   Decsription
//                                    Code                             ShuttleLink-   EntryPtr     ShuttleLink-
//                                                                     HeadCode                    EntryPtr

//Snt-sh  SNTShuttle                  Y (rtn shuttle)                  N              Y (rtn sh)   N               Simple shuttle - no feeder service
//Frh-sh  TimeCmdHeadCode             Y (outwd shuttle)                N              Y (outwd sh) N               Simple shuttle - no finishing service
//F-nshs  FNSNonRepeatToShuttle       N (shld be Y for outwd shuttle)  Y (shld be N)  Y (correct)  N (correct)     Feeder service link to shuttle
//Sns-sh  SNSShuttle                  Y (rtn shuttle)                  Y (feeder)     Y (rtn)      Y (fdr)         Shuttle link from feeder service
//Sns-fsh SNSNonRepeatFromShuttle     N (shld be Y for rtn shuttle)    Y (shld be N)  Y (correct)  N (correct)     Finishing service link from shuttle
//Fns-sh  FSHNewService               Y (outwd shuttle)                Y (finishing)  Y (outwd sh) Y (finish)      Shuttle link to finishing service
//
//Note:  Any shuttle start can have any finish - feeder and finish, neither, feeder but no finish & vice versa.

//NOTE: from above for F-nshs & Sns-fsh in the TrainDataVectorCopy the OtherLinkedHeadCode will be correct as it is derived from LinkTrainEntryPtr which is correct
//but for the original TrainDataVector the OtherLinkedHeadCode will be incorrect, hence have to use the NonRepeatingShuttleLinkHeadCode as that is the correct one
//these were errors when first coded but work ok, just keep in mind when making any changes

std::ofstream TDVCFile((CurDir + "\\Formatted timetables\\Conflict Analysis " + TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss") + "; " + RailwayTitle + "; " + TimetableTitle + " TrainDataVectorCopy.txt").c_str());
AnsiString OHC = "", NRHC = "";
AnsiString OLk = "", NRLk = "";
TDVCFile << "Note that for the TrainDataVectorCopy OH and OLk should always be the same, as OH is derived from OHLk; and similarly for NR and NRLk\n\n";
for(TTrainDataVector::iterator TDVCIt = TrainDataVectorCopy.begin(); TDVCIt != TrainDataVectorCopy.end(); TDVCIt++)
{
    TDVCFile << TDVCIt->ServiceReference + '\n';
    TDVCFile << TDVCIt->Description + '\n';
    for(unsigned int x = 0; x < TDVCIt->ActionVector.size(); x++)
    {
        TActionVectorEntry AVE = TDVCIt->ActionVector.at(x);
        if(AVE.OtherHeadCode == "")
        {
            OHC = "OH 0";
        }
        else
        {
            OHC = "OH " + AVE.OtherHeadCode;
        }
        if(AVE.NonRepeatingShuttleLinkHeadCode == "")
        {
            NRHC = "NR 0";
        }
        else
        {
            NRHC = "NR " + AVE.NonRepeatingShuttleLinkHeadCode;
        }
        if(TDVCIt->ActionVector.at(x).LinkedTrainEntryPtr == 0)
        {
            OLk = "OLk 0";
        }
        else
        {
            OLk = "OLk " + TDVCIt->ActionVector.at(x).LinkedTrainEntryPtr->ServiceReference;
        }
        if(TDVCIt->ActionVector.at(x).NonRepeatingShuttleLinkEntryPtr == 0)
        {
            NRLk = "NRLk 0";
        }
        else
        {
            NRLk = "NRLk " + TDVCIt->ActionVector.at(x).NonRepeatingShuttleLinkEntryPtr->ServiceReference;
        }

        if(AVE.FormatType == TimeCmd) //cdt only
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << '\n';
        }
        if((AVE.FormatType == TimeCmdHeadCode) || (AVE.FormatType == FNSNonRepeatToShuttle))
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC << ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if((AVE.FormatType == FSHNewService) || (AVE.FormatType == SNSShuttle)) //these should have 2 linked services
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC <<  ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if(AVE.FormatType == SNSNonRepeatFromShuttle)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC << ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if(AVE.FormatType == StartNew)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << " Snt RearStartID " << Track->TrackElementAt(-1, AVE.RearStartOrRepeatMins).ElementID
                <<  " FrontStartID " << Track->TrackElementAt(-2, AVE.FrontStartOrRepeatDigits).ElementID << '\n';
        }
        else if(AVE.FormatType == SNTShuttle)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << " Snt-sh RearStartID " << Track->TrackElementAt(-3, AVE.RearStartOrRepeatMins).ElementID
                <<  " FrontStartID " << Track->TrackElementAt(-4, AVE.FrontStartOrRepeatDigits).ElementID << '\n';
        }
        else if((AVE.FormatType == TimeLoc) && (AVE.ArrivalTime != TDateTime(-1)))
        {
            TDVCFile << Utilities->Format96HHMM(AVE.ArrivalTime) << " Arr " << AVE.LocationName <<  '\n';
        }
        else if((AVE.FormatType == TimeLoc) && (AVE.DepartureTime != TDateTime(-1)))
        {
            TDVCFile << Utilities->Format96HHMM(AVE.DepartureTime) << " Dep " << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == TimeTimeLoc)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.ArrivalTime) << ' ' << Utilities->Format96HHMM(AVE.DepartureTime) << ' ' << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == PassTime)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << "Pass" << ' ' << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == ExitRailway)
        {
            TDVCFile << Utilities->Format96HHMM(AVE.EventTime) << " Fer" <<  '\n';
        }
        else if(AVE.FormatType == FinRemHere)
        {
            TDVCFile << "Frh" <<  '\n';
        }
    }
    TDVCFile << '\n';
}
TDVCFile.close();

//print out original TrainDataVector for comparison
std::ofstream TDVFile((CurDir + "\\Formatted timetables\\Conflict Analysis " + TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss") + "; " + RailwayTitle + "; " + TimetableTitle + " TrainDataVector.txt").c_str());
TDVFile << "Note that in the TrainDataVector, non-repeating shuttle link services F-nshs and Sns-fsh use the non-repeating headcode (NR) values for the corresponding "
            "shuttle headcodes when it should be the other headcode (OH), and the other headcode is unused.  The link values are the right way round.  Also OH & NR "
            "values ARE headcodes and not service references, but OLk and NRLk values are service references.\n\n";
//F-nshs  FNSNonRepeatToShuttle       N (shld be Y for outwd shuttle)  Y (shld be N)  Y (correct)  N (correct)     Feeder service link to shuttle
//Sns-fsh SNSNonRepeatFromShuttle     N (shld be Y for rtn shuttle)    Y (shld be N)  Y (correct)  N (correct)     Finishing service link from shuttle
for(TTrainDataVector::iterator TDVIt = TrainDataVector.begin(); TDVIt != TrainDataVector.end(); TDVIt++)
{
    TDVFile << TDVIt->ServiceReference + '\n';
    TDVFile << TDVIt->Description + '\n';
    for(unsigned int x = 0; x < TDVIt->ActionVector.size(); x++)
    {
        TActionVectorEntry AVE = TDVIt->ActionVector.at(x);
        if(AVE.OtherHeadCode == "")
        {
            OHC = "OH 0";
        }
        else
        {
            OHC = "OH " + AVE.OtherHeadCode;
        }
        if(AVE.NonRepeatingShuttleLinkHeadCode == "")
        {
            NRHC = "NR 0";
        }
        else
        {
            NRHC = "NR " + AVE.NonRepeatingShuttleLinkHeadCode;
        }
        if(TDVIt->ActionVector.at(x).LinkedTrainEntryPtr == 0)
        {
            OLk = "OLk 0";
        }
        else
        {
            OLk = "OLk " + TDVIt->ActionVector.at(x).LinkedTrainEntryPtr->ServiceReference;
        }
        if(TDVIt->ActionVector.at(x).NonRepeatingShuttleLinkEntryPtr == 0)
        {
            NRLk = "NRLk 0";
        }
        else
        {
            NRLk = "NRLk " + TDVIt->ActionVector.at(x).NonRepeatingShuttleLinkEntryPtr->ServiceReference;
        }

        if(AVE.FormatType == TimeCmd) //cdt only
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << '\n';
        }
        if((AVE.FormatType == TimeCmdHeadCode) || (AVE.FormatType == FNSNonRepeatToShuttle))
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC << ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if((AVE.FormatType == FSHNewService) || (AVE.FormatType == SNSShuttle)) //these should have 2 linked services
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC << ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if(AVE.FormatType == SNSNonRepeatFromShuttle)
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << OHC << ' ' << NRHC << ' ' << OLk << ' ' << NRLk << '\n';
        }
        else if(AVE.FormatType == StartNew)
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << " Snt RearStartID " << Track->TrackElementAt(-5, AVE.RearStartOrRepeatMins).ElementID
                <<  " FrontStartID " << Track->TrackElementAt(-6, AVE.FrontStartOrRepeatDigits).ElementID << '\n';
        }
        else if(AVE.FormatType == SNTShuttle)
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << " Snt-sh RearStartID " << Track->TrackElementAt(-7, AVE.RearStartOrRepeatMins).ElementID
                <<  " FrontStartID " << Track->TrackElementAt(-8, AVE.FrontStartOrRepeatDigits).ElementID << '\n';
        }
        else if((AVE.FormatType == TimeLoc) && (AVE.ArrivalTime != TDateTime(-1)))
        {
            TDVFile << Utilities->Format96HHMM(AVE.ArrivalTime) << " Arr " << AVE.LocationName <<  '\n';
        }
        else if((AVE.FormatType == TimeLoc) && (AVE.DepartureTime != TDateTime(-1)))
        {
            TDVFile << Utilities->Format96HHMM(AVE.DepartureTime) << " Dep " << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == TimeTimeLoc)
        {
            TDVFile << Utilities->Format96HHMM(AVE.ArrivalTime) << ' ' << Utilities->Format96HHMM(AVE.DepartureTime) << ' ' << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == PassTime)
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << ' ' << "Pass" << ' ' << AVE.LocationName <<  '\n';
        }
        else if(AVE.FormatType == ExitRailway)
        {
            TDVFile << Utilities->Format96HHMM(AVE.EventTime) << " Fer" <<  '\n';
        }
        else if(AVE.FormatType == FinRemHere)
        {
            TDVFile << "Frh" <<  '\n';
        }
    }
    TDVFile << '\n';
}
TDVFile.close();
//end of debugging
*/
        //arrivals
        if(ArrChecked)
        {
            //sort in ArrTime order for each location
            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                while(Ptr2->Location == Ptr1->Location) //ends with Ptr2 one past same Location value as Ptr1
                {
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                std::sort(Ptr1, Ptr2, &LocServiceTimesArrTimeSort);
                Ptr1 = Ptr2; //first entry with next name
                if(Ptr2 != LocServiceTimesVector.end())
                {
                    Ptr2++;
                }
            }

            //routine for arrivals - number of trains arriving within the specified range with services listed at the end

            TTFile3 << "Arrival & pass analysis: an asterisk means that the number of same approach code arrivals and passes is equal to or greater than the number of platforms.\n";
            TTFile3 << "If the total number of arrivals and passes at the same time exceeds the number of platforms the 'Trains present at location analysis' will show an asterisk.\n\n";
            MinuteString = " minutes";
            AnsiString ServiceAndRepeatNumTotal = "", ServiceAndRepeatNumTotalOutput = "";
            if(ArrRange == 1)
            {
                MinuteString = " minute";
            }
            TTFile3 << "Location,Number of,Number of,Services arriving within " << AnsiString(ArrRange) << MinuteString << " with their arrival times and approach codes\n";
            TTFile3 << ",Platforms,Trains\n\n";

            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                PreviousService = "";
                NumTrainsAtLoc = 0;
                ServiceAndRepeatNumTotal = "";
                NumPlats = 0;
                NumPlatsAtThisLocCalculated = false;
                BasicTime = "";
                while((Ptr2->Location != Ptr1->Location) || ((Ptr1->Location == "") && (Ptr2->Location == "")))
                {
                    PreviousService = "";
                    NumTrainsAtLoc = 0;
                    ServiceAndRepeatNumTotal = "";
                    NumPlats = 0;
                    NumPlatsAtThisLocCalculated = false;
                    BasicTime = "";
                    Ptr1++;
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                if(Ptr2 == LocServiceTimesVector.end())
                {
                    break;
                }
                while(Ptr2->Location == Ptr1->Location)
                {
                    PreviousService = "";
                    NumTrainsAtLoc = 0;
                    ServiceAndRepeatNumTotal = "";
                    BasicTime = Ptr1->ArrTime; //used to compare later times - later pointer contents have same or later times as sorted in time order
                    if((Ptr1->Location == "") && (Ptr2->Location == ""))
                    {
                        break;
                    }
                    while(!WithinTimeRange(0, BasicTime, Ptr2->ArrTime, ArrRange) || ((Ptr1->ArrTime == "") && (Ptr2->ArrTime == "")))
                    {
                        BasicTime = Ptr2->ArrTime; //used to compare later times or last can exceed first
                        Ptr1++;
                        Ptr2++;
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                    if(Ptr2->Location != Ptr1->Location)
                    {
                        break;
                    }
                    while(WithinTimeRange(1, BasicTime, Ptr2->ArrTime, ArrRange))
                    {
                        if((Ptr1->ArrTime == "") && (Ptr2->ArrTime == ""))
                        {
                            break;
                        }
                        if(!NumPlatsAtThisLocCalculated) //num plats at relevant location, reset when locations change
                        {
                            NumPlats = Track->NumberOfPlatforms(0, Ptr1->Location);
                            NumPlatsAtThisLocCalculated = true;
                        }
                        if(Ptr1->ServiceAndRepeatNum != PreviousService) //don't print it twice if same as last - as will be if >1 service at same loc at same time
                        {
                            if(ServiceAndRepeatNumTotal == "")
                            {
                                ServiceAndRepeatNumTotal = Ptr1->ServiceAndRepeatNum + "," + Ptr1->ArrTime;
                                NumTrainsAtLoc = 1;
                            }
                            else
                            {
                                ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr1->ServiceAndRepeatNum + "," + Ptr1->ArrTime;
                            }
                        }
                        PreviousService = Ptr2->ServiceAndRepeatNum; //last service at relevant time, reset when times differ
                        if(ServiceAndRepeatNumTotal == "")
                        {
                            ServiceAndRepeatNumTotal = Ptr2->ServiceAndRepeatNum + "," + Ptr2->ArrTime;
                            NumTrainsAtLoc = 1;
                        }
                        else
                        {
                            ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr2->ServiceAndRepeatNum + "," + Ptr2->ArrTime;
                        }
                        Ptr1 = Ptr2;
                        Ptr2++;
                        if((Ptr2 == LocServiceTimesVector.end()) || (Ptr2->Location != Ptr1->Location) || (!WithinTimeRange(2, BasicTime, Ptr2->ArrTime, ArrRange)))
                        {
                            int MaxNumberOfSameDirections = 0;
                            ServiceAndRepeatNumTotalOutput = ConsolidateSARNTArrDep(1, ServiceAndRepeatNumTotal, NumTrainsAtLoc, Ptr1->Location, true, AnalysisError, MaxNumberOfSameDirections); //sort into alphabetical order and remove duplicates
                            if(AnalysisError)                                                                                                                    //has to be Ptr1->Location as Ptr2 loc may have changed
                            {
//                                ShowMessage("Error in arrival analysis - file will be incomplete and/or corrupt. Please send railway and timetable files to railwayfeedback@gmail.com for investigation - thanks. Details: " + ServiceAndRepeatNumTotalOutput);
                                TTFile3.close();
                                throw Exception(ServiceAndRepeatNumTotalOutput.c_str());
//                                Utilities->CallLogPop(2224);
//                                return false;
                            }
                            AnsiString Asterisk = "";
                            if(MaxNumberOfSameDirections >= NumPlats)
                            {
                                Asterisk = "* ";
                            }
                            //print out a single line for number of trains at loc with all service refs
                            TTFile3 << Asterisk << Ptr1->Location  << "," << NumPlats << "," << NumTrainsAtLoc << "," << ServiceAndRepeatNumTotalOutput << '\n'; //no description as >1 service
                            ArrivalsPrinted = true;
                            ServiceAndRepeatNumTotal = "";
                        }
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
            }
            if(!ArrivalsPrinted)
            {
                TTFile3 << "Nothing to report for arrivals";
            }
            TTFile3 << "\n\n";
        }
        //end of routine for arrivals
        SequenceLog += "7\n";
        //departures
        if(DepChecked)
        {
            //sort in DepTime order for each location
            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                while(Ptr2->Location == Ptr1->Location) //ends with Ptr2 one past same Location value as Ptr1
                {
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                std::sort(Ptr1, Ptr2, &LocServiceTimesDepTimeSort);
                Ptr1 = Ptr2; //first entry with next name
                if(Ptr2 != LocServiceTimesVector.end())
                {
                    Ptr2++;
                }
            }

            //routine for departures - number of trains departing within the specified range with services listed at the end
            TTFile3 << "Departure & pass analysis: an asterisk means that the number of same exit code departures and passes is equal to or greater than the number of platforms.\n";
            TTFile3 << "If the total number of departures and passes at the same time exceeds the number of platforms the 'Trains present at location analysis' will show an asterisk.\n\n";
            MinuteString = " minutes";
            AnsiString ServiceAndRepeatNumTotal = "", ServiceAndRepeatNumTotalOutput = "";
            if(DepRange == 1)
            {
                MinuteString = " minute";
            }
            TTFile3 << "Location,Number of,Number of,Services departing within " << AnsiString(DepRange) << MinuteString << " with their departure times and exit codes\n";
            TTFile3 << ",Platforms,Trains\n\n";

            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                PreviousService = "";
                NumTrainsAtLoc = 0;
                ServiceAndRepeatNumTotal = "";
                NumPlats = 0;
                NumPlatsAtThisLocCalculated = false;
                BasicTime = "";
                while((Ptr2->Location != Ptr1->Location) || ((Ptr1->Location == "") && (Ptr2->Location == "")))
                {
                    PreviousService = "";
                    NumTrainsAtLoc = 0;
                    ServiceAndRepeatNumTotal = "";
                    NumPlats = 0;
                    NumPlatsAtThisLocCalculated = false;
                    BasicTime = "";
                    Ptr1++;
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                if(Ptr2 == LocServiceTimesVector.end())
                {
                    break;
                }
                while(Ptr2->Location == Ptr1->Location)
                {
                    PreviousService = "";
                    NumTrainsAtLoc = 0;
                    ServiceAndRepeatNumTotal = "";
                    BasicTime = Ptr1->DepTime;  //used to compare later times - later pointer contents have same or later times as sorted in time order
                    if((Ptr1->Location == "") && (Ptr2->Location == ""))
                    {
                        break;
                    }
                    while(!WithinTimeRange(3, BasicTime, Ptr2->DepTime, DepRange) || ((Ptr1->DepTime == "") && (Ptr2->DepTime == "")))
                    {
                        BasicTime = Ptr2->DepTime; //used to compare later times or last can exceed first
                        Ptr1++;
                        Ptr2++;
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                    if(Ptr2->Location != Ptr1->Location)
                    {
                        break;
                    }
                    while(WithinTimeRange(4, BasicTime, Ptr2->DepTime, DepRange))
                    {
                        if((Ptr1->DepTime == "") && (Ptr2->DepTime == ""))
                        {
                            break;
                        }
                        if(!NumPlatsAtThisLocCalculated) //num plats at relevant location, reset when locations change
                        {
                            NumPlats = Track->NumberOfPlatforms(1, Ptr1->Location);
                            NumPlatsAtThisLocCalculated = true;
                        }
                        if(Ptr1->ServiceAndRepeatNum != PreviousService) //don't print it twice if same as last - as will be if >1 service at same loc at same time
                        {
                            if(ServiceAndRepeatNumTotal == "")
                            {
                                ServiceAndRepeatNumTotal = Ptr1->ServiceAndRepeatNum + "," + Ptr1->DepTime;
                                NumTrainsAtLoc = 1;
                            }
                            else
                            {
                                ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr1->ServiceAndRepeatNum + "," + Ptr1->DepTime;
                            }
                        }
                        PreviousService = Ptr2->ServiceAndRepeatNum; //last service at relevant time, reset when times differ
                        if(ServiceAndRepeatNumTotal == "")
                        {
                            ServiceAndRepeatNumTotal = Ptr2->ServiceAndRepeatNum + "," + Ptr2->DepTime;
                            NumTrainsAtLoc = 1;
                        }
                        else
                        {
                            ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr2->ServiceAndRepeatNum + "," + Ptr2->DepTime;
                        }
                        Ptr1 = Ptr2;
                        Ptr2++;
                        if((Ptr2 == LocServiceTimesVector.end()) || (Ptr2->Location != Ptr1->Location) || (!WithinTimeRange(5, BasicTime, Ptr2->DepTime, DepRange)))
                        {
                            int MaxNumberOfSameDirections = 0;
                            ServiceAndRepeatNumTotalOutput = ConsolidateSARNTArrDep(3, ServiceAndRepeatNumTotal, NumTrainsAtLoc, Ptr1->Location, false, AnalysisError, MaxNumberOfSameDirections); //sort into alphabetical order and remove duplicates
                            if(AnalysisError)                                                                                                                     //has to be Ptr1->Location as Ptr2 loc may have changed
                            {
//                                ShowMessage("Error in departure analysis - file will be incomplete and/or corrupt. Please send railway and timetable files to railwayfeedback@gmail.com for investigation - thanks. Details: " + ServiceAndRepeatNumTotalOutput);
                                TTFile3.close();
                                throw Exception(ServiceAndRepeatNumTotalOutput.c_str());
//                                Utilities->CallLogPop(2225);
//                                return false;
                            }
                            AnsiString Asterisk = "";
                            if(MaxNumberOfSameDirections >= NumPlats)
                            {
                                Asterisk = "* ";
                            }
                            //print out a single line for number of trains at loc with all service refs
                            TTFile3 << Asterisk << Ptr1->Location  << "," << NumPlats << "," << NumTrainsAtLoc << "," << ServiceAndRepeatNumTotalOutput << '\n'; //no description as >1 service
                            DeparturesPrinted = true;
                            ServiceAndRepeatNumTotal = "";
                        }
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
            }
            if(!DeparturesPrinted)
            {
                TTFile3 << "Nothing to report for departures";
            }
            TTFile3 << "\n\n";
        }
        //end of routine for departures
        SequenceLog += "8\n";

        //list trains at locations at same time

        if(AtLocChecked)
        {
            //sort in AtLocTime order for each location
            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                while(Ptr2->Location == Ptr1->Location) //ends with Ptr2 one past same Location value as Ptr1
                {
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                std::sort(Ptr1, Ptr2, &LocServiceTimesAtLocTimeSort);
                Ptr1 = Ptr2; //first entry with next name
                if(Ptr2 != LocServiceTimesVector.end())
                {
                    Ptr2++;
                }
            }

            //print out simultaneous AtLocs (don't need range of times for AtLocs)
            TTFile3 << "Trains present at location analysis: an asterisk means that the number of trains at the location is greater than the number of platforms.\n\n";
            TTFile3 << "Location,Number of,Number of,Time,Services at the location at that time\n";
            TTFile3 << ",Platforms,Trains,\n\n";
            AnsiString ServiceAndRepeatNumTotal = "", ServiceAndRepeatNumTotalOutput = "";
            Ptr1 = LocServiceTimesVector.begin();
            Ptr2 = Ptr1 + 1;
            while(Ptr2 != LocServiceTimesVector.end())
            {
                PreviousService = "";
                ServiceAndRepeatNumTotal = "";
                NumTrainsAtLoc = 0;
                NumPlats = 0;
                NumPlatsAtThisLocCalculated = false;
                FrhCount = 0;

                while((Ptr2->Location != Ptr1->Location) || ((Ptr1->Location == "") && (Ptr2->Location == "")))
                {
                    PreviousService = "";
                    ServiceAndRepeatNumTotal = "";
                    NumTrainsAtLoc = 0;
                    NumPlats = 0;
                    NumPlatsAtThisLocCalculated = false;
                    FrhCount = 0;
                    Ptr1++;
                    Ptr2++;
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
                if(Ptr2 == LocServiceTimesVector.end())
                {
                    break;
                }
                while(Ptr2->Location == Ptr1->Location)
                {
                    if(Ptr1->FrhMarker == "Frh")  //this test is made here and each time Ptr1 increases with Ptr1 & 2 at same loc so as to catch them all
                    {
                        FrhCount++;
                        Ptr1->FrhMarker = "FrhCounted";  //to avoid double counting
                    }
                    PreviousService = "";
                    NumTrainsAtLoc = 0;
                    ServiceAndRepeatNumTotal = "";
                    if((Ptr1->Location == "") && (Ptr2->Location == ""))
                    {
                        break;
                    }
                    while((Ptr2->AtLocTime != Ptr1->AtLocTime) || ((Ptr1->AtLocTime == "") && (Ptr2->AtLocTime == "")))
                    {
                        Ptr1++;
                        if(Ptr1->FrhMarker == "Frh")
                        {
                            FrhCount++;
                            Ptr1->FrhMarker = "FrhCounted";  //to avoid double counting
                        }
                        Ptr2++;
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                    if(Ptr2->Location != Ptr1->Location)
                    {
                        break;
                    }
                    while(Ptr2->AtLocTime == Ptr1->AtLocTime)
                    {
                        if((Ptr1->AtLocTime == "") && (Ptr2->AtLocTime == ""))
                        {
                            break;
                        }
                        if(!NumPlatsAtThisLocCalculated) //num plats at relevant location, reset when locations change
                        {
                            NumPlats = Track->NumberOfPlatforms(2, Ptr1->Location);
                            NumPlatsAtThisLocCalculated = true;
                        }
                        if(Ptr1->ServiceAndRepeatNum != PreviousService) //don't print it twice if same as last - as will be if >1 service at same loc at same time
                        {
                            if(ServiceAndRepeatNumTotal == "")
                            {
                                ServiceAndRepeatNumTotal = Ptr1->ServiceAndRepeatNum;
                                NumTrainsAtLoc = 1;
                            }
                            else
                            {
                                ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr1->ServiceAndRepeatNum;
                            }
                        }
                        PreviousService = Ptr2->ServiceAndRepeatNum; //last service at relevant time, reset when times differ, has to be Ptr2 to compare Ptr1 at next round when incremented
                        if(ServiceAndRepeatNumTotal == "")
                        {
                            ServiceAndRepeatNumTotal = Ptr2->ServiceAndRepeatNum;
                            NumTrainsAtLoc = 1;
                        }
                        else
                        {
                            ServiceAndRepeatNumTotal = ServiceAndRepeatNumTotal + "," + Ptr2->ServiceAndRepeatNum;
                        }
                        Ptr1 = Ptr2;
                        if(Ptr1->FrhMarker == "Frh")
                        {
                            FrhCount++;
                            Ptr1->FrhMarker = "FrhCounted"; //to avoid double counting
                        }
                        Ptr2++;
                        if((Ptr2 == LocServiceTimesVector.end()) || (Ptr2->Location != Ptr1->Location) || (Ptr2->AtLocTime != Ptr1->AtLocTime))
                        {
//old text                  //only print out if no remainers (1st condition), change in remainers (2nd condition) or change in ServiceAndRepeatNumTotalOutput, and >1 train (later condition)
//new text                  //don't print out if all remainers or if only 1 train at loc
                            ServiceAndRepeatNumTotalOutput = ConsolidateSARNTAtLoc(1, ServiceAndRepeatNumTotal, NumTrainsAtLoc); //sort into alphabetical order, remove duplicates, and calculate new value for NumTrainsAtLoc
//old condits               if((FrhCount == 0) || (FrhCount != LastFrhCount) || (PreviousServiceAndRepeatNumTotalOutput != ServiceAndRepeatNumTotalOutput))//don't print if same output
/*new condits*/ if((NumTrainsAtLoc > 1) && ((FrhCount < NumTrainsAtLoc) || (FrhCount != LastFrhCount)))
                            {
                                AnsiString Asterisk = "";
                                if(NumTrainsAtLoc > NumPlats)
                                {
                                    Asterisk = "* ";
                                }
                                //print out a single line for number of trains at loc with all service refs
                                if(FrhCount == 0)
                                {
                                    TTFile3 << Asterisk << Ptr1->Location  << "," << NumPlats << "," << NumTrainsAtLoc << "," << Ptr1->AtLocTime << "," << ServiceAndRepeatNumTotalOutput << '\n';
                                }
                                else if(FrhCount == 1)
                                {
                                    TTFile3 << Asterisk << Ptr1->Location  << "," << NumPlats << "," << NumTrainsAtLoc << "," << Ptr1->AtLocTime << " (1 remains here)," << ServiceAndRepeatNumTotalOutput << '\n';
                                }
                                else
                                {
                                    TTFile3 << Asterisk << Ptr1->Location  << "," << NumPlats << "," << NumTrainsAtLoc << "," << Ptr1->AtLocTime << " (" << FrhCount << " remain here)," << ServiceAndRepeatNumTotalOutput << '\n';
                                }
                                LastFrhCount = FrhCount;
                                PreviousServiceAndRepeatNumTotalOutput = ServiceAndRepeatNumTotalOutput;
                                AtLocsPrinted = true;
                                ServiceAndRepeatNumTotal = "";
                            }
                        }
                        if(Ptr2 == LocServiceTimesVector.end())
                        {
                            break;
                        }
                        if(Ptr2->Location != Ptr1->Location)
                        {
                            break;
                        }
                    }
                    if(Ptr2 == LocServiceTimesVector.end())
                    {
                        break;
                    }
                }
            }
            if(!AtLocsPrinted)
            {
                TTFile3 << "Nothing to report for trains at locations";
            }
            TTFile3 << "\n\n";
            //end of simultaneous AtLocs
        }
        SequenceLog += "9\n";

/*
//start of debugging section
        //print out the full vector here for testing purposes
            TTFile3 << "Full LocServiceTimesVector\n\n";
            TTFile3 << "Location,AtLocTime,ArrTime,DepTime,ServiceAndRepeatNum,Description\n\n";

            for(TLocServiceTimesVector::iterator Ptr = LocServiceTimesVector.begin(); Ptr != LocServiceTimesVector.end(); Ptr++)
            {
                TTFile3 << Ptr->Location << "," << Ptr->AtLocTime << "," << Ptr->ArrTime << "," << Ptr->DepTime << "," << Ptr->ServiceAndRepeatNum << "," << Ptr->FrhMarker << '\n';
            }

            TTFile3 << "\n\n\n";
//end of debugging
*/

/*cdt analysis - added at v2.10.0
2 pass system:  1st extract as a single service all Snt (or Snt-sh) starts, with Fns/Sns links combined (and F-nshs/Sns-sh) (though add a new
changeover code [chr XXXX - 'change ref + new reference] until come to Fjo, Frh, Frh-sh, Fer (ignore exit loc as can't stop there), ignore jbos &
repeats, but with fsp & rsp store all the foregoing service entries along with the split reference & add that to the relevant Sfs entry as a new
service.  For shuttles with feeder start with feeder & progress into shuttle, ending when finish & remain here or progressing into the finishing
service.

Use The TrainDataVectorCopy as that has all unique service refs.

2nd run the cdt checker similar to that in SecondPassActions, but where a same name found either side of a changeover code quote both refs.  Add a
similar unexpected cdt check where if have different locs either side of a cdt then may be inappropriate.

First create a new TrainDataVector from earlier copy as above with single services
*/
        if(DirChecked)
        {
     //direction analysis added at v2.10.0
            TTrainDataEntry SingleServiceEntry, PartServiceEntry, NewPartServiceEntry, TempEntry;
            TTrainDataVector SingleServiceVector, PartServiceVector;

    //find new train services (Snt or Snt-sh) & remember that entries can be in any order
    //NB: ALWAYS use OtherHeadCode (which is now a service reference) for any follow-on service
            TTFile3 << "Train direction analysis - consisting of train facing directions on creation and possible missing or questionable changes of direction:\n\n";
            for(unsigned int x = 0; x < TrainDataVectorCopy.size(); x++)
            {
                TTrainDataEntry TDE = TrainDataVectorCopy.at(x);
                if(TDE.ActionVector.at(TDE.ActionVector.size() - 1).FormatType == Repeat)
                {
                    TDE.ActionVector.erase(TDE.ActionVector.end() - 1); //strip repeat entry if present
                }
                const TActionVector &AV = TDE.ActionVector;
                if((AV.at(0).Command == "Snt") || (AV.at(0).Command == "Snt-sh"))
                {
                    SingleServiceEntry = TDE;
                    TActionVector &SSAV = SingleServiceEntry.ActionVector;
                    for(unsigned int y = 0; y < SSAV.size(); y++)
                    {
                        if((SSAV.at(y).Command == "Fjo") || (SSAV.at(y).Command == "Frh") || (SSAV.at(y).Command == "Fer") || (SSAV.at(y).Command == "Frh-sh"))
                        {
                            SingleServiceVector.push_back(SingleServiceEntry); //push the complete entry
                            break; //finished with this one
                        }
                        else if((SSAV.at(y).Command == "fsp") || (SSAV.at(y).Command == "rsp"))
                        {
                            PartServiceEntry = TDE; //start with complete entry
                            PartServiceEntry.ActionVector.clear(); //clear AV
                            for(unsigned int z = 0; z <= y; z++)
                            {
                                PartServiceEntry.ActionVector.push_back(TDE.ActionVector.at(z)); //add back all AVs up to & inc fsp/rsp
                                if(z == y)
                                {
                                    PartServiceEntry.ActionVector.at(z).Command = "chr-sp"; //change split command to chr
                                    PartServiceEntry.ActionVector.at(z).OtherHeadCode = PartServiceEntry.ActionVector.at(z).LinkedTrainEntryPtr->ServiceReference;
                                }
                            }
                            PartServiceVector.push_back(PartServiceEntry);
                            if(SSAV.at(y).Command == "fsp")
                            {
                                SSAV.at(y).Command = "Front split - original service continues below";
                                SSAV.at(y).OtherHeadCode = "";
                            }
                            if(SSAV.at(y).Command == "rsp")
                            {
                                SSAV.at(y).Command = "Rear split - original service continues below";
                                SSAV.at(y).OtherHeadCode = "";
                            }
                            //don't break & continue here because the original train carries on
                        }
                        else if(SSAV.at(y).Command == "Fns")
                        {
                            SSAV.at(y).Command = "chr-Fns";
                            SSAV.at(y).OtherHeadCode = SSAV.at(y).LinkedTrainEntryPtr->ServiceReference;
                            PartServiceVector.push_back(SingleServiceEntry); //not complete yet
                            break; //from y loop
                        }
                        else if(SSAV.at(y).Command == "Fns-sh")
                        {
                            SSAV.at(y).Command = "chr-Fns-sh";
                            SSAV.at(y).OtherHeadCode = SSAV.at(y).NonRepeatingShuttleLinkEntryPtr->ServiceReference;
                            SSAV.at(y).NonRepeatingShuttleLinkHeadCode = "";
                            PartServiceVector.push_back(SingleServiceEntry); //not complete yet
                            break; //from y loop
                        }
                        else if(SSAV.at(y).Command == "F-nshs")
                        {
                            SSAV.at(y).Command = "chr-F-nshs"; //NonRepeatingShuttleLinkHeadCode is the shuttle headcode
                            SSAV.at(y).OtherHeadCode = SSAV.at(y).LinkedTrainEntryPtr->ServiceReference;
                            SSAV.at(y).NonRepeatingShuttleLinkHeadCode = "";
                            PartServiceVector.push_back(SingleServiceEntry); //not complete yet
                            break; //from y loop
                        }
                    }
                }
            }
            SequenceLog += "10\n";
            //now have all complete entries in SingleServiceVector and all part services in PartServiceVector but without any follow-ons

            //Now add Sns & Sns-sh services to PartServiceVector entries
            AnsiString NextRef;
            while(!PartServiceVector.empty())
            {
                PartServiceEntry = PartServiceVector.at(0); //deal with front entry and add new entries at the back
                for(unsigned int y = 0; y < PartServiceEntry.ActionVector.size(); y++)
                {
                    if(PartServiceEntry.ActionVector.at(y).Command.SubString(1,3) == "chr")
                    {
                          NextRef = PartServiceEntry.ActionVector.at(y).OtherHeadCode;
                    }
                }
                //find it in TrainDataVectorCopy
                bool FinishType = true, FoundFlag = false;
                while(FinishType)
                {
                    TempEntry = GetServiceFromVector(0, NextRef, TrainDataVectorCopy, FinishType, FoundFlag); //FinishType is a bool where false = Final (Fjo, Frh, Fer, or
                                                                                                //Frh-sh); true = MoreToCome (Fns, Fns-sh, F-nshs)
                    if(FoundFlag)
                    {
                        for(unsigned int y = 1; y < TempEntry.ActionVector.size(); y++) //starts at 1 as that is the entry after the start entry
                        {
                            if((TempEntry.ActionVector.at(y).Command == "") && (TempEntry.ActionVector.at(y).FormatType != Repeat))
                            {
                                PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y));
                            }
                            else if((TempEntry.ActionVector.at(y).Command[1] != 'F') && (TempEntry.ActionVector.at(y).Command != "fsp") && (TempEntry.ActionVector.at(y).Command != "rsp") && (TempEntry.ActionVector.at(y).FormatType != Repeat))
                            {
                                PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y));
                            }
                            else
                            {
                                if((TempEntry.ActionVector.at(y).Command == "Fjo") || (TempEntry.ActionVector.at(y).Command == "Frh") || (TempEntry.ActionVector.at(y).Command == "Fer") || (TempEntry.ActionVector.at(y).Command == "Frh-sh"))
                                {
                                    PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y));
                                    SingleServiceVector.push_back(PartServiceVector.at(0)); //push the complete entry
                                    PartServiceVector.erase(PartServiceVector.begin());
                                    break; //from y loop
                                }
                                else if((TempEntry.ActionVector.at(y).Command == "fsp") || (TempEntry.ActionVector.at(y).Command == "rsp"))
                                {
                                    NewPartServiceEntry = PartServiceVector.at(0); //covers everything up to but excluding the split
                                    NewPartServiceEntry.ActionVector.push_back(TempEntry.ActionVector.at(y)); //now includes the split
                                    NewPartServiceEntry.ActionVector.at(NewPartServiceEntry.ActionVector.size() - 1).Command = "chr-sp"; //change split command to chr
                                    NewPartServiceEntry.ActionVector.at(NewPartServiceEntry.ActionVector.size() - 1).OtherHeadCode = NewPartServiceEntry.ActionVector.at(NewPartServiceEntry.ActionVector.size() - 1).LinkedTrainEntryPtr->ServiceReference;
                                    PartServiceVector.push_back(NewPartServiceEntry); //new entry for the split service
                                    if(TempEntry.ActionVector.at(y).Command == "fsp")
                                    {
                                        TempEntry.ActionVector.at(y).Command = "Front split - original service continues below";
                                        TempEntry.ActionVector.at(y).OtherHeadCode = "";
                                    }
                                    if(TempEntry.ActionVector.at(y).Command == "rsp")
                                    {
                                        TempEntry.ActionVector.at(y).Command = "Rear split - original service continues below";
                                        TempEntry.ActionVector.at(y).OtherHeadCode = "";
                                    }
                                    PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y));
                                }
                                else if(TempEntry.ActionVector.at(y).Command == "Fns")
                                {
                                    TempEntry.ActionVector.at(y).Command = "chr-Fns";
                                    NextRef = TempEntry.ActionVector.at(y).LinkedTrainEntryPtr->ServiceReference;
                                    TempEntry.ActionVector.at(y).OtherHeadCode = NextRef;
                                    PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y)); //not complete yet
                                    break; //from y loop
                                }
                                else if(TempEntry.ActionVector.at(y).Command == "Fns-sh")
                                {
                                    TempEntry.ActionVector.at(y).Command = "chr-Fns-sh";
                                    TempEntry.ActionVector.at(y).OtherHeadCode = TempEntry.ActionVector.at(y).NonRepeatingShuttleLinkEntryPtr->ServiceReference;
                                    TempEntry.ActionVector.at(y).NonRepeatingShuttleLinkHeadCode = "";
                                    NextRef = TempEntry.ActionVector.at(y).NonRepeatingShuttleLinkEntryPtr->ServiceReference;
                                    PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y)); //not complete yet
                                    break; //from y loop
                                }
                                else if(TempEntry.ActionVector.at(y).Command == "F-nshs")
                                {
                                    TempEntry.ActionVector.at(y).Command = "chr-F-nshs"; //NonRepeatingShuttleLinkHeadCode is the shuttle headcode
                                    TempEntry.ActionVector.at(y).OtherHeadCode = TempEntry.ActionVector.at(y).LinkedTrainEntryPtr->ServiceReference;
                                    TempEntry.ActionVector.at(y).NonRepeatingShuttleLinkHeadCode = "";
                                    NextRef = TempEntry.ActionVector.at(y).LinkedTrainEntryPtr->ServiceReference;
                                    PartServiceVector.at(0).ActionVector.push_back(TempEntry.ActionVector.at(y)); //not complete yet
                                    break; //from y loop
                                }
                            }
                        }
                    }
                    else
                    {
                        SequenceLog +=  + "11\n";
                        throw Exception("Unable to find service reference " + NextRef + " Last ref checked = " + TempEntry.ServiceReference);
                    }
                }
            }
            if(!PartServiceVector.empty())
            {
                SequenceLog += "12\n";
                throw Exception("PartServiceVector should be empty here - size = " + AnsiString(PartServiceVector.size()));
            }
            SequenceLog += "13\n";
    /*
      form:-
      HeadCode[;Description (plain text, no commas or semicolons)][;StartSpeed(kph); MaxRunningSpeed(kph); Mass(tonnes, prog converts to kg);
      MaxBrakeRate(tonnes force, prog converts to m/s/s); & gross power(kW, prog converts to power at rail in w)
      then multiple entries, separated by commas, of the form:-

      HH:MM;Snt;RearStartIdent FrontStartIdent                    }StartNew                }
      HH:MM;Snt-sh;RearStartIdent FrontStartIdent;Fsh HeadCode    }SNTShuttle              }
      HH:MM;Sns-sh;Fxx-sh HeadCode;F-nshs HeadCode (non-repeating)}SNSShuttle              }

      HH:MM;Command;HeadCode (Sfs Sns jbo fsp rsp Fns Fjo Frh-sh) }TimeCmdHeadCode         }  Train action entries
      HH:MM;F-nshs;NonRepeatingShuttleLinkHeadCode                }FNSNonRepeatToShuttle   }
      HH:MM;Sns-fsh;NonRepeatingShuttleLinkHeadCode               }SNSNonRepeatFromShuttle }

      HH:MM;Command (cdt)                                         }TimeCmd                 }
      HH:MM;Location (arr & dep)                                  }TimeLoc                 }
      HH:MM;HH:MM;Location                                        }TimeTimeLoc             }
      HH:MM;pas;Location                                          }PassTime                }
      HH:MM;Fns-sh;Snx-sh HeadCode;Sns-fsh HeadCode (non-rep)     }FSHNewService           }
      HH:MM;Fer;set of allowable IDs                              }ExitRailway             }
      Command   (Frh only)                                        }FinRemHere              }

      R;mm;dd;nn.                                                  Repeat                      Repeat entry

      Formats:

      Command only:                               Frh
      Time;Command:                               cdt
      Time;Command;Headcode:                      Sfs Sns jbo fsp rsp Fns Fjo Frh-sh F-nshs Sns-fsh
      Time;Command;2 Element IDs:                 Snt
      Time;Comand;n Element IDs:                  Fer
      Time;Command;rep Headcode;nonrep Headcode:  Sns-sh Fns-sh
      Time;Command;2 Element IDs;Headcode         Snt-sh
      Time;Command;Location                       pas
      Time;Location                               Arr Dep
      Time;Time;Location                          Arr & dep together
    */

/*
Perform the starting direction check (Snt & Snt-sh entries).  Starts with the train's front element,
checking forwards until it comes to a continuation (no report), a location name that is not null and
different to the train's front element name (whether null or not) (no report), a leading point
(no report) or buffers (report).
*/
            bool BufferFacingUnReportedFlag = true;
            for(unsigned int x = 0; x < SingleServiceVector.size(); x++)
            {
                TTrackElement ThisElement, NextElement;
                TTrainDataEntry TDE = SingleServiceVector.at(x);
                if(TDE.ActionVector.at(TDE.ActionVector.size() - 1).FormatType == Repeat)
                {
                    SequenceLog += "13a\n";
                    throw Exception("Repeat entry present in SingleServiceVector at position " + AnsiString(x));
                }
                const TActionVector &AV = TDE.ActionVector;
                if((AV.at(0).Command == "Snt") || (AV.at(0).Command == "Snt-sh"))
                {
                    bool BufferFlag = false;
                    int FrontTVPos = AV.at(0).FrontStartOrRepeatDigits;
                    int RearTVPos =  AV.at(0).RearStartOrRepeatMins;
                    AnsiString FrontLocName = AV.at(0).LocationName;
                    int NextEntryPos, NextExitPos;
                    ThisElement = Track->TrackElementAt(1395, FrontTVPos);
                    int ThisExitPos;
                    if(ThisElement.Conn[0] == RearTVPos)
                    {
                        ThisExitPos = 1;
                    }
                    else if(ThisElement.Conn[1] == RearTVPos)
                    {
                        ThisExitPos = 0;
                    }
                    else if(ThisElement.Conn[2] == RearTVPos)
                    {
                        ThisExitPos = 3;
                    }
                    else if(ThisElement.Conn[3] == RearTVPos)
                    {
                        ThisExitPos = 2;
                    }
                    if((ThisElement.TrackType == Buffers) && (ThisExitPos == 0))//pos 0 is the buffer
                    {
                        BufferFlag = true;
                    }
                    else //continue tracking forwards
                    {
                        while(true)
                        {
                            if(ThisElement.Conn[ThisExitPos]  == -1)
                            {
                                SequenceLog = "13b\n";
                                throw Exception("ThisElement connects to -1 for " + TDE.ServiceReference);
                            }
                            NextElement = Track->TrackElementAt(1396, ThisElement.Conn[ThisExitPos]);
                            NextEntryPos = ThisElement.ConnLinkPos[ThisExitPos];
                            if((NextElement.TrackType == Points) && ((NextEntryPos == 0) || (NextEntryPos == 2))) //leading points
                            {
                                BufferFlag = false; //should already be false
                                break;
                            }
                            else if(NextElement.TrackType == Continuation)
                            {
                                BufferFlag = false;
                                break;
                            }
                            else if((NextElement.ActiveTrackElementName != "") && (NextElement.ActiveTrackElementName != FrontLocName))
                            {
                                BufferFlag = false;
                                break;
                            }
                            else if(NextElement.TrackType == Buffers)
                            {
                                BufferFlag = true;
                                break;
                            }
                            else if((NextElement.TrackType == Points) && ((NextEntryPos == 1) || (NextEntryPos == 3))) //trailing points
                            {
                                ThisElement = NextElement;
                                ThisExitPos = 0;
                                continue;
                            }
                            else
                            {
                                if(NextEntryPos == 0)
                                {
                                    NextExitPos = 1;
                                }
                                else if(NextEntryPos == 1)
                                {
                                    NextExitPos = 0;
                                }
                                else if(NextEntryPos == 2)
                                {
                                    NextExitPos = 3;
                                }
                                else if(NextEntryPos == 3)
                                {
                                    NextExitPos = 2;
                                }
                            }
                            ThisElement = NextElement;
                            ThisExitPos = NextExitPos;
                        }
                    }
                    if(BufferFlag)
                    {
                        if(BufferFacingUnReportedFlag)
                        {
                            TTFile3 << "Train facing direction on creation analysis:-\n\n";
                            BufferFacingUnReportedFlag = false;
                        }
                        TTFile3 << "Service " + TDE.ServiceReference + " facing buffers on creation\n";
                    }
                }
            }
            if(BufferFacingUnReportedFlag)
            {
                TTFile3 << "Nothing to report for train facing directions\n\n";
            }
            else
            {
                TTFile3 << '\n';
            }
            SequenceLog += "13c\n";

    //Perform the missing cdt check.  Check every entry simiar to the check in SecondPassActions and if find any print out the full sequence and service entries
            AnsiString LocationNameToBeChecked = "";
            bool MissingcdtUnreportedFlag = true;
            TNumList MarkerList;
            for(unsigned int x = 0; x < SingleServiceVector.size(); x++)
            {
                const TTrainDataEntry &TDEntry = SingleServiceVector.at(x);
                unsigned int y = 0;
                int FirstInstance = 9999, SecondInstance = 9999; //9999 ensures won't be marked if not changed
                bool FullBreak = false;
                MarkerList.clear();
                const TActionVectorEntry &AVEntry0 = TDEntry.ActionVector.at(0);
                // first discard unlocated Snt entries as they don't have location name set
                if((AVEntry0.Command == "Snt") && (AVEntry0.LocationType == EnRoute))
                {
                    y = 1;
                }
                while((y < TDEntry.ActionVector.size()) && !FullBreak)
                // need to check each location name separately in turn, skipped for SignallerControl entries
                {
                    if((TDEntry.ActionVector.at(y).Command == "Fer") || (TDEntry.ActionVector.at(y).FormatType == Repeat) ||
                        (TDEntry.ActionVector.at(y).Command == "Fjo") || (TDEntry.ActionVector.at(y).Command == "Frh") ||
                        (TDEntry.ActionVector.at(y).Command == "Frh-sh"))
                    {
                        break; // out of the 'while' loop since have reached the end
                    }
                    LocationNameToBeChecked = TDEntry.ActionVector.at(y).LocationName;
                    FirstInstance = y;
                    for(unsigned int z = y; z < TDEntry.ActionVector.size(); z++)
                    {
                        const TActionVectorEntry &AVEntry = TDEntry.ActionVector.at(z);
                        if((AVEntry.Command == "Fer") || (AVEntry.FormatType == Repeat) ||
                            (AVEntry.Command == "Fjo") || (AVEntry.Command == "Frh") ||
                            (AVEntry.Command == "Frh-sh"))
                        {
                            break; // out of the 'z' loop since have reached the end & 'Fer' & 'Repeat' have no location name set
                        }
                        if(AVEntry.Command == "cdt")
                        {
                            break; // out of the 'z' loop since the check is only valid up to a change of direction
                        }
                        if(AVEntry.LocationName == LocationNameToBeChecked)
                        {
                            continue; // keep going while name same
                        }
                        if(AVEntry.LocationName != LocationNameToBeChecked)
                        // if name different check forwards to see if repeats
                        {
                            for(unsigned int a = z; a < TDEntry.ActionVector.size(); a++)
                            {
                                if(TDEntry.ActionVector.at(a).Command == "cdt")
                                {
                                    break; // out of the 'a' & 'z' loops since the check is only valid up to a change of direction
                                }
                                if(TDEntry.ActionVector.at(a).LocationName == LocationNameToBeChecked)
                                {
                                    SecondInstance = a;
                                    AnsiString Sequence = TDEntry.ServiceReference;
                                    for(unsigned int b = 0; b < TDEntry.ActionVector.size(); b++)
                                    {
                                        if(TDEntry.ActionVector.at(b).Command.SubString(1,3) == "chr")
                                        {
                                            Sequence = Sequence + AnsiString(" -> ") + TDEntry.ActionVector.at(b).OtherHeadCode;
                                        }
                                    }
                                    if(MissingcdtUnreportedFlag)
                                    {
                                        TTFile3 << "Possibly missing changes of direction - these will be missing unless the service travels in a loop back to the locations marked:-\n\n";
                                    }
                                    TTFile3 << LocationNameToBeChecked << " is listed twice with no direction change between in service sequence: " << Sequence << "\n\n";
                                    MarkerList.push_back(FirstInstance);
                                    MarkerList.push_back(SecondInstance);
                                    SingleServiceOutput(0, x, MarkerList, SingleServiceVector, TTFile3);
                                    MissingcdtUnreportedFlag = false;
                                    FullBreak = true; //no more checks for this sequence
                                    break; //out of the a & z loops
                                }
                            }
                            break; // out of the 'z' loop since have checked 'a' as far as need to
                        }
                    }
                    y++;
                }
            }
            if(MissingcdtUnreportedFlag)
            {
                TTFile3 << "Nothing to report for missing changes of direction\n\n";
            }
            else
            {
                TTFile3 << '\n';
            }
            SequenceLog += "14\n";

/*  Perform the questionable cdt check. Examine each service in the SingleServiceVector, and if don't find the same
    name either side of a cdt (before the next cdt) then flag as a questionable cdt.
    Method:  Have an outer loop for each service that looks for cdts.  When found work backwards to the last cdt or beginning and std::list all the
    locations excluding the cdt location.  Then work forwards to the next cdt or the end and do the same.  Sort each list and make unique (duplicated
    names on one side of a cdt already checked either by the tt validator or the missing cdt check.  Then compare the two lists and if any location
    included in both then ok, else report as questionable. If one list is empty then it is reported.
*/
            typedef std::list<AnsiString> TLocList;
            TLocList BackwardList, ForwardList;
            bool IntroLineNeeded = true;
            for(unsigned int x = 0; x < SingleServiceVector.size(); x++)
            {
                unsigned int cdtPosition = 9999;
                AnsiString cdtLocation = "";
                bool FoundSameName = false;
                MarkerList.clear();
                const TTrainDataEntry &TDEntry = SingleServiceVector.at(x);
                for(unsigned int y = 0; y < TDEntry.ActionVector.size(); y++)
                // need to check each location name separately in turn, skipped for SignallerControl entries
                {
                    BackwardList.clear();
                    ForwardList.clear();
                    const TActionVectorEntry &AVEntry = TDEntry.ActionVector.at(y);
                    if((AVEntry.Command == "Fer") || (AVEntry.FormatType == Repeat) ||  //end of SSVector, shouldn't be any repeats
                        (AVEntry.Command == "Fjo") || (AVEntry.Command == "Frh") ||
                        (AVEntry.Command == "Frh-sh"))
                    {
                        if(MarkerList.empty())
                        {
                            break; // out of the 'y' loop since have reached the end & nothing to report
                        }
                        else
                        {
                            AnsiString Sequence = TDEntry.ServiceReference;
                            for(unsigned int b = 0; b < TDEntry.ActionVector.size(); b++)
                            {
                                if(TDEntry.ActionVector.at(b).Command.SubString(1,3) == "chr")
                                {
                                    Sequence = Sequence + AnsiString(" -> ") + TDEntry.ActionVector.at(b).OtherHeadCode;
                                }
                            }
                            MarkerList.sort();
                            if(IntroLineNeeded)
                            {
                                TTFile3 << "Questionable change of direction analysis.\n\n";
                                TTFile3 << "For marked changes of direction there are no same-name locations listed both above (up to the start or another direction change)\n";
                                TTFile3 << "and below (down to the end or another direction change) but not counting the change of direction location itself.\n\n";
                                TTFile3 << "These changes of direction are probably valid for movements to and from depots but all should be checked to\n";
                                TTFile3 << "make sure that none has been included incorrectly:\n\n";
                                IntroLineNeeded = false;
                            }
                            TTFile3 << "Service sequence " << Sequence << " contains questionable changes of direction:-\n\n";
                            SingleServiceOutput(1, x, MarkerList, SingleServiceVector, TTFile3);
                            break;
                        }
                    }
                    if(AVEntry.Command != "cdt")
                    {
                        continue; //only looking for cdts
                    }
                    //here have found a cdt
                    cdtPosition = y;
                    cdtLocation = AVEntry.LocationName;
                    for(int z = y - 1; z >= 0; z--)
                    {
                        const TActionVectorEntry &AVEntry2 = TDEntry.ActionVector.at(z);
                        if(AVEntry2.Command == "cdt")
                        {
                            break; //don't look further back than the last cdt
                        }
                        if((AVEntry2.LocationName != "") && (AVEntry2.LocationName != cdtLocation)) //if an earlier entry == cdtLocation will have been picked up in an earlier check
                        {
                            BackwardList.push_back(AVEntry2.LocationName);
                        }
                    }
                    BackwardList.sort();
                    BackwardList.unique();
                    for(unsigned int z = y + 1; z < TDEntry.ActionVector.size(); z++)
                    {
                        const TActionVectorEntry &AVEntry3 = TDEntry.ActionVector.at(z);
                        if((AVEntry3.Command == "Fer") || (AVEntry3.FormatType == Repeat) ||
                            (AVEntry3.Command == "Fjo") || (AVEntry3.Command == "Frh") ||
                            (AVEntry3.Command == "Frh-sh") || (AVEntry3.Command == "cdt"))
                        {
                            break; // out of the 'z' loop since have reached another cdt or the end
                        }
                        if((AVEntry3.LocationName != "") && (AVEntry3.LocationName != cdtLocation)) //if a later entry == cdtLocation will have been picked up in an earlier check
                        {
                            ForwardList.push_back(AVEntry3.LocationName);
                        }
                    }
                    ForwardList.sort();
                    ForwardList.unique();
                    FoundSameName = false;
                    //now have both lists compiled (may be empty) so check for same name in both & report if don't find any
                    if(!BackwardList.empty() && !ForwardList.empty())
                    {
                        for(TLocList::iterator BLIt = BackwardList.begin(); BLIt != BackwardList.end(); BLIt++)
                        {
                            for(TLocList::iterator FLIt = ForwardList.begin(); FLIt != ForwardList.end(); FLIt++)
                            {
                                if(*BLIt == *FLIt)
                                {
                                    FoundSameName = true;
                                }
                            }
                        }
                    }
                    if(!FoundSameName) //report the inability to find same name
                    {
                        MarkerList.push_back(cdtPosition);
                    }
                }
            }
            if(IntroLineNeeded)
            {
                TTFile3 << "Nothing to report for questionable changes of direction\n\n";
            }
            else
            {
                TTFile3 << '\n';
            }
/*
//debug section
//print all SSVector for diagnostic purposes
            TTFile3 << "Whole SSVector\n\n";
            TNumList EmptyList;
            for(unsigned int x = 0; x < SingleServiceVector.size(); x++)
            {
                SingleServiceOutput(, x, EmptyList, SingleServiceVector, TTFile3);
            }
//end of debug section
*/
        }
        SequenceLog += "15\n";
        TTFile3.close();
        Utilities->CallLogPop(2212);
        return(true);
    }

    catch(const Exception &e) //non error catch
    {
        AnsiString TTErrorFileName = "Analysis Error.txt";
        TTErrorFileName = CurDir + "\\Formatted timetables\\" + TTErrorFileName;
        std::ofstream TTError(TTErrorFileName.c_str());
        if(TTError == 0)
        {
            ShowMessage("Analysis error file failed to open - can't be created");
            Utilities->CallLogPop(2233);
            return(false);
        }
        AnsiString TimeNow = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        TTError << TimeNow.c_str() << '\n' << ArrRange << '\n' << ArrChecked << '\n' << DepRange << '\n' <<
        DepChecked << '\n' << AtLocChecked << '\n' << SequenceLog << '\n' << AnsiString(e.Message);

        TTError.close();
        ShowMessage("Error in Conflict Analysis: A file called 'Analysis Error.txt' has been created in your Formatted timetables folder. Please send this file together with your railway and timetable files to railwayfeedback@gmail.com for investigation - many thanks");
        Utilities->CallLogPop(2226);
        return(false);
    }
}

// ---------------------------------------------------------------------------
void TTrainController::SingleServiceOutput(int Caller, int SSVectorNumber, TNumList MarkerList, TTrainDataVector &SingleServiceVector, std::ofstream &VecFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + AnsiString(SSVectorNumber) + ',' + ",SingleServiceOutput");
    if((SSVectorNumber < 0) || ((unsigned int)SSVectorNumber >= SingleServiceVector.size()))
    {
        throw Exception("SSVectorNumber out of range, = " + AnsiString(SSVectorNumber) + ", Vector size = " + SingleServiceVector.size());
    }
    TTrainDataEntry SingleService = SingleServiceVector.at(SSVectorNumber);
        {
        VecFile << ",Initial service reference " << SingleService.ServiceReference + '\n';
        AnsiString Marker = "";
        for(unsigned int x = 0; x < SingleService.ActionVector.size(); x++)
        {
            Marker = ',';
            for(TNumListIterator MLIt = MarkerList.begin(); MLIt != MarkerList.end(); MLIt++)
            {
                if(int(x) == *MLIt)
                {
                    Marker = "-->,";
                    break;
                }
            }
            TActionVectorEntry AVE = SingleService.ActionVector.at(x);
            if(AVE.FormatType == StartNew)
            {
                AnsiString RearID = Track->TrackElementAt(1397, AVE.RearStartOrRepeatMins).ElementID;
                AnsiString FrontID = Track->TrackElementAt(1398, AVE.FrontStartOrRepeatDigits).ElementID;
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << RearID << ' ' << FrontID << '\n';
            }
            if(AVE.FormatType == SNTShuttle)
            {
                AnsiString RearID = Track->TrackElementAt(1399, AVE.RearStartOrRepeatMins).ElementID;
                AnsiString FrontID = Track->TrackElementAt(1400, AVE.FrontStartOrRepeatDigits).ElementID;
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << RearID << ' ' << FrontID << ' ' << AVE.OtherHeadCode << '\n';
            }
            if(AVE.FormatType == SNSShuttle) //should all have been converted to chr
            {
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << AVE.OtherHeadCode << ' ' << AVE.NonRepeatingShuttleLinkHeadCode << '\n';
            }
            if(AVE.FormatType == Repeat) //shouldn't be any repeats, only here to show if any have been copied
            {
                VecFile << Marker << "Repeat " << AVE.RearStartOrRepeatMins << ' ' << AVE.FrontStartOrRepeatDigits << ' ' << AVE.NumberOfRepeats << '\n';
            }
            if((AVE.FormatType == TimeCmd) || (AVE.FormatType == TimeCmdHeadCode) || (AVE.FormatType == FNSNonRepeatToShuttle) || (AVE.FormatType == FSHNewService))
            {
                TActionVectorEntry AVHolder = AVE;
                if(AVE.Command.SubString(1,3) == "chr")
                {
                    if(AVE.Command.SubString(5, AVE.Command.Length() - 4) == "sp")
                    {
                        AVE.Command = "Change of service to " + AVE.OtherHeadCode + " after split";
                        AVE.OtherHeadCode = "";
                    }
                    if(AVE.Command.SubString(5, AVE.Command.Length() - 4) == "Fns")
                    {
                        AVE.Command = "Change of service to ";
                    }
                    if(AVE.Command.SubString(5, AVE.Command.Length() - 4) == "Fns-sh")
                    {
                        AVE.Command = "Change to shuttle finishing service";
                    }
                    if(AVE.Command.SubString(5, AVE.Command.Length() - 4) == "F-nshs")
                    {
                        AVE.Command = "Change to shuttle service " + AVE.OtherHeadCode + " from feeder";
                        AVE.OtherHeadCode = "";
                    }
                }
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << ' ' << AVE.Command << ' ' << AVE.OtherHeadCode << '\n';
                AVE = AVHolder;
            }
            else if((AVE.FormatType == TimeLoc) && (AVE.ArrivalTime != TDateTime(-1)))
            {
                VecFile << Marker << Utilities->Format96HHMM(AVE.ArrivalTime) << " Arr " << AVE.LocationName << '\n';
            }
            else if((AVE.FormatType == TimeLoc) && (AVE.DepartureTime != TDateTime(-1)))
            {
                VecFile << Marker << Utilities->Format96HHMM(AVE.DepartureTime) << " Dep " << AVE.LocationName << '\n';
            }
            else if(AVE.FormatType == TimeTimeLoc)
            {
                VecFile << Marker << Utilities->Format96HHMM(AVE.ArrivalTime) << ' ' << Utilities->Format96HHMM(AVE.DepartureTime) << ' ' << AVE.LocationName << '\n';
            }
            else if(AVE.FormatType == PassTime)
            {
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << ' ' << "Pass" << ' ' << AVE.LocationName << '\n';
            }
            else if(AVE.FormatType == ExitRailway) //ListOfExits added at v2.10.0
            {
                AnsiString ListOfExits = "";
                for(TNumListIterator NLIt = AVE.ExitList.begin(); NLIt != AVE.ExitList.end(); NLIt++)
                {
                    ListOfExits += AnsiString(Track->TrackElementAt(1432, *NLIt).ElementID) + ' ';
                }
                VecFile << Marker << Utilities->Format96HHMM(AVE.EventTime) << " Fer " << ListOfExits <<'\n';
            }
            else if(AVE.FormatType == FinRemHere)
            {
                VecFile << Marker << "Frh" << '\n';
            }
        }
        VecFile << '\n';
    }
    Utilities->CallLogPop(2318);
}

// ---------------------------------------------------------------------------

TTrainDataEntry TTrainController::GetServiceFromVector(AnsiString Caller, AnsiString HeadCode, TTrainDataVector Vector, bool &FinishType, bool &FoundFlag)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetServiceFromVector," + HeadCode);
    FoundFlag = false;
    FinishType = true;
    for(unsigned int x = 0; x < Vector.size(); x++)
    {
//        AnsiString ThisRef = Vector.at(x).ServiceReference;
        if(Vector.at(x).ServiceReference == HeadCode)
        {
            if(Vector.at(x).ActionVector.at(Vector.at(x).ActionVector.size() - 1).FormatType == Repeat) //shouldn't be any repeats
            {
                TActionVectorEntry AVE = Vector.at(x).ActionVector.at(Vector.at(x).ActionVector.size() - 2);
                if((AVE.Command == "Fjo") || (AVE.Command == "Frh") || (AVE.Command == "Fer") || (AVE.Command == "Frh-sh"))
                {
                    FinishType = false;
                }
            }
            else
            {
                TActionVectorEntry AVE = Vector.at(x).ActionVector.at(Vector.at(x).ActionVector.size() - 1);
                if((AVE.Command == "Fjo") || (AVE.Command == "Frh") || (AVE.Command == "Fer") || (AVE.Command == "Frh-sh"))
                {
                    FinishType = false;
                }
            }
            FoundFlag = true;
            Utilities->CallLogPop(2319);
            return(Vector.at(x));
        }
    }
    Utilities->CallLogPop(2320);
    return(Vector.at(Vector.size() - 1)); //return last for want of returning something
}

// ---------------------------------------------------------------------------

bool TTrainController::WithinTimeRange(int Caller, AnsiString Time1, AnsiString Time2, int MinuteRange) //times are "HH:MM"
{
//convert times to integer minutes
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",WithinTimeRange," + Time1 + "," + Time2 + "," + AnsiString(MinuteRange));
    if((Time1 == "") || (Time2 == ""))
    {
        Utilities->CallLogPop(2213);
        return(false);
    }
    int Mins = Time1.SubString(4,2).ToInt();
    int Hours = Time1.SubString(1,2).ToInt();
    int Time1Mins = (Hours * 60) + Mins;
    Mins = Time2.SubString(4,2).ToInt();
    Hours = Time2.SubString(1,2).ToInt();
    int Time2Mins = (Hours * 60) + Mins;
    if(abs(Time1Mins - Time2Mins) <= MinuteRange)
    {
        Utilities->CallLogPop(2214);
        return(true);
    }
    Utilities->CallLogPop(2215);
    return(false);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::ConsolidateSARNTArrDep(int Caller, const AnsiString Input, int &NumTrainsAtLoc, AnsiString Location, bool Arrival,
                                                    bool &AnalysisError, int &MaxNumberOfSameDirections)
{
    //input consists of services and service Arr or Dep times as a comma separated list, Location needed to determine direction information

    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ConsolidateSARNTArrDep," + Input);
        AnsiString Output = "", OneService = "", TempStr1 = "", TempStr2 = "";
        int SCPos = 0;
        std::list<AnsiString> ServiceList; //this is the list of services with times extracted from Input - not to be confused with ServiceCallingPointsList
        //first change every second comma in Input to a semicolon so can separate services but keep times with services
        bool EvenComma = false;
        for(int x = 1; x <= Input.Length(); x++)
        {
            TempStr1 = Input[x];
            if(TempStr1 == AnsiString(',') && EvenComma)
            {
                TempStr2 += ';';
            }
            else
            {
                TempStr2 += Input[x];
            }
            if(TempStr1 == AnsiString(','))
            {
                EvenComma = !EvenComma;
            }
        }
        //load up the list of services with associated times
        while(TempStr2.Length() > 0)
        {
            SCPos = TempStr2.Pos(';');
            if(SCPos > 0) //0 if not found, as won't be when only one service left
            {
                OneService = TempStr2.SubString(1, SCPos - 1);
                ServiceList.push_back(OneService);
                TempStr2 = TempStr2.SubString(SCPos + 1, TempStr2.Length() - SCPos);
            }
            else //no semicolon so looking at last (or only) element
            {
                ServiceList.push_back(TempStr2);
                TempStr2 = "";
            }
        }
        ServiceList.sort(); // alphabetical order
        ServiceList.unique(); //remove duplicates
        NumTrainsAtLoc = ServiceList.size(); //calc this after removing duplicates as may not have changed

        //now add direction information from AllServiceCallingLocsMap - key is service ref and value a list of calling points in order
        int DirectionMarker = 0;  //this is added in & runs from 1 upwards, same marker for diff services = same direction
        //first add the direction marker "&0" for not yet allocated - '&' is an identifier
        std::list<AnsiString>::iterator SLIt, SLIt1, SLIt2, SLIt3;

        for(SLIt = ServiceList.begin(); SLIt != ServiceList.end(); SLIt++)
        {
            *SLIt = *SLIt + "&0"; //add in a basic direction marker to each service
        }
        SLIt3 = ServiceList.end();
        SLIt3--; //so points to last element
        AnsiString ServiceRef1, ServiceRef2, AnsiTime1, AnsiTime2, RepeatInfo1, RepeatInfo2;  //1 refers to first for..next loop & 2 to second
        int AmpersandPos, SpacePos, CommaPos1, CommaPos2, RepeatNum1, RepeatNum2;
        TAllServiceCallingLocsMap::iterator ASCLIt1, ASCLIt2;
        TServiceCallingLocsList ServiceCallingLocsList1, ServiceCallingLocsList2;
        MaxNumberOfSameDirections = 0; //at end of each SLIt loop if SameDirectionCount > MaxNumberOfSameDirections then MaxNumberOfSameDirections = SameDirectionCount
        int SameDirectionCount = 0; //starts at 1 at each SLIt loop (because SLIt1 entry already has a DirectionMarker) and increments for every same direction

        for(std::list<AnsiString>::iterator SLIt1 = ServiceList.begin(); SLIt1 != SLIt3; SLIt1++) //should be end() - 1 but can't use -1 with lists so have to improvise
        {
            SLIt = SLIt1;
            SLIt++; //so points to one after SLIt1
            if(SLIt1->SubString(SLIt1->Length() - 1, 2) != AnsiString("&0"))
            {
                continue; //already allocated so skip to the next
            }
            else
            {
                CommaPos1 = SLIt1->Pos(','); //can't be 0
                ServiceRef1 = SLIt1->SubString(1, CommaPos1 - 1);
                //but this contains "(First service..." etc so need to strip these, but use to extract RepeatNum
                SpacePos = ServiceRef1.Pos(' ');
                RepeatNum1 = 0;
                if(SpacePos > 0) //otherwise it's already correct
                {
                    RepeatInfo1 = ServiceRef1.SubString(SpacePos + 2, ServiceRef1.Length() - SpacePos - 2); //drops the brackets and leaves "First service", "Repeat 2" etc
                    ServiceRef1 = ServiceRef1.SubString(1, SpacePos - 1);
                    if(RepeatInfo1[1] == 'F')
                    {
                        RepeatNum1 = 0;
                    }
                    else
                    {
                        SpacePos = RepeatInfo1.Pos(' ');
                        RepeatNum1 = RepeatInfo1.SubString(SpacePos + 1, RepeatInfo1.Length() - SpacePos).ToInt();
                    }
                }
                AnsiTime1 =  SLIt1->SubString(CommaPos1 + 1, SLIt1->Length() - CommaPos1);
                //but this includes the "&0" etc so need to strip these
                AmpersandPos = AnsiTime1.Pos('&');
                AnsiTime1 = AnsiTime1.SubString(1, AmpersandPos - 1);

                ASCLIt1 = AllServiceCallingLocsMap.find(ServiceRef1);
                if(ASCLIt1 == AllServiceCallingLocsMap.end()) //can't find it
                {
                    throw Exception("ASCLIt1 Error in " + Input);
                }
                ServiceCallingLocsList1 = ASCLIt1->second;
                AmpersandPos = SLIt1->Pos('&');
                *SLIt1 = SLIt1->SubString(1, AmpersandPos); //truncate up to & leave in the '&'
                *SLIt1 = *SLIt1 + AnsiString(++DirectionMarker); //now add the next marker (pre-increment), allow for it being more than one digit

                SameDirectionCount = 1;
                for(SLIt2 = SLIt; SLIt2 != ServiceList.end(); SLIt2++)
                {
                    CommaPos2 = SLIt2->Pos(','); //can't be 0
                    ServiceRef2 = SLIt2->SubString(1, CommaPos2 - 1);
                    //but this contains "(First service..." etc so need to strip these
                    SpacePos = ServiceRef2.Pos(' ');
                    RepeatNum2 = 0;
                    if(SpacePos > 0) //otherwise it's already correct
                    {
                        RepeatInfo2 = ServiceRef2.SubString(SpacePos + 2, ServiceRef2.Length() - SpacePos - 2); //drops the brackets and leaves "First service", "Repeat 2" etc
                        ServiceRef2 = ServiceRef2.SubString(1, SpacePos - 1);
                        if(RepeatInfo2[1] == 'F')
                        {
                            RepeatNum2 = 0;
                        }
                        else
                        {
                            SpacePos = RepeatInfo2.Pos(' ');
                            RepeatNum2 = RepeatInfo2.SubString(SpacePos + 1, RepeatInfo2.Length() - SpacePos).ToInt();
                        }
                    }
                    AnsiTime2 = SLIt2->SubString(CommaPos2 + 1, SLIt2->Length() - CommaPos2);
                    //but this includes the "&0" etc so need to strip these
                    AmpersandPos = AnsiTime2.Pos('&');
                    AnsiTime2 = AnsiTime2.SubString(1, AmpersandPos - 1);

                    ASCLIt2 = AllServiceCallingLocsMap.find(ServiceRef2);
                    if(ASCLIt2 == AllServiceCallingLocsMap.end()) //can't find it
                    {
                        throw Exception("ASCLIt2 Error in " + Input);
                    }
                    ServiceCallingLocsList2 = ASCLIt2->second;
                    //now compare the two
                    if(SameDirection(0, ServiceRef1, ServiceRef2, AnsiTime1, AnsiTime2, RepeatNum1, RepeatNum2, ServiceCallingLocsList1, ServiceCallingLocsList2, Location, Arrival))
                    {
                        int AmpersandPos = SLIt2->Pos('&');
                        *SLIt2 = SLIt2->SubString(1, AmpersandPos); //truncate up to & leave in the '&'
                        *SLIt2 = *SLIt2 + AnsiString(DirectionMarker); //now add the same marker as *SLIt1
                        SameDirectionCount++;
                    }
                }
                if(SameDirectionCount > MaxNumberOfSameDirections)
                {
                    MaxNumberOfSameDirections = SameDirectionCount;
                }
            }
        }

        if(SLIt3->SubString(SLIt3->Length() - 1, 2) == AnsiString("&0")) //*SLTIt3 is the last in the list and may not have been allocated, if not it doesn't match
        {
            //any existing direction so allocate it now
            AmpersandPos = SLIt3->Pos('&');
            *SLIt3 = SLIt3->SubString(1, AmpersandPos); //truncate up to & leave in the '&'
            *SLIt3 = *SLIt3 + AnsiString(++DirectionMarker);
        }
        //now change direction markers to upper case letters beginning with 'A' (and continuing with 'AA' if exceed 26) & add a comma before so have ServiceRef, DirectionMarker, Time
        for(SLIt = ServiceList.begin(); SLIt != ServiceList.end(); SLIt++)
        {
            //extract the DirectionMarker as an integer
            AmpersandPos = SLIt->Pos('&');
            AnsiString DirectionMarkerString = SLIt->SubString(AmpersandPos + 1, SLIt->Length() - AmpersandPos); //extract the number as an ansistring
            AnsiString ServiceWithoutMarker = SLIt->SubString(1, AmpersandPos - 1); //truncate the &number
            DirectionMarker = DirectionMarkerString.ToInt();
            AnsiString DirectionSuffix = "";
            char c;
            if(DirectionMarker < 27)
            {
                c = 64 + DirectionMarker; //so 1 -> 'A'
                DirectionSuffix = "," + AnsiString(c);
            }
            else if(DirectionMarker < 53)
            {
                c = 65 + DirectionMarker - 27; //so 27 -> 'AA'
                DirectionSuffix = ",A" + AnsiString(c);
            }
            else
            {
                DirectionSuffix = ",?"; //shouldn'tn ever get this far!
            }
            *SLIt = ServiceWithoutMarker + DirectionSuffix;
        }
        //now prepare the final consolidated output
        for(SLIt = ServiceList.begin(); SLIt != ServiceList.end(); SLIt++)
        {
            Output = Output + *SLIt + ","; //will end up with an unwanted comma at the end
        }
        if(Output.Length() > 0)
        {
            Output = Output.SubString(1, Output.Length() - 1); //remove the last comma
        }
        Utilities->CallLogPop(2216);
        return(Output);
    }

    catch(const Exception &e)  //non error catch
    {
        AnalysisError = true;
        Utilities->CallLogPop(2227);
        return(e.Message);
    }
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::ConsolidateSARNTAtLoc(int Caller, const AnsiString Input, int &NumTrainsAtLoc)
{
    //similar to above but doesn't include times in the input
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ConsolidateSARNTAtLoc," + Input);
    AnsiString InternalInput = Input, Output = "", OneService = "";
    int CommaPos = 0;
    std::list<AnsiString> ServiceList;
    //load up the list
    while(InternalInput.Length() > 0)
    {
        CommaPos = InternalInput.Pos(',');
        if(CommaPos > 0) //0 if not found, as won't be when only one service left
        {
            OneService = InternalInput.SubString(1, CommaPos - 1);
            ServiceList.push_back(OneService);
            InternalInput = InternalInput.SubString(CommaPos + 1, InternalInput.Length() - CommaPos);
        }
        else //no comma so looking at last (or only) element
        {
            ServiceList.push_back(InternalInput);
            InternalInput = "";
        }
    }

    ServiceList.sort(); // alphabetical order
    ServiceList.unique(); //remove duplicates
    NumTrainsAtLoc = ServiceList.size(); //calc this after removing duplicates as may not have changed
    for(std::list<AnsiString>::iterator SLIt = ServiceList.begin(); SLIt != ServiceList.end(); SLIt++)
    {
        Output = Output + *SLIt + ","; //will end up with an unwanted comma at the end
    }
    if(Output.Length() > 0)
    {
        Output = Output.SubString(1, Output.Length() - 1); //remove the last comma
    }
    Utilities->CallLogPop(2217);
    return(Output);
}

// ---------------------------------------------------------------------------


bool TTrainController::SameDirection(int Caller, AnsiString Ref1In, AnsiString Ref2In, AnsiString Time1, AnsiString Time2, int RepeatNum1, int RepeatNum2, TServiceCallingLocsList List1,
                                     TServiceCallingLocsList List2, AnsiString Location, bool Arrival)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SameDirection," + Ref1In + "," + Ref2In  + "," + Time1 + "," + Time2 + "," +
                                 AnsiString(RepeatNum1) + "," + AnsiString(RepeatNum2) + "," + Location);

    std::list<AnsiString>::iterator LP1, LP2, ListPtr1, ListPtr2, LocPtr1, LocPtr2;     //LP1 & 2 are temporary pointers, ListPtrs are
    //general list pointers, LocPtrs point to Location in the two lists

    //first find the relevant values for LocPtr1 & LocPtr2 taking account of cdts and times
    //for List1
    bool LocFound = false;
    AnsiString Ref1 = Ref1In, Ref2 = Ref2In;
    int IncMinutes;
    TDateTime FirstServiceTime;

    //first need to strip off /1, /2 etc if present from Ref1 & Ref2 (leave Ref1In & Ref2In for error message & retain value as target in finding the correct reference for cdts)
    int Ref1Target = 0, Ref1Count = 0;
    int Ref2Target = 0, Ref2Count = 0;

/* drop this after retained slashes in ServiceRef
    int SlashPos = Ref1.Pos('/');
    if(SlashPos > 0)     //if 0 Ref1 == Ref1In & target stays  at 0
    {
        Ref1Target = Ref1.SubString(SlashPos + 1, Ref1.Length() - SlashPos).ToInt();
        Ref1 = Ref1.SubString(1, SlashPos - 1);     //truncate up to but omit '/'
    }
    int Ref2Target = 0, Ref2Count = 0;
    SlashPos = Ref2.Pos('/');
    if(SlashPos > 0)     //if 0 leave as is
    {
        Ref2Target = Ref2.SubString(SlashPos + 1, Ref2.Length() - SlashPos).ToInt();
        Ref2 = Ref2.SubString(1, SlashPos - 1);     //truncate up to but omit '/'
    }
*/

    for(ListPtr1 = List1.begin(); ListPtr1 != List1.end(); ListPtr1++)     //note that when this routine entered Ref1In &  Ref2In are already set to the correct services,
    {
        //even if others have same names. But if there are cdt's then need to refind the correct service
        if((*ListPtr1) == Location)                                        //
        {
            LocPtr1 = ListPtr1;     //may be modified later
            LocFound = true;
        }
        if(ListPtr1->SubString(1, 3) == "%%%")
        {
            AnsiString CDTTime = ListPtr1->SubString(4, 5);
            //now adjust the time to correspond to the repeat if there is one
            if(RepeatNum1 > 0)     //if it is 0 then AnsiTime1 is already valid
            {
                IncMinutes = -1;
                FirstServiceTime = TDateTime(-1);
                bool BreakFlag = false;
                for(TTrainDataVector::iterator TDVIt = TrainDataVectorCopy.begin(); TDVIt != TrainDataVectorCopy.end(); TDVIt++)
                {
                    if(TDVIt->ServiceReference == Ref1)
                    {
                        if(Ref1Target > Ref1Count)
                        {
                            Ref1Count++;
                            continue;
                        }
                        IncMinutes = TDVIt->ActionVector.back().RearStartOrRepeatMins;
                        for(TActionVector::iterator AVIt = TDVIt->ActionVector.begin(); AVIt != TDVIt->ActionVector.end(); AVIt++)
                        {
                            if(Utilities->Format96HHMM(AVIt->EventTime) == CDTTime)
                            {
                                FirstServiceTime = AVIt->EventTime;     //i.e. the FirstService value of CDTTime
                                BreakFlag = true;
                                break;
                            }
                            if(Utilities->Format96HHMM(AVIt->ArrivalTime) == CDTTime)     //add arr & dep in case find sooner (though dep shouldn't be sooner)
                            {
                                FirstServiceTime = AVIt->ArrivalTime;
                                BreakFlag = true;
                                break;
                            }
                            if(Utilities->Format96HHMM(AVIt->DepartureTime) == CDTTime)
                            {
                                FirstServiceTime = AVIt->DepartureTime;
                                BreakFlag = true;
                                break;
                            }
                        }
                        if(BreakFlag)
                        {
                            break;
                        }
                    }
                }
                if(IncMinutes == -1)
                {
                    throw Exception("Failed to find service for ServiceRef1 in SameDirection " + Ref1In + " " + Ref2In  + " " + Time1 + " " + Time2 + " " + AnsiString(RepeatNum1) + " " + AnsiString(RepeatNum2) + " " + Location);
                }
                if(FirstServiceTime == TDateTime(-1))
                {
                    throw Exception("Failed to find first service time for ServiceRef1 in SameDirection " + Ref1In + " " + Ref2In  + " " + Time1 + " " + Time2 + " " + AnsiString(RepeatNum1) + " " + AnsiString(RepeatNum2) + " " + Location);
                }
                CDTTime = Utilities->Format96HHMM(TrainController->GetRepeatTime(60, FirstServiceTime, RepeatNum1, IncMinutes));
            }
            if(!Arrival && (Time1 == CDTTime))     //continue if equal in case next is a departure for the Location
            {
                LocFound = false;
                continue;
            }
            if(Arrival && (Time1 == CDTTime))     //gone far enough so can stop
            {
                break;
            }
            if(Time1 > CDTTime)     //not there yet so go on
            {
                LocFound = false;
                continue;
            }
            if(Time1 < CDTTime)     //gone too far so can stop now
            {
                break;
            }
        }
    }
    if(!LocFound)     //have to find it in both lists
    {
        Utilities->CallLogPop(2228);
        return( false);
    }
    //for List2
    LocFound = false;
    for(ListPtr2 = List2.begin(); ListPtr2 != List2.end(); ListPtr2++)
    {
        if((*ListPtr2) == Location)
        {
            LocPtr2 = ListPtr2;     //may be modified later
            LocFound = true;
        }
        if(ListPtr2->SubString(1, 3) == "%%%")
        {
            AnsiString CDTTime = ListPtr2->SubString(4, 5);
            //now adjust the time to correspond to the repeat if there is one
            if(RepeatNum2 > 0)     //if it is 0 then AnsiTime1 is already valid
            {
                IncMinutes = -1;
                FirstServiceTime = TDateTime(-1);
                bool BreakFlag = false;
                for(TTrainDataVector::iterator TDVIt = TrainDataVectorCopy.begin(); TDVIt != TrainDataVectorCopy.end(); TDVIt++)
                {
                    if(TDVIt->ServiceReference == Ref2)
                    {
                        if(Ref2Target > Ref2Count)
                        {
                            Ref2Count++;
                            continue;
                        }
                        IncMinutes = TDVIt->ActionVector.back().RearStartOrRepeatMins;
                        for(TActionVector::iterator AVIt = TDVIt->ActionVector.begin(); AVIt != TDVIt->ActionVector.end(); AVIt++)
                        {
                            if(Utilities->Format96HHMM(AVIt->EventTime) == CDTTime)
                            {
                                FirstServiceTime = AVIt->EventTime;
                                BreakFlag = true;
                                break;
                            }
                            if(Utilities->Format96HHMM(AVIt->ArrivalTime) == CDTTime)
                            {
                                FirstServiceTime = AVIt->ArrivalTime;
                                BreakFlag = true;
                                break;
                            }
                            if(Utilities->Format96HHMM(AVIt->DepartureTime) == CDTTime)
                            {
                                FirstServiceTime = AVIt->DepartureTime;
                                BreakFlag = true;
                                break;
                            }
                        }
                        if(BreakFlag)
                        {
                            break;
                        }
                    }
                }
                if(IncMinutes == -1)
                {
                    throw Exception("IncMinutes -1 for ServiceRef2 in SameDirection " + Ref1In + " " + Ref2In  + " " + Time1 + " " + Time2 + " " + AnsiString(RepeatNum1) + " " + AnsiString(RepeatNum2) + " " + Location);
                }
                if(FirstServiceTime == TDateTime(-1))
                {
                    throw Exception("First service time -1 for ServiceRef2 in SameDirection " + Ref1In + " " + Ref2In  + " " + Time1 + " " + Time2 + " " + AnsiString(RepeatNum1) + " " + AnsiString(RepeatNum2) + " " + Location);
                }
                CDTTime = Utilities->Format96HHMM(TrainController->GetRepeatTime(61, FirstServiceTime, RepeatNum2, IncMinutes));
            }
            if(!Arrival && (Time2 == CDTTime))     //continue if equal in case next is a departure for the Location
            {
                LocFound = false;
                continue;
            }
            if(Arrival && (Time2 == CDTTime))     //gone far enough so can stop
            {
                break;
            }
            if(Time2 > CDTTime)     //not there yet so go on
            {
                LocFound = false;
                continue;
            }
            if(Time2 < CDTTime)     //gone too far so can stop now
            {
                break;
            }
        }
    }
    if(!LocFound)        //have to find it in both lists, and should be found but allow for it not being
    {
        Utilities->CallLogPop(2229);
        return( false);
    }
    //now, for the arrival analysis, see if there is a common location before the LocPtrs & within any cdts, and if so return true, else return false
    //set ListPtr1 to the search start position
    if(Arrival)
    {
        LP1 = List1.begin();
        LP1--;     //now points to before the first entry
        for(ListPtr1 = LocPtr1; ListPtr1 != LP1; ListPtr1--)     //search backwards from Location
        {
            if(ListPtr1 == List1.begin())
            {
                break;
            }
            if(ListPtr1->SubString(1, 3) == "%%%")     //a cdt event
            {
                ListPtr1++;     //point to one past the cdt
                break;
            }
        }
        //set ListPtr2 to the search start position
        LP2 = List2.begin();
        LP2--;     //now points to before the first entry
        for(ListPtr2 = LocPtr2; ListPtr2 != LP2; ListPtr2--)
        {
            if(ListPtr2 == List2.begin())
            {
                break;
            }
            if(ListPtr2->SubString(1, 3) == "%%%")     //a cdt event
            {
                ListPtr2++;     //point to one past the cdt
                break;
            }
        }
        //ListPtr1 & 2 now at search start position
        LP1 = ListPtr1;
        LP2 = ListPtr2;
        //now search forwards, i.e. for common locations before Location
        for(ListPtr1 = LP1; ListPtr1 != List1.end(); ListPtr1++)
        {
            if(ListPtr1 == LocPtr1)     //reached Location without finding a common earlier location so skip to the backwards check
            {
                break;
            }
            if(ListPtr1->SubString(1, 3) == "%%%")     //reached a cdt event without finding a common earlier location
            {
                break;
            }
            for(ListPtr2 = LP2; ListPtr2 != List2.end(); ListPtr2++)
            {
                if(ListPtr2 == LocPtr2)     //not found common earlier location so go to the next ListPtr1
                {
                    break;
                }
                if(ListPtr2->SubString(1, 3) == "%%%")     //reached a cdt event without finding a common earlier location so go to the next ListPtr1
                {
                    break;
                }
                if((*ListPtr1) == (*ListPtr2))     //found a common earlier location
                {
                    Utilities->CallLogPop(2230);
                    return( true);
                }
            }
        }
    }

    //now, for the departure analysis, reset the start positions and search locations after Location

    else
    {
        LP1 = LocPtr1;
        LP1++;                     //start at one past the location itself
        LP2 = LocPtr2;
        LP2++;
        for(ListPtr1 = LP1; ListPtr1 != List1.end(); ListPtr1++)
        {
            if(ListPtr1 == List1.end())     //reached end point so stop
            {
                break;
            }
            if(ListPtr1->SubString(1, 3) == "%%%")     //reached a cdt event without finding a common location
            {
                break;
            }
            for(ListPtr2 = LP2; ListPtr2 != List2.end(); ListPtr2++)
            {
                if(ListPtr2 == List2.end())     //reached end point so go to next ListPtr1
                {
                    break;
                }
                if(ListPtr2->SubString(1, 3) == "%%%")     //reached a cdt event without finding a common location so go to the next ListPtr1
                {
                    break;
                }
                if((*ListPtr1) == (*ListPtr2))     //found a common later location
                {
                    Utilities->CallLogPop(2231);
                    return( true);
                }
            }
        }
    }
    Utilities->CallLogPop(2232);
    return( false);
}

// ---------------------------------------------------------------------------

AnsiString TTrainController::GetExitLocationAndAt(int Caller, TNumList &ExitList, AnsiString &AllowedExits) const
{
    // changed at v2.7.0 to show allowable exit elements
    if(ExitList.empty())
    {
        return("");
    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetExitLocationAndAt");
    AnsiString StartName = Track->TrackElementAt(735, *(ExitList.begin())).ActiveTrackElementName;
    AnsiString ExitLocList = "";
    AllowedExits = "";

    unsigned int Counter = 0;
    for(TNumListIterator ELIt = ExitList.begin(); ELIt != ExitList.end(); ELIt++)
    {
        ExitLocList += Track->TrackElementAt(1018, *ELIt).ElementID + " ";
        Counter++;
        if(((Counter % 6) == 0) && (Counter < (ExitList.size() - 1))) // only add a newline if more to come
        {
            ExitLocList += "\n";
        }
    }
    if(StartName == "")
    {
        if(ExitList.size() == 1)
        {
            AnsiString ID = Track->TrackElementAt(738, *(ExitList.begin())).ElementID;
            Utilities->CallLogPop(1571);
            return(" at " + ID);
        }
        else
        {
            Utilities->CallLogPop(1572);
            if(ExitList.size() < 4)
            {
                AllowedExits = ",\nallowable exit element(s): " + ExitLocList;
                return("");
            }
            else
            {
                AllowedExits = ",\nallowable exit element(s):\n" + ExitLocList;
                return("");
            }
        }
    }
    for(TNumListIterator ELIT = ExitList.begin(); ELIT != ExitList.end(); ELIT++)
    {
        if(Track->TrackElementAt(736, *ELIT).ActiveTrackElementName != StartName)
        {
            Utilities->CallLogPop(1570);
            if(ExitList.size() < 4)
            {
                AllowedExits = ",\nallowable exit element(s): " + ExitLocList;
                return("");
            }
            else
            {
                AllowedExits = ",\nallowable exit element(s):\n" + ExitLocList;
                return("");
            }
        }
    }
    Utilities->CallLogPop(1569);
    if(ExitList.size() < 4)
    {
        AllowedExits = ",\nallowable exit element(s): " + ExitLocList;
        return(" at " + StartName);
    }
    else
    {
        AllowedExits = ",\nallowable exit element(s):\n" + ExitLocList;
        return(" at " + StartName);
    }
}

// ---------------------------------------------------------------------------
/* can't trust this as locations within a vector may not be contiguous
  bool TTrainController::IsServiceTerminating(int Caller, TTrainDataEntry *TDEPtr, TActionVectorEntry *AVPtr)
  {
  //Search ActionVector from the position after the entry value for Ptr to the end, and return true if find a Finish
  //entry before Fer or TimeLoc.  No point checking for TimeTimeLoc since at a stop location now so a later TimeTimeLoc
  //must be preceded by a TimeLoc departure
  Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsServiceTerminating");
  for(unsigned int x=1;x<TDEPtr->ActionVector.size();x++)
  {
  if((AVPtr + x) < TDEPtr->ActionVector.end())
  {
  AnsiString xx = (AVPtr + x)->Command;//test
  TTimetableFormatType xy = (AVPtr + x)->FormatType;//test
  TTimetableSequenceType xz = (AVPtr + x)->SequenceType;//test
  if(((AVPtr + x)->Command == "Fer") || ((AVPtr + x)->FormatType == TimeLoc))
  {
  Utilities->CallLogPop();
  return false;
  }
  else if((AVPtr + x)->SequenceType == FinishSequence)
  {
  Utilities->CallLogPop();
  return true;
  }
  }
  }
  Utilities->CallLogPop();
  return false;
  }
*/
// ---------------------------------------------------------------------------

void TTrainController::SendPerformanceSummary(int Caller, std::ofstream &PerfFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SendPerformanceSummary");
    AnsiString FormatStr = "####0.0";
    AnsiString AvLateArrMins = "";
    AnsiString AvEarlyArrMins = "";
    AnsiString AvLatePassMins = "";
    AnsiString AvEarlyPassMins = "";
    AnsiString AvLateDepMins = "";
    AnsiString AvLateExitMins = "";
    AnsiString AvEarlyExitMins = "";

    //calculate remaining CumulativeDelayedRandMinsAllTrains for trains still in vector (CumulativeDelayedRandMinsAllTrains for exited or removed trains already accounted for)
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        Utilities->CumulativeDelayedRandMinsAllTrains += int(TrainVectorAt(89, x).CumulativeDelayedRandMinsOneTrain);
    }

    if(LateArrivals > 0)
    {
        AvLateArrMins = FormatFloat(FormatStr, (TotLateArrMins / LateArrivals));
    }
    if(EarlyArrivals > 0)
    {
        AvEarlyArrMins = FormatFloat(FormatStr, (TotEarlyArrMins / EarlyArrivals));
    }
    if(LatePasses > 0)
    {
        AvLatePassMins = FormatFloat(FormatStr, (TotLatePassMins / LatePasses));
    }
    if(EarlyPasses > 0)
    {
        AvEarlyPassMins = FormatFloat(FormatStr, (TotEarlyPassMins / EarlyPasses));
    }
    if(LateDeps > 0)
    {
        AvLateDepMins = FormatFloat(FormatStr, (TotLateDepMins / LateDeps));
    }
    if(LateExits > 0) //added at v2.9.1
    {
        AvLateExitMins = FormatFloat(FormatStr, (TotLateExitMins / LateExits));
    }
    if(EarlyExits > 0) //added at v2.9.1
    {
        AvEarlyExitMins = FormatFloat(FormatStr, (TotEarlyExitMins / EarlyExits));
    }
    PerfFile << '\n' << '\n' << "***************************************";
    PerfFile << '\n' << '\n' << "Performance summary:" << '\n';

    if(OnTimeArrivals != 1)
    {
        PerfFile << OnTimeArrivals << " on-time arrivals" << '\n';
    }
    else
    {
        PerfFile << OnTimeArrivals << " on-time arrival" << '\n';
    }
    if(LateArrivals > 1)
    {
        PerfFile << LateArrivals << " late arrivals (average " << AvLateArrMins.c_str() << " min)" << '\n';
    }
    else if(LateArrivals == 1)
    {
        PerfFile << LateArrivals << " late arrival (" << AvLateArrMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << LateArrivals << " late arrivals" << '\n';
    }
    if(EarlyArrivals > 1)
    {
        PerfFile << EarlyArrivals << " early arrivals (average " << AvEarlyArrMins.c_str() << " min)" << '\n';
    }
    else if(EarlyArrivals == 1)
    {
        PerfFile << EarlyArrivals << " early arrival (" << AvEarlyArrMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << EarlyArrivals << " early arrivals" << '\n';
    }
    if(OnTimePasses != 1)
    {
        PerfFile << OnTimePasses << " on-time passes" << '\n';
    }
    else
    {
        PerfFile << OnTimePasses << " on-time pass" << '\n';
    }
    if(LatePasses > 1)
    {
        PerfFile << LatePasses << " late passes (average " << AvLatePassMins.c_str() << " min)" << '\n';
    }
    else if(LatePasses == 1)
    {
        PerfFile << LatePasses << " late pass (" << AvLatePassMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << LatePasses << " late passes" << '\n';
    }
    if(EarlyPasses > 1)
    {
        PerfFile << EarlyPasses << " early passes (average " << AvEarlyPassMins.c_str() << " min)" << '\n';
    }
    else if(EarlyPasses == 1)
    {
        PerfFile << EarlyPasses << " early pass (" << AvEarlyPassMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << EarlyPasses << " early passes" << '\n';
    }

    if(OnTimeExits != 1)        //this batch added at v2.9.1
    {
        PerfFile << OnTimeExits << " on-time exits" << '\n';
    }
    else
    {
        PerfFile << OnTimeExits << " on-time exit" << '\n';
    }
    if(LateExits > 1)
    {
        PerfFile << LateExits << " late exits (average " << AvLateExitMins.c_str() << " min)" << '\n';
    }
    else if(LateExits == 1)
    {
        PerfFile << LateExits << " late exit (" << AvLateExitMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << LateExits << " late exits" << '\n';
    }
    if(EarlyExits > 1)
    {
        PerfFile << EarlyExits << " early exits (average " << AvEarlyExitMins.c_str() << " min)" << '\n';
    }
    else if(EarlyExits == 1)
    {
        PerfFile << EarlyExits << " early exit (" << AvEarlyExitMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << EarlyExits << " early exits" << '\n';
    }

    if(OnTimeDeps != 1)
    {
        PerfFile << OnTimeDeps << " on-time departures" << '\n';
    }
    else
    {
        PerfFile << OnTimeDeps << " on-time departure" << '\n';
    }
    if(LateDeps > 1)
    {
        PerfFile << LateDeps << " late departures (average " << AvLateDepMins.c_str() << " min)" << '\n';
    }
    else if(LateDeps == 1)
    {
        PerfFile << LateDeps << " late departure (" << AvLateDepMins.c_str() << " min)" << '\n';
    }
    else
    {
        PerfFile << LateDeps << " late departures" << '\n';
    }
    TDateTime TempExcessLCDownTime;
    for(unsigned int x = 0; x < Track->BarriersDownVector.size(); x++)  //added at v2.6.0 - should have been added earlier
    {
//        if(Track->BarriersDownVector.at(x).ReducedTimePenalty)  //assume train still to cross LC as probably will, else have false high value & can have
                                                                  //later perf summaries with lower values, changed at v2.8.0
//        {
        TempExcessLCDownTime = TrainController->TTClockTime - Track->BarriersDownVector.at(x).StartTime - TDateTime(180.0 / 86400);
//        }
/*
        else
        {
            TempExcessLCDownTime = TrainController->TTClockTime - Track->BarriersDownVector.at(x).StartTime;
        }
*/
        if(TempExcessLCDownTime > TDateTime(0))
        {
            TrainController->ExcessLCDownMins += (double(TempExcessLCDownTime) * 1440);
        }
    }

    AnsiString FormattedExcessLCDownMins = FormatFloat(FormatStr, ExcessLCDownMins);

    if(ExcessLCDownMins > 0.1)
    {
        PerfFile << FormattedExcessLCDownMins.c_str() << " excess minutes of level crossing barrier down time" << '\n';
    }
    if(Utilities->CumulativeDelayedRandMinsAllTrains > 0) //added at v2.13.0
    {
        PerfFile << Utilities->CumulativeDelayedRandMinsAllTrains << " minutes lost due to random delays when stopped at locations" << '\n';
    }
    if(MissedStops != 1)
    {
        PerfFile << MissedStops << " missed stops" << '\n';
    }
    else
    {
        PerfFile << MissedStops << " missed stop" << '\n';
    }
    if(OtherMissedEvents != 1)
    {
        PerfFile << OtherMissedEvents << " other missed events" << '\n';
    }
    else
    {
        PerfFile << OtherMissedEvents << " other missed event" << '\n';
    }
    if(SkippedTTEvents != 1)
    {
        PerfFile << SkippedTTEvents << " skipped timetable events" << '\n';
    }
    else
    {
        PerfFile << SkippedTTEvents << " skipped timetable event" << '\n';
    }
    if(UnexpectedExits != 1)
    {
        PerfFile << UnexpectedExits << " unexpected train exits" << '\n';
    }
    else
    {
        PerfFile << UnexpectedExits << " unexpected train exit" << '\n';
    }
    if(IncorrectExits != 1)
    {
        PerfFile << IncorrectExits << " incorrect train exits" << '\n';
    }
    else
    {
        PerfFile << IncorrectExits << " incorrect train exit" << '\n';
    }
    if(NumFailures != 1)
    {
        PerfFile << NumFailures << " train failures" << '\n';
    }
    else
    {
        PerfFile << NumFailures << " train failure" << '\n';
    }
    if(AvHoursIntValue > 0)
    {
        if(AvHoursIntValue == 1)
        {
            PerfFile << AvHoursIntValue << " hour mean time betweeen train failures" << '\n';
        }
        else
        {
            PerfFile << AvHoursIntValue << " hours mean time betweeen train failures" << '\n';
        }
    }
    AnsiString AvLateMinsLocsNotReached = "";

    CalcOperatingAndNotStartedTrainLateness(0);
    int LocsNotReached = (NotStartedTrainLateArr + OperatingTrainLateArr); //dropped divide by 2 after 2.7.0 as don't count late departures as 'failed to arrive'
    // each location has an arrival and departure (generally) so divide by 2 - no, dropped after 2.7.0

    if(LocsNotReached > 0)
    {
        AvLateMinsLocsNotReached = FormatFloat(FormatStr, (OperatingTrainLateMins + NotStartedTrainLateMins) / (NotStartedTrainLateArr + OperatingTrainLateArr));
        PerfFile << LocsNotReached << " locations that trains failed to reach (average lateness " << AvLateMinsLocsNotReached.c_str() << " min)" << '\n';
    }
    if(SPADRisks != 1)
    {
        PerfFile << SPADRisks << " SPAD risks" << '\n';
    }
    else
    {
        PerfFile << SPADRisks << " SPAD risk" << '\n';
    }
    if(SPADEvents != 1)
    {
        PerfFile << SPADEvents << " SPADs" << '\n';
    }
    else
    {
        PerfFile << SPADEvents << " SPAD" << '\n';
    }
    if(Derailments != 1)
    {
        PerfFile << Derailments << " derailments" << '\n';
    }
    else
    {
        PerfFile << Derailments << " derailment" << '\n';
    }
    if(CrashedTrains != 1)
    {
        PerfFile << CrashedTrains << " crashed trains" << '\n';
    }
    else
    {
        PerfFile << CrashedTrains << " crashed train" << '\n';
    }
    PerfFile << '\n' << "***************************************" << '\n';

    bool DerailSPADFlag = false, CrashFlag = false;

    int OverallScorePercent = 100;
    int TotArrDepExit = 0;
    double TotLateMinsFactor = 1;
    double MissedStopAndSPADRiskFactor = 1;
    double NetNegFactor = 1;

    TotArrDepExit = OnTimeArrivals + LateArrivals + EarlyArrivals + OnTimeDeps + LateDeps + NotStartedTrainLateArr + OperatingTrainLateArr +
            EarlyExits + LateExits + OnTimeExits; //exits added at v2.9.1, passes not counted
    // TotArrDep: total number of arrivals & departures including those for trains that haven't reached their destinations yet and are late
    // changed at v1.1.4 - calc was inside "if(OverallScorePercent == 100).." block so could remain 0 for SPADs & crashes, & then received the
    // 'no timetabled departures... message, which was inappropriate

    if((SPADEvents > 0) || (Derailments > 0))
    {
        OverallScorePercent = 5; // overrides other calculations
        DerailSPADFlag = true;
    }
    if(CrashedTrains > 0)
    {
        OverallScorePercent = 0; // overrides other calculations
        CrashFlag = true;
    }
    if(OverallScorePercent == 100)
    {
        int LatenessPenalty = TotLateArrMins + TotLateDepMins; //added at v2.13.0 for random delays
        if(Utilities->CumulativeDelayedRandMinsAllTrains > LatenessPenalty)
        {
            LatenessPenalty = 0;
        }
        else
        {
            LatenessPenalty -= Utilities->CumulativeDelayedRandMinsAllTrains;
        }
        if(TotArrDepExit > 0)
        {
            TotLateMinsFactor = exp((-0.1732) * (LatenessPenalty + OperatingTrainLateMins + NotStartedTrainLateMins + TotLateExitMins +
                ((OtherMissedEvents + SkippedTTEvents + UnexpectedExits + ExcessLCDownMins) * 15)) / TotArrDepExit); //exits added at v2.9.1
            // TotLateMinsFactor: negative exponential factor based on overall average arr & dep minutes late (with OtherMissedEvents & UnexpectedExits
            // counting as 15 mins late each), where 4 mins late average = half, 8 mins late = a quarter etc
            MissedStopAndSPADRiskFactor = exp((-17.33) * (MissedStops + SPADRisks + IncorrectExits) / TotArrDepExit);
            // MissedEventAndSPADRiskFactor: negative exponential factor based on number of missed stops, SPAD risks & IncorrectExits as a proportion
            // of arrivals & departures, where 4% = half, 8% = a quarter etc
            NetNegFactor = TotLateMinsFactor * MissedStopAndSPADRiskFactor;
            // NetNegfactor: product of the above two
            OverallScorePercent = 100 * NetNegFactor;
        }
    }
    if((TotArrDepExit > 0) || DerailSPADFlag || CrashFlag)
    // flag condits added at v1.1.4 - see above for what the error was
    {
        AnsiString OneFailureString = ", though the failure would account for some poor performance";
        AnsiString TwoOrMoreFailureString = ", though the failures would account for some poor performance";
        AnsiString AddedString = "";
        if(NumFailures == 1)
        {
            AddedString = OneFailureString;
        }
        if(NumFailures > 1)
        {
            AddedString = TwoOrMoreFailureString;
        }
        PerfFile << "\nOverall score: " << OverallScorePercent << "%\n";
        AnsiString Rating = "";
        if(OverallScorePercent == 100)
        {
            Rating = "Perfect!";
        }
        else if(OverallScorePercent >= 95)
        {
            Rating = "Excellent";
        }
        else if(OverallScorePercent >= 90)
        {
            Rating = "Very good";
        }
        else if(OverallScorePercent >= 80)
        {
            Rating = "Good";
        }
        else if(OverallScorePercent >= 70)
        {
            Rating = "Fair";
        }
        else if(OverallScorePercent >= 60)
        {
            Rating = "Unacceptable" + AddedString;
        }
        else if(OverallScorePercent >= 50)
        {
            Rating = "Poor" + AddedString;
        }
        else if(OverallScorePercent >= 40)
        {
            Rating = "Bad" + AddedString;
        }
        else if(OverallScorePercent >= 30)
        {
            Rating = "Very bad" + AddedString;
        }
        else if(OverallScorePercent >= 20)
        {
            Rating = "Terrible" + AddedString;
        }
        else if(OverallScorePercent >= 10)
        {
            Rating = "Appalling" + AddedString;
        }
        else if(OverallScorePercent >= 5)
        {
            if(DerailSPADFlag)
            {
                Rating = "Disastrous - potential loss of life";
            }
            // SPADs/Derailments
            else
            {
                Rating = "Dire" + AddedString;
            }
        }
        else if(OverallScorePercent < 5)
        {
            if(CrashFlag)
            {
                Rating = "Catastrophic - loss of life"; // Crashes
            }
            else
            {
                Rating = "Abysmal";
            }
        }
        PerfFile << "Overall rating: " << Rating.c_str() << '\n';
    }
    else
    {
        PerfFile << "\nThere were no timetabled departures, arrivals or exits so there is insufficient information to provide a performance score or rating" << '\n';
    }
    PerfFile << '\n' << "***************************************";
    PerfFile.flush();
    Utilities->CallLogPop(1736);
}

// ---------------------------------------------------------------------------

void TTrainController::SetWarningFlags(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetWarningFlags");
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        TTrain &Train = TrainVectorAt(58, x);
        if(Train.Crashed)
        // can't use background colours for crashed & derailed because same colour
        {
            CrashWarning = true;
        }
        else if(Train.Derailed)
        // can't use background colours for crashed & derailed because same colour
        {
            DerailWarning = true;
        }
        else if(Train.BackgroundColour == clSPADBackground)
        // use colour as that changes as soon as passes signal
        {
            SPADWarning = true;
        }
        else if(Train.BackgroundColour == clTrainFailedBackground)
        {
            TrainFailedWarning = true;
        }
        else if(Train.BackgroundColour == clCallOnBackground)
        // use colour as also stopped at signal
        {
            CallOnWarning = true;
        }
        else if(Train.BackgroundColour == clSignalStopBackground)
        // use colour to distinguish from call-on
        {
            SignalStopWarning = true;
        }
        else if(Train.BackgroundColour == clBufferAttentionNeeded)
        // use colour to distinguish from ordinary buffer stop
        {
            BufferAttentionWarning = true;
        }
    }
    Utilities->CallLogPop(1796);
}

// ---------------------------------------------------------------------------

void TTrainController::CalcOperatingAndNotStartedTrainLateness(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CalcSignalStopLateness");

    // calculate lateness for running trains
    OperatingTrainLateMins = 0;
    OperatingTrainLateArr = 0;
    for(unsigned int x = 0; x < TrainVector.size(); x++)
    {
        TTrain &Train = TrainVectorAt(64, x);
        for(TActionVectorEntry * AVEntryPtr = &Train.TrainDataEntryPtr->ActionVector.front(); AVEntryPtr < &Train.TrainDataEntryPtr->ActionVector.back();
            AVEntryPtr++)
        {
            if(AVEntryPtr < Train.ActionVectorEntryPtr)
            {
                continue;
            }
            if((AVEntryPtr->ArrivalTime > TDateTime(-1)) && !Train.RevisedStoppedAtLoc() && (GetRepeatTime(42, AVEntryPtr->ArrivalTime, Train.RepeatNumber, Train.IncrementalMinutes) <
                                                                                         TTClockTime)) //!Train.StoppedAtLocation added after 2.7.0 as don't want to count TimeTimeLocs that have arrived
            {
                OperatingTrainLateMins += 1440 * double(TTClockTime - GetRepeatTime(43, AVEntryPtr->ArrivalTime, Train.RepeatNumber, Train.IncrementalMinutes));
                OperatingTrainLateArr++;
            }
/*  dropped departures after 2.7.0 because these don't count for 'failed to reach' numbers
            if((AVEntryPtr->DepartureTime > TDateTime(-1)) && (GetRepeatTime(44, AVEntryPtr->DepartureTime, Train.RepeatNumber, Train.IncrementalMinutes) <
                TTClockTime))
            {
                OperatingTrainLateMins += 1440 * double(TTClockTime - GetRepeatTime(45, AVEntryPtr->DepartureTime, Train.RepeatNumber, Train.IncrementalMinutes));
                OperatingTrainArrDep++;
            }
*/
        }
    }

    // calculate lateness for trains that haven't started yet (could be held awaiting entry)
    NotStartedTrainLateMins = 0;
    NotStartedTrainLateArr = 0;

    for(unsigned int x = 0; x < TrainDataVector.size(); x++)
    {
        TTrainDataEntry & TDEntry = TrainDataVector.at(x);
        const TActionVectorEntry &AVEntryLast = TDEntry.ActionVector.at(TDEntry.ActionVector.size() - 1);
        int IncrementalMinutes = 0;
        if(AVEntryLast.FormatType == Repeat)
        {
            IncrementalMinutes = AVEntryLast.RearStartOrRepeatMins;
        }
        for(int y = 0; y < TDEntry.NumberOfTrains; y++)
        {
            TTrainOperatingData &TTOD = TDEntry.TrainOperatingDataVector.at(y);
            if(TTOD.RunningEntry != NotStarted)
            {
                continue;
            }
            // note that can't rely on the above for sessionfiles saved before v0.6b as wasn't set to Running for Sns/Fsp/rsp & shuttles
            // but if trains had exited then would be set to Exited, so need to check against trains still operating - use the test below
            bool TrainOperatingFlag = false;
            for(unsigned int a = 0; a < TrainController->TrainVector.size(); a++)
            {
                if((TrainController->TrainVector.at(a).TrainDataEntryPtr == &TDEntry) && (TrainController->TrainVector.at(a).RepeatNumber == y))
                {
                    TrainOperatingFlag = true;
                    break;
                }
            }
            if(TrainOperatingFlag)
            {
                continue;
            }
            if(GetRepeatTime(46, TDEntry.ActionVector.at(0).EventTime, y, IncrementalMinutes) > TTClockTime)
            {
                break; // if the first time is greater than TTClockTime then all the rest will also be greater (& default of -1 will be less so will be ignored)
            }
            for(unsigned int z = 0; z < TDEntry.ActionVector.size(); z++)
            {
                TActionVectorEntry &AVEntry = TDEntry.ActionVector.at(z);
                if(GetRepeatTime(35, AVEntry.EventTime, y, IncrementalMinutes) > TTClockTime)
                {
                    break; // all the rest will also be greater (& default of -1 will be less)
                }
                if(GetRepeatTime(36, AVEntry.ArrivalTime, y, IncrementalMinutes) > TTClockTime)
                {
                    break; // all the rest will also be greater (& default of -1 will be less)
                }
                if(GetRepeatTime(37, AVEntry.DepartureTime, y, IncrementalMinutes) > TTClockTime)
                {
                    break; // all the rest will also be greater (& default of -1 will be less)
                }
                if((AVEntry.ArrivalTime > TDateTime(-1)) && (GetRepeatTime(38, AVEntry.ArrivalTime, y, IncrementalMinutes) < TTClockTime))
                {
                    NotStartedTrainLateMins += 1440 * double(TTClockTime - GetRepeatTime(39, AVEntry.ArrivalTime, y, IncrementalMinutes));
                    NotStartedTrainLateArr++;
                }
/* dropped departures after 2.7.0 as only interested in 'failed to reach' number - if train hasn't arrived then it hasn't departed so shouldn't count that as part of 'failed to reach'
                if((AVEntry.DepartureTime > TDateTime(-1)) && (GetRepeatTime(40, AVEntry.DepartureTime, y, IncrementalMinutes) < TTClockTime))
                {
                    NotStartedTrainLateMins += 1440 * double(TTClockTime - GetRepeatTime(41, AVEntry.DepartureTime, y, IncrementalMinutes));
                    NotStartedTrainArrDep++;
                }
*/
            }
        }
    }
    Utilities->CallLogPop(1894);
}

// ---------------------------------------------------------------------------

void TTrainController::RebuildOpTimeToActMultimap(int Caller)
// new v2.2.0 for OperatorActionPanel (OperatorActionPanel changed for ActionsDueForm at v2.13.0)
// clears entries then adds values for running trains then for continuation entries
// dont limit size here as need to check all trains (ActionsDueListBox is limited to 20 trains in Interface.cpp)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RebuildOpTimeToActMultimap");
    OpTimeToActMultiMap.clear();
    TOpTimeToActMultiMapEntry OpTimeToActMultiMapEntry;

    if(!TrainVector.empty())
    // build OpTimeToActMultiMap entries for running trains
    {
        AnsiString HeadCode;
        // dropped in favour of TrainID for running trains int VecPos; //TrackVectorPosition of LeadElement or continuation where train is to enter
        int TrainID;
        THCandTrainPosParam HCandTrainPosParam;
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
            HeadCode = TrainVectorAt(62, x).HeadCode;
            TrainID = TrainVectorAt(63, x).TrainID;
            HCandTrainPosParam.first = HeadCode;
            HCandTrainPosParam.second = TrainID;
            float TimeToAct = TrainVectorAt(65, x).OpTimeToAct;
            if((TimeToAct >= 0) && (TimeToAct < 59.9))
            // -1 indicates don't display
            {
                OpTimeToActMultiMapEntry.first = TimeToAct;
                OpTimeToActMultiMapEntry.second = HCandTrainPosParam;
                OpTimeToActMultiMap.insert(OpTimeToActMultiMapEntry);
            }
        }
    }
/*
     * class TContinuationTrainExpectationEntry
      {
      public:
      AnsiString Description; ///< service description
      AnsiString HeadCode; ///< service headcode
      int RepeatNumber; ///< service RepeatNumber
      int IncrementalMinutes; ///< Repeat separation in minutes
      int IncrementalDigits; ///< Repeat headcode separation
      int VectorPosition; ///< TrackVectorPosition for the continuation element
      TTrainDataEntry *TrainDataEntryPtr; ///< points to the service entry in the timetable's TrainDataVector
      };

      Multimap class for TContinuationTrainExpectationEntry objects, where the access key is the expectation time
      typedef std::multimap<TDateTime, TContinuationTrainExpectationEntry> TContinuationTrainExpectationMultiMap;
      typedef TContinuationTrainExpectationMultiMap::iterator TContinuationTrainExpectationMultiMapIterator; ///< iterator for the multimap
      typedef std::pair<TDateTime, TContinuationTrainExpectationEntry> TContinuationTrainExpectationMultiMapPair; ///< a single multimap entry
*/

    if(!ContinuationTrainExpectationMultiMap.empty())
    // build OpTimeToActMultiMap entries for expected trains
    {
        // note that using the ContinuationTrainExpectationMultiMap automatically ensures that entries are in ascending time order
        // first have to calculate times to red signal for each train due to enter (ignore later trains as will likely change before they are due)
        float TimeToAct = 0; // minutes
        int DistanceToRedSignal = 0; // metres
        TContinuationEntryVecPosVector ContinuationEntryVecPosVector;
        // used to ensure only one train displayed for a given continuation
        ContinuationEntryVecPosVector.clear();
        bool LaterTrain = false;
        TContinuationTrainExpectationMultiMapIterator CTEIt = ContinuationTrainExpectationMultiMap.begin();
        while(CTEIt != TrainController->ContinuationTrainExpectationMultiMap.end())
        {
            LaterTrain = false;
            if(CTEIt->second.TrainDataEntryPtr->TrainOperatingDataVector.at(CTEIt->second.RepeatNumber).RunningEntry != NotStarted)
            {
                CTEIt++;
                continue; // not interested in running or exited trains
            }
            if(Track->TrackElementAt(934, CTEIt->second.VectorPosition).TrainIDOnElement > 0)
            {
                CTEIt++;
                continue;
                // don't include trains not entered yet when a train is already on the continuation
            }
            if(!ContinuationEntryVecPosVector.empty())
            {
                for(unsigned int x = 0; x < ContinuationEntryVecPosVector.size(); x++)
                {
                    if(CTEIt->second.VectorPosition == ContinuationEntryVecPosVector.at(x))
                    {
                        LaterTrain = true;
                        ;
                        // skip past remaining trains waiting to enter at same point
                        break;
                    }
                }
            }
            if(LaterTrain)
            {
                CTEIt++;
                continue;
            }
            ContinuationEntryVecPosVector.push_back(CTEIt->second.VectorPosition);
            AnsiString HeadCode = CTEIt->second.HeadCode;
            float CurrentStopTime; // set to 0 at start of function
            float LaterStopTime; // set to 0 at start of function
            float RecoverableTime; // set to 0 at start of function
            int AvTrackSpeed; // set to 0 at start of function
            int TrainID = -1; // not yet allocated for train still to enter
            int DistanceToExit; //not used for continuation entries
            THVShortPair ExitPair;
            bool SigControlAndCanPassRedSignal = false; // doesn't apply for a continuation

//at v2.11.0 found that with *AVPtr set to ...ActionVector.at(0) below instead of ...at(1) to stop signaller control trains throwing an error (because there is no ...at(1) -
//discovered with Birmingham) the LaterStopTime isn't calculated and if a train does something other than depart after an arrival it is still listed in the actions due panel -
//because it just calcs the distance to the red signal and converts that to a time.  So here (after v2.11.0) this new test is introduced to determine whether a train is a
//signaller control train (when the ActionVector size is 1) or not (ActionVector size > 1), and the ...at(value) is set accordingly - 0 for signaller control or 1 if not.

            int AtValue = 1;
            if(CTEIt->second.TrainDataEntryPtr->ActionVector.size() == 1)
            {
                AtValue = 0;
            }
            DistanceToRedSignal = CalcDistanceToRedSignalandStopTime(1, CTEIt->second.VectorPosition, 0,
                    // EntryPos always 0 for entering at a continuation
                    SigControlAndCanPassRedSignal, &CTEIt->second.TrainDataEntryPtr->ActionVector.at(AtValue), //see above note
                    HeadCode, TrainID, CurrentStopTime, LaterStopTime, RecoverableTime, AvTrackSpeed, DistanceToExit, ExitPair);
            // for above VectorPosition is the first element to have its length included in the sum, so for a continuation it's the continuation itself
            // for a train it's the one in front of LeadElement
            if(AvTrackSpeed < 30)
            {
                AvTrackSpeed = 30;
            }
            if(DistanceToRedSignal == -1)
            {
                TimeToAct = 60.0;
            }
            else
            {
                int Speed = AvTrackSpeed;
                int MaxSpeed = int(CTEIt->second.TrainDataEntryPtr->MaxRunningSpeed);
                if(AvTrackSpeed > MaxSpeed)
                {
                    Speed = MaxSpeed;
                }
                if(CTEIt->second.TrainDataEntryPtr->ActionVector.at(0).SignallerControl) //changed to ...at(0) from at(1) at v2.11.0 as SignallerControl only valid for ..at(0)
                // defined in timetable as under signaller control
                {
                    Speed = CTEIt->second.TrainDataEntryPtr->SignallerSpeed;
                    LaterStopTime = 0;
                }
                TimeToAct = LaterStopTime + DistanceToRedSignal * 3.6 / 60 / Speed;
                // accel & decel taken into account in
                // CalcDistanceToRedSignalandStopTime
                // 3.6 convertsKm/h to m/s & 60 converts seconds to minutes
                // don't need CurrentStopTime or RecoverableTime for continuation entries
                float MinsBefEnter = double(CTEIt->first - TTClockTime) * 86400.0 / 60.0;
                TimeToAct += MinsBefEnter;
            }
            THCandTrainPosParam HCandTrainPosParam;
            HCandTrainPosParam.first = HeadCode;
            HCandTrainPosParam.second = -1 - CTEIt->second.VectorPosition;
            // -1-CTE... because 2nd value covers TrainID if +ve &
            // continuation track vector position if -ve, -1 allows for vecpos being 0
            if(TimeToAct < 59.9) // if 60 don't enter a value in multimap
            {
                OpTimeToActMultiMapEntry.first = TimeToAct;
                OpTimeToActMultiMapEntry.second = HCandTrainPosParam;
                OpTimeToActMultiMap.insert(OpTimeToActMultiMapEntry);
            }
            CTEIt++;
        }
    }
    Utilities->CallLogPop(2081);
}

// ---------------------------------------------------------------------------

void TTrainController::RebuildTimeToExitMultiMap(int Caller)
// new for multiplayer
// clears entries then adds values for running trains
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RebuildTimeToExitMultiMap");
    TimeToExitMultiMap.clear();
    TTimeToExitMultiMapEntry TimeToExitMultiMapEntry;

    if(!TrainVector.empty())
    // build map entries for running trains
    {
        TExitInfo ExitInfo;  //corresponds to TServiceInfo in Interface
        THVShortPair ExitPair;
        float TimeToExit;
        for(unsigned int x = 0; x < TrainVector.size(); x++)
        {
            ExitInfo.ServiceReference = TrainVectorAt(75, x).TrainDataEntryPtr->ServiceReference;
            ExitInfo.RepeatNumber = short(TrainVectorAt(81, x).RepeatNumber);
            ExitInfo.TimeToExitSecs = short(TrainVectorAt(77, x).TimeToExit * 60);
            ExitPair = TrainVectorAt(76, x).ExitPair;
            if((ExitInfo.TimeToExitSecs >= 3570) || (ExitInfo.TimeToExitSecs < 1)) //59.5 mins or -60 secs
            {
                ExitInfo.TimeToExitSecs = -1;
            }
            TimeToExitMultiMapEntry.first = ExitPair;
            TimeToExitMultiMapEntry.second = ExitInfo;
            TimeToExitMultiMap.insert(TimeToExitMultiMapEntry);
        }
    }
    Utilities->CallLogPop(2323);
}

// ---------------------------------------------------------------------------

int TTrainController::CalcDistanceToRedSignalandStopTime(int Caller, int TrackVectorPosition, int TrackVectorPositionEntryPos,
                      bool SigControlAndCanPassRedSignal, TActionVectorEntry *AVPtr, AnsiString HeadCode, int TrainID, float &CurrentStopTime, float &LaterStopTime,
                      float &RecoverableTime, int &AvTrackSpeed, int &DistanceToExit, THVShortPair &ExitPair)
// new v2.2.0
// vectorPosition is the value for the first element to be measured - for a continuation it's the continuation itself, for a train
// it's the one after LeadElement, returns -1 for infinity - i.e. not approaching red signal (e.g. maybe cdt before reach it).
// CurrentStopTime is the time to depart from the current station (if stopped at a station) and LaterStopTime is the total station
// stop times for stations after the current one. DistanceToRedSignal is what the name implies, if -1 is returned the other values
// aren't used - this means there is no display for the train in question
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",DistanceToRedSignal, " + AnsiString(TrackVectorPosition) + ", " +
                                 AnsiString(TrackVectorPositionEntryPos) + ", " + AVPtr->Command);
    int DistanceToRedSignal = 0;
    DistanceToExit = -1;
    ExitPair.first = -1;
    ExitPair.second = -1;
    int CumTrackSpeed = 0;
    // average track speed, in case need to use in time calc
    int TrackSpeedCount = 0;
    float KmPerLocationStop;
    float MaxAllowableSpeed;

    //below added at v2.6.1
    if(TrainID > -1)
    {
        TTrain &Train = TrainVectorAtIdent(51, TrainID);
        Train.DistanceToStationStop = 0; //if find a red signal first then this distance isn't needed
        Train.StationStopCalculated = false;
    }
    AvTrackSpeed = 0;
    int CurrentElement = TrackVectorPosition;
    int CurrentEntryPos = TrackVectorPositionEntryPos;
    int NextElement;
    int NextEntryPos;
    int NextExitPos;

    CurrentStopTime = 0;
    LaterStopTime = 0;
    RecoverableTime = 0;
    if(CurrentElement == -1) // end element, no action needed
    {
        Utilities->CallLogPop(2094);
        return(-1);
    }
    int CurrentExitPos;

    // get ExitPos for first element to be measured
    if(Track->TrackElementAt(935, CurrentElement).TrackType == Points)
    {
        if((CurrentEntryPos == 0) || (CurrentEntryPos == 2)) // leading point
        {
            if(Track->TrackElementAt(936, CurrentElement).Attribute == 0)
            {
                CurrentExitPos = 1;
            }
            else
            {
                CurrentExitPos = 3;
            }
        }
        else
        {
            CurrentExitPos = 0; // trailing point
        }
    }
    else
    {
        CurrentExitPos = Track->GetNonPointsOppositeLinkPos(CurrentEntryPos);
    }
    // get CumTrackSpeed for first measured element

    TConfiguration CurrentExitConfig = Track->TrackElementAt(937, CurrentElement).Config[CurrentExitPos];
    int CurrentAttribute = Track->TrackElementAt(938, CurrentElement).Attribute;
    bool CurrentElementFailed = Track->TrackElementAt(1549, CurrentElement).Failed; //added at v2.13.2

    // check if currently stopped at a location, and if so add the remaining dwell time
    // can't use CurrentElement as that is in front of LeadElement and might not be at the location
    if(TrainID > -1)
    // -1 for a continuation and can't be at a location as not yet entered
    {
        TTrain &Train = TrainVectorAtIdent(39, TrainID);   //Train wasn't a reference before v2.6.1 mods so FirstLaterStopRecoverableTime wouldn't be reset for the referenced train
        Train.FirstLaterStopRecoverableTime = 0;
        // this used to deduct from RecoverableTime when arrive at a location
        if(Train.RevisedStoppedAtLoc())
        {
            if(Train.StoppedForTrainInFront)
            {
                Utilities->CallLogPop(2082);
                return(-1); // no action needed
            }
            else if(!((Train.ActionVectorEntryPtr->FormatType == TimeTimeLoc) || (Train.ActionVectorEntryPtr->FormatType == TimeLoc)))
            {
                Utilities->CallLogPop(2083);
                return(-1); // not due a departure so no action needed
            }
            else // due a departure
            {
                double TimeToDepart = double(Train.ReleaseTime - TrainController->TTClockTime) * 86400 / 60; // mins to depart
                // can't convert a TDateTime to a float directly
                CurrentStopTime = float(TimeToDepart);
                AVPtr++;
            }
        }
    }
    // check if CurrentElement is a red signal, but ok if autosig route after provided signal not failed
    if((CurrentExitConfig == Signal) && (CurrentAttribute == 0))
    // ok if autosig route after red signal unless signal has failed
    {
        int NextElement = Track->TrackElementAt(939, CurrentElement).Conn[CurrentExitPos];
        int NextEntryPos = Track->TrackElementAt(940, CurrentElement).ConnLinkPos[CurrentExitPos];
        int RouteNumber; // holder for referenced value, not used
        if((AllRoutes->GetRouteTypeAndNumber(33, NextElement, NextEntryPos, RouteNumber) == TAllRoutes::AutoSigsRoute) && !CurrentElementFailed)
        {                                                                                     //CurrentElementFailed added at v2.13.2
            Utilities->CallLogPop(2078);
            return(-1);
        }
        else if(SigControlAndCanPassRedSignal)
        // ignore signal and increment CurrentElement to NextElement
        {
            if(Track->TrackElementAt(941, NextElement).TrackType == Points)
            {
                if((NextEntryPos == 0) || (NextEntryPos == 2))
                // leading entry point
                {
                    if(Track->TrackElementAt(942, NextElement).Attribute == 0)
                    {
                        NextExitPos = 1;
                    }
                    else
                    {
                        NextExitPos = 3;
                    }
                }
                else
                {
                    NextExitPos = 0; // trailing entry point
                }
            }
            else
            {
                NextExitPos = Track->GetNonPointsOppositeLinkPos(NextEntryPos);
            }
            CurrentElement = NextElement;
            CurrentEntryPos = NextEntryPos;
            CurrentExitPos = NextExitPos;
            CurrentExitConfig = Track->TrackElementAt(943, CurrentElement).Config[CurrentExitPos];
            CurrentAttribute = Track->TrackElementAt(944, CurrentElement).Attribute;
        }
        else if((TrainID > -1) && (TrainVectorAtIdent(40, TrainID).TrainMode == Timetable)) // ignore signallercontrol or will
        // give 'NOW' indication after allowed to pass stop signal when LeadMidLag (AllowedToPassRedSignal reset by this point)
        {
            Utilities->CallLogPop(2084);
            return(0);
            // stopped with red signal in front, don't need AvSpeedLimit in this case, & if at location awaiting departure dwell time already calculated
        }
    }
    int LaterStopNumber = 0;
    int x = 0;
    // added in v2.4.0 to prevent endless circling round track loops - spotted by Xeon 09/03/20 & reported by emsil

    while(!((CurrentExitConfig == Signal) && (CurrentAttribute == 0)))
    // not red signal next (in fwd direction) so enter loop to calc CumLength
    {
        x++; // added in v2.4.0 as above
        if(x > 5000)
        {
            Utilities->CallLogPop(2120);
            return(-1);
        }
        if(CurrentEntryPos > 1)
        {
            DistanceToRedSignal += Track->TrackElementAt(916, CurrentElement).Length23;
            CumTrackSpeed += Track->TrackElementAt(945, CurrentElement).SpeedLimit23;
        }
        else
        {
            DistanceToRedSignal += Track->TrackElementAt(917, CurrentElement).Length01;
            CumTrackSpeed += Track->TrackElementAt(946, CurrentElement).SpeedLimit01;
        }
        TrackSpeedCount++;

        //added for multiplayer - exiting at a continuation and continuation length already added
        if((Track->TrackElementAt(1407, CurrentElement).TrackType == Continuation) && (Track->TrackElementAt(1408, CurrentElement).Config[CurrentExitPos] == End))
        {
            DistanceToExit = DistanceToRedSignal; //don't need to exit function here as will exit when find that the next Conn value is -1
            ExitPair.first = Track->TrackElementAt(1409, CurrentElement).HLoc;
            ExitPair.second = Track->TrackElementAt(1410, CurrentElement).VLoc;
            //here repeat calcs for MaxAllowableSpeed & AvTrackSpeed as done at end for stop signal
            //need here as next element will be -1 so will exit before calcs at end
            if(TrackSpeedCount > 0)
            {
                MaxAllowableSpeed = CumTrackSpeed / TrackSpeedCount;
            }
            else // shouldn't reach here but include to prevent divide by zero error
            {
                if(CurrentEntryPos > 1)
                {
                    MaxAllowableSpeed = Track->TrackElementAt(951, CurrentElement).SpeedLimit23;
                }
                else
                {
                    MaxAllowableSpeed = Track->TrackElementAt(952, CurrentElement).SpeedLimit01;
                }
                // Train MaxRunningSpeed taken into account in RebuildOpTimeToActMultimap
            }
            //calc AvTrackSpeed
            if(LaterStopNumber > 0)
            {
                KmPerLocationStop = float(DistanceToRedSignal) / LaterStopNumber / 1000; // m to km
                AvTrackSpeed = (8.75 * KmPerLocationStop) + 44;
            // Av speed calculation based on formula: Speed = 8.75*(kms/location stop) + 44 km/sec (from experiments), subject to a maximum of
            // average line speed/2 (for half distance accelerating and half decelerating.
            }
            else
            {
                AvTrackSpeed = (sqrt(float(DistanceToRedSignal) / 1000) * 44) + 60;
                // using linear trendline for accel & decel distance at various speeds
                // at half braking, speed never < 60 using this
            }
            if(AvTrackSpeed > MaxAllowableSpeed)
            {
                AvTrackSpeed = MaxAllowableSpeed;
            }
        }

        // added at v2.6.1 to find DistanceToStationStop for trains running early
        if(TrainID > -1) //can ignore continuation entries as these don't run early
        {
            TTrain &Train = TrainVectorAtIdent(52, TrainID);
            if(!Train.StationStopCalculated)
            {
                if(Train.TrainMode == Timetable)
                {
                    bool StopRequired = false;
                    if(!Train.TimetableFinished && (Train.NameInTimetableBeforeCDT(16, Track->TrackElementAt(1005, CurrentElement).ActiveTrackElementName,
                        StopRequired) > -1) && ((Track->TrackElementAt(1006, CurrentElement).StationEntryStopLinkPos1 == CurrentEntryPos) ||
                        (Track->TrackElementAt(1010, CurrentElement).StationEntryStopLinkPos2 == CurrentEntryPos)))
                    {
                        // no need to add in the length of element to CumulativeLength
                        if(StopRequired)
                        {
                            Train.DistanceToStationStop = DistanceToRedSignal; // DistanceToRedSignal holds the intermediate distance to this point
                            Train.StationStopCalculated = true; //don't want to update it with later stops
                        }
                    }
                }
            }
        }
        // check for train in front, but if on a bridge on other track then ok
        TTrackElement TE = Track->TrackElementAt(947, CurrentElement);
        int TrainOnElement;
        if(TE.TrackType != Bridge)
        {
            TrainOnElement = TE.TrainIDOnElement;
        }
        else
        {
            if(CurrentEntryPos > 1)
            {
                TrainOnElement = TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
            }
            else
            {
                TrainOnElement = TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
            }
        }
        if((TrainOnElement > -1) && (TrainOnElement != TrainID))
        // train in front before red signal
        {
            Utilities->CallLogPop(2085);
            return(-1);
        }
        // add to stoptime if required
        if(Track->TrackElementAt(948, CurrentElement).ActiveTrackElementName != "")
        {
            double StopTimeDouble;
            while(AVPtr->FormatType == PassTime)
            {
                AVPtr++; // skip past any passes
            }
            if((Track->TrackElementAt(949, CurrentElement).ActiveTrackElementName == AVPtr->LocationName) && ((AVPtr->FormatType == TimeLoc) ||
                                                                                                              (AVPtr->FormatType == TimeTimeLoc)))
            // stop due here so calc dwell time & advance Ptr
            {
                if(AVPtr->FormatType == TimeTimeLoc)
                {
                    LaterStopNumber++;
                    StopTimeDouble = double(AVPtr->DepartureTime - AVPtr->ArrivalTime) * 86400.0 / 60.0;
                    if(StopTimeDouble < 0.5)
                    {
                        StopTimeDouble = 0.5;
                    }
                    // at least 30 secs delay at station
                    // can't convert a TDateTime to a float directly
                    LaterStopTime += float(StopTimeDouble);
                    RecoverableTime += StopTimeDouble - 0.5;
                    if((LaterStopNumber == 1) && (TrainID > -1))
                    {
                        TrainVectorAtIdent(41, TrainID).FirstLaterStopRecoverableTime = RecoverableTime;
                    }
                    AVPtr++;
                }
                else if((AVPtr->FormatType == TimeLoc) && (AVPtr->ArrivalTime != TDateTime(-1))) // must be an arrival
                {
                    if((AVPtr + 1)->FormatType == TimeLoc)
                    // must be a departure
                    {
                        LaterStopNumber++;
                        StopTimeDouble = double((AVPtr + 1)->DepartureTime - AVPtr->ArrivalTime) * 86400.0 / 60.0;
                        // can't convert a TDateTime to a float directly
                        if(StopTimeDouble < 0.5)
                        {
                            StopTimeDouble = 0.5;
                        }
                        // at least 30 secs delay at station
                        LaterStopTime += float(StopTimeDouble);
                        RecoverableTime += StopTimeDouble - 0.5;
                        if((LaterStopNumber == 1) && (TrainID > -1))
                        {
                            TrainVectorAtIdent(42, TrainID).FirstLaterStopRecoverableTime = RecoverableTime;
                        }
                        AVPtr++;
                        AVPtr++;
                    }
                    else // not a departure, does something else at the location so no calculation needed
                    {
                        Utilities->CallLogPop(2086);
                        return(-1);
                    }
                }
            }
        }
        NextElement = Track->TrackElementAt(950, CurrentElement).Conn[CurrentExitPos];
        if(NextElement == -1) // reached end element, no action needed
        {
            Utilities->CallLogPop(2077);
            return(-1);
        }
        NextEntryPos = Track->TrackElementAt(919, CurrentElement).ConnLinkPos[CurrentExitPos];
        // get NextExitPos
        if(Track->TrackElementAt(920, NextElement).TrackType == Points)
        {
            if((NextEntryPos == 0) || (NextEntryPos == 2))
            // leading entry point
            {
                if(Track->TrackElementAt(921, NextElement).Attribute == 0)
                {
                    NextExitPos = 1;
                }
                else
                {
                    NextExitPos = 3;
                }
            }
            else
            {
                NextExitPos = 0; // trailing entry point
            }
        }
        else
        {
            NextExitPos = Track->GetNonPointsOppositeLinkPos(NextEntryPos);
        }
        CurrentElement = NextElement;
        CurrentEntryPos = NextEntryPos;
        CurrentExitPos = NextExitPos;
        CurrentExitConfig = Track->TrackElementAt(922, CurrentElement).Config[CurrentExitPos];
        CurrentAttribute = Track->TrackElementAt(923, CurrentElement).Attribute;
        CurrentElementFailed = Track->TrackElementAt(1550, CurrentElement).Failed; //added at v2.13.2
    }
    if((CurrentExitConfig == Signal) && (CurrentAttribute == 0))
    // ok if autosig route after red signal, no action needed
    {
        int NextElement = Track->TrackElementAt(924, CurrentElement).Conn[CurrentExitPos];
        int NextEntryPos = Track->TrackElementAt(925, CurrentElement).ConnLinkPos[CurrentExitPos];
        int RouteNumber; // holder for referenced value, not used
        if((AllRoutes->GetRouteTypeAndNumber(31, NextElement, NextEntryPos, RouteNumber) == TAllRoutes::AutoSigsRoute) && !CurrentElementFailed)
        {                                                                              //CurrentElementFailed added at v2.13.2
            Utilities->CallLogPop(2095);
            return(-1);
        }
    }

    if(TrackSpeedCount > 0)
    {
        MaxAllowableSpeed = CumTrackSpeed / TrackSpeedCount;
    }
    else // shouldn't reach here but include to prevent divide by zero error
    {
        if(CurrentEntryPos > 1)
        {
            MaxAllowableSpeed = Track->TrackElementAt(1433, CurrentElement).SpeedLimit23;
        }
        else
        {
            MaxAllowableSpeed = Track->TrackElementAt(1434, CurrentElement).SpeedLimit01;
        }
        // Train MaxRunningSpeed taken into account in RebuildOpTimeToActMultimap
    }

    if(LaterStopNumber > 0)
    {
        KmPerLocationStop = float(DistanceToRedSignal) / LaterStopNumber / 1000; // m to km
        AvTrackSpeed = (8.75 * KmPerLocationStop) + 44;
    }
    else
    // Av speed calculation based on formula: Speed = 8.75*(kms/location stop) + 44 km/sec (from experiments), subject to a maximum of
    // average line speed/2 (for half distance accelerating and half decelerating.
    {
        AvTrackSpeed = (sqrt(float(DistanceToRedSignal) / 1000) * 44) + 60;
        // using linear trendline for accel & decel distance at various speeds
        // at half braking, speed never < 60 using this
    }
    if(AvTrackSpeed > MaxAllowableSpeed)
    {
        AvTrackSpeed = MaxAllowableSpeed;
    }
    Utilities->CallLogPop(2096);
    return(DistanceToRedSignal);
}

// ---------------------------------------------------------------------------
// end of TTrainController entries
// ---------------------------------------------------------------------------
