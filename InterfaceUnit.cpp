// InterfaceUnit.cpp
/*
   BEWARE OF COMMENTS in .cpp files:  they were accurate when written but have
   sometimes been overtaken by changes and not updated
   Comments in .h files are believed to be accurate and up to date

   This is a source code file for "railway.exe", a railway operation
   simulator, written originally in Borland C++ Builder 4 Professional with
   later updates in Embarcadero C++Builder 10.2.
   Copyright (C) 2010 Albert Ball [original development]

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// ---------------------------------------------------------------------------

#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include <Forms.hpp>
#include <Buttons.hpp>
#include <ExtCtrls.hpp>
#include <Menus.hpp>
#include <Dialogs.hpp>
#include <Graphics.hpp>
#include <ComCtrls.hpp>
#include <Clipbrd.hpp> //for selection clipboard functions at v2.8.0
#include <fstream>
#include <sstream> //for clipboard functions at v2.8.0
#include <vector>
#include <vcl.h>
#include <stdio.h>
#include <algorithm>  //for sort

#pragma hdrstop
// The above batch of include files above #pragma hdrstop appear in all .cpp files.
// They aren't all needed in each case but being together and identical they speed
// up compilation considerably (without ~14 min, with ~1 min!). They are used in
// conjunction with 'use pre-compiled headers' in the project compiler options.

#include "InterfaceUnit.h"
#include "GraphicUnit.h"
//#include "DisplayUnit.h" included in TrackUnit.h
#include "TextUnit.h"
#include "TrainUnit.h"
#include "TrackUnit.h"
#include "AboutUnit.h"
#include "PerfLogUnit.h" //added at v2.13.0 for Performance log form
#include "ActionsDueUnit.h" //added at v2.13.0 for ActionsDue form
#include "Utilities.h"
#include "API.h"        //added at v2.10.0
#include <dirent.h>
#include <Filectrl.hpp> //to check whether directories exist

// ---------------------------------------------------------------------------
#include <Vcl.HTMLHelpViewer.hpp>   //added at v2.0.0 for access to the .chm help file
#pragma package(smart_init)
#pragma link "Vcl.HTMLHelpViewer"   //added at v2.0.0 for access to the .chm help file
#pragma resource "*.dfm"

TInterface *Interface;
API *session_api_;  //moved from header to avoid AboutForm having access and defining _session_api_
                    //as well as Interface and giving a warning, added at v2.10.0

// Folder Names
const UnicodeString TInterface::RAILWAY_DIR_NAME = "Railways";
const UnicodeString TInterface::TIMETABLE_DIR_NAME = "Program timetables";
const UnicodeString TInterface::PERFLOG_DIR_NAME = "Performance logs";
const UnicodeString TInterface::SESSION_DIR_NAME = "Sessions";
const UnicodeString TInterface::IMAGE_DIR_NAME = "Images";
const UnicodeString TInterface::FORMATTEDTT_DIR_NAME = "Formatted timetables";
const UnicodeString TInterface::USERGRAPHICS_DIR_NAME = "Graphics";

// ---------------------------------------------------------------------------

__fastcall TInterface::TInterface(TComponent* Owner) : TForm(Owner)
{
    // constructor
    try
    {
        Screen->Cursor = TCursor(-11); // Hourglass
        DirOpenError = false;
        AllSetUpFlag = false; //flag to prevent MasterClock from being enabled when application activates if there has been an error during
        // initial setup
        // MasterClock->Enabled = false;//keep this stopped until all set up (no effect here as form not yet created, made false in object insp)
        // Visible = false; //keep the Interface form invisible until all set up (no effect here as form not yet created, made false in object insp)
        ProgramVersion = GetVersion();
        // use GNU Major/Minor/Patch version numbering system, change for each published modification, Dev x = interim internal
        // development stages (don't show on published versions)

        // check for presence of directories, creation failure probably indicates that the
        // working folder is read-only

        CurDir = AnsiString(GetCurrentDir());
//        ShowMessage("Curdir from GetCurrentDir() " + CurDir);    //these used to check behaviour outside the compiler
        UnicodeString FullProgramName = GetModuleName(0);              // added at v2.9.0 to check executable exists
//        ShowMessage("FullProgramName " + FullProgramName);
        UnicodeString ProgramName = ExtractFileName(FullProgramName);  // as above
//        ShowMessage("ProgramName " + ProgramName);
        UnicodeString ProgramDirectoryName = ExtractFilePath(FullProgramName);  // as above
//        ShowMessage("ProgramDirectoryName " + ProgramDirectoryName);

        if(!FileExists(ProgramName))  //added at v2.9.0 after discovering the effect described in the message
        {
            if(!SetCurrentDir(ProgramDirectoryName)) //if false the current directory couldn't be changed
            {
                ShowMessage("The working directory does not contain the railway executable file so the program cannot "
                            "open. This is usually because the program has been selected via the right-click taskbar icon though it may "
                            "also happen in other circumstances. It is caused by the Windows operating system re-assigning the "
                            "working directory for some unknown reason, though whether or not it happens appears to depend on the "
                            "Windows update version.\n\n"
                            "To avoid this happening please open the program by double clicking the program icon on the desktop "
                            "if there is one, or the program icon shown in Windows Explorer.");
                Application->Terminate();
            }
            else
            {
                CurDir = AnsiString(GetCurrentDir());
            }
        }

        if(!DirectoryExists(RAILWAY_DIR_NAME))
        {
            if(!CreateDir(RAILWAY_DIR_NAME))
            {
                DirOpenError = true;
            }

        }
        if(!DirectoryExists(TIMETABLE_DIR_NAME))
        {
            if(!CreateDir(TIMETABLE_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(!DirectoryExists(PERFLOG_DIR_NAME))
        {
            if(!CreateDir(PERFLOG_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(!DirectoryExists(SESSION_DIR_NAME))
        {
            if(!CreateDir(SESSION_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(!DirectoryExists(IMAGE_DIR_NAME))
        {
            if(!CreateDir(IMAGE_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(!DirectoryExists(FORMATTEDTT_DIR_NAME))
        {
            if(!CreateDir(FORMATTEDTT_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(!DirectoryExists(USERGRAPHICS_DIR_NAME))
        {
            if(!CreateDir(USERGRAPHICS_DIR_NAME))
            {
                DirOpenError = true;
            }
        }
        if(DirOpenError)
        {
            ShowMessage("Failed to create one or more of folders: " + RAILWAY_DIR_NAME + ", " + TIMETABLE_DIR_NAME + ", " + PERFLOG_DIR_NAME + ", " +
                        SESSION_DIR_NAME + ", " + IMAGE_DIR_NAME + ", " + FORMATTEDTT_DIR_NAME + ", " + USERGRAPHICS_DIR_NAME + ", " +
                        "program operation will be restricted");
        }
        Application->HelpFile = AnsiString(CurDir + "\\Help.chm"); // added at v2.0.0 for .chm help file

        MainMenu1->AutoHotkeys = maManual; // Embarcadero mod: to suppress '&' inclusion for underlined characters in menu items
        PopupMenu->AutoHotkeys = maManual; // as above

        Utilities = new TUtilities;
        RailGraphics = new TRailGraphics();

        int DispW = (Screen->Width - 64) / 16; // will truncate down to a multiple of 16 OK here as screen dimensions are accurate
        int DispH = (Screen->Height - 192) / 16; // Interface dimensions are 16 too wide & 14 short in height
        MainScreen->Width = DispW * 16;
        MainScreen->Height = DispH * 16;

        Display = new TDisplay(MainScreen, OutputLog1, OutputLog2, OutputLog3, OutputLog4, OutputLog5, OutputLog6, OutputLog7, OutputLog8,
                               OutputLog9, OutputLog10);
        Utilities->ScreenElementWidth = DispW;
        Utilities->ScreenElementHeight = DispH;
        HiddenScreen = new TImage(Interface);
        HiddenScreen->Width = MainScreen->Width;
        HiddenScreen->Height = MainScreen->Height;
        HiddenDisplay = new TDisplay(HiddenScreen, OutputLog1, OutputLog2, OutputLog3, OutputLog4, OutputLog5, OutputLog6, OutputLog7,
                                     OutputLog8, OutputLog9, OutputLog10);
        TextHandler = new TTextHandler;
        Track = new TTrack;
        AllRoutes = new TAllRoutes;
        ConstructPrefDir = new TOnePrefDir;
        ConstructRoute = new TOneRoute;
        EveryPrefDir = new TOnePrefDir;
        SelectPrefDir = new TOnePrefDir;
        TrainController = new TTrainController;
        SelectBitmap = new Graphics::TBitmap;
        SelectBitmap->PixelFormat = pf8bit;
        SelectBitmap->Transparent = true;
        PointFlash = new TGraphicElement;
        AutoRouteStartMarker = new TGraphicElement;
        SigRouteStartMarker = new TGraphicElement;
        NonSigRouteStartMarker = new TGraphicElement;
        LengthWarningSentFlag = false;
        PasteWarningSentFlag = false; // added at v2.6.0
        FillSelectionMessageSentFlag = false; // added at v2.6.0
        LCManualLowerBarriersMessageSent = false; // added at v2.6.0
        RecoverClipboardMessageSent = false; // added at v2.8.0
        TooLongMessageSentFlag = false; //added at v2.9.1
        TooShortMessageSentFlag = false; //added at v2.9.1
        Track->NoPlatsMessageSent = false; //added at v2.10.0
        PrefDirConflictAdviceMessageSent = false; //added at v2.13.0
        TrainLeaveWarningSent = false; //added at v2.14.0
        InvertTTEntryMessageSent = false; //added at v2.15.0
        Utilities->DefaultTrackLength = 100;     //moved here at v2.11.0, may be changed in reading config.txt //changed at v2.13.1
        Utilities->DefaultTrackSpeedLimit = 200; //moved here at v2.11.0, may be changed in reading config.txt


        TrackInfoOnOffMenuItem->Caption = "Show"; // added here at v1.2.0 because dropped from ResetAll()
        TrainStatusInfoOnOffMenuItem->Caption = "Hide Status"; // changed at v2.0.0 so normally visible
        TrainTTInfoOnOffMenuItem->Caption = "Hide Timetable"; // as above
        NoDelaysMenuItem->Enabled = false;
        NoFailuresMenuItem->Enabled = false;

        /* ======================= ROS Dummy API ===============================
                    Connect API to track variables of interest, added at v2.10.0
        */
        session_api_ = new API(CurDir + "\\session.ini");
        session_api_->add_metadata_str("railway", &RailwayTitle);
        session_api_->add_metadata_str("timetable", &TimetableTitle);
        session_api_->add_metadata_str("performance_file", &PerformanceFileName);
        session_api_->add_metadata_int("main_mode", &api_main_mode_);
        session_api_->add_metadata_int("operation_mode", &api_oper_mode_);

        // =====================================================================

        ResetAll(0);

        TempTTFileName = "";

        PointFlash->LoadOverlayGraphic(3, RailGraphics->bmGreenRect);
        AutoRouteStartMarker->LoadOverlayGraphic(4, RailGraphics->bmLightBlueRect);
        SigRouteStartMarker->LoadOverlayGraphic(5, RailGraphics->bmGreenRect);
        NonSigRouteStartMarker->LoadOverlayGraphic(6, RailGraphics->bmRedRect);

        RouteFlashDuration = 0.0;
        PointsFlashDuration = 0.0;

        FloatingLabel->Color = clB4G5R5;
        TrackElementPanel->Color = clB5G5R4;
        InfoPanel->Color = clB4G5R5;

        Utilities->RHSignalFlag = false; // new at v2.3.0 for RH signals, always left hand on startup
        SigsOnLeftImage1->Picture->Bitmap->LoadFromResourceName(0, "SigsOnLeft");
        SigsOnLeftImage2->Picture->Bitmap->LoadFromResourceName(0, "SigsOnLeft");
        SigsOnLeftImage1->Transparent = true;
        SigsOnLeftImage2->Transparent = true;
        SigsOnLeftImage1->Picture->Bitmap->TransparentColor = clB5G5R5;
        SigsOnLeftImage2->Picture->Bitmap->TransparentColor = clB5G5R5;
        SigsOnRightImage1->Picture->Bitmap->LoadFromResourceName(0, "SigsOnRight");
        SigsOnRightImage2->Picture->Bitmap->LoadFromResourceName(0, "SigsOnRight");
        SigsOnRightImage1->Transparent = true;
        SigsOnRightImage2->Transparent = true;
        SigsOnRightImage1->Picture->Bitmap->TransparentColor = clB5G5R5;
        SigsOnRightImage2->Picture->Bitmap->TransparentColor = clB5G5R5;

        SaveRailwayDialog->InitialDir = CurDir + "\\" + RAILWAY_DIR_NAME; // default locations, may be changed when Config.txt loaded
        LoadRailwayDialog->InitialDir = CurDir + "\\" + RAILWAY_DIR_NAME;
        TimetableDialog->InitialDir = CurDir + "\\" + TIMETABLE_DIR_NAME;
        SaveTTDialog->InitialDir = CurDir + "\\" + TIMETABLE_DIR_NAME;
        LoadSessionDialog->InitialDir = CurDir + "\\" + SESSION_DIR_NAME;
        LoadUserGraphicDialog->InitialDir = CurDir + "\\" + USERGRAPHICS_DIR_NAME; // not changeable
        LoadCouplingFileDialog->InitialDir = CurDir; // not changeable
        ReloadConfigMenuItem->Enabled = true;  //new at v2.11.0
        bool NoConfig = false;
        LoadConfigFile(0, true, NoConfig); //true for first load
        if(NoConfig)
        {
            SaveConfigFile(0);  //added at v2.13.1 so always have a config file
        }

        SpeedButton1->Glyph->LoadFromResourceName(0, "gl1");
        SpeedButton2->Glyph->LoadFromResourceName(0, "gl2");
        SpeedButton3->Glyph->LoadFromResourceName(0, "gl3");
        SpeedButton4->Glyph->LoadFromResourceName(0, "gl4");
        SpeedButton5->Glyph->LoadFromResourceName(0, "gl5");
        SpeedButton6->Glyph->LoadFromResourceName(0, "gl6");
        SpeedButton7->Glyph->LoadFromResourceName(0, "gl7");
        SpeedButton8->Glyph->LoadFromResourceName(0, "gl8");
        SpeedButton9->Glyph->LoadFromResourceName(0, "gl9");
        SpeedButton10->Glyph->LoadFromResourceName(0, "gl10");
        SpeedButton11->Glyph->LoadFromResourceName(0, "gl11");
        SpeedButton12->Glyph->LoadFromResourceName(0, "gl12");
        SpeedButton13->Glyph->LoadFromResourceName(0, "gl13");
        SpeedButton14->Glyph->LoadFromResourceName(0, "gl14");
        SpeedButton15->Glyph->LoadFromResourceName(0, "gl15");
        SpeedButton16->Glyph->LoadFromResourceName(0, "gl16");
        SpeedButton18->Glyph->LoadFromResourceName(0, "gl18");
        SpeedButton19->Glyph->LoadFromResourceName(0, "gl19");
        SpeedButton20->Glyph->LoadFromResourceName(0, "gl20");
        SpeedButton21->Glyph->LoadFromResourceName(0, "gl21");
        SpeedButton22->Glyph->LoadFromResourceName(0, "gl22");
        SpeedButton23->Glyph->LoadFromResourceName(0, "gl23");
        SpeedButton24->Glyph->LoadFromResourceName(0, "gl24");
        SpeedButton25->Glyph->LoadFromResourceName(0, "gl25");
        SpeedButton26->Glyph->LoadFromResourceName(0, "gl26");
        SpeedButton27->Glyph->LoadFromResourceName(0, "gl27");
        SpeedButton28->Glyph->LoadFromResourceName(0, "gl28");
        SpeedButton29->Glyph->LoadFromResourceName(0, "gl29");
        SpeedButton30->Glyph->LoadFromResourceName(0, "gl30");
        SpeedButton31->Glyph->LoadFromResourceName(0, "gl31");
        SpeedButton32->Glyph->LoadFromResourceName(0, "gl32");
        SpeedButton33->Glyph->LoadFromResourceName(0, "gl33");
        SpeedButton34->Glyph->LoadFromResourceName(0, "gl34");
        SpeedButton35->Glyph->LoadFromResourceName(0, "gl35");
        SpeedButton36->Glyph->LoadFromResourceName(0, "gl36");
        SpeedButton37->Glyph->LoadFromResourceName(0, "gl37");
        SpeedButton38->Glyph->LoadFromResourceName(0, "gl38");
        SpeedButton39->Glyph->LoadFromResourceName(0, "gl39");
        SpeedButton40->Glyph->LoadFromResourceName(0, "gl40");
        SpeedButton41->Glyph->LoadFromResourceName(0, "gl41");
        SpeedButton42->Glyph->LoadFromResourceName(0, "gl42");
        SpeedButton43->Glyph->LoadFromResourceName(0, "gl43");
        SpeedButton44->Glyph->LoadFromResourceName(0, "gl44");
        SpeedButton45->Glyph->LoadFromResourceName(0, "gl45");
        SpeedButton46->Glyph->LoadFromResourceName(0, "gl46");
        SpeedButton47->Glyph->LoadFromResourceName(0, "gl47");
        SpeedButton48->Glyph->LoadFromResourceName(0, "gl48");
        SpeedButton49->Glyph->LoadFromResourceName(0, "gl49");
        SpeedButton50->Glyph->LoadFromResourceName(0, "gl50");
        SpeedButton51->Glyph->LoadFromResourceName(0, "gl51");
        SpeedButton52->Glyph->LoadFromResourceName(0, "gl52");
        SpeedButton53->Glyph->LoadFromResourceName(0, "gl53");
        SpeedButton54->Glyph->LoadFromResourceName(0, "gl54");
        SpeedButton55->Glyph->LoadFromResourceName(0, "gl55");
        SpeedButton56->Glyph->LoadFromResourceName(0, "gl56");
        SpeedButton57->Glyph->LoadFromResourceName(0, "gl57");
        SpeedButton58->Glyph->LoadFromResourceName(0, "gl58");
        SpeedButton59->Glyph->LoadFromResourceName(0, "gl59");
        SpeedButton60->Glyph->LoadFromResourceName(0, "gl60");
        SpeedButton61->Glyph->LoadFromResourceName(0, "gl61");
        SpeedButton62->Glyph->LoadFromResourceName(0, "gl62");
        SpeedButton63->Glyph->LoadFromResourceName(0, "gl63");
        SpeedButton64->Glyph->LoadFromResourceName(0, "gl64");
        SpeedButton65->Glyph->LoadFromResourceName(0, "gl65");
        SpeedButton66->Glyph->LoadFromResourceName(0, "gl66");
        SpeedButton67->Glyph->LoadFromResourceName(0, "gl67");
        SpeedButton68->Glyph->LoadFromResourceName(0, "gl68");
        SpeedButton69->Glyph->LoadFromResourceName(0, "gl69");
        SpeedButton70->Glyph->LoadFromResourceName(0, "gl70");
        SpeedButton71->Glyph->LoadFromResourceName(0, "gl71");
        SpeedButton72->Glyph->LoadFromResourceName(0, "gl72");
        SpeedButton73->Glyph->LoadFromResourceName(0, "gl73");
        SpeedButton74->Glyph->LoadFromResourceName(0, "gl74");
        SpeedButton75->Glyph->LoadFromResourceName(0, "gl75");
        SpeedButton76->Glyph->LoadFromResourceName(0, "gl76");
        SpeedButton77->Glyph->LoadFromResourceName(0, "gl77");
        SpeedButton78->Glyph->LoadFromResourceName(0, "gl78");
        SpeedButton79->Glyph->LoadFromResourceName(0, "gl79");
        SpeedButton80->Glyph->LoadFromResourceName(0, "gl80");
        SpeedButton81->Glyph->LoadFromResourceName(0, "gl81");
        SpeedButton82->Glyph->LoadFromResourceName(0, "gl82");
        SpeedButton83->Glyph->LoadFromResourceName(0, "gl83");
        SpeedButton84->Glyph->LoadFromResourceName(0, "gl84");
        SpeedButton85->Glyph->LoadFromResourceName(0, "gl85");
        SpeedButton86->Glyph->LoadFromResourceName(0, "gl86");
        SpeedButton87->Glyph->LoadFromResourceName(0, "gl87");
        SpeedButton88->Glyph->LoadFromResourceName(0, "gl88set");
        SpeedButton89->Glyph->LoadFromResourceName(0, "gl89set");
        SpeedButton90->Glyph->LoadFromResourceName(0, "gl90set");
        SpeedButton91->Glyph->LoadFromResourceName(0, "gl91set");
        SpeedButton92->Glyph->LoadFromResourceName(0, "gl92set");
        SpeedButton93->Glyph->LoadFromResourceName(0, "gl93set");
        SpeedButton94->Glyph->LoadFromResourceName(0, "gl94set");
        SpeedButton95->Glyph->LoadFromResourceName(0, "gl95set");
        SpeedButton96->Glyph->LoadFromResourceName(0, "ConcourseGlyph");
        SpeedButton97->Glyph->LoadFromResourceName(0, "gl97");
        SpeedButton98->Glyph->LoadFromResourceName(0, "gl98");
        SpeedButton99->Glyph->LoadFromResourceName(0, "gl99");
        SpeedButton100->Glyph->LoadFromResourceName(0, "gl100");
        SpeedButton101->Glyph->LoadFromResourceName(0, "gl101");
        SpeedButton102->Glyph->LoadFromResourceName(0, "gl102");
        SpeedButton103->Glyph->LoadFromResourceName(0, "gl103");
        SpeedButton104->Glyph->LoadFromResourceName(0, "gl104");
        SpeedButton105->Glyph->LoadFromResourceName(0, "gl105");
        SpeedButton106->Glyph->LoadFromResourceName(0, "gl106");
        SpeedButton107->Glyph->LoadFromResourceName(0, "gl107");
        SpeedButton108->Glyph->LoadFromResourceName(0, "gl108");
        SpeedButton109->Glyph->LoadFromResourceName(0, "gl109");
        SpeedButton110->Glyph->LoadFromResourceName(0, "gl110");
        SpeedButton111->Glyph->LoadFromResourceName(0, "gl111");
        SpeedButton112->Glyph->LoadFromResourceName(0, "gl112");
        SpeedButton113->Glyph->LoadFromResourceName(0, "gl113");
        SpeedButton114->Glyph->LoadFromResourceName(0, "gl114");
        SpeedButton115->Glyph->LoadFromResourceName(0, "gl115");
        SpeedButton116->Glyph->LoadFromResourceName(0, "gl116");
        SpeedButton117->Glyph->LoadFromResourceName(0, "gl117");
        SpeedButton118->Glyph->LoadFromResourceName(0, "gl118");
        SpeedButton119->Glyph->LoadFromResourceName(0, "gl119");
        SpeedButton120->Glyph->LoadFromResourceName(0, "gl120");
        SpeedButton121->Glyph->LoadFromResourceName(0, "gl121");
        SpeedButton122->Glyph->LoadFromResourceName(0, "gl122");
        SpeedButton123->Glyph->LoadFromResourceName(0, "gl123");
        SpeedButton124->Glyph->LoadFromResourceName(0, "gl124");
        SpeedButton125->Glyph->LoadFromResourceName(0, "gl125");
        SpeedButton126->Glyph->LoadFromResourceName(0, "gl126");
        SpeedButton127->Glyph->LoadFromResourceName(0, "gl127");
        SpeedButton128->Glyph->LoadFromResourceName(0, "gl128");
        SpeedButton129->Glyph->LoadFromResourceName(0, "gl129");
        SpeedButton130->Glyph->LoadFromResourceName(0, "gl130");
        SpeedButton131->Glyph->LoadFromResourceName(0, "gl131");
        SpeedButton132->Glyph->LoadFromResourceName(0, "gl132");
        SpeedButton133->Glyph->LoadFromResourceName(0, "gl133");
        SpeedButton134->Glyph->LoadFromResourceName(0, "gl134");
        SpeedButton135->Glyph->LoadFromResourceName(0, "gl135");
        SpeedButton136->Glyph->LoadFromResourceName(0, "gl136");
        SpeedButton137->Glyph->LoadFromResourceName(0, "gl137");
        SpeedButton138->Glyph->LoadFromResourceName(0, "gl138");
        SpeedButton139->Glyph->LoadFromResourceName(0, "gl139");
        SpeedButton140->Glyph->LoadFromResourceName(0, "gl140");
        SpeedButton141->Glyph->LoadFromResourceName(0, "gl141");
        SpeedButton142->Glyph->LoadFromResourceName(0, "gl142");
        SpeedButton143->Glyph->LoadFromResourceName(0, "gl143");
        SpeedButton145->Glyph->LoadFromResourceName(0, "gl145");
        SpeedButton146->Glyph->LoadFromResourceName(0, "gl146");
        // below not in RailGraphics
        SpeedButton144->Glyph->LoadFromResourceName(0, "LCGlyph");

        AddPrefDirButton->Glyph->LoadFromResourceName(0, "AddPrefDir");
        AddTextButton->Glyph->LoadFromResourceName(0, "AddText");
        AddTrackButton->Glyph->LoadFromResourceName(0, "AddTrack");
        AutoSigsButton->Glyph->LoadFromResourceName(0, "AutoTop");
        SigAutoNonConsecButton->Glyph->LoadFromResourceName(0, "AutoBottom");
        CallingOnButton->Glyph->LoadFromResourceName(0, "CallingOn");
        DeleteAllPrefDirButton->Glyph->LoadFromResourceName(0, "ClearAllPrefDir");
        DeleteOnePrefDirButton->Glyph->LoadFromResourceName(0, "ClearOnePrefDir");
        ExitOperationButton->Glyph->LoadFromResourceName(0, "Exit");
        ExitPrefDirButton->Glyph->LoadFromResourceName(0, "Exit");
        ExitTrackButton->Glyph->LoadFromResourceName(0, "Exit");
        ExitTTModeButton->Glyph->LoadFromResourceName(0, "Exit");
        FontButton->Glyph->LoadFromResourceName(0, "FontGraphic");
        HomeButton->Glyph->LoadFromResourceName(0, "Home");
        LocationNameButton->Glyph->LoadFromResourceName(0, "NameLocs");
        MoveTextOrGraphicButton->Glyph->LoadFromResourceName(0, "MoveTextOrGraphic");
        NewHomeButton->Glyph->LoadFromResourceName(0, "NewHome");
        UnrestrictedButton->Glyph->LoadFromResourceName(0, "NonSig");
        OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
        OperatorActionButton->Glyph->LoadFromResourceName(0, "ShowOpActionPanel");
        PerformanceLogButton->Glyph->LoadFromResourceName(0, "ShowLog");
        PresetAutoSigRoutesButton->Glyph->LoadFromResourceName(0, "PresetAutoSigRoutes");
        RouteCancelButton->Glyph->LoadFromResourceName(0, "RouteCancel");
        SaveRailwayPDPButton->Glyph->LoadFromResourceName(0, "SaveRailway"); // PrefDirPanel
        SaveRailwayBaseModeButton->Glyph->LoadFromResourceName(0, "SaveRailway"); // OperatingPanel
        SaveRailwayTBPButton->Glyph->LoadFromResourceName(0, "SaveRailway"); // TrackBuildPanel
        SaveSessionButton->Glyph->LoadFromResourceName(0, "SaveSession");
        ScreenDownButton->Glyph->LoadFromResourceName(0, "BlackArrowDown");
        ScreenGridButton->Glyph->LoadFromResourceName(0, "ScreenGrid");
        ScreenLeftButton->Glyph->LoadFromResourceName(0, "BlackArrowLeft");
        ScreenRightButton->Glyph->LoadFromResourceName(0, "BlackArrowRight");
        ScreenUpButton->Glyph->LoadFromResourceName(0, "BlackArrowUp");
        SetGapsButton->Glyph->LoadFromResourceName(0, "ConnectGaps");
        SetLengthsButton->Glyph->LoadFromResourceName(0, "SetDists");
        ShowHideTTButton->Glyph->LoadFromResourceName(0, "Hide");
        SigAspectButton->Glyph->LoadFromResourceName(0, "FourAspect"); // new at version 0.6
        SigPrefConsecButton->Glyph->LoadFromResourceName(0, "PrefTop");
        SigPrefNonConsecButton->Glyph->LoadFromResourceName(0, "PrefBottom");
        TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision1");
        TrackOKButton->Glyph->LoadFromResourceName(0, "Validate");
        TTClockAdjButton->Glyph->LoadFromResourceName(0, "TTClock");
        UserGraphicButton->Glyph->LoadFromResourceName(0, "PictureImage");

        BufferAttentionImage->Picture->Bitmap->LoadFromResourceName(0, "BufferWarning");
        CallOnImage->Picture->Bitmap->LoadFromResourceName(0, "CallingOn");
        CrashImage->Picture->Bitmap->LoadFromResourceName(0, "CrashWarning");
        DerailImage->Picture->Bitmap->LoadFromResourceName(0, "DerailWarning");
        SignalStopImage->Picture->Bitmap->LoadFromResourceName(0, "SignalStopWarning");
        SPADImage->Picture->Bitmap->LoadFromResourceName(0, "SPADWarning");
        TrainFailedImage->Picture->Bitmap->LoadFromResourceName(0, "TrainFailedWarning"); // new at v2.4.0
        ManualLCDownImage->Picture->Bitmap->LoadFromResourceName(0, "ManualLCDownImage"); // new at v2.9.0

        DistanceKey->Picture->Bitmap->LoadFromResourceName(0, "DistanceKey");
        PrefDirKey->Picture->Bitmap->LoadFromResourceName(0, "PrefDirKey");

        TrackLinkedImage->Picture->Bitmap->LoadFromResourceName(0, "TrackLinkedGraphic");
        TrackNotLinkedImage->Picture->Bitmap->LoadFromResourceName(0, "TrackNotLinkedGraphic");
        GapsNotSetImage->Picture->Bitmap->LoadFromResourceName(0, "GapsNotSetGraphic");
        GapsSetImage->Picture->Bitmap->LoadFromResourceName(0, "GapsSetGraphic");
        LocationNamesNotSetImage->Picture->Bitmap->LoadFromResourceName(0, "LocNamesNotSetGraphic");
        LocationNamesSetImage->Picture->Bitmap->LoadFromResourceName(0, "LocNamesSetGraphic");

        SkipListExitImage->Picture->Bitmap->LoadFromResourceName(0, "Exit"); //new at v2.11.0


/* Don't need this - load icon directly into both Interface form & Application (via Project - Options - Application - Load Icon)
     RailwayIcon = new TPicture;
     RailwayIcon->Icon->LoadFromResourceName(0, "Icon1.ico");
     Icon = RailwayIcon->Icon;
     Application->Icon = RailwayIcon->Icon;
*/

        AnsiString NL = '\n';
        const AnsiString TTLabelStr1 = "Start new train" + NL + "Start new service from a split" + NL + "Start new service from another service" + NL +
            "Start new non-repeating shuttle finish service" + NL + "Start new shuttle train at a timetabled stop" + NL +
            "Start new shuttle service from a feeder";

        const AnsiString TTLabelStr2 = "Pass" + NL + "Be joined by another train" + NL + "Front split" + NL + "Rear split" + NL + "Change direction of train";

        const AnsiString TTLabelStr3 = "Finish && form a new service" + NL + "Finish && join another train" + NL + "Finish && exit railway" + NL +
            "Finish && repeat shuttle, finally remain here" + NL + "Finish && repeat shuttle, finally form a finishing service" + NL +
            "Finish non-repeating shuttle feeder service" + NL + "Finish && remain here";

        const AnsiString TTLabelStr4 = "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL +
            "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "HH:MM" + NL + "     " +
            NL + "R";

        const AnsiString TTLabelStr5 = "HH:MM ';' Location" + NL + "HH:MM ';' HH:MM ';' Location";

        const AnsiString TTLabelStr6 = "+ rear element ID - space - front element ID [+ optional ';S']" + NL + "+ ref. of the train that splits" + NL +
            "+ other service ref." + NL + "+ shuttle service ref." + NL + "+ rear element ID - space - front element ID ';' linked shuttle ref." + NL +
            "+ linked shuttle service ref. ';' feeder service ref." + NL + "+ location" + NL + "+ joining train ref." + NL + "+ new service ref." + NL +
            "+ new service ref." + NL + "    " + NL + "+ new service ref." + NL + "+ ref. of train to join" + NL +
            "+ list of valid exit element IDs (at least 1) separated by spaces" + NL + "+ linked shuttle service ref.";

        const AnsiString TTLabelStr7 = "Arrival OR departure time (program will determine which from the context) + location." + NL +
            "Arrival time, departure time (with no events between) + location";

        const AnsiString TTLabelStr9 = "Timetable entries" + NL + "(service references etc.)";
        const AnsiString TTLabelStr11 = "Timetable" + NL + "start time";

        const AnsiString TTLabelStr12 = "NB: WITHIN SERVICES commas must" + NL + "not be used (have special meanings)," + NL +
            "and semicolons may only be used to" + NL + "separate service components.";

        const AnsiString TTLabelStr13 = "+ linked shuttle service ref. ';' finishing service ref." + NL + "+ linked shuttle service ref.";

        const AnsiString TTLabelStr15 = "Repeat the service + ';' minutes between repeats ';' digit increment ';' number of repeats (last line of service)";

        TTLabel1->Caption = TTLabelStr1;
        TTLabel2->Caption = TTLabelStr2;
        TTLabel3->Caption = TTLabelStr3;
        TTLabel4->Caption = TTLabelStr4;
        TTLabel5->Caption = TTLabelStr5;
        TTLabel6->Caption = TTLabelStr6;
        TTLabel7->Caption = TTLabelStr7;
        TTLabel9->Caption = TTLabelStr9;
        TTLabel11->Caption = TTLabelStr11;
        TTLabel12->Caption = TTLabelStr12;
        TTLabel13->Caption = TTLabelStr13;
        TTLabel15->Caption = TTLabelStr15;

        SelectBitmap->TransparentColor = Utilities->clTransparent;
        RailGraphics->ChangeAllTransparentColours(Utilities->clTransparent, clB5G5R5); // original colour is as loaded at this stage - white
        RailGraphics->SetUpAllDerivitiveGraphics(Utilities->clTransparent);

        TextBox->Color = clB3G3R3;
        MainScreen->Canvas->Brush->Color = Utilities->clTransparent;
        MainScreen->Canvas->FillRect(MainScreen->ClientRect);

        if((Screen->Width < 1024) || (Screen->Height < 768))
        {
            ShowMessage("Please note that this program works best with a screen resolution of at least 1024 x 768.  Please change if possible");
        }
        SkipFormResizeEvent = true; // added at v2.1.0
        MasterClock->Enabled = true;
        Visible = true; // make Interface form visible (set to false at design time)    autocalls FormResize so it is skipped by SkipFormResizeEvent being true
        WindowState = wsMaximized; // need this for full screen at start                autocalls FormResize so it is skipped by SkipFormResizeEvent being true
        MTBFEditBox->Left = MainScreen->Left + MainScreen->Width - MTBFEditBox->Width + 30; // new v2.4.0 30 is to place it above the positional panel
                                                                                            // has to come after Visible = true or doesn't show
        MTBFLabel->Left = MainScreen->Left + MainScreen->Width - MTBFEditBox->Width + 30 - 55; // new v2.4.0 placed above and to the left of MTBFEditBox
        PositionalPanel->Left = MainScreen->Left + MainScreen->Width; // changed at v2.4.0
        PositionalPanel->Top = MainScreen->Top; // changed at v2.4.0
        PositionalPanel->Height = MainScreen->Height; // changed at v2.4.0
        AllSetUpFlag = true;
        TotalTicks = 0;
        Level1Mode = BaseMode;
        SetLevel1Mode(131); // to reset background colour mode menu choices
        Screen->Cursor = TCursor(-2); // Arrow
        SkipFormResizeEvent = false; // added at v2.1.0
        SelectedGraphicFileName = ""; // only set to null here so always has a value after use LoadUserGraphic

        FloatingPanel->Color = TColor(0xF0FFFF); // new v2.2.0, corrects floating panel background colour in Windows 10
        DevelopmentPanel->Color = TColor(0xCCCCCC); // new v2.2.0 as above
        TTStartTimeBox->Color = TColor(0x99FFFF); // cream
        HighlightPanel->Color = TColor(0x33CCFF);
        TrainController->OpActionPanelHintDelayCounter = 0;
        MTBFEditBox->Visible = false; // new at v2.4.0
        MTBFLabel->Visible = false;
        TrainController->AvHoursIntValue = 0;
        TrainController->MTBFHours = 0;
        TrainController->TwoOrMoreLocationsWarningGiven = false;
        CancelSelectionFlag = false;
        TTStartTimePtr = TimetableEditVector.end(); //these are iterators so can't use '0'in 64bit version, best to initialise to an invalid location to force errors if not set properly
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();
        Track->OverrideAndHideSignalBridgeMessage = false; // added at v2.5.1 to allow facing signals before bridges - with a warning
        ConflictPanel->Visible = false;
        TTClockAdjustWarningPanel->Visible = false;
        TTClockAdjustWarningHide = false;
        TwoLocationNamePanel->Visible = false;
        TwoLocationNamePanelHide = false;
        LastNonCtrlOrShiftKeyDown = -1; // set to no key
        ClipboardChecked = false;
        MMoveTrackSelFlag = false;
        MMovePrefDirSelFlag = false;
        MMoveCopyCutSelPickedUpFlag = false;
        MMoveTextGraphicTextFoundFlag = false;
        MMoveTextGraphicUserGraphicFoundFlag = false;
        NumPlayers = 0; //Multiplayer integer
        MultiplayerMenu->Enabled = false;
        MultiplayerMenu->Visible = false; //<-- only until multiplayer added (also temproarily false in designer)
        CouplingFileLoadedFlag = false;
        PlayerMakingInitialContactFlag = false;
        PlayerReadyToBeginFlag = false;
        PlayerCancelJoinFlag = false;
        PlayerAwaitingHostStartFlag = false;
        HostInSessionFlag = false;
        PlayerInSessionFlag = false;
        LastHostDataReceived = TDateTime(0);//initial value
        ConsecutiveSelfUpdates = 0;
        SkipTTActionsListBox->Visible = false;
        SkipListHeaderPanel->Visible = false;
        ElapsedTimeTestFunctionStart = false;
        ElapsedTimerRunning = false;
        Utilities->DelayMode = Nil;
        Utilities->FailureMode = FNil;
        Utilities->MTBTSRs = Utilities->NilMTBTSRs;          //set high initially
        Utilities->SignalChangeEventsPerFailure = Utilities->NilSignalChangeEventsPerFailure; //set high initially
        Utilities->PointChangeEventsPerFailure = Utilities->NilPointChangeEventsPerFailure; //set high initially
        Utilities->CumulativeDelayedRandMinsAllTrains = 0; //added at v2.13.0
        AllEntriesTTListBox->TopIndex = 0; //added at v2.13.0 to initialise the value (seemed to initialise to 0 without this but not documented)

        SigImagePanel->Left = (Interface->Width - SigImagePanel->Width) / 2; // added for v2.3.0

        // below added at v2.4.0 so able to load session files with the correct decimal point
        Utilities->DecimalPoint = '.'; // default case is full stop
        char *LocalNumericInformation = setlocale(LC_NUMERIC, ""); // need this to set lconv to the environment's numeric format
        Utilities->SetLocaleResultOK = true;
        FirstPerfLogFormDisplay = true; //added at v2.13.0 for Performance log form
        if(AnsiString(LocalNumericInformation).Length() == 0) // call failed, don't change decimal point in Utilities.cpp
        {
            Utilities->SetLocaleResultOK = false;
        }
        struct lconv Locale; // store this structure in memory (accessed via locale.h in Utilities.h)
        struct lconv *conv = &Locale;
        // read the locality conversion structure
        conv = localeconv(); // this is what updates the structure
        Utilities->DecimalPoint = conv->decimal_point[0];
    }

    catch(const EFOpenError &e)
    {
        TMsgDlgButtons But;
        But << mbOK;
        MessageDlg(e.Message + " - program must terminate", mtError, But, 0);
        Application->Terminate();
    }

    catch(const Exception &e)
    {
        TMsgDlgButtons But;
        But << mbOK;
        AnsiString Message = "A fatal error occurred during the program setup process, the program must terminate.  Message = " + e.Message;
        MessageDlg(Message, mtError, But, 0); // this message given first in case can't create the error log
        ErrorLog(115, e.Message);
        Application->Terminate();
    }
}

// ---------------------------------------------------------------------------

__fastcall TInterface::~TInterface()
{
    // destructor
    try
    {
        // rewrite ConfigFile with signal handedness, background colour, InitialDir values (may be same but no matter) & default track element length & speed limit
        SaveConfigFile(1);   //added at v2.11.0
        DeleteFile(TempTTFileName); // added at v2.5.0 to prevent temporary files building up
        SkipFormResizeEvent = true; // added at v2.1.0
        delete NonSigRouteStartMarker;
        delete SigRouteStartMarker;
        delete AutoRouteStartMarker;
        delete PointFlash;
        delete SelectBitmap;
        delete TrainController;
        delete EveryPrefDir;
        delete SelectPrefDir;
        delete ConstructRoute;
        delete ConstructPrefDir;
        delete AllRoutes;
        delete Track;
        delete TextHandler;
        delete HiddenDisplay;
        delete HiddenScreen;
        delete Display;
        delete RailGraphics;
        delete Utilities;
        delete session_api_;        //added at v2.10.0
    }
    catch(const Exception &e)
    {
        ErrorLog(116, e.Message);
    }
}
////autocalls FormResize at end

// ---------------------------------------------------------------------------

void __fastcall TInterface::FormCreate(TObject *Sender)
{
    // these functions have to be defined here to take effect when application activated & deactivated
    try
    {
        Application->OnDeactivate = AppDeactivate;
        Application->OnActivate = AppActivate;
    }
    catch(const Exception &e)
    {
        ErrorLog(117, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::AppDeactivate(TObject *Sender)
{
    // pause operation if operating & stop the master clock
    try
    {
        if((Level1Mode == OperMode) && (Level2OperMode == Operating))
        {
            if(Track->RouteFlashFlag) // in case route building - cancels the route, freezes otherwise - reported
            {
                // by Matt Blades 30/06/11
                RevertToOriginalRouteSelector(14);
                ConstructRoute->RouteFlash.RouteFlashVector.clear();
                ConstructRoute->ClearRoute();
                Screen->Cursor = TCursor(-2); // Arrow
                Track->RouteFlashFlag = false;
                ClearandRebuildRailway(48); // to get rid of displayed route
            }
            if(Track->PointFlashFlag)
            // added at v1.3.1 to prevent lockup for flashing points when deactivates.  Notified by Ian Walker in his email of 25/03/13.
            {
                PointFlash->PlotOriginal(42, Display);
                Track->PointFlashFlag = false;
                DivergingPointVectorPosition = -1;
                Screen->Cursor = TCursor(-2); // Arrow
            }
            if(!HostInSessionFlag && !PlayerInSessionFlag) //don't pause if multiplay in session
            {
                Level2OperMode = Paused;
                SetLevel2OperMode(2);
            }
        }
        if(!HostMultiplayInProgressFlag && !PlayerMultiplayInProgressFlag)
        {
            MasterClock->Enabled = false; //keep enabled for comms in multiplayer
        }
        ClipboardChecked = false; // added at v2.8.0 to force a check of the clipboard (via ClockTimer2 & SetTrackModeMenu)
    }
    catch(const Exception &e)
    {
        ErrorLog(118, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::AppActivate(TObject *Sender)
{
    // restart the master clock providing Interface constructor has run
    try
    {
        if(AllSetUpFlag)
        {
            MasterClock->Enabled = true; //will already be enabled if no multiplay
            ClipboardChecked = false; // at v2.9.0 added here too as for some unknown reason it doesn't always work when just in deactivate
        }
    }
    catch(const Exception &e)
    {
        ErrorLog(119, e.Message);
    }
}

// ---------------------------------------------------------------------------

UnicodeString TInterface::GetVersion()
{
    DWORD VersionHandle;
    DWORD VersionSize;
    LPBYTE pBuffer;
    UnicodeString strVersion = L"N/A";

    VersionSize = GetFileVersionInfoSizeW(Application->ExeName.c_str(), &VersionHandle);
    if(VersionSize)
    {
        pBuffer = new BYTE[VersionSize];

        if(GetFileVersionInfoW(Application->ExeName.c_str(), VersionHandle, VersionSize, pBuffer))
        {
            VS_FIXEDFILEINFO *fi;
            UINT buflen;

            // uncomment strVersion and HIWORD alternates below when future CI implemented: sas@2.1.0
            if(VerQueryValueW(pBuffer, L"\\", (void**)&fi, &buflen))
            {
                // strVersion.sprintf(L"%d.%d.%d (Build %d)",
                strVersion.sprintf(L"%d.%d.%d", HIWORD(fi->dwFileVersionMS), LOWORD(fi->dwFileVersionMS), HIWORD(fi->dwFileVersionLS));
                // HIWORD(fi->dwFileVersionLS), LOWORD(fi->dwFileVersionLS)
            }
        }
        delete[]pBuffer;
    }
    return(L" v" + strVersion);
}

// ---------------------------------------------------------------------------
// Track Build Interface
// ---------------------------------------------------------------------------
void __fastcall TInterface::BuildTrackMenuItemClick(TObject *Sender) // Mode Menu Item
{
    try
    {
        TrainController->LogEvent("BuildTrackMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildTrackMenuItemClick");
        Level1Mode = TrackMode;
        SetLevel1Mode(0);
        Utilities->CallLogPop(1159);
    }
    catch(const Exception &e)
    {
        ErrorLog(120, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::AddTrackButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("AddTrackButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AddTrackButtonClick");
        Level1Mode = TrackMode;
        SetLevel1Mode(38);
        Level2TrackMode = AddTrack;
        SetLevel2TrackMode(2);
        Utilities->CallLogPop(1162);
    }
    catch(const Exception &e)
    {
        ErrorLog(121, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SpeedButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SpeedButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SpeedButtonClick");
        ReselectMenuItem->Enabled = false;
        if(((TSpeedButton*)Sender)->Down)
        {
            CurrentSpeedButton = (TSpeedButton*)Sender;
// TrainController->LogEvent("SpeedButtonClick, " + CurrentSpeedButton->Tag); //v 1.3.1 - using non-AnsiString CurrentSpeedButton->Tag sends (for an unknown reason) a completely wrong string to LogEvent, usually "...(behind this message)"
            TrainController->LogEvent("SpeedButtonClick, " + AnsiString(CurrentSpeedButton->Tag)); // new version //use for v1.3.2
            if((Level2TrackMode == TrackSelecting) && (CurrentSpeedButton->Tag != 144))
            // new addition at v2.6.0 to fill selected area with the element corresponding to CurrentSpeedButton
            {
                // 144 = level crossing & these not permitted
                if((SelectRect.left != SelectRect.right) && (SelectRect.top != SelectRect.bottom) && SelectionValid)
                {
                    Screen->Cursor = TCursor(-11); // Hourglass;
                    InfoPanel->Caption = "SELECTING:  Filling area with chosen element";
                    bool FillSelectionFlag = false;
                    if(!FillSelectionMessageSentFlag)
                    {
                        UnicodeString MessageStr =
                            "Click 'Yes' to fill the area with the chosen element or 'No' to abort.\n" "Existing elements won't be overwritten although track can\n"
                            "have platforms and non-station named location elements added.\n\nThis message will not be shown again.";
                        int button = Application->MessageBox(MessageStr.c_str(), L"", MB_YESNO);
                        if(button == IDYES)
                        {
                            FillSelectionFlag = true;
                        }
                    }
                    if(FillSelectionFlag || FillSelectionMessageSentFlag)
                    {
                        bool TrackLinkingRequiredFlag = true;
                        for(int HLoc = SelectRect.left; HLoc < SelectRect.right; HLoc++)
                        {
                            for(int VLoc = SelectRect.top; VLoc < SelectRect.bottom; VLoc++)
                            {
                                if((HLoc != SelectRect.right) || (VLoc != SelectRect.bottom))
                                {
                                    Track->PlotAndAddTrackElement(3, CurrentSpeedButton->Tag, 0, HLoc, VLoc, TrackLinkingRequiredFlag, false);
// false for internal checks
                                    // above now has extra zero 'Aspect' parameter at v2.2.0 so can distinguish between adding track and pasting
                                }
                                else
                                {
                                    Track->PlotAndAddTrackElement(4, CurrentSpeedButton->Tag, 0, HLoc, VLoc, TrackLinkingRequiredFlag, true);
// internal checks true for last plot
                                }
                            }
                        }
                    }
                    Track->SetTrackFinished(false);
                    ClearandRebuildRailway(80); // to remove selection outline
                    SelectionValid = false;
                    Track->CopyFlag = false;
                    Track->SkipLocationNameMultiMapCheck = false;
                    ResetSelectRect();
                    SetLevel1Mode(139);
                    Level2TrackMode = AddTrack;
                    SetLevel2TrackMode(66);
                    FillSelectionMessageSentFlag = true;
                    Screen->Cursor = TCursor(-2); // Arrow
                    ReselectMenuItem->Enabled = true; // allow when filling areas
                }
            }
        }
        else
        {
            CurrentSpeedButton = 0;
        }
        Utilities->CallLogPop(1163);
    }
    catch(const Exception &e)
    {
        ErrorLog(122, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TrackOKButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TrackOKButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TrackOKButtonClick");
        Screen->Cursor = TCursor(-11); // Hourglass;  //added at v2.11.1
        SelectionValid = false;
        ResetChangedFileDataAndCaption(0, true);
        bool LocError;
        int HLoc, VLoc;
        // erase any corrupted PrefDirs then rebuild track & PrefDir vectors
// EveryPrefDir->EraseCorruptedElementsAfterTrackBuild();  not needed after dispensed with blank track elements for erased elements
        if(!(Track->TryToConnectTrack(0, LocError, HLoc, VLoc, true))) // true for give messages
        // if successful repositions TrackVector & builds TrackMap
        {
            if(LocError) // links not complete or other error - show offending element
            {
                while((Display->DisplayOffsetH - HLoc) > 0)
                {
                    Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
                }
                while((HLoc - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
                {
                    Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
                }
                while((Display->DisplayOffsetV - VLoc) > 0)
                {
                    Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
                }
                while((VLoc - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
                {
                    Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
                }
                ClearandRebuildRailway(0);
                Display->InvertElement(0, HLoc * 16, VLoc * 16);
                ShowMessage("Incomplete track or other error - see highlighted element (it may be behind this message "
                            "which can be moved by left clicking the mouse in the title bar and dragging it).");
                ClearandRebuildRailway(1); // to clear inversion
                Level1Mode = TrackMode;
                SetLevel1Mode(39);
                Level2TrackMode = AddTrack; // go to add track regardless of where started from
                SetLevel2TrackMode(3);
                Screen->Cursor = TCursor(-2); // Arrow //added at v2.11.1
                Utilities->CallLogPop(0);
                return;
            }
            else
            {
                // reach here if there are no track elements
                ShowMessage("Unable to set any track links");
                Level1Mode = TrackMode;
                SetLevel1Mode(40);
                Level2TrackMode = AddTrack;
                SetLevel2TrackMode(4); // go to add track regardless of where started from
                Screen->Cursor = TCursor(-2); // Arrow //added at v2.11.1
                Utilities->CallLogPop(1);
                return;
            }
        }
        else
        {
            // success so far as track is concerned ('TrackFinished' set in TryToConnectTrack)
            EveryPrefDir->RebuildPrefDirVector(0); // from TrackMap
        }
// success if reach here ('TrackFinished' set in TryToConnectTrack)
        if(Level2TrackMode == AddTrack)
        {
            Level2TrackMode = AddTrack;
            Level1Mode = TrackMode;
            SetLevel1Mode(41);
            SetLevel2TrackMode(5);
        }
        else
        {
            Level1Mode = TrackMode;
            SetLevel1Mode(36); // back to TrackMode if not in AddTrack mode
        }
        ShowMessage("Successful Completion");
        Screen->Cursor = TCursor(-2); // Arrow //added at v2.11.1
        Utilities->CallLogPop(2);
    }
    catch(const Exception &e)
    {
        ErrorLog(3, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SetGapsButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SetGapsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SetGapsButtonClick");
        SelectionValid = false;
        ReselectMenuItem->Enabled = false;
        Level1Mode = TrackMode;
        SetLevel1Mode(42);
        Level2TrackMode = GapSetting;
        SetLevel2TrackMode(6);
        Utilities->CallLogPop(1164);
    }
    catch(const Exception &e)
    {
        ErrorLog(123, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::AddTextButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("AddTextButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AddTextButtonClick");
        Level1Mode = TrackMode;
        SetLevel1Mode(43);
        Level2TrackMode = AddText;
        SetLevel2TrackMode(7);
        Utilities->CallLogPop(1165);
    }
    catch(const Exception &e)
    {
        ErrorLog(124, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::MoveTextOrGraphicButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MoveTextOrGraphicButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MoveTextOrGraphicButtonClick");
        Level1Mode = TrackMode;
        SetLevel1Mode(44);
        Level2TrackMode = MoveTextOrGraphic;
        SetLevel2TrackMode(8);
        Utilities->CallLogPop(1166);
    }
    catch(const Exception &e)
    {
        ErrorLog(125, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TextBoxKeyPress(TObject *Sender, char &Key)
{
    try
    {
        TrainController->LogEvent("TextBoxKeyPress," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TextBoxKeyPress," + AnsiString(Key));
        if(Key == '\x0D') // CR
        {
            if(TextBox->Text != "") // if blank then don't save
            {
                if(Display->GetFont()->Color == clB5G5R5) // white
                {
                    TFont *TempFont = new TFont;
                    TempFont->Assign(Display->GetFont());
                    TempFont->Color = clB0G0R0; // change to black for vector & saving
                    Display->SetFont(TempFont);
                    delete TempFont;
                }
                TFont *DisplayFont = Display->GetFont();
                TTextItem TempText = TTextItem(Text_X, Text_Y, TextBox->Text, DisplayFont);
                TempText.Font = DisplayFont; // may have been changed in above constructor when returned as reference
                TextHandler->EnterAndDisplayNewText(0, TempText, Text_X, Text_Y);
                ResetChangedFileDataAndCaption(12, true); // moved here from MainScreenMouseDown2 after 2.7.0 in case nothing changed
            }
            EditMenu->Enabled = true;
            TextBox->Visible = false;
            SetLevel2TrackMode(56); // to enable 'move text' if first text item added
        }
        else if(Key == '\x1B') // escape
        {
            if(TextBox->Text != "")
            {
                ResetChangedFileDataAndCaption(28, true); // added here after 2.7.0 in case replaced existing text (which is selected) with blank
            }
            TextBox->Visible = false;
        }
        Utilities->CallLogPop(3);
    }
    catch(const Exception &e)
    {
        ErrorLog(4, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LocationNameButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LocationNameButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LocationNameButtonClick");
        Level1Mode = TrackMode;
        SetLevel1Mode(45);
        Level2TrackMode = AddLocationName;
        SetLevel2TrackMode(9);
        Utilities->CallLogPop(1167);
    }
    catch(const Exception &e)
    {
        ErrorLog(126, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LocationNameKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("LocationNameKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LocationNameKeyUp," + AnsiString(Key));
        if(Track->LNPendingList.empty())
        {
            ShowMessage("Error, location name being entered without an entry in LNPendingList");
            Level1Mode = TrackMode;
            SetLevel1Mode(46);
            Level2TrackMode = AddLocationName;
            SetLevel2TrackMode(10);
            Utilities->CallLogPop(4);
            return;
        }
        if(Key == '\x1B') // escape
        {
            Track->LNPendingList.clear(); // get rid of existing entry
            Level1Mode = TrackMode;
            SetLevel1Mode(47);
            Level2TrackMode = AddLocationName;
            SetLevel2TrackMode(11);
            Utilities->CallLogPop(5);
            return;
        }
        if(Key == '\x0D')
        {
            Screen->Cursor = TCursor(-11); // Hourglass;
            SetTrackBuildImages(8);
            ResetChangedFileDataAndCaption(8, true); // moved here after 2.7.0 from mainScreenMouseDown2 in case nothing changed
            AnsiString ExistingName;
            LocationNameTextBox->Text = LocationNameTextBox->Text.Trim();
// added at v2.6.1 to prevent added spaces because they skip the different location same name chack
            if(Track->LNPendingList.front() > -1)
            {
                ExistingName = Track->InactiveTrackElementAt(27, Track->LNPendingList.front()).LocationName;
            }
            else
            {
                ExistingName = Track->TrackElementAt(425, -1 - (Track->LNPendingList.front())).LocationName;
            }
            if(Track->LocationNameAllocated(1, LocationNameTextBox->Text) && (ExistingName != LocationNameTextBox->Text))
            {
                // name allocated to a different location

                if(LocationNameTextBox->Text != "") //if new name is NULL then don't give message but carry out all other
                {                                   //functions - added at v2.14.0
                    UnicodeString MessageStr = UnicodeString("Another location named '") + LocationNameTextBox->Text +
                        UnicodeString("' already exists.  If you continue its name will be erased.  Do you wish to continue?");
                    int button = Application->MessageBox(MessageStr.c_str(), L"Warning!", MB_YESNO | MB_ICONWARNING);
                    if(button == IDNO)
                    {
                        Track->LNPendingList.clear(); // get rid of existing entry
                        Screen->Cursor = TCursor(-2); // Arrow
                        Level1Mode = TrackMode;
                        SetLevel1Mode(48);
                        Level2TrackMode = AddLocationName;
                        SetLevel2TrackMode(12);
                        Utilities->CallLogPop(6);
                        return;
                    }
                }
                Track->EraseLocationAndActiveTrackElementNames(1, LocationNameTextBox->Text);
                Track->EnterLocationName(1, LocationNameTextBox->Text, false);
                int HPos, VPos;
                bool UseExistingPosition = false;
                if(EraseLocationNameText(0, LocationNameTextBox->Text, HPos, VPos))
                {
                    ;
                } // condition not used

                // above may be redundant at v1.1.0 due to name erase in EnterLocationName
                // but, the location to be named may also have an existing name, in which case that needs to be erased
                // and the position re-used
                if(ExistingName != "")
                {
                    if(EraseLocationNameText(3, ExistingName, HPos, VPos))
                    {
                        UseExistingPosition = true; // may be redundant at v1.1.0 due to name erase in EnterLocationName
                    }
                }
                AddLocationNameText(0, LocationNameTextBox->Text, HPos, VPos, UseExistingPosition);
                Screen->Cursor = TCursor(-2); // Arrow
                Level1Mode = TrackMode;
                SetLevel1Mode(49);
                Level2TrackMode = AddLocationName;
                SetLevel2TrackMode(13);
                Utilities->CallLogPop(7);
                return;
            }
            else if(Track->LocationNameAllocated(2, LocationNameTextBox->Text) && (ExistingName == LocationNameTextBox->Text))
            {
                // same name being entered again
                Track->LNPendingList.clear(); // get rid of existing entry as the location already has this name
                                              // but in case the name is not already in text vector erase it and re-add it
                                              // if it wasn't in the vector erasing it has no effect
                int HPos, VPos;
                bool UseExistingPosition = false;
                if(EraseLocationNameText(2, LocationNameTextBox->Text, HPos, VPos))
                {
                    UseExistingPosition = true;
                }
                // above may be redundant at v1.1.0 due to name erase in EnterLocationName
                AddLocationNameText(2, LocationNameTextBox->Text, HPos, VPos, UseExistingPosition);
                Screen->Cursor = TCursor(-2); // Arrow
                Level1Mode = TrackMode;
                SetLevel1Mode(50);
                Level2TrackMode = AddLocationName;
                SetLevel2TrackMode(14);
                Utilities->CallLogPop(8);
                return;
            }
            else
            {
                // either a new name for an unnamed location, or a different name for a named location
                // check validity of entry
                AnsiString LocStr = LocationNameTextBox->Text;
                LocStr = LocStr.Trim(); // strip leading & trailing spaces, and control characters
                LocationNameTextBox->Text = LocStr; // reset this as used below
/* drop this, now covered by ...Trim() above
            //strip leading spaces
            while((LocStr != "") && (LocStr[1] == ' '))
                {
                LocStr = LocStr.SubString(2, LocStr.Length()-1);
                }
*/
                if((LocStr != "") && (LocStr[1] >= '0') && (LocStr[1] <= '9')) // can't begin with a number
                {
                    Screen->Cursor = TCursor(-2); // Arrow
                    ShowMessage("Location name can't begin with a number");
                    Level1Mode = TrackMode;
                    SetLevel1Mode(51);
                    Level2TrackMode = AddLocationName;
                    SetLevel2TrackMode(15);
                    Utilities->CallLogPop(776);
                    return;
                }
                if(LocStr.Length() > 50)
                {
                    Screen->Cursor = TCursor(-2); // Arrow
                    ShowMessage("Location name too long, 50 characters maximum");
                    Level1Mode = TrackMode;
                    SetLevel1Mode(122);
                    Level2TrackMode = AddLocationName;
                    SetLevel2TrackMode(55);
                    Utilities->CallLogPop(1735);
                    return;
                }
                for(int x = 1; x <= LocStr.Length(); x++)
                {
                    char Ch = LocStr[x];
                    if((Ch != ' ') && (Ch != '&') && (Ch != '(') && (Ch != ')') && (Ch != ':') && (Ch != 39) && (Ch != '.') && (Ch != '-') && (Ch != '+') &&
                       (Ch != '/') && ((Ch < '0') || (Ch > '9')) && ((Ch < 'A') || (Ch > 'Z')) && ((Ch < 'a') || (Ch > 'z')))
                    {
                        Screen->Cursor = TCursor(-2); // Arrow
                        ShowMessage(
                            "Location name contains one or more invalid characters, must be alphanumeric, brackets, space, full stop, colon, inverted comma, '-', '+', '/' or '&&'");
                        Level1Mode = TrackMode;
                        SetLevel1Mode(52);
                        Level2TrackMode = AddLocationName;
                        SetLevel2TrackMode(16);
                        Utilities->CallLogPop(777);
                        return;
                    }
                }
                if(LocStr == "cdt") // this has Time:Command which could be confused with Time:Loc
                {
                    Screen->Cursor = TCursor(-2); // Arrow
                    ShowMessage("Location name cannot be 'cdt', this name would interfere with the timetable");
                    Level1Mode = TrackMode;
                    SetLevel1Mode(53);
                    Level2TrackMode = AddLocationName;
                    SetLevel2TrackMode(17);
                    Utilities->CallLogPop(778);
                    return;
                }
                Track->EnterLocationName(2, LocStr, false);
                // need to check if the location already has a name, and if so erase it from the textvector
                int HPos, VPos;
                bool UseExistingPosition = false;
                if(ExistingName != "")
                {
                    if(EraseLocationNameText(1, ExistingName, HPos, VPos))
                    {
                        UseExistingPosition = true; // may be redundant at v1.1.0 due to name erase in EnterLocationName
                    }
                }
                AddLocationNameText(1, LocationNameTextBox->Text, HPos, VPos, UseExistingPosition);
                Screen->Cursor = TCursor(-2); // Arrow
                Level1Mode = TrackMode;
                SetLevel1Mode(54);
                Level2TrackMode = AddLocationName;
                SetLevel2TrackMode(18);
                Utilities->CallLogPop(9);
                return;
            }
        }
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(10);
    }
    catch(const Exception &e)
    {
        ErrorLog(5, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SetLengthsButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SetLengthsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SetLengthsButtonClick");
        SelectLengthsFlag = false;
        ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap(); // added for extended distances
        Level1Mode = TrackMode;
        SetLevel1Mode(55);
        Level2TrackMode = DistanceStart;
        SetLevel2TrackMode(19);
        Utilities->CallLogPop(1168);
    }
    catch(const Exception &e)
    {
        ErrorLog(127, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LengthOKButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LengthOKButtonClick," + DistanceBox->Text + "," + SpeedLimitBox->Text);
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LengthOKButtonClick");
        ResetChangedFileDataAndCaption(4, true); // moved here after 2.7.0 so only need to save if something changed
        int Dist = 0, SpeedLimit = 0;
        AnsiString DistanceStr = DistanceBox->Text;
        if(SelectLengthsFlag && (DistanceStr == ""))
        {
            DistanceStr = "No change";
        }
        AnsiString SpeedStr = SpeedLimitBox->Text;
        if(SelectLengthsFlag && (SpeedStr == ""))
        {
            SpeedStr = "No change";
        }
        if(SelectLengthsFlag)
        {
            if(DistanceStr == "No change")
            {
                Dist = -1; // i.e.don't change
            }
            if(SpeedStr == "No change")
            {
                SpeedLimit = -1; // i.e.don't change
            }
        }
        else
        {
            if(DistanceStr == AnsiString(OverallDistance))
            {
                Dist = -1; // i.e.don't change
            }
            if((SpeedStr == "Mixed") || (SpeedStr == AnsiString(OverallSpeedLimit)))
            {
                SpeedLimit = -1; // i.e.don't change
            }
        }
        if(((Dist != -1) && (DistanceStr.Length() > 6)) || ((SpeedLimit != -1) && (SpeedStr.Length() > 6)))
        {
            ShowMessage("One or more entries too long");
            Utilities->CallLogPop(11);
            return;
        }
        if((DistanceStr == "") || (SpeedStr == ""))
        {
            ShowMessage("One or more entries blank");
            Utilities->CallLogPop(12);
            return;
        }
        if(SelectLengthsFlag && (Dist != -1))
        {
            for(int x = 1; x <= DistanceStr.Length(); x++)
            {
                if((DistanceStr[x] < '0') || (DistanceStr[x] > '9'))
                {
                    ShowMessage("Track length value must be a positive whole number, or blank for no change");
                    Utilities->CallLogPop(1415);
                    return;
                }
            }
        }
        if(!SelectLengthsFlag)
        {
            for(int x = 1; x <= DistanceStr.Length(); x++)
            {
                if((DistanceStr[x] < '0') || (DistanceStr[x] > '9'))
                {
                    ShowMessage("Distance must be a positive whole number");
                    Utilities->CallLogPop(13);
                    return;
                }
            }
        }
        if(SelectLengthsFlag && (SpeedLimit != -1))
        {
            for(int x = 1; x <= SpeedStr.Length(); x++)
            {
                if((SpeedStr[x] < '0') || (SpeedStr[x] > '9'))
                {
                    ShowMessage("Speed limit must be a positive whole number, or blank for no change");
                    Utilities->CallLogPop(1416);
                    return;
                }
            }
        }
        if(!SelectLengthsFlag && (SpeedStr != "Mixed"))
        {
            for(int x = 1; x <= SpeedStr.Length(); x++)
            {
                if((SpeedStr[x] < '0') || (SpeedStr[x] > '9'))
                {
                    ShowMessage("Speed limit must be a positive whole number, or 'Mixed'");
                    Utilities->CallLogPop(14);
                    return;
                }
            }
        }
        if(Dist != -1)
        {
            Dist = DistanceStr.ToInt();
        }
        if(SpeedLimit != -1)
        {
            SpeedLimit = SpeedStr.ToInt();
        }
/* don't need this with new condition below
    if(SelectLengthsFlag && (Dist != -1) && (Dist < 20))
        {
        ShowMessage("Track length value must be a minimum of 10m, setting to 10m");
        Dist = 20;
        }
*/
        if(((Dist != -1) && (Dist < 10)) || ((SpeedLimit != -1) && (SpeedLimit < 10)) || ((SpeedLimit != -1) && (SpeedLimit > TTrain::MaximumSpeedLimit)))
        // new limiting values for v0.6 (used only to fail at either value 0); added TTrain::MaxSpeedLimit at v2.1.0
        {
            ShowMessage("Lengths must be 10m or more, and speeds must be between 10km/h and 400km/h"); // changed at v2.1.0 to limit max speed
            Utilities->CallLogPop(15);
            return;
        }
        DistanceBox->Text = "";
        SpeedLimitBox->Text = "";
        if(SelectLengthsFlag)
        {
            int LowSelectHLoc = SelectBitmapHLoc;
            int HighSelectHLoc = SelectBitmapHLoc + (SelectBitmap->Width / 16);
            int LowSelectVLoc = SelectBitmapVLoc;
            int HighSelectVLoc = SelectBitmapVLoc + (SelectBitmap->Height / 16);
            bool FoundFlag;
            bool NamedLocPresent = false;
            if((Dist != -1) && (Dist != Utilities->DefaultTrackLength))
            {
                for(int x = LowSelectHLoc; x < HighSelectHLoc; x++)
                {
                    for(int y = LowSelectVLoc; y < HighSelectVLoc; y++)
                    {
                        if(Track->IsPlatformOrNamedNonStationLocationPresent(6, x, y))
                        {
                            NamedLocPresent = true;
                        }
                    }
                }
            }
            if(NamedLocPresent && (Dist < 50)) // changed in v2.4.0
            {
                if(!TooShortMessageSentFlag)  //added at v2.9.1
                {
                    ShowMessage("Note: Named location elements are quite short. If they are too short the simulation might be too unrealistic.\n\nThis message will not be shown again.");
                    TooShortMessageSentFlag = true;   //added at v2.9.1
                }
            }
            if(NamedLocPresent && (Dist > 200)) // changed in v2.4.0
            {
                if(!TooLongMessageSentFlag)   //added at v2.9.1
                {
                    ShowMessage("Note: Named location elements are quite long. If they are too long the simulation might be too unrealistic.\n\nThis message will not be shown again.");
                    TooLongMessageSentFlag = true;   //added at v2.9.1
                }
            }
            for(int x = LowSelectHLoc; x < HighSelectHLoc; x++)
            {
                for(int y = LowSelectVLoc; y < HighSelectVLoc; y++)
                {
                    int VecPos = Track->GetVectorPositionFromTrackMap(34, x, y, FoundFlag);
                    if(FoundFlag)
                    {
                        if(Dist > -1) // && !(Track->IsPlatformOrNamedNonStationLocationPresent(7, x, y)))
                        {
                            Track->TrackElementAt(692, VecPos).Length01 = Dist;
                            if(Track->TrackElementAt(693, VecPos).Length23 != -1)
                            {
                                Track->TrackElementAt(694, VecPos).Length23 = Dist;
                            }
                        }
                        if(SpeedLimit > -1)
                        {
                            Track->TrackElementAt(695, VecPos).SpeedLimit01 = SpeedLimit;
                            if(Track->TrackElementAt(696, VecPos).SpeedLimit23 != -1)
                            {
                                Track->TrackElementAt(697, VecPos).SpeedLimit23 = SpeedLimit;
                            }
                        }
                    }
                }
            }
            TrackLengthPanel->Visible = false;
            SelectLengthsFlag = false; // go back to normal distance setting mode
        }
        else
        {
            SetTrackLengths(1, Dist, SpeedLimit);
        }
        Level1Mode = TrackMode;
        SetLevel1Mode(57);
        Level2TrackMode = DistanceStart;
        SetLevel2TrackMode(21);
        Utilities->CallLogPop(16);
    }
    catch(const Exception &e)
    {
        ErrorLog(6, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LengthCancelButtonClick(TObject * Sender)
{
    try
    {
        TrainController->LogEvent("LengthCancelButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LengthCancelButtonClick");
        DistanceBox->Text = "";
        SpeedLimitBox->Text = "";
        TrackLengthPanel->Visible = false;
        SelectLengthsFlag = false; // go back to normal distance setting mode
        Level1Mode = TrackMode;
        SetLevel1Mode(59);
        Level2TrackMode = DistanceStart;
        SetLevel2TrackMode(23);
        Utilities->CallLogPop(1169);
    }
    catch(const Exception &e)
    {
        ErrorLog(128, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ResetDefaultLengthButtonClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ResetDefaultLengthButtonClick");
        TMsgDlgButtons Buttons;
        Buttons << mbYes << mbNo;
        if(MessageDlg("This will reset the selected elements to default lengths & speed limits.  Proceed?", mtWarning, Buttons, 0) == mrNo)
        {
            // leave all as was before
            Utilities->CallLogPop(17);
            return;
        }
        else
        {
            TrainController->LogEvent("Accepted ResetDefaultLengthButtonClick");
            ResetChangedFileDataAndCaption(25, true); // added after 2.7.0 so only need to save if something changed
            DistanceBox->Text = "";
            SpeedLimitBox->Text = "";
            if(SelectLengthsFlag)
            {
                int LowSelectHLoc = SelectBitmapHLoc;
                int HighSelectHLoc = SelectBitmapHLoc + (SelectBitmap->Width / 16);
                int LowSelectVLoc = SelectBitmapVLoc;
                int HighSelectVLoc = SelectBitmapVLoc + (SelectBitmap->Height / 16);
                bool FoundFlag;
                for(int x = LowSelectHLoc; x < HighSelectHLoc; x++)
                {
                    for(int y = LowSelectVLoc; y < HighSelectVLoc; y++)
                    {
                        int VecPos = Track->GetVectorPositionFromTrackMap(35, x, y, FoundFlag);
                        if(FoundFlag)
                        {
                            Track->TrackElementAt(698, VecPos).Length01 = Utilities->DefaultTrackLength;
                            if(Track->TrackElementAt(699, VecPos).Length23 != -1)
                            {
                                Track->TrackElementAt(700, VecPos).Length23 = Utilities->DefaultTrackLength;
                            }
                            Track->TrackElementAt(701, VecPos).SpeedLimit01 = Utilities->DefaultTrackSpeedLimit;
                            if(Track->TrackElementAt(702, VecPos).SpeedLimit23 != -1)
                            {
                                Track->TrackElementAt(703, VecPos).SpeedLimit23 = Utilities->DefaultTrackSpeedLimit;
                            }
                        }
                    }
                }
                TrackLengthPanel->Visible = false;
// ClearandRebuildRailway(47); don't need this
                SelectLengthsFlag = false; // go back to normal distance setting mode
            }
            else
            {
                TrackLengthPanel->Visible = false;
                bool FoundFlag;
                if(ConstructPrefDir->PrefDirSize() == 0)
                {
                    Utilities->CallLogPop(1120);
                    return;
                }
                for(unsigned int x = 0; x < ConstructPrefDir->PrefDirSize(); x++)
                {
                    TPrefDirElement PrefDirElement = ConstructPrefDir->GetFixedPrefDirElementAt(169, x);
                    TTrackElement & TrackElement = Track->TrackElementAt(37, Track->GetVectorPositionFromTrackMap(40, PrefDirElement.HLoc, PrefDirElement.VLoc,
                                                                                                                  FoundFlag));
                    if((TrackElement.TrackType == Points) || (TrackElement.TrackType == Crossover) || (TrackElement.TrackType == Bridge))
                    // only set the relevant track to default length & speed limit
                    {
                        if((PrefDirElement.GetELinkPos() < 2) && (PrefDirElement.GetXLinkPos() < 2)) // could be one of each for points
                        {
                            TrackElement.Length01 = Utilities->DefaultTrackLength;
                            TrackElement.SpeedLimit01 = Utilities->DefaultTrackSpeedLimit; // 200km/h = 125mph
                        }
                        else
                        {
                            TrackElement.Length23 = Utilities->DefaultTrackLength;
                            TrackElement.SpeedLimit23 = Utilities->DefaultTrackSpeedLimit; // 200km/h = 125mph
                        }
                    }
                    else // any other 1 track element, including platforms being present
                    {
                        if((PrefDirElement.GetELinkPos() > 1) && (PrefDirElement.GetXLinkPos() > 1))
                        {
                            throw Exception("Error, XLinkPos > 1 in SetOneDefaultTrackLength at " + AnsiString(TrackElement.HLoc) + " & " +
                                            AnsiString(TrackElement.VLoc));
                        }
                        TrackElement.Length01 = Utilities->DefaultTrackLength;
                        TrackElement.SpeedLimit01 = Utilities->DefaultTrackSpeedLimit; // 200km/h = 125mph
                        TrackElement.Length23 = -1;
                        TrackElement.SpeedLimit23 = -1;
                    }
                }
            }
            Level1Mode = TrackMode;
            SetLevel1Mode(61);
            Level2TrackMode = DistanceStart;
            SetLevel2TrackMode(25);
        }
        Utilities->CallLogPop(18);
    }
    catch(const Exception &e)
    {
        ErrorLog(7, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::RestoreAllDefaultLengthsButtonClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RestoreAllDefaultLengthsButtonClick");
        TMsgDlgButtons Buttons;
        Buttons << mbYes << mbNo;
        if(MessageDlg("This will reset ALL track elements to default lengths & speed limits.  Proceed?", mtWarning, Buttons, 0) == mrNo)
        {
            // leave all as was before
            Utilities->CallLogPop(19);
            return;
        }
        else
        {
            Track->SetAllDefaultLengthsAndSpeedLimits(1);
        }
        TrainController->LogEvent("Accepted RestoreAllDefaultLengthsButtonClick");
        ResetChangedFileDataAndCaption(26, true); // added after 2.7.0 so only need to save if something changed
        DistanceBox->Text = "";
        SpeedLimitBox->Text = "";
        TrackLengthPanel->Visible = false;
        SelectLengthsFlag = false; // go back to normal distance setting mode
        Level1Mode = TrackMode;
        SetLevel1Mode(63);
        Level2TrackMode = DistanceStart;
        SetLevel2TrackMode(27);
        Utilities->CallLogPop(20);
    }
    catch(const Exception &e)
    {
        ErrorLog(8, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ExitTrackButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExitTrackButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExitTrackButtonClick");
        if(Level2TrackMode == CutMoving)
        {
            Level2TrackMode = Pasting; // to paste the selection
            SetLevel2TrackMode(53);
        }
        DevelopmentPanel->Visible = false; // development use only
        ScreenGridFlag = false;
        SelectionValid = false;
        Track->SelectGraphicVector.clear();
        // delete all unwanted TPictures in UserGraphicMap
        if(!Track->UserGraphicMap.empty()) // if empty skip it
        {
            TTrack::TUserGraphicMap::iterator UGMIt = Track->UserGraphicMap.begin();
            do
            {
                bool GraphicFoundInVector = false;
                for(TTrack::TUserGraphicVector::iterator UGVIt = Track->UserGraphicVector.begin(); UGVIt < Track->UserGraphicVector.end(); UGVIt++)
                {
                    if(UGMIt->first == UGVIt->FileName)
                    {
                        GraphicFoundInVector = true;
                        break;
                    }
                }
                if(!GraphicFoundInVector)
                {
                    delete UGMIt->second;
                    Track->UserGraphicMap.erase(UGMIt);
                    UGMIt = Track->UserGraphicMap.begin(); // reset the iterator because erasing an element it points to invalidates it & if use it after then
                                                           // behaviour is undefined, the iteration will end eventually because the map has got shorter after an erase
                }
                else
                {
                    UGMIt++;
                }
            }
            while(UGMIt != Track->UserGraphicMap.end());
        }
        Level1Mode = BaseMode;
        SetLevel1Mode(2);
        Utilities->CallLogPop(1170);
    }
    catch(const Exception &e)
    {
        ErrorLog(129, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TextOrUserGraphicGridButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TextOrUserGraphicGridButtonClick," + AnsiString(TextOrUserGraphicGridVal));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TextOrUserGraphicGridButtonClick");
        if(TextOrUserGraphicGridVal == 1)
        {
            TextOrUserGraphicGridVal = 2;
            TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision2");
        }
        else if(TextOrUserGraphicGridVal == 2)
        {
            TextOrUserGraphicGridVal = 4;
            TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision4");
        }
        else if(TextOrUserGraphicGridVal == 4)
        {
            TextOrUserGraphicGridVal = 8;
            TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision8");
        }
        else if(TextOrUserGraphicGridVal == 8)
        {
            TextOrUserGraphicGridVal = 16;
            TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision16");
        }
        else
        {
            TextOrUserGraphicGridVal = 1;
            TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision1");
        }
        Utilities->CallLogPop(1171);
    }
    catch(const Exception &e)
    {
        ErrorLog(130, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SigAspectButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SigAspectButtonClick," + AnsiString(Track->SignalAspectBuildMode));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SigAspectButtonClick");
        if(Track->SignalAspectBuildMode == TTrack::FourAspectBuild)
        {
            Track->SignalAspectBuildMode = TTrack::ThreeAspectBuild;
            SigAspectButton->Glyph->LoadFromResourceName(0, "ThreeAspect");
        }
        else if(Track->SignalAspectBuildMode == TTrack::ThreeAspectBuild)
        {
            Track->SignalAspectBuildMode = TTrack::TwoAspectBuild;
            SigAspectButton->Glyph->LoadFromResourceName(0, "TwoAspect");
        }
        else if(Track->SignalAspectBuildMode == TTrack::TwoAspectBuild)
        {
            Track->SignalAspectBuildMode = TTrack::GroundSignalBuild;
            SigAspectButton->Glyph->LoadFromResourceName(0, "GroundSig");
// set all signal glyphs to ground signals
            LoadGroundSignalGlyphs(0);
        }
        else
        {
            Track->SignalAspectBuildMode = TTrack::FourAspectBuild;
            SigAspectButton->Glyph->LoadFromResourceName(0, "FourAspect");
// set all signal glyphs to normal signals
            LoadNormalSignalGlyphs(0);
        }
        Utilities->CallLogPop(1869);
    }
    catch(const Exception &e)
    {
        ErrorLog(180, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::FontButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("FontButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",FontButtonClick");
        FontDialog->Font = Display->GetFont(); // sets the dialog box font to the currently used font
        FontDialog->Execute(); // this displays the dialog box
        if(FontDialog->Font->Color == clB5G5R5) // white
        {
            FontDialog->Font->Color = clB0G0R0;     // black - don't store white in font, will display black as white on dark backgrounds
        }
        Display->SetFont(FontDialog->Font); // sets the displayed font to the output from the dialog box
        if(TextBox->Visible)
        {
            TextBox->SetFocus();
        }
        else if(LocationNameTextBox->Visible)
        {
            LocationNameTextBox->SetFocus();
        }
        Utilities->CallLogPop(1172);
    }
    catch(const Exception &e)
    {
        ErrorLog(131, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ScreenGridButtonClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ScreenGridButtonClick");
        if(ScreenGridFlag)
        {
            TrainController->LogEvent("ScreenGridButtonClick + ScreenGrid off");
            ScreenGridFlag = false;
        }
        else
        {
            TrainController->LogEvent("ScreenGridButtonClick + ScreenGrid on");
            ScreenGridFlag = true;
        }
        ClearandRebuildRailway(28);
        Utilities->CallLogPop(89);
    }
    catch(const Exception &e)
    {
        ErrorLog(33, e.Message);
    }
}

// ---------------------------------------------------------------------------
// PrefDir Interface
// ---------------------------------------------------------------------------
void __fastcall TInterface::PlanPrefDirsMenuItemClick(TObject *Sender) // Mode Menu Item
{
    try
    {
        TrainController->LogEvent("PlanPrefDirsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PlanPrefDirsMenuItemClick");
        Level1Mode = PrefDirMode;
        SetLevel1Mode(3);
        Utilities->CallLogPop(1173);
    }
    catch(const Exception &e)
    {
        ErrorLog(132, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::AddPrefDirButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("AddPrefDirButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AddPrefDirButtonClick");
        if(ConstructPrefDir->PrefDirSize() == 0)
        {
            ShowMessage("No preferred direction selection");
            Utilities->CallLogPop(22);
            return;
        }
        Screen->Cursor = TCursor(-11); // Hourglass;
        if(ConstructPrefDir->ValidatePrefDir(1))
        {
            EveryPrefDir->ConsolidatePrefDirs(0, ConstructPrefDir);
        }
        Level1Mode = PrefDirMode;
        SetLevel1Mode(4);
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(23);
    }
    catch(const Exception &e)
    {
        ErrorLog(10, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::DeleteAllPrefDirButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("DeleteAllPrefDirButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",DeleteAllPrefDirButtonClick");
        TMsgDlgButtons Buttons;
        Buttons << mbYes << mbNo;
        if(MessageDlg("Do you really want to clear all preferred directions?", mtWarning, Buttons, 0) == mrNo)
        {
            Utilities->CallLogPop(24);
            return;
        }
        // leave all as was before pressed DeleteAllPrefDirButton
        else
        {
            ResetChangedFileDataAndCaption(1, false);
            EveryPrefDir->ExternalClearPrefDirAnd4MultiMap();
            ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
            Level1Mode = PrefDirMode;
            SetLevel1Mode(5);
        }
        Utilities->CallLogPop(25);
    }
    catch(const Exception &e)
    {
        ErrorLog(11, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::DeleteOnePrefDirButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("DeleteOnePrefDirButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",DeleteOnePrefDirButtonClick");
        ResetChangedFileDataAndCaption(18, false);
// RlyFile = false; - don't alter this just for PrefDir changes
        Screen->Cursor = TCursor(-11); // Hourglass;
        for(unsigned int x = 0; x < ConstructPrefDir->PrefDirSize(); x++)
        {
            EveryPrefDir->EraseFromPrefDirVectorAnd4MultiMap(1, ConstructPrefDir->GetFixedPrefDirElementAt(178, x).HLoc,
                                                             ConstructPrefDir->GetFixedPrefDirElementAt(179, x).VLoc);
        }
        ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
        Level1Mode = PrefDirMode;
        SetLevel1Mode(81); // all PrefDir truncated
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1591);
    }
    catch(const Exception &e)
    {
        ErrorLog(46, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ExitPrefDirButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExitPrefDirButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExitPrefDirButtonClick");
        Level1Mode = BaseMode;
        SetLevel1Mode(6);
        Utilities->CallLogPop(1554);
    }
    catch(const Exception &e)
    {
        ErrorLog(133, e.Message);
    }
}

// ---------------------------------------------------------------------------
// Operate Railway Interface
// ---------------------------------------------------------------------------
void __fastcall TInterface::OperateRailwayMenuItemClick(TObject *Sender) // Mode Menu Item
{
    try
    {
        TrainController->LogEvent("OperateRailwayMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",OperateRailwayMenuItemClick");
        TTrain::NextTrainID = 0; // reset to 0 whenever enter operating mode
        AllRoutes->NextRouteID = 0; // reset to 0 whenever enter operating mode
        Level1Mode = OperMode;
        SetLevel1Mode(7);
        Utilities->CallLogPop(26);
    }
    catch(const Exception &e)
    {
        ErrorLog(12, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::OperateButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("StartOperationButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",OperateButtonClick");
        if((Level2OperMode == NoOperMode) || (Level2OperMode == Paused) || (Level2OperMode == PreStart))
        {
            Level2OperMode = Operating;
            SetLevel2OperMode(0);
        }
        else
        {
            Level2OperMode = Paused;
            SetLevel2OperMode(1);
        }
        Utilities->CallLogPop(1175);
    }
    catch(const Exception &e)
    {
        ErrorLog(37, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::AutoSigsButtonClick(TObject *Sender)
// must have PrefDirs to be available
{
    try
    {
        TrainController->LogEvent("AutoSigsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AutoSigsButtonClick");
        AutoSigsFlag = true;
        PreferredRoute = true;
        ConsecSignalsRoute = true;

        AutoSigsButton->Enabled = false;
        SigAutoNonConsecButton->Enabled = true;
        SigPrefConsecButton->Enabled = true;
        SigPrefNonConsecButton->Enabled = true;
        UnrestrictedButton->Enabled = true;

        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
        AutoRouteStartMarker->PlotOriginal(1, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(2, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(3, Display); // if overlay not plotted will ignore
        RouteMode = RouteNotStarted;
        Utilities->CallLogPop(28);
    }
    catch(const Exception &e)
    {
        ErrorLog(14, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SigAutoNonConsecButtonClick(TObject *Sender)
// must have PrefDirs to be available
{
    try
    {
        TrainController->LogEvent("SigAutoNonConsecButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SigAutoNonConsecButtonClick");
        AutoSigsFlag = true;
        PreferredRoute = true;
        ConsecSignalsRoute = false;

        AutoSigsButton->Enabled = true;
        SigAutoNonConsecButton->Enabled = false;
        SigPrefConsecButton->Enabled = true;
        SigPrefNonConsecButton->Enabled = true;
        UnrestrictedButton->Enabled = true;

        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
        AutoRouteStartMarker->PlotOriginal(46, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(47, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(48, Display); // if overlay not plotted will ignore
        RouteMode = RouteNotStarted;
        Utilities->CallLogPop(2556);
    }
    catch(const Exception &e)
    {
        ErrorLog(247, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::SigPrefConsecButtonClick(TObject *Sender)
// must have PrefDirs to be available
{
    try
    {
        TrainController->LogEvent("SigPrefConsecButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SigPrefConsecButtonClick");
        AutoSigsFlag = false;
        PreferredRoute = true;
        ConsecSignalsRoute = true;

        AutoSigsButton->Enabled = true;
        SigAutoNonConsecButton->Enabled = true;
        SigPrefConsecButton->Enabled = false;
        SigPrefNonConsecButton->Enabled = true;
        UnrestrictedButton->Enabled = true;

        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select PREFERRED ROUTE start signal, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select PREFERRED ROUTE start signal, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
        AutoRouteStartMarker->PlotOriginal(43, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(44, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(45, Display); // if overlay not plotted will ignore
        RouteMode = RouteNotStarted;
        Utilities->CallLogPop(2265);
    }
    catch(const Exception &e)
    {
        ErrorLog(221, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SigPrefNonConsecButtonClick(TObject *Sender)
// must have PrefDirs to be available
{
    try
    {
        TrainController->LogEvent("SigPrefNonConsecButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SigPrefNonConsecButtonClick");
        AutoSigsFlag = false;
        PreferredRoute = true;
        ConsecSignalsRoute = false;

        AutoSigsButton->Enabled = true;
        SigAutoNonConsecButton->Enabled = true;
        SigPrefConsecButton->Enabled = true;
        SigPrefNonConsecButton->Enabled = false;
        UnrestrictedButton->Enabled = true;

        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select PREFERRED ROUTE start signal, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select PREFERRED ROUTE start signal, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
        AutoRouteStartMarker->PlotOriginal(4, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(5, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(6, Display); // if overlay not plotted will ignore
        RouteMode = RouteNotStarted;
        Utilities->CallLogPop(29);
    }
    catch(const Exception &e)
    {
        ErrorLog(15, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::UnrestrictedButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("UnrestrictedButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",UnrestrictedButtonClick");
        AutoSigsFlag = false;
        PreferredRoute = false;
        ConsecSignalsRoute = false;
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            AutoSigsButton->Enabled = true;
            SigAutoNonConsecButton->Enabled = true;
            SigPrefConsecButton->Enabled = true;
            SigPrefNonConsecButton->Enabled = true;
            UnrestrictedButton->Enabled = false;
        }
        else
        {
            AutoSigsButton->Enabled = false;
            SigAutoNonConsecButton->Enabled = false;
            SigPrefConsecButton->Enabled = false;
            SigPrefNonConsecButton->Enabled = false;
            UnrestrictedButton->Enabled = false;
        }
        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
        AutoRouteStartMarker->PlotOriginal(7, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(8, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(9, Display); // if overlay not plotted will ignore
        RouteMode = RouteNotStarted;
        Utilities->CallLogPop(30);
    }
    catch(const Exception &e)
    {
        ErrorLog(16, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::RouteCancelButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("RouteCancelButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RouteCancelButtonClick");
        RouteCancelFlag = true;
        InfoPanel->Visible = true;
        InfoPanel->Caption = "ROUTE CANCELLING:  Right click on truncate element, first element to cancel (anywhere else to skip)";
        RouteCancelButton->Enabled = false;
        AutoRouteStartMarker->PlotOriginal(32, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(33, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(34, Display); // if overlay not plotted will ignore
        Utilities->CallLogPop(1176);
    }
    catch(const Exception &e)
    {
        ErrorLog(35, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::PerformanceLogButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PerformanceLogButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PerformanceLogButtonClick");
        if(!ShowPerfLogForm) //changed at v2.13.0 for Performance log form, so starts on bottom LH corner on first startup
						     //but retains current position thereafter
        {
            ShowPerfLogForm = true;
            PerfLogForm->Visible = true;
            if(FirstPerfLogFormDisplay) //initial position of PerfLogForm
            {
                PerfLogForm->Top = Screen->Height - PerfLogForm->Height - 32; //-32 to avoid overlapping taskbar
                PerfLogForm->Left = 0;
                FirstPerfLogFormDisplay = false;
            }
            PerformanceLogButton->Glyph->LoadFromResourceName(0, "HideLog");

        }
        else
        {
            ShowPerfLogForm = false;
            PerfLogForm->Visible = false;
            PerformanceLogButton->Glyph->LoadFromResourceName(0, "ShowLog");
        }
        Utilities->CallLogPop(1177);
    }
    catch(const Exception &e)
    {
        ErrorLog(36, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::OperatorActionButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("OperatorActionButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",OperatorActionButtonClick");
        if(!ShowActionsDueForm)
        {
            ShowActionsDueForm = true;
            if(FirstActionsDueFormDisplay) //initial position of PerfLogForm
            {
                ActionsDueForm->Top = Screen->Height - ActionsDueForm->Height - 32; //-32 to avoid overlapping taskbar;
                ActionsDueForm->Left = Screen->Width - ActionsDueForm->Width;
                FirstActionsDueFormDisplay = false;
            }
            else
            {
                ActionsDueForm->Top = ADFTop;
                ActionsDueForm->Left = ADFLeft;
            }
            ActionsDueForm->Visible = true;
            TrainController->OpActionPanelVisible = true;
            OperatorActionButton->Glyph->LoadFromResourceName(0, "HideOpActionPanel");
        }
        else
        {
            ShowActionsDueForm = false;
            ActionsDueForm->Visible = false;
            TrainController->OpActionPanelVisible = false;
            OperatorActionButton->Glyph->LoadFromResourceName(0, "ShowOpActionPanel");
        }
        Utilities->CallLogPop(2073);
    }
    catch(const Exception &e)
    {
        ErrorLog(199, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ExitOperationButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExitOperationButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExitOperationButtonClick");
        if((double(TrainController->TTClockTime - TrainController->LastSessionSaveTTClockTime) * 86400) >= 300)
        {
            UnicodeString MessageStr = "Please note that the session will be lost if it hasn't been saved.  Do you still wish to exit?";
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Utilities->CallLogPop(751);
                return;
            }
        }
        Track->ResetSignals(0);
        Track->ResetPoints(0);
        Track->ResetTSRs(0);  //added at v2.14.0
        TrainController->SendPerformanceSummary(0, Utilities->PerformanceFile); // must come before trains finished becuase examines the train vectors
        Utilities->PerformanceFile.close();
        TrainController->UnplotTrains(1);
        TrainController->FinishedOperation(0);
        RouteMode = None;
        PreferredRoute = true; // default starting conditions
        ConsecSignalsRoute = true; // default starting conditions
        AllRoutes->AllRoutesClear();
        ShowPerfLogForm = false;
        PerformanceLogButton->Glyph->LoadFromResourceName(0, "ShowLog");
        ShowActionsDueForm = false; // new at v2.2.0
        OperatorActionButton->Glyph->LoadFromResourceName(0, "ShowOpActionPanel"); // new v2.2.0
        PerfLogForm->PerformanceLogBox->Lines->Clear();
        PerfLogForm->Visible = false;
// TipButton->Glyph->LoadFromResourceName(0, "ShowLog"); //'Trains in play' new at v2.2.0
        ActionsDueForm->ActionsDueListBox->Clear();
        ActionsDueForm->Visible = false;
        ;
        TrainController->ContinuationAutoSigVector.clear();
        AllRoutes->LockedRouteVector.clear();
        Level1Mode = BaseMode;
        SetLevel1Mode(8); // calls Clearand...
        Utilities->CallLogPop(1555);
    }
    catch(const Exception &e)
    {
        ErrorLog(13, e.Message);
    }
}

// ---------------------------------------------------------------------------
// Menu Interface (for items not already covered above)
// ---------------------------------------------------------------------------
void __fastcall TInterface::LoadRailwayMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LoadRailwayMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LoadRailwayMenuItemClick");
        if(!ClearEverything(1))
        {
            Utilities->CallLogPop(1139);
            return;
        }
        // LoadRailwayDialog->Filter = "Development file (*.dev)|*.dev|Railway file (*.rly)|*.rly"; //as was
        // changed at v2.0.0 (Embarcadero change) to show all files together
        LoadRailwayDialog->Filter = "Railway file (*.rly or *.dev)|*.rly; *.dev";
        if(LoadRailwayDialog->Execute())
        {
            if(LoadRailwayDialog->InitialDir != TPath::GetDirectoryName(LoadRailwayDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                LoadRailwayDialog->InitialDir = TPath::GetDirectoryName(LoadRailwayDialog->FileName);
                SaveRailwayDialog->InitialDir = TPath::GetDirectoryName(LoadRailwayDialog->FileName);
            }
            TrainController->LogEvent("LoadRailway " + AnsiString(LoadRailwayDialog->FileName));
            LoadRailway(0, AnsiString(LoadRailwayDialog->FileName));
        }
        // else ShowMessage("Load Aborted"); drop this
        // Display->Update(); //display updated in ClearandRebuildRailway
        Track->CalcHLocMinEtc(9);
        Level1Mode = BaseMode;
        TrainController->AvHoursIntValue = 0;
        TrainController->MTBFHours = 0;
        SetLevel1Mode(11); // calls Clearand... to plot the new railway
        Utilities->CallLogPop(31);
    }
    catch(const Exception &e)  //made a non-error catch at v2.14.0 following Albie Vowles error of 15/12/22
    {
        TrainController->StopTTClockMessage(134, "Railway file failed to load - may be corrupt.\nError message: " + e.Message);
        Screen->Cursor = TCursor(-2); // Arrow;
        Utilities->CallLogPop(2551);
//        ErrorLog(17, e.Message);
    }
}
// ---------------------------------------------------------------------------

void TInterface::LoadRailway(int Caller, AnsiString LoadFileName)
{
    // display of the loaded railway covered in the calling routine
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadRailway," + LoadFileName);
    if(FileIntegrityCheck(0, LoadFileName.c_str()))
    {
        Screen->Cursor = TCursor(-11); // Hourglass;
        std::ifstream VecFile(LoadFileName.c_str());
        if(!(VecFile.fail()))
        {
            AnsiString TempString = Utilities->LoadFileString(VecFile); // version number
            int TempOffsetHHome = Utilities->LoadFileInt(VecFile);
            int TempOffsetVHome = Utilities->LoadFileInt(VecFile);
            bool GraphicsFollow = false;
            // can't load DisplayOffsetH & VHome until after LoadTrack as that calls TrackClear & zeroes them
// load track elements
            Track->LoadTrack(1, VecFile, GraphicsFollow);
// load text elements
            TextHandler->LoadText(0, VecFile);
// load PrefDir elements
            EveryPrefDir->LoadPrefDir(0, VecFile);
            if(GraphicsFollow)
            {
// load user graphics
                Track->LoadGraphics(0, VecFile, CurDir + "\\" + USERGRAPHICS_DIR_NAME); // include path to Graphics folder
            }
            EveryPrefDir->CheckPrefDirAgainstTrackVector(0); // clears PrefDir if any discrepancies found
            VecFile.close();
            Display->DisplayOffsetHHome = TempOffsetHHome;
            Display->DisplayOffsetVHome = TempOffsetVHome;
            Display->ResetZoomInOffsets();

            TFont *TempFont = new TFont; // if try to alter MainScreen->Canvas->Font directly it won't change the style for some reason
            TempFont->Style.Clear();
            TempFont->Name = "MS Sans Serif"; // reset font, else stays set to last displayed text font
            TempFont->Size = 10;
            TempFont->Color = clB0G0R0;
            TempFont->Charset = (TFontCharset)(0);
            MainScreen->Canvas->Font->Assign(TempFont);
            delete TempFont;

// calculate starting zoomed out offset values - same as when zoom out button clicked
            int OVOffH_NVCentre = Display->DisplayOffsetH - (1.5 * Utilities->ScreenElementWidth);
// start zoomout centre at DisplayOffsetH + 30 - zoomout width/2 = -(1.5 * 60)
            int LeftExcess = OVOffH_NVCentre - Track->GetHLocMin();
            int RightExcess = Track->GetHLocMax() - OVOffH_NVCentre - ((4 * Utilities->ScreenElementWidth) - 1);
            if((LeftExcess > 0) && (RightExcess > 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre;
            }
            else if((LeftExcess > 0) && (RightExcess <= 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre + ((RightExcess) / (Utilities->ScreenElementWidth / 2)) *
                    (Utilities->ScreenElementWidth / 2); // normalise to nearest half screen
            }
            else if((LeftExcess <= 0) && (RightExcess > 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre - ((LeftExcess) / (Utilities->ScreenElementWidth / 2)) * (Utilities->ScreenElementWidth / 2);
            }
            else
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre; // no excess at either side, so display in centre

            }
            int OVOffV_NVCentre = Display->DisplayOffsetV - (1.5 * Utilities->ScreenElementHeight);
            int TopExcess = OVOffV_NVCentre - Track->GetVLocMin();
            int BotExcess = Track->GetVLocMax() - OVOffV_NVCentre - ((4 * Utilities->ScreenElementHeight) - 1);
            if((TopExcess > 0) && (BotExcess > 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre;
            }
            else if((TopExcess > 0) && (BotExcess <= 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre + ((BotExcess) / (Utilities->ScreenElementHeight / 2)) *
                    (Utilities->ScreenElementHeight / 2); // normalise to nearest half screen
            }
            else if((TopExcess <= 0) && (BotExcess > 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre - ((TopExcess) / (Utilities->ScreenElementHeight / 2)) * (Utilities->ScreenElementHeight / 2);
            }
            else
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre; // no excess at either side, so display in centre
            }
// all above same as when zoom out button clicked
            Display->DisplayZoomOutOffsetVHome = Display->DisplayZoomOutOffsetV; // now set zoomed out 'home' values
            Display->DisplayZoomOutOffsetHHome = Display->DisplayZoomOutOffsetH;

            SavedFileName = AnsiString(LoadRailwayDialog->FileName); // includes the full PrefDir
            if(SavedFileName != "") // shouldn't be "" at this stage but leave in as a safeguard
            {
                Track->DuplicatedLocationName(1, true);
                char LastChar = SavedFileName[SavedFileName.Length()];
                if((LastChar == 'y') || (LastChar == 'Y'))
                {
                    if(!(Track->IsReadyForOperation(false)))
                    {
                        ShowMessage("Railway not ready for operation so unable to load as a .rly file.  Loading as a new railway under development");
                        SavedFileName = "";
                        RlyFile = false;
                        RailwayTitle = "";
                        TimetableTitle = "";
                        SetCaption(5);
                        Track->CalcHLocMinEtc(1);
                        Screen->Cursor = TCursor(-2); // Arrow
                        Level1Mode = BaseMode;
                        SetLevel1Mode(9);
                        session_api_->dump();   // update session INI file    //added at v2.10.0
                        Utilities->CallLogPop(1136);
                        return;
                    }
                    else
                    {
                        RlyFile = true;
                    }
                }
                else
                {
                    RlyFile = false;
                }
            }
            else
            {
                RlyFile = false;
            }
            FileChangedFlag = false;
            for(int x = AnsiString(LoadRailwayDialog->FileName).Length(); x > 0; x--)
            {
                if(AnsiString(LoadRailwayDialog->FileName)[x] == '\\')
                {
                    RailwayTitle = AnsiString(LoadRailwayDialog->FileName).SubString(x + 1, AnsiString(LoadRailwayDialog->FileName).Length() - x - 4);
                    TimetableTitle = "";
                    SetCaption(6);
                    break;
                }
            }
        } // if(VecFile)
        else
        {
            ShowMessage("File open failed prior to load");
        }
        Screen->Cursor = TCursor(-2); // Arrow
    } // if(FileIntegrityCheck(LoadRailwayDialog->FileName.c_str()))
    else
    {
        ShowMessage("File integrity check failed - unable to load " + LoadFileName + ". If the file exists and is spelled correctly then it is probably corrupt.");
    }   //message clarified at v2.14.0
    session_api_->dump();   // update session INI file  //added at v2.10.0
    Utilities->CallLogPop(1774);
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveMenuItemClick(TObject *Sender)
{
// save under existing name
// no need to alter RlyFile for saving under existing name

    try
    {
        TrainController->LogEvent("SaveMenuItemClick, " + SavedFileName);
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveMenuItemClick");
        Screen->Cursor = TCursor(-11); // Hourglass;
        std::ofstream VecFile(SavedFileName.c_str());
        if(!(VecFile.fail()))
        {
            Utilities->SaveFileString(VecFile, ProgramVersion);
            Utilities->SaveFileInt(VecFile, Display->DisplayOffsetHHome);
            Utilities->SaveFileInt(VecFile, Display->DisplayOffsetVHome);
            // save track elements
            if(Track->UserGraphicVector.empty())
            {
                Track->SaveTrack(3, VecFile, false); // false for no graphics (**Active elements** saved as marker)
            }
            else
            {
                Track->SaveTrack(8, VecFile, true); // true for graphics to be saved (**Active elements**1 saved as marker)
            }
            // save text elements
            TextHandler->SaveText(0, VecFile);
            // save PrefDir elements
            EveryPrefDir->SavePrefDirVector(0, VecFile);
            if(!Track->UserGraphicVector.empty())
            {
                // save user graphics
                Track->SaveUserGraphics(0, VecFile);
            }
            FileChangedFlag = false;
            VecFile.close();
        }
        else
        {
            ShowMessage("File open failed prior to save");
        }
        Screen->Cursor = TCursor(-2); // Arrow
        Level1Mode = BaseMode;
        SetLevel1Mode(12); // to disable the save option
        Utilities->CallLogPop(1178);
    }
    catch(const Exception &e)
    {
        ErrorLog(135, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SaveAsMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SaveAsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveAsMenuItemClick");
        SaveAsSubroutine(0);
        Utilities->CallLogPop(32);
    }
    catch(const Exception &e) //non-error catch added at v2.14.0
    {
        Screen->Cursor = TCursor(-2); // Arrow;
        UnicodeString MessageStr = "Unable to save\nError message: " + e.Message;
        Utilities->CallLogPop(2552);
//        ErrorLog(18, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveImageNoGridMenuItemClick(TObject *Sender)
{
    // need to stop clock in case invoke during operation
    try
    {
        TrainController->LogEvent("SaveImageNoGridMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveImageNoGridMenuItemClick");
        if(!DirectoryExists(CurDir + "\\" + IMAGE_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + IMAGE_DIR_NAME + " in the folder where 'railway.exe' resides.  Image can't be saved");
            Utilities->CallLogPop(1695);
            return;
        }
        Screen->Cursor = TCursor(-11); // Hourglass;
        TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
        TrainController->RestartTime = TrainController->TTClockTime;
        AnsiString ImageFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // format "16/06/2009 20:55:17"
        // avoid characters in filename:=   / \ : * ? " < > |
        ImageFileName = CurDir + "\\" + IMAGE_DIR_NAME + "\\RailwayImage " + ImageFileName + "; " + RailwayTitle + ".bmp";
        AnsiString ShortName = "";
        for(int x = ImageFileName.Length(); x > 0; x--)
        {
            if(ImageFileName[x] == '\\')
            {
                ShortName = ImageFileName.SubString(x + 1, ImageFileName.Length() - x - 4);
                break;
            }
        }
        ShowMessage("A bitmap file named " + ShortName + " will be created in the Images folder");
        Graphics::TBitmap *RailwayImage = new Graphics::TBitmap;
        RailwayImage->PixelFormat = pf8bit; // needed to ensure compatibility with track

        int HPosMin = Track->GetHLocMin() * 16;
        int HPosMax = (Track->GetHLocMax() + 1) * 16;
        int VPosMin = Track->GetVLocMin() * 16;
        int VPosMax = (Track->GetVLocMax() + 1) * 16;
        RailwayImage->Width = HPosMax - HPosMin;
        RailwayImage->Height = VPosMax - VPosMin;

        // need to check if there is any text that extends past HPosMax or below VPosMax
        // use font height x text length x .7 for new rh calc & font height * 1.5 for new bottom calc
        if(!TextHandler->TextVector.empty())
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr != TextHandler->TextVector.end(); TextPtr++)
            {
                int NewWidth = (TextPtr->HPos - HPosMin) + (abs(TextPtr->Font->Height) * TextPtr->TextString.Length() * 0.7);
                int NewHeight = (TextPtr->VPos - VPosMin) + (abs(TextPtr->Font->Height) * 1.5);
                if(NewWidth > RailwayImage->Width)
                {
                    RailwayImage->Width = NewWidth;
                }
                if(NewHeight > RailwayImage->Height)
                {
                    RailwayImage->Height = NewHeight;
                }
            }
        }
        RailwayImage->Canvas->Brush->Color = clB5G5R5; // set it all to white initially
        TRect Rect(0, 0, RailwayImage->Width, RailwayImage->Height);
        RailwayImage->Canvas->FillRect(Rect);

        // write graphics first so text & track overwrite
        Track->WriteGraphicsToImage(0, RailwayImage);
        // then write track & text so text overwrites graphics & inactive elements //changed name & added text after inactives at v2.10.0
        Track->WriteTrackAndTextToImage(0, RailwayImage);

        RailwayImage->SaveToFile(ImageFileName);
        delete RailwayImage;
        TrainController->BaseTime = TDateTime::CurrentDateTime();
        TrainController->StopTTClockFlag = false;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1535);
    }
    catch(const Exception &e) //non-error catch //modified at v2.13.0 to catch all errors
    {
        Screen->Cursor = TCursor(-2); // Arrow;
        UnicodeString MessageStr = "Unable to write the image to file, it may be too big";
        Application->MessageBox(MessageStr.c_str(), L"", MB_OK | MB_ICONWARNING);
        Utilities->CallLogPop(2297);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveImageAndGridMenuItemClick(TObject *Sender)
{
    // need to stop clock in case invoke during operation
    try
    {
        TrainController->LogEvent("SaveImageAndGridMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveImageAndGridMenuItemClick");
        if(!DirectoryExists(CurDir + "\\" + IMAGE_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + IMAGE_DIR_NAME + " in the folder where 'railway.exe' resides.  Image can't be saved");
            Utilities->CallLogPop(1696);
            return;
        }
        Screen->Cursor = TCursor(-11); // Hourglass;
        TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
        TrainController->RestartTime = TrainController->TTClockTime;
        AnsiString ImageFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // format "16/06/2009 20:55:17"
        // avoid characters in filename:=   / \ : * ? " < > |
        ImageFileName = CurDir + "\\" + IMAGE_DIR_NAME + "\\RailwayImage " + ImageFileName + "; " + RailwayTitle + ".bmp";
        AnsiString ShortName = "";
        for(int x = ImageFileName.Length(); x > 0; x--)
        {
            if(ImageFileName[x] == '\\')
            {
                ShortName = ImageFileName.SubString(x + 1, ImageFileName.Length() - x - 4);
                break;
            }
        }
        ShowMessage("A bitmap file named " + ShortName + " will be created in the Images folder");
        Graphics::TBitmap *RailwayImage = new Graphics::TBitmap;
        RailwayImage->PixelFormat = pf8bit; // needed to ensure compatibility with track
        int HPosMin = Track->GetHLocMin() * 16;
        int HPosMax = (Track->GetHLocMax() + 1) * 16;
        int VPosMin = Track->GetVLocMin() * 16;
        int VPosMax = (Track->GetVLocMax() + 1) * 16;
        RailwayImage->Width = HPosMax - HPosMin;
        RailwayImage->Height = VPosMax - VPosMin;

        // need to check if there is any text that extends past HPosMax or below VPosMax
        // use font height x text length x .7 for new rh calc & font height * 1.5 for new bottom calc
        if(!TextHandler->TextVector.empty())
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr != TextHandler->TextVector.end(); TextPtr++)
            {
                int NewWidth = (TextPtr->HPos - HPosMin) + (abs(TextPtr->Font->Height) * TextPtr->TextString.Length() * 0.7);
                int NewHeight = (TextPtr->VPos - VPosMin) + (abs(TextPtr->Font->Height) * 1.5);
                if(NewWidth > RailwayImage->Width)
                {
                    RailwayImage->Width = NewWidth;
                }
                if(NewHeight > RailwayImage->Height)
                {
                    RailwayImage->Height = NewHeight;
                }
            }
        }
        RailwayImage->Canvas->Brush->Color = clB5G5R5; // set it all to white initially
        TRect Rect(0, 0, RailwayImage->Width, RailwayImage->Height);
        RailwayImage->Canvas->FillRect(Rect);

        // write the grid first so all else on top
        for(int x = 0; x < ((RailwayImage->Width) / 16); x++)
        {
            for(int y = 0; y < ((RailwayImage->Height) / 16); y++)
            {
                RailwayImage->Canvas->Draw((x * 16), (y * 16), RailGraphics->bmGrid); // graphic is black on white so no need to change
            }
        }
        // write graphics next so text & track overwrite
        Track->WriteGraphicsToImage(1, RailwayImage);
        // then write track & text so text overwrites graphics & inactive elements
        Track->WriteTrackAndTextToImage(1, RailwayImage);  //changed name & added text after inactives at v2.10.0
        RailwayImage->SaveToFile(ImageFileName);
        delete RailwayImage;
        TrainController->BaseTime = TDateTime::CurrentDateTime();
        TrainController->StopTTClockFlag = false;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1536);
    }
    catch(const Exception &e) //non-error catch //modified at v2.13.0 to catch all errors
    {
        Screen->Cursor = TCursor(-2); // Arrow;
        UnicodeString MessageStr = "Unable to write the image to file, it may be too big";
        Application->MessageBox(MessageStr.c_str(), L"", MB_OK | MB_ICONWARNING);
        Utilities->CallLogPop(2298);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveImageAndPrefDirsMenuItemClick(TObject *Sender)
{
    // need to stop clock in case invoke during operation
    try
    {
        TrainController->LogEvent("SaveImageAndPrefDirsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveImageAndPrefDirsMenuItemClick");
        if(!DirectoryExists(CurDir + "\\" + IMAGE_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + IMAGE_DIR_NAME + " in the folder where 'railway.exe' resides.  Image can't be saved");
            Utilities->CallLogPop(1697);
            return;
        }
        Screen->Cursor = TCursor(-11); // Hourglass;
        TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
        TrainController->RestartTime = TrainController->TTClockTime;
        AnsiString ImageFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // format "16/06/2009 20:55:17"
        // avoid characters in filename:=   / \ : * ? " < > |
        ImageFileName = CurDir + "\\" + IMAGE_DIR_NAME + "\\RailwayImage " + ImageFileName + "; " + RailwayTitle + ".bmp";
        AnsiString ShortName = "";
        for(int x = ImageFileName.Length(); x > 0; x--)
        {
            if(ImageFileName[x] == '\\')
            {
                ShortName = ImageFileName.SubString(x + 1, ImageFileName.Length() - x - 4);
                break;
            }
        }
        ShowMessage("A bitmap file named " + ShortName + " will be created in the Images folder");
        Graphics::TBitmap *RailwayImage = new Graphics::TBitmap;
        RailwayImage->PixelFormat = pf8bit; // needed to ensure compatibility with track
        int HPosMin = Track->GetHLocMin() * 16;
        int HPosMax = (Track->GetHLocMax() + 1) * 16;
        int VPosMin = Track->GetVLocMin() * 16;
        int VPosMax = (Track->GetVLocMax() + 1) * 16;
        RailwayImage->Width = HPosMax - HPosMin;
        RailwayImage->Height = VPosMax - VPosMin;

        // need to check if there is any text that extends past HPosMax or below VPosMax
        // use font height x text length x .7 for new rh calc & font height * 1.5 for new bottom calc
        if(!TextHandler->TextVector.empty())
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr != TextHandler->TextVector.end(); TextPtr++)
            {
                int NewWidth = (TextPtr->HPos - HPosMin) + (abs(TextPtr->Font->Height) * TextPtr->TextString.Length() * 0.7);
                int NewHeight = (TextPtr->VPos - VPosMin) + (abs(TextPtr->Font->Height) * 1.5);
                if(NewWidth > RailwayImage->Width)
                {
                    RailwayImage->Width = NewWidth;
                }
                if(NewHeight > RailwayImage->Height)
                {
                    RailwayImage->Height = NewHeight;
                }
            }
        }
        RailwayImage->Canvas->Brush->Color = clB5G5R5; // set it all to white initially
        TRect Rect(0, 0, RailwayImage->Width, RailwayImage->Height);
        RailwayImage->Canvas->FillRect(Rect);

        // write graphics first so text & track overwrite
        Track->WriteGraphicsToImage(2, RailwayImage);
        // then write track & text so text overwrites graphics & inactive elements
        Track->WriteTrackAndTextToImage(2, RailwayImage); //changed name & added text after inactives at v2.10.0
        EveryPrefDir->WritePrefDirToImage(0, RailwayImage);
        RailwayImage->SaveToFile(ImageFileName);
        delete RailwayImage;
        TrainController->BaseTime = TDateTime::CurrentDateTime();
        TrainController->StopTTClockFlag = false;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1566);
    }
    catch(const Exception &e) //non-error catch  //modified at v2.13.0 to catch all errors
    {
        Screen->Cursor = TCursor(-2); // Arrow;
        UnicodeString MessageStr = "Unable to write the image to file, it may be too big";
        Application->MessageBox(MessageStr.c_str(), L"", MB_OK | MB_ICONWARNING);
        Utilities->CallLogPop(2299);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveOperatingImageMenuItemClick(TObject *Sender)
{
    // need to stop clock
    try
    {
        TrainController->LogEvent("SaveOperatingImageMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveOperatingImageMenuItemClick");
        if(!DirectoryExists(CurDir + "\\" + IMAGE_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + IMAGE_DIR_NAME + " in the folder where 'railway.exe' resides.  Image can't be saved");
            Utilities->CallLogPop(1702);
            return;
        }
        Screen->Cursor = TCursor(-11); // Hourglass;
        TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
        TrainController->RestartTime = TrainController->TTClockTime;

        AnsiString TimetableTimeStr = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        TimetableTimeStr = TimetableTimeStr.SubString(1, 2) + '.' + TimetableTimeStr.SubString(4, 2) + '.' + TimetableTimeStr.SubString(7, 2);
        AnsiString ImageFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // format "16/06/2009 20:55:17"
        // avoid characters in filename:=   / \ : * ? " < > |
        ImageFileName = CurDir + "\\" + IMAGE_DIR_NAME + "\\RailwayImage " + ImageFileName + "; Timetable time " + TimetableTimeStr + "; " + RailwayTitle +
            "; " + TimetableTitle + ".bmp";
        AnsiString ShortName = "";
        for(int x = ImageFileName.Length(); x > 0; x--)
        {
            if(ImageFileName[x] == '\\')
            {
                ShortName = ImageFileName.SubString(x + 1, ImageFileName.Length() - x - 4);
                break;
            }
        }
        ShowMessage("A bitmap file named " + ShortName + " will be created in the Images folder");
        Graphics::TBitmap *RailwayImage = new Graphics::TBitmap;
        RailwayImage->PixelFormat = pf8bit; // needed to ensure compatibility with track
        int HPosMin = Track->GetHLocMin() * 16;
        int HPosMax = (Track->GetHLocMax() + 1) * 16;
        int VPosMin = Track->GetVLocMin() * 16;
        int VPosMax = (Track->GetVLocMax() + 1) * 16;
        RailwayImage->Width = HPosMax - HPosMin;
        RailwayImage->Height = VPosMax - VPosMin;

        // need to check if there is any text that extends past HPosMax or below VPosMax
        // use font height x text length x .7 for new rh calc & font height * 1.5 for new bottom calc
        if(!TextHandler->TextVector.empty())
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr != TextHandler->TextVector.end(); TextPtr++)
            {
                int NewWidth = (TextPtr->HPos - HPosMin) + (abs(TextPtr->Font->Height) * TextPtr->TextString.Length() * 0.7);
                int NewHeight = (TextPtr->VPos - VPosMin) + (abs(TextPtr->Font->Height) * 1.5);
                if(NewWidth > RailwayImage->Width)
                {
                    RailwayImage->Width = NewWidth;
                }
                if(NewHeight > RailwayImage->Height)
                {
                    RailwayImage->Height = NewHeight;
                }
            }
        }
        RailwayImage->Canvas->Brush->Color = clB5G5R5; // set it all to white initially
        TRect Rect(0, 0, RailwayImage->Width, RailwayImage->Height);
        RailwayImage->Canvas->FillRect(Rect);

        // write graphics first so text & track overwrite
        Track->WriteGraphicsToImage(3, RailwayImage);
        // then write track and text so both overwrite graphics & text overwrites inactive elements
        Track->WriteOperatingTrackAndTextToImage(0, RailwayImage); // need points with single fillets, signals with colours, gaps all connected
        AllRoutes->WriteAllRoutesToImage(0, RailwayImage);
// add any locked route markers
        if(!AllRoutes->LockedRouteVector.empty())
        {
            for(TAllRoutes::TLockedRouteVectorIterator LRVIT = AllRoutes->LockedRouteVector.end() - 1; LRVIT >= AllRoutes->LockedRouteVector.begin(); LRVIT--)
            {
                TOneRoute Route = AllRoutes->GetFixedRouteAt(167, LRVIT->RouteNumber);
                int x = Route.PrefDirSize() - 1;
                bool BreakFlag = false;
                TPrefDirElement PrefDirElement = Route.GetFixedPrefDirElementAt(188, x);
                while(PrefDirElement.GetTrackVectorPosition() != LRVIT->RearTrackVectorPosition)
                {
                    RailwayImage->Canvas->Draw((PrefDirElement.HLoc - Track->GetHLocMin()) * 16, (PrefDirElement.VLoc - Track->GetVLocMin()) * 16,
                                               RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                    if(!(AllRoutes->TrackIsInARoute(13, PrefDirElement.Conn[PrefDirElement.GetELinkPos()],
                                                    PrefDirElement.ConnLinkPos[PrefDirElement.GetELinkPos()])))
                    {
                        BreakFlag = true;
                        break; // train removed earlier element from route so stop here
                    }
                    x--;
                    PrefDirElement = Route.GetFixedPrefDirElementAt(180, x);
                }
                if(!BreakFlag)
                {
                    if(PrefDirElement.GetTrackVectorPosition() == LRVIT->RearTrackVectorPosition)
                    {
                        RailwayImage->Canvas->Draw((PrefDirElement.HLoc - Track->GetHLocMin()) * 16, (PrefDirElement.VLoc - Track->GetVLocMin()) * 16,
                                                   RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                    }
                }
            }
        }
        TrainController->WriteTrainsToImage(0, RailwayImage);
        RailwayImage->SaveToFile(ImageFileName);
        delete RailwayImage;
        TrainController->BaseTime = TDateTime::CurrentDateTime();
        TrainController->StopTTClockFlag = false;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1703);
    }
    catch(const Exception &e) //non-error catch  //modified at v2.13.0 to catch all errors
    {
        Screen->Cursor = TCursor(-2); // Arrow;
        UnicodeString MessageStr = "Unable to write the image to file, it may be too big";
        Application->MessageBox(MessageStr.c_str(), L"", MB_OK | MB_ICONWARNING);
        Utilities->CallLogPop(2540);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveHeaderMenu1Click(TObject *Sender)
{
//
    try
    {
        TrainController->LogEvent("SaveHeaderMenu1Click");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveHeaderMenu1Click");
        if(Sender == SaveSessionButton)
        {
            SaveSessionFlag = true;
        }
        else if(SavedFileName == "") // use 'Save As' function
        {
            SaveAsSubroutine(1);
        }
        else // ordinary save
        {
            Screen->Cursor = TCursor(-11); // Hourglass;
            std::ofstream VecFile(SavedFileName.c_str());
            if(!(VecFile.fail()))
            {
                Utilities->SaveFileString(VecFile, ProgramVersion);
                Utilities->SaveFileInt(VecFile, Display->DisplayOffsetHHome);
                Utilities->SaveFileInt(VecFile, Display->DisplayOffsetVHome);
                // save track elements
                if(Track->UserGraphicVector.empty())
                {
                    Track->SaveTrack(9, VecFile, false); // false for no graphics (**Active elements** saved as marker)
                }
                else
                {
                    Track->SaveTrack(10, VecFile, true); // true for graphics to be saved (**Active elements**1 saved as marker)
                }
                // save text elements
                TextHandler->SaveText(5, VecFile);
                // save PrefDir elements
                EveryPrefDir->SavePrefDirVector(8, VecFile);
                if(!Track->UserGraphicVector.empty())
                {
                    // save user graphics
                    Track->SaveUserGraphics(1, VecFile);
                }
                FileChangedFlag = false;
                VecFile.close();
            }
            else
            {
                ShowMessage("Railway failed to save - can't open file");
            }
            Screen->Cursor = TCursor(-2); // Arrow
        }
        Utilities->CallLogPop(1552);
    }
    catch(const Exception &e) //non-error catch added at 2.14.0
    {
        TrainController->StopTTClockMessage(135, "Save failed\nError message: " + e.Message);
        Screen->Cursor = TCursor(-2); // Arrow;
//        ErrorLog(44, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LoadSessionMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LoadSessionMenuItemClick");
        LoadSessionFlag = true; // load session within ClockTimer2
    }
    catch(const Exception &e)
    {
        ErrorLog(136, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ClearAllMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ClearAllMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ClearAllMenuItemClick");
        if(ClearEverything(2))
        {
            ;
        } // no change in action on result

        Level1Mode = BaseMode;
        SetLevel1Mode(126);
        Utilities->CallLogPop(1179);
    }
    catch(const Exception &e)
    {
        ErrorLog(137, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ExportTTMenuItemClick(TObject *Sender)
{
    // no need to stop clock as can't be called when railway operating
    try
    {
        TrainController->LogEvent("ExportTTMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExportTTMenuItemClick");
        if(!DirectoryExists(CurDir + "\\" + FORMATTEDTT_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + FORMATTEDTT_DIR_NAME + " in the folder where 'railway.exe' resides.  Timetable can't be exported");
            Utilities->CallLogPop(1699);
            return;
        }
// Screen->Cursor = TCursor(-11); // Hourglass; - no good setting here as it's reset by ShowMessage in CreateFormattedTimetable. It's set there after
// the message instead, but reset here afterwards
        // no need to stop clock as can't select this if operating
        TrainController->CreateFormattedTimetable(0, RailwayTitle, TimetableTitle, CurDir);
        Screen->Cursor = TCursor(-2); // Arrow - reset after above function returns
        Utilities->CallLogPop(1573);
    }
    catch(const Exception &e)
    {
        ErrorLog(138, e.Message);
    }
}
// ---------------------------------------------------------------------------
// Timetable editing functions

/* Note that during early development the timetable was created outside the program as a .csv file using Excel, it was only later that
   the editing functions within the program were developed.  Much of the original structure was preserved though to avoid rewriting the
   code interpretation functions in TrainUnit.cpp.  This is why commas are used as service event separators, and why it is necessary to
   convert them to CRLFs for display and back again for internal storage.  It is acknowledged that all this makes the editing functions
   somewhat cumbersome, and, as ever, if I was starting again I wouldn't do it like that!

   CR & LF review:
   These cause problems by the way that different subroutines handle them.

   AnsiStrings can incorporate CRLFs, but the end of an AnsiString is marked by a '\0' character as in 'C' strings.

   In the fstream functions 'getline(char_type* s, streamsize n)' extracts characters from the stream and puts them in buffer 's' until
   (a) n-1 characters are stored + '\0' after the n-1 characters;
   (b) a '\n' (CRLF) character is found in the stream, in which case a '\0' is added to the buffer after the text that immediately
   precedes the CRLF in the stream; and
   (c) an eof() is found in the stream, in which case a '\0' is added to the buffer at the end of the text.
   Note that if no characters are stored a '\0' is still stored in position [0] of the buffer.

   The << operator in ofstreams, when used with a null terminated string, doesn't store the null.  If it is required it has to be
   sent explicitly, e.g. file << '\0'.  Presumably the same applies for CRLF terminated strings.

*/
// ---------------------------------------------------------------------------

void __fastcall TInterface::CreateTimetableMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CreateTimetableMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CreateTimetableMenuItemClick");
        CreateEditTTFileName = "";
        TimetableEditVector.clear();
        TimetableEditPanel->Visible = true;
        TrainController->TTEditPanelVisible = true; // added at v2.6.0 for two location message
        HighlightPanel->Visible = false;
        TimetablePanel->Visible = true;
        TimetablePanel->BringToFront(); // in case SaveRailway button visible, want it hidden else obscures the panel text
        ShowHideTTButton->Glyph->LoadFromResourceName(0, "Hide");
        OneEntryTimetableMemo->Clear();
        AllEntriesTTListBox->Clear();
        TTStartTimeBox->Text = "";
        AddSubMinsBox->Text = "";
        OneEntryTimetableContents = "";
        LocationNameComboBox->Clear();
        TimetableTitle = ""; // unload any loaded timetable.  Added here at v2.1.0
        TrainController->TrainDataVector.clear(); // unload any loaded timetable.    Added here at v2.1.0
        SetCaption(9); // added at v2.1.0 as formerly retained earlier loaded tt name in error
        TimetableChangedFlag = false;
        TimetableValidFlag = false;
        TTEntryChangedFlag = false;
        TimetableChangedInAZOrderFlag = false;
        AZOrderButton->Caption = AnsiString("A-Z Order");
        AZOrderButton->Hint = AnsiString("Arrange services in alphabetical order       Toggle with Shift+ Z");
        CopiedEntryFlag = false;
        NewEntryInPreparationFlag = false;
        CopiedEntryStr = "";
        TEVPtr = TimetableEditVector.end();
        TTCurrentEntryPtr = TimetableEditVector.end();
        TTStartTimePtr = TimetableEditVector.end();
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();

// populate LocationNameComboBox if a railway is loaded, but first compile the ActiveTrackElementNameMap
        TTrack::TActiveTrackElementNameMapEntry ActiveTrackElementNameMapEntry;
        Track->ActiveTrackElementNameMap.clear();
        for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
        {
            if((Track->TrackElementAt(1036, x).ActiveTrackElementName != "") && (Track->ContinuationNameMap.find(Track->TrackElementAt(1037, x).ActiveTrackElementName))
               == Track->ContinuationNameMap.end())
            {
                // exclude any name that appears in a continuation, error message given in tt validation if try to include such a name in a tt
                ActiveTrackElementNameMapEntry.first = Track->TrackElementAt(1038, x).ActiveTrackElementName;
                ActiveTrackElementNameMapEntry.second = 0; // this is a dummy value
                Track->ActiveTrackElementNameMap.insert(ActiveTrackElementNameMapEntry);
            }
        }
        Track->ActiveTrackElementNameMapCompiledFlag = true;
        if(!(Track->ActiveTrackElementNameMap.empty()))
        {
            LocationNameComboBox->Text = "Location names";
// new version at beta v0.2b
            for(TTrack::TActiveTrackElementNameIterator ATENIT = Track->ActiveTrackElementNameMap.begin(); ATENIT != Track->ActiveTrackElementNameMap.end();
                ATENIT++)
            {
                LocationNameComboBox->Items->Add(ATENIT->first); // continuations excluded during compilation, but a location that includes
                                                                 // continuations as well as other track will be included - earlier version
                                                                 // would have excluded them
            }

/* old version using LocationNameMultiMap, changed to use ActiveTrackElementNames to avoid including lone concourses and named non-station
    locations
        TStringList *StringList = new TStringList;
        StringList->Clear();//probably already empty but help file doesn't say so
        StringList->Sorted = false;//for now
        for(TTrack::TLocationNameMultiMapIterator LNMIT = Track->LocationNameMultiMap.begin(); LNMIT != Track->LocationNameMultiMap.end(); LNMIT++)
            {
            NewKey = LNMIT->first;
            if(OldKey != NewKey)//only add new values
                {
                if(Track->ContinuationNameMap.find(NewKey) == Track->ContinuationNameMap.end())//not a continuation
                    {
                    StringList->Add(NewKey);
                    OldKey = NewKey;
                    }
                }
            }
        StringList->Sort();
        for(int x=0;x<StringList->Count;x++)
            {
            LocationNameComboBox->Items->Add(StringList->Strings[x]);
            }
        delete StringList;
*/
        }
        else
        {
            LocationNameComboBox->Text = "No locations (listed when a railway with names is loaded)";
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(82);
        session_api_->dump();   // update session INI file   //added at v2.10.0
        Utilities->CallLogPop(1595);
    }
    catch(const Exception &e)
    {
        ErrorLog(47, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::EditTimetableMenuItemClick(TObject *Sender)
/* The .ttb file contains a sequence of AnsiStrings separated by null characters.  CRLFs may be embedded within the AnsiStrings,
                 * to cause newlines when displayed.  Each AnsiString corresponds to a timetable 'entry'
*/
{
    try
    {
        TrainController->LogEvent("EditTimetableMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",EditTimetableMenuItemClick");
        SigImagePanel->Visible = false; // stop panel showing while waiting for name entry
        TimetableDialog->Filter = "Timetable file (*.ttb)|*ttb";
        CreateEditTTFileName = "";
        TimetableEditVector.clear();
        TimetableEditPanel->Visible = true;
        TrainController->TTEditPanelVisible = true; // added at v2.6.0 for two location message
        HighlightPanel->Visible = false;
        TimetablePanel->Visible = true;
        TimetablePanel->BringToFront(); // in case SaveRailway button visible, want it hidden else obscures the panel text
        ShowHideTTButton->Glyph->LoadFromResourceName(0, "Hide");
        OneEntryTimetableMemo->Clear();
        AllEntriesTTListBox->Clear();
        TTStartTimeBox->Text = "";
        AddSubMinsBox->Text = "";
        OneEntryTimetableContents = "";
        LocationNameComboBox->Clear();
        TimetableTitle = ""; // unload any loaded timetable.  Moved here from below at v2.1.0 for consistency with CreateTimetable
        TrainController->TrainDataVector.clear(); // unload any loaded timetable.  Moved here from below at v2.1.0 for consistency with CreateTimetable
        SetCaption(8); // added at v2.1.0 as formerly retained earlier loaded tt name in error
        TEVPtr = TimetableEditVector.end();
        TTCurrentEntryPtr = TimetableEditVector.end(), TTStartTimePtr = TimetableEditVector.end();
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();
        if(TimetableDialog->Execute())
        {
            if(TimetableDialog->InitialDir != TPath::GetDirectoryName(TimetableDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                TimetableDialog->InitialDir = TPath::GetDirectoryName(TimetableDialog->FileName);
                SaveTTDialog->InitialDir = TPath::GetDirectoryName(TimetableDialog->FileName);
            }
            CreateEditTTFileName = AnsiString(TimetableDialog->FileName);
            TrainController->LogEvent("EditTimetable " + CreateEditTTFileName);
            std::ifstream TTBLFile(CreateEditTTFileName.c_str(), std::ios_base::binary); // open in binary to examine each character
            if(TTBLFile.is_open())
            {
                // check doesn't contain any non-ascii characters except CR, LF & '\0', and isn't empty
                char c;
                while(!TTBLFile.eof())
                {
                    TTBLFile.get(c);
                    if((c < 32) && (c != 13) && (c != 10) && (c != '\0')) // char is signed by default so values > 127 will be caught as treated as -ve
                    {
                        ShowMessage("Timetable file is empty or contains non-ascii characters, codes must be between 20 and 127, or CR or LF");
                        TTBLFile.close();
                        Utilities->CallLogPop(1612);
                        return;
                    }
                }
                TTBLFile.close();
            }
            else
            {
                ShowMessage("Failed to open timetable file " + CreateEditTTFileName + ", make sure it's spelled correctly, it exists and isn't open in another application");
                Utilities->CallLogPop(1597);
                return;
            }
            // reopen again in binary mode so the "\r\n" pairs stay as they are rather than being entered as '\n'
            Delay(4, 100); // 100mSec delay between closing & re-opening file
            TTBLFile.open(CreateEditTTFileName.c_str(), std::ios_base::binary);
            if(TTBLFile.is_open())
            {
                TTBLFile.clear(); // to clear eofbit from last read
                TTBLFile.seekg(0); // shouldn't be needed but include for safety
                TimetableChangedFlag = false;
                TimetableValidFlag = false;
                TTEntryChangedFlag = false;
                TimetableChangedInAZOrderFlag = false;
                AZOrderButton->Caption = AnsiString("A-Z Order");
                AZOrderButton->Hint = AnsiString("Arrange services in alphabetical order       Toggle with Shift+ Z");
                NewEntryInPreparationFlag = false;
                CopiedEntryStr = "";
                CopiedEntryFlag = false;
// CreateEditTTFileName = TimetableDialog->FileName;
                for(int x = CreateEditTTFileName.Length(); x > 0; x--)
                {
                    if(CreateEditTTFileName[x] == '\\')
                    {
                        CreateEditTTTitle = CreateEditTTFileName.SubString(x + 1, CreateEditTTFileName.Length() - x - 4);
                        break;
                    }
                }
                char *TimetableEntryString = new char[10000];
                while(true)
                {
                    TTBLFile.getline(TimetableEntryString, 10000, '\0'); // pick up the entire AnsiString, including any embedded newlines
                    if(TTBLFile.eof() && (TimetableEntryString[0] == '\0')) // stores a null in 1st position if doesn't load any characters
                    {
                        // may still have eof even if read a line, and
                        // if so need to process it
                        break;
                    }
                    AnsiString OneLine(TimetableEntryString);
                    TimetableEditVector.push_back(OneLine);
                }
                TTBLFile.close();
                delete[]TimetableEntryString;
                // here with TimetableEditVector compiled
            }
            else
            {
                ShowMessage("Failed to open timetable file " + CreateEditTTFileName + ", make sure it's spelled correctly, it exists and isn't open in another application");
                Utilities->CallLogPop(1654);
                return;
            }
        }
        else // cancelled dialog [section prior to CallLogPop added for v1.3.2 to clear timetable screen if cancel button pressed]
        {
            CreateEditTTFileName = "";
// set to null to allow a check during error file saving, if not null save the tt being edited to the file (see entry in ExitTTModeButtonClick)
            CreateEditTTTitle = ""; // as above
            Level1Mode = BaseMode;
            SetLevel1Mode(132);
            Utilities->CallLogPop(1633);
            return;
        }
        CompileAllEntriesMemoAndSetPointers(0);
        if(TimetableEditVector.empty())
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(89);
            Utilities->CallLogPop(1614);
            return;
        }
// all now set where can be
        TTCurrentEntryPtr = TimetableEditVector.begin();

// populate LocationNameComboBox if a railway is loaded, but first compile the ActiveTrackElementNameMap
        TTrack::TActiveTrackElementNameMapEntry ActiveTrackElementNameMapEntry;
        Track->ActiveTrackElementNameMap.clear();
        for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
        {
            if((Track->TrackElementAt(1039, x).ActiveTrackElementName != "") && (Track->ContinuationNameMap.find(Track->TrackElementAt(1040, x).ActiveTrackElementName))
               == Track->ContinuationNameMap.end())
            {
                // exclude any name that appears in a continuation, error message given in tt validation if try to include such a name in a tt
                ActiveTrackElementNameMapEntry.first = Track->TrackElementAt(1041, x).ActiveTrackElementName;
                ActiveTrackElementNameMapEntry.second = 0; // this is a dummy value
                Track->ActiveTrackElementNameMap.insert(ActiveTrackElementNameMapEntry);
            }
        }
        Track->ActiveTrackElementNameMapCompiledFlag = true;
        if(!(Track->ActiveTrackElementNameMap.empty()))
        {
            LocationNameComboBox->Text = "Location names";
// new version for beta v0.2b
            for(TTrack::TActiveTrackElementNameIterator ATENIT = Track->ActiveTrackElementNameMap.begin(); ATENIT != Track->ActiveTrackElementNameMap.end();
                ATENIT++)
            {
                LocationNameComboBox->Items->Add(ATENIT->first); // continuations excluded during compilation, but a location that includes
                                                                 // continuations as well as other track will be included - earlier version
                                                                 // would have excluded them
            }
        }
        else
        {
            LocationNameComboBox->Text = "No locations (listed when a railway with names is loaded)";
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(83);
        session_api_->dump();   // update session INI file   //added at v2.10.0
        Utilities->CallLogPop(1596);
    }
    catch(const Exception &e) //non-error catch added at v2.14.0
    {
        TrainController->StopTTClockMessage(139, "Timetable failed to load - may be corrupt.\nError message: " + e.Message);
        Screen->Cursor = TCursor(-2); // Arrow;
        Utilities->CallLogPop(2555);
//        ErrorLog(48, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ShowHideTTButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ShowHideTTButtonClick");
        if(TimetableEditPanel->Visible)
        {
            ShowHideTTButton->Glyph->LoadFromResourceName(0, "Show");
            TimetableEditPanel->Visible = false;
            TrainController->TTEditPanelVisible = false; // added at v2.6.0 for two location message
            ShowHideTTButton->Hint = "Show the timetable editor          Shift S";
// InfoPanel->Visible = false;                          //changed at v1.3.0 to make it clearer that still in TT mode
            InfoPanel->Caption = "Timetable mode: editor hidden"; // as above
        }
        else
        {
            ShowHideTTButton->Glyph->LoadFromResourceName(0, "Hide");
            TimetableEditPanel->Visible = true;
            TrainController->TTEditPanelVisible = true; // added at v2.6.0 for two location message
            ShowHideTTButton->Hint = "Hide the timetable editor to see the railway          Shift H";
            Level1Mode = TimetableMode;
            SetLevel1Mode(124);
        }
    }
    catch(const Exception &e)
    {
        ErrorLog(139, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::NextTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("NextTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",NextTTEntryButtonClick");
        if((TTCurrentEntryPtr == TimetableEditVector.end()) || TimetableEditVector.empty())
        {
            Utilities->CallLogPop(1683);
            return;
        }
        if(TTCurrentEntryPtr < (TimetableEditVector.end() - 1))
        {
            TTCurrentEntryPtr++;
        }
        TTEntryChangedFlag = false;
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        Level1Mode = TimetableMode;
        SetLevel1Mode(85);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1605);
    }
    catch(const Exception &e)
    {
        ErrorLog(50, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::PreviousTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PreviousTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PreviousTTEntryButtonClick");
        if((TTCurrentEntryPtr == TimetableEditVector.end()) || TimetableEditVector.empty())
        {
            Utilities->CallLogPop(1684);
            return;
        }
        if(TTCurrentEntryPtr > TimetableEditVector.begin())
        {
            TTCurrentEntryPtr--;
        }
        TTEntryChangedFlag = false;
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        Level1Mode = TimetableMode;
        SetLevel1Mode(86);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1607);
    }
    catch(const Exception &e)
    {
        ErrorLog(51, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::NewTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("NewTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",NewTTEntryButtonClick");
        OneEntryTimetableMemo->Clear();
        OneEntryTimetableMemo->SetFocus();
        NewEntryInPreparationFlag = true;
        Level1Mode = TimetableMode;
        SetLevel1Mode(103);
        Utilities->CallLogPop(1615);
    }
    catch(const Exception &e)
    {
        ErrorLog(52, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::AddMinsButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("AddMinsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AddMinsButtonClick");
        bool ValidFlag = true;
        for(int x = 1; x <= AddSubMinsBox->Text.Length(); x++)
        {
            if((AddSubMinsBox->Text[x] > '9') || (AddSubMinsBox->Text[x] < '0')) // tested in TTHandler but check here as a safeguard
            {
                ValidFlag = false;
                break;
            }
        }
        if(ValidFlag)
        {
            if(AddSubMinsBox->Text.ToInt() == 0)
            {
                ValidFlag = false;
            }
        }
        if((TTCurrentEntryPtr == TimetableEditVector.end()) || (*TTCurrentEntryPtr == "") || (AddSubMinsBox->Text == "") || !ValidFlag)
        {
            Utilities->CallLogPop(1649);
            return;
        }
        TDateTime DummyTime;
        int AddMins = AddSubMinsBox->Text.ToInt();
        for(int x = 0; x < OneEntryTimetableMemo->Lines->Count; x++)
        {
            for(int y = 1; y < (OneEntryTimetableMemo->Lines->Strings[x].Length() - 3); y++)
            {
                if(TrainController->CheckTimeValidity(25, OneEntryTimetableMemo->Lines->Strings[x].SubString(y, 5), DummyTime))
                {
                    int Mins = OneEntryTimetableMemo->Lines->Strings[x].SubString(y + 3, 2).ToInt();
                    int Hrs = OneEntryTimetableMemo->Lines->Strings[x].SubString(y, 2).ToInt();
                    Mins += AddMins;
                    while(Mins >= 60)
                    {
                        Mins -= 60;
                        Hrs++;
                    }
                    if(Hrs > 95)
                    {
                        ShowMessage("One or more times excessive, not permitted to exceed 95 hours");
                        Utilities->CallLogPop(1650);
                        return;
                    }
                    AnsiString MinsStr = AnsiString(Mins), HrsStr = AnsiString(Hrs);
                    if(Mins < 10)
                    {
                        MinsStr = "0" + MinsStr;
                    }
                    if(Hrs < 10)
                    {
                        HrsStr = "0" + HrsStr;
                    }
                    int StrLength = OneEntryTimetableMemo->Lines->Strings[x].Length();
                    AnsiString NewString = OneEntryTimetableMemo->Lines->Strings[x].SubString(1, (y - 1)); // up to but not including the time
                    NewString += HrsStr + ':' + MinsStr;
                    NewString += OneEntryTimetableMemo->Lines->Strings[x].SubString((y + 5), (StrLength - y - 4));
                    OneEntryTimetableMemo->Lines->Strings[x] = NewString;
                }
            }
        }

        OneEntryTimetableMemo->HideSelection = true;
        OneEntryTimetableMemo->SelStart = 0; // need this & next command to set cursor to the top
        OneEntryTimetableMemo->SelLength = 0;
        TimetableValidFlag = false;
        TimetableChangedFlag = true;
        TTEntryChangedFlag = true;
        Level1Mode = TimetableMode;
        SetLevel1Mode(91);
        Utilities->CallLogPop(1617);
    }
    catch(const Exception &e)
    {
        ErrorLog(54, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SubMinsButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SubMinsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SubMinsButtonClick");
        bool ValidFlag = true;
        for(int x = 1; x <= AddSubMinsBox->Text.Length(); x++)
        {
            if((AddSubMinsBox->Text[x] > '9') || (AddSubMinsBox->Text[x] < '0')) // tested in TTHandler but check here as a safeguard
            {
                ValidFlag = false;
                break;
            }
        }
        if(ValidFlag)
        {
            if(AddSubMinsBox->Text.ToInt() == 0)
            {
                ValidFlag = false;
            }
        }
        if((TTCurrentEntryPtr == TimetableEditVector.end()) || (*TTCurrentEntryPtr == "") || (AddSubMinsBox->Text == "") || !ValidFlag)
        {
            Utilities->CallLogPop(1659);
            return;
        }
        TDateTime DummyTime;
        int SubMins = AddSubMinsBox->Text.ToInt();
        for(int x = 0; x < OneEntryTimetableMemo->Lines->Count; x++)
        {
            for(int y = 1; y < (OneEntryTimetableMemo->Lines->Strings[x].Length() - 3); y++)
            {
                if(TrainController->CheckTimeValidity(28, OneEntryTimetableMemo->Lines->Strings[x].SubString(y, 5), DummyTime))
                {
                    int Mins = OneEntryTimetableMemo->Lines->Strings[x].SubString(y + 3, 2).ToInt();
                    int Hrs = OneEntryTimetableMemo->Lines->Strings[x].SubString(y, 2).ToInt();
                    Mins -= SubMins;
                    while(Mins < 0)
                    {
                        Mins += 60;
                        Hrs--;
                    }
                    if(Hrs < 0)
                    {
                        ShowMessage("One or more times are now before 00:00, this is not permitted");
                        Utilities->CallLogPop(1660);
                        return;
                    }
                    AnsiString MinsStr = AnsiString(Mins), HrsStr = AnsiString(Hrs);
                    if(Mins < 10)
                    {
                        MinsStr = "0" + MinsStr;
                    }
                    if(Hrs < 10)
                    {
                        HrsStr = "0" + HrsStr;
                    }
                    int StrLength = OneEntryTimetableMemo->Lines->Strings[x].Length();
                    AnsiString NewString = OneEntryTimetableMemo->Lines->Strings[x].SubString(1, (y - 1)); // up to but not including the time
                    NewString += HrsStr + ':' + MinsStr;
                    NewString += OneEntryTimetableMemo->Lines->Strings[x].SubString((y + 5), (StrLength - y - 4));
                    OneEntryTimetableMemo->Lines->Strings[x] = NewString;
                }
            }
        }
        OneEntryTimetableMemo->HideSelection = true;
        OneEntryTimetableMemo->SelStart = 0; // need this & next command to set cursor to the top
        OneEntryTimetableMemo->SelLength = 0;
        TimetableValidFlag = false;
        TimetableChangedFlag = true;
        TTEntryChangedFlag = true;
        Level1Mode = TimetableMode;
        SetLevel1Mode(92);
        Utilities->CallLogPop(1618);
    }
    catch(const Exception &e)
    {
        ErrorLog(55, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::CopyTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CopyTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CopyTTEntryButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            Utilities->CallLogPop(1636);
            return;
        }
        CopiedEntryStr = *TTCurrentEntryPtr;
        CopiedEntryFlag = true;
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
                                                    // position changing in AllEntriesTTListBox
        Level1Mode = TimetableMode;
        SetLevel1Mode(93);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1619);
    }
    catch(const Exception &e)
    {
        ErrorLog(56, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::InvertTTEntryButtonClick(TObject *Sender) //added at v2.15.0
{
    try
    {
        TrainController->LogEvent("InvertTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",InvertTTEntryButtonClick");
        TTimetableEditVector InputVector, OutputVector, OutputVector2, TimeVector1, TimeVector2; //TTimetableEditVector is an ansistring vector type so convenient to use
        typedef std::vector<int> TMinVector;
        TMinVector MinVector;
        AnsiString OneLine = *TTCurrentEntryPtr, SubStr, First, Second, Third, Fourth, TrainDataLine, NewEntry;
        int RearStartOrRepeatMins, FrontStartOrRepeatDigits;
        TTimetableFormatType FormatType;
        TTimetableLocationType LocationType;
        TTimetableSequenceType SequenceType;
        TTimetableShuttleLinkType ShuttleLinkType;
        TNumList ExitList;
        bool Warning, RepeatFlag = false;
        int Count = 1; // anything > 0 OK as if 0 still seeking a start time in ProcessOne...
        bool EndOfFile = false;
        bool FinalCallFalse = false;
        bool GiveMessagesFalse = false;
        bool CheckLocationsExistInRailwayFalse = false;
        TrainController->StripSpaces(7, *TTCurrentEntryPtr);
        if(!TrainController->ProcessOneTimetableLine(7, Count, *TTCurrentEntryPtr, EndOfFile, FinalCallFalse, GiveMessagesFalse, CheckLocationsExistInRailwayFalse))
        // return true for success
        {
            ShowMessage("There seem to be one or more errors in the syntax for the selected entry.\n\nPlease correct before inverting. ");
            Utilities->CallLogPop(2560);
            return;
        }
        else //Syntax ok
        {    //parse the entry (*TTCurrentEntryPtr) storing all the valid lines in an ansistring vector
            while(true) //button only enabled if a legitimate service is highlighted
            {
                int Pos = OneLine.Pos(',');
                if(Pos == 0)//no more commas found so remainder is the last, unless there is no remainder
                {
                    if(OneLine.Length() > 0)
                    {
                        InputVector.push_back(OneLine);
                    }
                    break;
                }
                else
                {
                    SubStr = OneLine.SubString(1, Pos - 1);
                    InputVector.push_back(SubStr);
                    if(Pos == OneLine.Length()) //reached end and ends with a comma, probably not allowed but keep just in case
                    {
                        break;
                    }
                    OneLine = OneLine.SubString(Pos + 1, OneLine.Length() - Pos);
                    continue;
                }
            }
            //here with InputVector populated, weed out any invalid entries
/*
NewEntry = "";   //populated
for(TTEVPtr IPVIt = InputVector.begin(); IPVIt < InputVector.end(); IPVIt++)
{
    NewEntry += *IPVIt + ',';
}
CopiedEntryStr = NewEntry; //this is needed for pasting as a new entry
PasteTTEntryButton->Click(); //paste it after the current entry
*/

            TDateTime TimeVal; //not used
            if(InputVector.size() > 0)
            {
                for(TTEVPtr IPVIt = InputVector.end() - 1; IPVIt >= InputVector.begin(); IPVIt--) //backwards so can erase invalid entries
                {
                    if(((*IPVIt)[1] == 'R') && (IPVIt == InputVector.end() - 1))// repeat, erase it (must be last entry
                    {
                        RepeatFlag = true;
                        InputVector.erase(IPVIt);
                        continue;
                    }
                    if(IPVIt == InputVector.begin()) // store for later then erase train data line
                    {
                        TrainDataLine = *IPVIt;
                        InputVector.erase(IPVIt);
                        break;
                    }
                    if(TrainController->SplitEntry(2, *IPVIt, GiveMessagesFalse, CheckLocationsExistInRailwayFalse, First, Second,
                                  Third, Fourth, RearStartOrRepeatMins, FrontStartOrRepeatDigits, FormatType,
                                  LocationType, SequenceType, ShuttleLinkType, ExitList, Warning))
                    {
                        if((!TrainController->CheckTimeValidity(34, First, TimeVal)) && (FormatType != FinRemHere)) //Frh has no time so don't want to erase this
                        {
                            InputVector.erase(IPVIt);
                            continue;
                        }
                        if((FormatType == TimeLoc) || (FormatType == TimeTimeLoc) || (FormatType == PassTime))
                        {
                            continue;
                        }
                        if((Second == "jbo") || (Second == "fsp") || (Second == "rsp") || (Second == "cdt"))
                        {
                            continue;
                        }
                        if((SequenceType == FinishSequence) || (SequenceType == StartSequence))//keep these so have start & finish times to use (modified) as inverted finish & start times
                        {
                            continue;
                        }
                        InputVector.erase(IPVIt); //if none (should only be repeats & they are dealt with above, but keep for safety's sake) of above then erase
                        continue;
                    }
                    else
                    {
                        InputVector.erase(IPVIt); //if fails when split then erase
                        continue;
                    }
                }
            }
            if(InputVector.size() == 0)
            {
                ShowMessage("Can't find any actions to invert!");
                Utilities->CallLogPop(2561);
                return;
            }
            if(InputVector.size() == 1)
            {
                ShowMessage("Only one action so there's nothing to invert!");
                Utilities->CallLogPop(2562);
                return;
            }
            //now have InputVector populated in order with legitimate entries & it isn't empty, change all TimeTimeLocs to 2 x TimeLocs & Finish to TimeLoc
/*
NewEntry = ""; //weeded out
for(TTEVPtr IPVIt = InputVector.begin(); IPVIt < InputVector.end(); IPVIt++)
{
    NewEntry += *IPVIt + ',';
}
CopiedEntryStr = NewEntry; //this is needed for pasting as a new entry
PasteTTEntryButton->Click(); //paste it after the current entry
*/

            while(true) //have to restart the search after every insertion as the vector may change location
            {
                bool TimeTimeLocFound = false;
                AnsiString LastTimeVal = "";
                for(TTEVPtr IPVIt = InputVector.begin(); IPVIt < InputVector.end(); IPVIt++)
                {
                    if((*IPVIt)[1] == 'W') // warning
                    {
                        *IPVIt = (*IPVIt).SubString(2, (*IPVIt).Length() - 1);
                        // strip it off
                    }
                    if(TrainController->SplitEntry(3, *IPVIt, GiveMessagesFalse, CheckLocationsExistInRailwayFalse, First, Second,
                                  Third, Fourth, RearStartOrRepeatMins, FrontStartOrRepeatDigits, FormatType,
                                  LocationType, SequenceType, ShuttleLinkType, ExitList, Warning))
                    {
                        if(FormatType == TimeTimeLoc)
                        {
                            LastTimeVal = Second;
                            AnsiString Arrival = First + ";" + Third;
                            AnsiString Departure = Second + ";" + Third;
                            *IPVIt = Departure; //substitute for original entry
                            InputVector.insert(IPVIt, Arrival); //insertion is before current pointer position, hence arrival
                            TimeTimeLocFound = true;
                            break; //from for.. next.. loop
                        }
                        else if(SequenceType == StartSequence)
                        {
                            *IPVIt = First + ";<Service finish command>";
                            LastTimeVal = First;
                            continue; //to next IPVIt value
                        }
                        else if(FormatType == FinRemHere)
                        {
                            *IPVIt = LastTimeVal + ";<Service start command>";
                            break; //from for.. next.. loop, will also break from While loop as TimeTimeLoc won't have been found
                        }
                        else if((SequenceType == FinishSequence) && (FormatType != FinRemHere))
                        {
                            *IPVIt = First + ";<Service start command>";
                            break; //from for.. next.. loop, will also break from While loop as TimeTimeLoc won't have been found
                        }
                        else
                        {
                            LastTimeVal = First;
                            continue; //to next IPVIt value
                        }
                    }
                    else
                    {
                        //shouldn't reach here but if do then abort
                        ShowMessage("Unable to invert this entry");
                        Utilities->CallLogPop(2563);
                        return;
                    }
                }
                if(TimeTimeLocFound)
                {
                    continue; //repeat the while loop
                }
                else
                {
                    break; //from while loop
                }
            }
            //InputVector now complete

/*
NewEntry = ""; //start & finish added & all TimeLocs
for(TTEVPtr IPVIt = InputVector.begin(); IPVIt < InputVector.end(); IPVIt++)
{
    NewEntry += *IPVIt + ',';
}
CopiedEntryStr = NewEntry; //this is needed for pasting as a new entry
PasteTTEntryButton->Click(); //paste it after the current entry
*/

            //populate OutputVector in reverse
            for(TTEVPtr IPVIt = InputVector.end() - 1; IPVIt >= InputVector.begin(); IPVIt--)
            {
                OutputVector.push_back(*IPVIt);
            }
            //extract all times in same order into TimeVector1
            for(TTEVPtr OPVIt = OutputVector.begin(); OPVIt < OutputVector.end(); OPVIt++)
            {
                TimeVector1.push_back((*OPVIt).SubString(1, 5));
            }
            //convert times to integers
            for(TTEVPtr TVIt = TimeVector1.begin(); TVIt < TimeVector1.end(); TVIt++)
            {
                int Mins, Hrs;
                Mins = (*TVIt).SubString(4, 2).ToInt();
                Hrs = (*TVIt).SubString(1, 2).ToInt();
                MinVector.push_back(Mins + (Hrs * 60));
            }
            //zero all wrt first time
            for(TMinVector::iterator MVIt = MinVector.begin(); MVIt < MinVector.end(); MVIt++)
            {
                int StartVal;
                if(MVIt == MinVector.begin())
                {
                    StartVal = *MVIt;
                }
                *MVIt -= StartVal;
            }
            //change sign of all negative integers
            for(TMinVector::iterator MVIt = MinVector.begin(); MVIt < MinVector.end(); MVIt++)
            {
                *MVIt = abs(*MVIt);
            }
            //put these values back into OutVector after changing back to AnsiStrings
            for(unsigned int x = 0; x < MinVector.size(); x++)
            {
                AnsiString AnsiTimeVal = TrainController->MinsToAnsiTime(MinVector.at(x));
                AnsiString OutVal = OutputVector.at(x);
                AnsiString NewOutVal = AnsiTimeVal + OutputVector.at(x).SubString(6, OutputVector.at(x).Length() - 5);
                OutputVector.at(x) = NewOutVal;
            }
/*
NewEntry = "";
for(TTEVPtr PVIt = OutputVector.begin(); PVIt < OutputVector.end(); PVIt++)
{
    NewEntry += *PVIt + ',';
}
CopiedEntryStr = NewEntry; //this is needed for pasting as a new entry
PasteTTEntryButton->Click(); //paste it after the current entry
*/

            //convert successive TimeLocs to TimeTimeLocs and substitute text for linked service reference
            bool FirstTimeLocRegistered = false;
            AnsiString ArrivalTime, DepartureTime, FirstTimeLoc, FirstLocation;
            for(TTEVPtr OPVIt = OutputVector.begin(); OPVIt < OutputVector.end(); OPVIt++)
            {
                if(TrainController->SplitEntry(4, *OPVIt, GiveMessagesFalse, CheckLocationsExistInRailwayFalse, First, Second,
                              Third, Fourth, RearStartOrRepeatMins, FrontStartOrRepeatDigits, FormatType,
                              LocationType, SequenceType, ShuttleLinkType, ExitList, Warning))
                {
                    if((FormatType != TimeLoc) || (OPVIt == OutputVector.begin()) || (OPVIt == OutputVector.end() - 1)) // first & last entries are start & finish but show as TimeLocs so capture it here
                    {
                        if(FirstTimeLocRegistered)
                        {
                            OutputVector2.push_back(FirstTimeLoc); //push this first as not followed by a second TimeLoc
                        }
                        FirstTimeLocRegistered = false;
                        if((Second == "jbo") || (Second == "fsp") || (Second == "rsp"))
                        {
                            OutputVector2.push_back(First + AnsiString(';') + Second + ";<linked service reference>");
                        }
                        else
                        {
                            OutputVector2.push_back(*OPVIt);
                        }
                    }
                    else
                    {
                        if(!FirstTimeLocRegistered)
                        {
                            ArrivalTime = (*OPVIt).SubString(1, 5);
                            FirstTimeLocRegistered = true;
                            FirstTimeLoc = *OPVIt;
                            FirstLocation = (*OPVIt).SubString(7, (*OPVIt).Length() - 6);
                        }
                        else
                        {
                            if(FirstLocation == (*OPVIt).SubString(7, (*OPVIt).Length() - 6)) //locations same
                            {
                                DepartureTime = (*OPVIt).SubString(1, 5);
                                OutputVector2.push_back(ArrivalTime + AnsiString(';') + DepartureTime + AnsiString(';') + FirstLocation);
                                FirstTimeLocRegistered = false;
                            }
                            else
                            {
                                OutputVector2.push_back(FirstTimeLoc); //earlier one was a TimeLoc on its own
                                ArrivalTime = (*OPVIt).SubString(1, 5);  //now register the current TimeLoc entry
                                FirstTimeLocRegistered = true;
                                FirstTimeLoc = *OPVIt;
                                FirstLocation = (*OPVIt).SubString(7, (*OPVIt).Length() - 6);
                                FirstTimeLocRegistered = true;
                            }
                        }
                    }
                }
            }
            //add in train data & repeat command if RepeatFlag true
            AnsiString Remainder = "";
            int Pos = TrainDataLine.Pos(';'); //find first semicolon (will be after the service ref)
            TrainDataLine = TrainDataLine.SubString(Pos + 1, TrainDataLine.Length() - Pos); //chop off the service ref
            Pos = TrainDataLine.Pos(';'); //find semicolon after the description (if none then no train data)
            if((Pos != 0) && (Pos != TrainDataLine.Length())) //data present, if not then Remainder == ""
            {
                Remainder = TrainDataLine.SubString(Pos, TrainDataLine.Length() - Pos + 1); //chop off the description but leave the semicolon after it
            }
            TrainDataLine = "<Service ref>;<Description>" + Remainder;
            OutputVector2.insert(OutputVector2.begin(), TrainDataLine);
            if(RepeatFlag)
            {
                OutputVector2.insert(OutputVector2.end(), "<Repeat command if required>");
            }
            // convert to a timetable entry - single string

            NewEntry = "";
            for(TTEVPtr OPVIt = OutputVector2.begin(); OPVIt < OutputVector2.end(); OPVIt++)
            {
                NewEntry += *OPVIt + ',';
            }

            if(!InvertTTEntryMessageSent)
            {
                ShowMessage("The events in the highlighted service will be listed in reverse order and pasted and highlighted as the next entry. "
                    "Train data, transit and dwell times match the current entry but the start time is 00:00, ready to be adjusted using the 'Add mins' function "
                    "with a value corresponding to the required start time in minutes.\n\nService reference, description, start, finish and repeat "
                    "commands and linked service references remain to be added (indicated by '<...>'), and if this is to be a follow-on service then "
                    "the train data must be removed.\n\nThis message will not be shown again.");
                InvertTTEntryMessageSent = true;
            }

            CopiedEntryStr = NewEntry; //this is needed for pasting as a new entry
            PasteTTEntryButton->Click(); //paste it after the current entry
            Utilities->CallLogPop(2564);
        }
    }
    catch(const Exception &e) //non-error catch
    {
        ShowMessage("Unable to invert this entry.  Error message = " + e.Message);
        Utilities->CallLogPop(2565);
        return;
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CutTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CutTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CutTTEntryButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end()) // || (*TTCurrentEntryPtr == ""))//safeguard
        {
            Utilities->CallLogPop(1674);
            return;
        }
        CopiedEntryStr = *TTCurrentEntryPtr;
        CopiedEntryFlag = true;
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // vector pointers unreliable after an erase,
                                                                            // so use the position in the vector
        TimetableEditVector.erase(TTCurrentEntryPtr);
// now need to rebuild all the pointers & the AllEntriesTTListBox so repeat the process from EditTimetableMenuItemClick
// pick up the start time if there is one
        TimetableChangedFlag = true;
        TimetableValidFlag = false;
        TTEntryChangedFlag = false;
        TEVPtr = TimetableEditVector.end();
        TTCurrentEntryPtr = TimetableEditVector.end(), TTStartTimePtr = TimetableEditVector.end();
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        AllEntriesTTListBox->Clear();
        CompileAllEntriesMemoAndSetPointers(10);
        if(TimetableEditVector.empty())
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(109);
            Utilities->CallLogPop(1777);
            return;
        }
// reset the TTCurrentEntryPtr to the Entry before the erased one if there is one //was 'after', changed at v2.5.0
// but vector pointers unreliable after an erase, so use the position in the vector
        if(OldVectorPos == 0)
        {
            TTCurrentEntryPtr = TimetableEditVector.begin();
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos - 1;
        }
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            OneEntryTimetableMemo->Clear();
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(115);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1676);
    }
    catch(const Exception &e)
    {
        ErrorLog(111, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::PasteTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PasteTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PasteTTEntryButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end()) // || (CopiedEntryStr == "")) allow blank copies
        {
            Utilities->CallLogPop(1637);
            return;
        }
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // vector pointers unreliable after an insert
        TimetableEditVector.insert(TTCurrentEntryPtr + 1, CopiedEntryStr); // inserts before the indicated pointer position, i.e. immediately
                                                                           // after the current Entry - may be at the end
        TimetableChangedFlag = true;
        TimetableValidFlag = false;
        TTEntryChangedFlag = false;
        TEVPtr = TimetableEditVector.end();
        TTCurrentEntryPtr = TimetableEditVector.end(), TTStartTimePtr =
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        AllEntriesTTListBox->Clear();
        CompileAllEntriesMemoAndSetPointers(2);
        if(TimetableEditVector.empty())
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(110);
            Utilities->CallLogPop(1778);
            return;
        }
// restore TTCurrentEntryPtr
        TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
        TTCurrentEntryPtr++; // advance the pointer to the pasted entry
// CopiedEntryStr = "";//revert to null - no, allow multiple copies
        Level1Mode = TimetableMode;
        SetLevel1Mode(94);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1620);
    }
    catch(const Exception &e)
    {
        ErrorLog(57, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::DeleteTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("DeleteTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",DeleteTTEntryButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            Utilities->CallLogPop(1645);
            return;
        }
        UnicodeString MessageStr = "Are you sure this entry should be deleted?";
        int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
        if(button == IDNO)
        {
            Utilities->CallLogPop(1663);
            return;
        }
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // vector pointers unreliable after an erase,
                                                                            // so use the position in the vector
        TimetableEditVector.erase(TTCurrentEntryPtr);

// now need to rebuild all the pointers & the AllEntriesTTListBox so repeat the process from EditTimetableMenuItemClick
// pick up the start time if there is one
        TimetableChangedFlag = true;
        TimetableValidFlag = false;
        TTEntryChangedFlag = false;
        TEVPtr = TimetableEditVector.end();
        TTCurrentEntryPtr = TimetableEditVector.end(), TTStartTimePtr = TimetableEditVector.end();
        TTFirstServicePtr = TimetableEditVector.end();
        TTLastServicePtr = TimetableEditVector.end();
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        AllEntriesTTListBox->Clear();
        CompileAllEntriesMemoAndSetPointers(3);
        if(TimetableEditVector.empty())
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(111);
            Utilities->CallLogPop(1779);
            return;
        }
// reset the TTCurrentEntryPtr to the Entry before the erased one if there is one
// but vector pointers unreliable after an erase, so use the position in the vector
        if(OldVectorPos == 0)
        {
            TTCurrentEntryPtr = TimetableEditVector.begin();
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos - 1;
        }
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            OneEntryTimetableMemo->Clear();
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(95);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1621);
    }
    catch(const Exception &e)
    {
        ErrorLog(58, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SaveTTEntryButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveTTEntryButtonClick");
/* allow blank lines to be saved
           AnsiString ContentStr = OneEntryTimetableMemo->Text;
           if((ContentStr == "\r\n") || (ContentStr == "\n") || (ContentStr == ""))
            {
            Utilities->CallLogPop(1679);
            return;
            }
*/
        AnsiString TempStr = "";
        bool ActiveLine = false;
        if(TTCurrentEntryPtr != TimetableEditVector.end())
        {
            if(*TTCurrentEntryPtr != "")
            {
                if((TTCurrentEntryPtr >= TTFirstServicePtr) && (TTCurrentEntryPtr <= TTLastServicePtr) && ((*TTCurrentEntryPtr)[1] != '*'))
                {
                    ActiveLine = true;
                    // need to add commas after each line in OneEntryTimetableMemo exept the last, where have '\0'
                    for(int x = 0; x < OneEntryTimetableMemo->Lines->Count; x++)
                    {
                        for(int y = 1; y <= OneEntryTimetableMemo->Lines->Strings[x].Length(); y++)
                        {
                            TempStr += OneEntryTimetableMemo->Lines->Strings[x][y];
                        }
                        if(x < (OneEntryTimetableMemo->Lines->Count - 1))
                        {
                            TempStr += ',';
                        }
                        // No need to add a '\n' as a '\0' is added automatically as a string delimiter.  If add '\n' then it is treated as a blank line and
                        // ends the timetable
                    }
                    // strip any excess commas from the end
                    if(TempStr != "")
                    {
                        while(TempStr[TempStr.Length()] == ',')
                        {
                            TempStr = TempStr.SubString(1, TempStr.Length() - 1);
                            if(TempStr == "")
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
        if(!ActiveLine)
        {
            TempStr = OneEntryTimetableMemo->Text; // Note that if the entry was intended as a service but goes in as plain text because
                                                   // the service & entry pointers aren't yet set, then CRLFs will be converted to commas in
                                                   // CompileAllEntriesMemoAndSetPointers if it appears after the start time
                                                   // and before a blank line or end of file, so the syntax check will work OK
        }
        if(AZOrderButton->Caption == AnsiString("Original Order"))
        {
            TimetableChangedInAZOrderFlag = true;
        }
        TimetableValidFlag = false;
        TimetableChangedFlag = true;
        TTEntryChangedFlag = false;
        int TopPos;
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            NewEntryInPreparationFlag = true;
        }
        if(!NewEntryInPreparationFlag)
        {
            (*TTCurrentEntryPtr) = TempStr;
            // need to reset the AllEntriesTTListBox in case the headcode has changed
            int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // vector pointers unreliable after an insert
            TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
            // position changing in AllEntriesTTListBox
            AllEntriesTTListBox->Clear();
            CompileAllEntriesMemoAndSetPointers(4);
            if(TimetableEditVector.empty())
            {
                Level1Mode = TimetableMode;
                SetLevel1Mode(112);
                Utilities->CallLogPop(1780);
                return;
            }
            // restore TTCurrentEntryPtr
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
        }
        else
        {
            NewEntryInPreparationFlag = false;
            if(TTCurrentEntryPtr != TimetableEditVector.end())
            {
                int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // vector pointers unreliable after an insert
                TimetableEditVector.insert(TTCurrentEntryPtr + 1, TempStr); // inserts before the indicated pointer position, which may be at the end
                TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
                TTCurrentEntryPtr++;
            }
            else
            {
                TimetableEditVector.insert(TimetableEditVector.end(), TempStr); // inserts before the indicated pointer position
                TTCurrentEntryPtr = TimetableEditVector.end() - 1;
            }
            int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // save the current position
            TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
            // position changing in AllEntriesTTListBox
            AllEntriesTTListBox->Clear();
            CompileAllEntriesMemoAndSetPointers(5);
            if(TimetableEditVector.empty())
            {
                Level1Mode = TimetableMode;
                SetLevel1Mode(113);
                Utilities->CallLogPop(1781);
                return;
            }
// reset the TTCurrentEntryPtr after CompileAllEntriesMemoAndSetPointers
            if(OldVectorPos >= TimetableEditVector.end() - TimetableEditVector.begin() - 1)
            {
                TTCurrentEntryPtr = TimetableEditVector.end() - 1;
            }
            else
            {
                TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
            }
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(96);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1622);
    }
    catch(const Exception &e)
    {
        ErrorLog(59, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveTTButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SaveTTButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveTTButtonClick");
        if(TimetableEditVector.empty())
        {
            ShowMessage("Timetable is empty, can't save an empty timetable");
            Utilities->CallLogPop(1685);
            return;
        }
        std::ofstream TTBLFile;
        if(CreateEditTTFileName != "")
        {
            TTBLFile.open(CreateEditTTFileName.c_str(), std::ios_base::binary); // if text then each time sees a "\r\n" pair enters "\r\n\n" because '\n'
            // on its own causes "\r\n' to ne inserted, binary just enters characters as they are
        }
        else
        {
            if(SaveTTDialog->Execute())
            {
                if(SaveTTDialog->InitialDir != TPath::GetDirectoryName(SaveTTDialog->FileName)) // new at v2.6.0 to retain a new directory
                {
                    TimetableDialog->InitialDir = TPath::GetDirectoryName(SaveTTDialog->FileName);
                    SaveTTDialog->InitialDir = TPath::GetDirectoryName(SaveTTDialog->FileName);
                }
                CreateEditTTFileName = AnsiString(SaveTTDialog->FileName);
                for(int x = CreateEditTTFileName.Length(); x > 0; x--)
                {
                    if(CreateEditTTFileName[x] == '\\')
                    {
                        CreateEditTTTitle = CreateEditTTFileName.SubString(x + 1, CreateEditTTFileName.Length() - x - 4);
                        break;
                    }
                }
                TTBLFile.open(CreateEditTTFileName.c_str(), std::ios_base::binary); // if text then each time sees a "\r\n" pair enters "\r\n\n" because '\n'
                // on its own causes "\r\n' to ne inserted, binary just enters characters as they are
            }
            else // cancelled dialog
            {
                Level1Mode = TimetableMode;
                SetLevel1Mode(137);
                Utilities->CallLogPop(2205);
                return;
            }
        }
        if(TTBLFile.is_open())
        {
            for(TEVPtr = TimetableEditVector.begin(); TEVPtr != TimetableEditVector.end(); TEVPtr++)
            {
                TTBLFile << (*TEVPtr).c_str() << '\0';
            }
            TimetableChangedFlag = false;
            TTBLFile.close();
        }
        else
        {
            ShowMessage(CreateEditTTFileName + " failed to open, ensure not already open in another application");
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(97);
        Utilities->CallLogPop(1623);
    }
    catch(const Exception &e) //non-error catch
    {
        TrainController->StopTTClockMessage(136, "Timetable failed to save\nError message: " + e.Message);  //added at v2.15.0
        Screen->Cursor = TCursor(-2); // Arrow;
//        ErrorLog(60, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SaveTTAsButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SaveTTAsButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveTTAsButtonClick");
        if(TimetableEditVector.empty())
        {
            ShowMessage("Timetable is empty, can't save an empty timetable");
            Utilities->CallLogPop(1686);
            return;
        }
        std::ofstream TTBLFile;
        if(SaveTTDialog->Execute())
        {
            if(SaveTTDialog->InitialDir != TPath::GetDirectoryName(SaveTTDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                TimetableDialog->InitialDir = TPath::GetDirectoryName(SaveTTDialog->FileName);
                SaveTTDialog->InitialDir = TPath::GetDirectoryName(SaveTTDialog->FileName);
            }
            CreateEditTTFileName = SaveTTDialog->FileName;
            for(int x = SaveTTDialog->FileName.Length(); x > 0; x--)
            {
                if(SaveTTDialog->FileName[x] == '\\')
                {
                    CreateEditTTTitle = SaveTTDialog->FileName.SubString(x + 1, SaveTTDialog->FileName.Length() - x - 4);
                    break;
                }
            }
            TTBLFile.open(CreateEditTTFileName.c_str(), std::ios_base::binary); // if text then each time sees a "\r\n" pair enters "\r\n\n" because '\n'
            // on its own causes "\r\n' to ne inserted, binary just enters characters as they are
        }
        else // cancelled dialog
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(138);
            Utilities->CallLogPop(2206);
            return;
        }
        if(TTBLFile.is_open())
        {
            for(TEVPtr = TimetableEditVector.begin(); TEVPtr != TimetableEditVector.end(); TEVPtr++)
            {
                TTBLFile << (*TEVPtr).c_str() << '\0';
            }
            TimetableChangedFlag = false;
            TTBLFile.close();
        }
        else
        {
            ShowMessage(CreateEditTTFileName + " failed to open, ensure not already open in another application");
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(117);
        Utilities->CallLogPop(1667);
    }
    catch(const Exception &e)
    {
        ErrorLog(108, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::TTServiceSyntaxCheckButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTServiceSyntaxCheckButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTServiceSyntaxCheckButtonClick");
        int Count = 1; // anything > 0 OK as if 0 still seeking a start time
        bool EndOfFile = false;
        bool FinalCallFalse = false;
        bool GiveMessagesTrue = true;
        bool CheckLocationsExistInRailway = false;
        if(RlyFile)
        {
            CheckLocationsExistInRailway = true;
        }
// TrainController->AnyHeadCodeValid = true; //don't fail here because of an unrestricted headcode, if no good will find when validate (dropped at v0.6b)
        if(TrainController->ProcessOneTimetableLine(2, Count, *TTCurrentEntryPtr, EndOfFile, FinalCallFalse, GiveMessagesTrue, CheckLocationsExistInRailway))
        // return true for success
        {
            ShowMessage(
                "The basic syntax seems OK but this check is very limited.  Other aspects can only be checked by validating the whole timetable with the appropriate railway (.rly) loaded");
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(98);
        Utilities->CallLogPop(1624);
    }
    catch(const Exception &e)
    {
        ErrorLog(61, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ValidateTimetableButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ValidateTimetableButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ValidateTimetableButtonClick");
        // reset all message flags, stops them being given twice   new at v2.4.0
        TrainController->SSHigh = false;
        TrainController->MRSHigh = false;
        TrainController->MRSLow = false;
        TrainController->MassHigh = false;
        TrainController->BFHigh = false;
        TrainController->BFLow = false;
        TrainController->PwrHigh = false;
        TrainController->SigSHigh = false;
        TrainController->SigSLow = false;
        if(CreateEditTTFileName == "")
        {
            Utilities->CallLogPop(1664);
            return;
        }
        bool CheckLocationsExistInRailwayTrue = true;
        if(TrainController->TimetableIntegrityCheck(2, CreateEditTTFileName.c_str(), true, CheckLocationsExistInRailwayTrue)) // messages  = true
        {
            Screen->Cursor = TCursor(-11); // Hourglass;
            std::ifstream TTBLFile(CreateEditTTFileName.c_str(), std::ios_base::binary);
            if(TTBLFile.is_open())
            {
                if(BuildTrainDataVectorForValidateFile(0, TTBLFile, true, CheckLocationsExistInRailwayTrue)) // messages  = true
                {
                    if(!TwoLocationNamePanel->Visible)  //added at v2.9.1.  If this visible don't override it with another message.
                    {
                        ShowMessage("Timetable integrity OK");
                        TimetableValidFlag = true;
                    }
// TrainController->TrainDataVector.clear(); keep this so can export a formatted tt
                }
            }
            else
            {
                ShowMessage("Failed to open timetable file, make sure it's spelled correctly, it exists and isn't open in another application");
            }
            Screen->Cursor = TCursor(-2); // Arrow
        } // if(TimetableIntegrityCheck
        else
        {
// ShowMessage("Timetable preliminary integrity check failed"); dropped in v2.4.0 as messages given in all called functions
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(99);
        Utilities->CallLogPop(1625);
    }
    catch(const Exception &e)
    {
        ErrorLog(62, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::MoveTTEntryUpButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MoveTTEntryUpButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MoveTTEntryUpButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            Utilities->CallLogPop(1634);
            return;
        }
        if(TTCurrentEntryPtr < (TimetableEditVector.begin() + 1)) // shouldn't reach here but return if do
        {
            Utilities->CallLogPop(1632);
            return;
        }
        TEVPtr = TTCurrentEntryPtr - 1; // find earlier Entry
        AnsiString TempStr = *TEVPtr;
        *TEVPtr = *TTCurrentEntryPtr;
        *TTCurrentEntryPtr = TempStr;
        TTCurrentEntryPtr = TEVPtr;
        TimetableChangedFlag = true;
        TimetableValidFlag = false;

// now rebuild AllEntriesTTListBox, DisplayOneTTLineInPanel will highlight it
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        AllEntriesTTListBox->Clear();
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // save the old position
        CompileAllEntriesMemoAndSetPointers(6);
// reset the TTCurrentEntryPtr after CompileAllEntriesMemoAndSetPointers
        if(OldVectorPos >= TimetableEditVector.end() - TimetableEditVector.begin() - 1)
        {
            TTCurrentEntryPtr = TimetableEditVector.end() - 1;
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(100);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1626);
    }
    catch(const Exception &e)
    {
        ErrorLog(63, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::MoveTTEntryDownButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MoveTTEntryDownButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MoveTTEntryDownButtonClick");
        if(TTCurrentEntryPtr == TimetableEditVector.end())
        {
            Utilities->CallLogPop(1635);
            return;
        }
        if(TTCurrentEntryPtr >= (TimetableEditVector.end() - 1)) // shouldn't reach here but return if do
        {
            Utilities->CallLogPop(1678);
            return;
        }
        TEVPtr = TTCurrentEntryPtr + 1; // find later Entry
        AnsiString TempStr = *TEVPtr;
        *TEVPtr = *TTCurrentEntryPtr;
        *TTCurrentEntryPtr = TempStr;
        TTCurrentEntryPtr = TEVPtr;
        TimetableChangedFlag = true;
        TimetableValidFlag = false;

// now rebuild AllEntriesTTListBox, DisplayOneTTLineInPanel will highlight it
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
        // position changing in AllEntriesTTListBox
        AllEntriesTTListBox->Clear();
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // save the old position
        CompileAllEntriesMemoAndSetPointers(7);
// reset the TTCurrentEntryPtr after CompileAllEntriesMemoAndSetPointers
        if(OldVectorPos >= TimetableEditVector.end() - TimetableEditVector.begin() - 1)
        {
            TTCurrentEntryPtr = TimetableEditVector.end() - 1;
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(101);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1627);
    }
    catch(const Exception &e)
    {
        ErrorLog(64, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::CancelTTEntryButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CancelTTActionButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CancelTTActionButtonClick");
        TTEntryChangedFlag = false;
        if(NewEntryInPreparationFlag)
        {
            NewEntryInPreparationFlag = false;
            OneEntryTimetableMemo->Clear();
        }
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
                                                    // position changing in AllEntriesTTListBox
        Level1Mode = TimetableMode;
        SetLevel1Mode(102);
        if((TTCurrentEntryPtr - TimetableEditVector.begin()) < TopPos)
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
        }
        else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (TopPos + 45))
        {
            AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
        }
        else
        {
            AllEntriesTTListBox->TopIndex = TopPos;
        }
        Utilities->CallLogPop(1630);
    }
    catch(const Exception &e)
    {
        ErrorLog(102, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::RestoreTTButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("RestoreTTButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RestoreTTButtonClick");
        if(TimetableChangedFlag)
        {
            UnicodeString MessageStr = "All changes to the timetable will be lost - proceed?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Utilities->CallLogPop(1651);
                return;
            }
        }
        // repeat from EditTimetableMenuItemClick, but no need to check for non-ascii characters
        // open in binary mode so the "\r\n" pairs stay as they are rather than being entered as '\n'
        std::ifstream TTBLFile(CreateEditTTFileName.c_str(), std::ios_base::binary);
        if(TTBLFile.is_open())
        {
            TimetableChangedFlag = false;
            TimetableValidFlag = false;
            TTEntryChangedFlag = false;
            NewEntryInPreparationFlag = false;
            CopiedEntryFlag = false;
            CopiedEntryStr = "";
            TimetableEditVector.clear();
            OneEntryTimetableMemo->Clear();
            AllEntriesTTListBox->Clear();
            TTStartTimeBox->Text = "";
            AddSubMinsBox->Text = "";
            TEVPtr = TimetableEditVector.end();
            TTCurrentEntryPtr = TimetableEditVector.end(), TTStartTimePtr = TimetableEditVector.end();
            TTFirstServicePtr = TimetableEditVector.end();
            TTLastServicePtr = TimetableEditVector.end();
            char *TimetableEntryString = new char[10000];
            while(true)
            {
                TTBLFile.getline(TimetableEntryString, 10000, '\0'); // pick up the entire AnsiString, including any embedded newlines
                if(TTBLFile.eof() && (TimetableEntryString[0] == '\0')) // stores a null in 1st position if doesn't load any characters
                {
                    // may still have eof even if read a line, and
                    // if so need to process it
                    break;
                }
                AnsiString OneLine(TimetableEntryString);
                TimetableEditVector.push_back(OneLine);
            }
            TTBLFile.close();
            delete[]TimetableEntryString;
            // here with TimetableEditVector compiled
        }
        else
        {
            ShowMessage("Failed to open timetable file, make sure it's spelled correctly, it exists and isn't open in another application");
            Utilities->CallLogPop(1655);
            return;
        }
        CompileAllEntriesMemoAndSetPointers(8);
        if(TimetableEditVector.empty())
        {
            Level1Mode = TimetableMode;
            SetLevel1Mode(114);
            Utilities->CallLogPop(1782);
            return;
        }
// all now set where can be
        TTCurrentEntryPtr = TimetableEditVector.begin();
// end of repeat from EditTimetableMenuItemClick

        Level1Mode = TimetableMode;
        SetLevel1Mode(104);
        Utilities->CallLogPop(1652);
    }
    catch(const Exception &e)
    {
        ErrorLog(104, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ExportTTButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExportTTButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExportTTButtonClick");
        if(!DirectoryExists(CurDir + "\\" + FORMATTEDTT_DIR_NAME))
        {
            ShowMessage("Failed to find folder " + FORMATTEDTT_DIR_NAME + " in the folder where 'railway.exe' resides.  Timetable can't be exported");
            Utilities->CallLogPop(1698);
            return;
        }
// Screen->Cursor = TCursor(-11); // Hourglass; - no good setting here as it's reset by ShowMessage in CreateFormattedTimetable. It's set there after
// the message instead, but reset here afterwards
        AnsiString TTTitle;
        if(RlyFile && TimetableValidFlag && (CreateEditTTFileName != ""))
        {
            for(int x = CreateEditTTFileName.Length(); x > 0; x--) // first need to strip out the timetable title from the full name
            {
                if(CreateEditTTFileName[x] == '\\')
                {
                    TTTitle = CreateEditTTFileName.SubString(x + 1, CreateEditTTFileName.Length() - x - 4);
                    break;
                }
            }
            TrainController->CreateFormattedTimetable(1, RailwayTitle, TTTitle, CurDir);
        }
        Screen->Cursor = TCursor(-2); // Arrow - reset after above function returns
        Level1Mode = TimetableMode;
        SetLevel1Mode(116);
        Utilities->CallLogPop(1662);
    }
    catch(const Exception &e)
    {
        ErrorLog(107, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TTTextButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTTextButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTTextButtonClick");
/*
           if(TTStartTimePtr == 0)
           {
            OneEntryTimetableMemo->Clear();
            TTStartTimeBox->SetFocus();
            Utilities->CallLogPop(1673);
            return;
            }
*/
        int SelPos = OneEntryTimetableMemo->SelStart;
        AnsiString FirstPart = OneEntryTimetableMemo->Text.SubString(1, SelPos);
        AnsiString LastPart = OneEntryTimetableMemo->Text.SubString(SelPos + 1, OneEntryTimetableMemo->Text.Length() - SelPos);
        OneEntryTimetableMemo->Text = FirstPart + ((TButton*)Sender)->Caption + LastPart;
        OneEntryTimetableMemo->SelStart = SelPos + ((TButton*)Sender)->Caption.Length();
        TTEntryChangedFlag = true;
        OneEntryTimetableMemo->SetFocus();
        Level1Mode = TimetableMode;
        SetLevel1Mode(119);
        Utilities->CallLogPop(1672);
    }
    catch(const Exception &e)
    {
        ErrorLog(110, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ExitTTModeButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExitTTCreateEditButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExitTTCreateEditButtonClick");
        if(TimetableChangedFlag)
        {
            UnicodeString MessageStr = "The timetable has changed.\n\nAre you sure you want to exit without saving it?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Utilities->CallLogPop(1603);
                return;
            }
        }
        TimetableChangedFlag = false;
        CreateEditTTFileName = ""; // set to null to allow a check during error file saving, if not null save the tt being edited to the file
                                   // added for Beta v0.2b
        CreateEditTTTitle = ""; // as above
        ConflictPanel->Visible = false;
        Level1Mode = BaseMode;
        SetLevel1Mode(84);
        Utilities->CallLogPop(1606);
    }
    catch(const Exception &e)
    {
        ErrorLog(49, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LocationNameComboBoxClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LocationNameComboBoxClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LocationNameComboBoxClick");
        if(TTStartTimePtr != TimetableEditVector.end())
        {
            LocationNameComboBox->SelectAll();
            int SelPos = OneEntryTimetableMemo->SelStart;
            AnsiString FirstPart = OneEntryTimetableMemo->Text.SubString(1, SelPos);
            AnsiString LastPart = OneEntryTimetableMemo->Text.SubString(SelPos + 1, OneEntryTimetableMemo->Text.Length() - SelPos);
            OneEntryTimetableMemo->Text = FirstPart + LocationNameComboBox->SelText + LastPart;
            OneEntryTimetableMemo->SelStart = SelPos + LocationNameComboBox->SelText.Length();
            TTEntryChangedFlag = true;
            OneEntryTimetableMemo->SetFocus();
            Level1Mode = TimetableMode;
            SetLevel1Mode(118);
        }
        Utilities->CallLogPop(1669);
    }
    catch(const Exception &e)
    {
        ErrorLog(109, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::OneEntryTimetableMemoKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
// TrainController->LogEvent("OneEntryTimetableMemoKeyUp");  drop this - too many entries
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",OneEntryTimetableMemoKeyUp");
        if(OneEntryTimetableMemo->Text == OneEntryTimetableContents)
        {
            Utilities->CallLogPop(1716);
            return;
        }
        TimetableChangedFlag = true;
        TTEntryChangedFlag = true;
        TimetableValidFlag = false;
        Level1Mode = TimetableMode;
        SetLevel1Mode(127);
        Utilities->CallLogPop(1629);
    }
    catch(const Exception &e)
    {
        ErrorLog(66, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::AddSubMinsBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
// forces a recheck for whether addmins/submins buttons should be enabled
    try
    {
        TrainController->LogEvent("AddSubMinsBoxKeyUp");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AddSubMinsBoxKeyUp");
        Level1Mode = TimetableMode;
        SetLevel1Mode(108);
        Utilities->CallLogPop(1658);
    }
    catch(const Exception &e)
    {
        ErrorLog(106, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::LocationNameComboBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("LocationNameComboBoxKeyUp");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LocationNameComboBoxKeyUp");
        if(!Track->LocationNameMultiMap.empty())
        {
            LocationNameComboBox->Text = "Location names";
        }
        else
        {
            LocationNameComboBox->Text = "No locations (listed when a railway with names is loaded)";
        }
        Utilities->CallLogPop(1677);
    }
    catch(const Exception &e)
    {
        ErrorLog(112, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::AllEntriesTTListBoxMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
// Select the item pointed to unless a 'save entry' is pending in which case ignore
    try
    {
        TrainController->LogEvent("AllEntriesTTListBoxMouseUp," + AnsiString(X) + "," + AnsiString(Y));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AllEntriesTTListBoxMouseUp," + AnsiString(X) + "," + AnsiString(Y));
        if((TTCurrentEntryPtr == TimetableEditVector.end()) || TimetableEditVector.empty())
        {
            Utilities->CallLogPop(1687);
            return;
        }
        if(TTEntryChangedFlag || NewEntryInPreparationFlag) // if a save/cancel pending don't permit anything else
        {
            Utilities->CallLogPop(1688);
            return;
        }
        int TopPos = AllEntriesTTListBox->TopIndex; // need to store this & reset it after SetLevel1Mode to prevent the scroll
                                                    // position changing in AllEntriesTTListBox

//substituted for the below
        int LBIndex = AllEntriesTTListBox->ItemAtPos(TPoint(X,Y), true);
        if(LBIndex == -1)
        {
            TTCurrentEntryPtr = TimetableEditVector.end() - 1;
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + LBIndex;
        }
//dropped at v2.13.0 as unreliable on high resolution monitors
        // find item required - 13 pixels per line of text
/*        if((TopPos + (Y / 13)) >= AllEntriesTTListBox->Items->Count)
        {
            TTCurrentEntryPtr = TimetableEditVector.end() - 1;
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + (Y / 13) + TopPos;
        }
*/
        int OldVectorPos = TTCurrentEntryPtr - TimetableEditVector.begin(); // save the old position
        CompileAllEntriesMemoAndSetPointers(9);
// reset the TTCurrentEntryPtr after CompileAllEntriesMemoAndSetPointers
        if(OldVectorPos >= TimetableEditVector.end() - TimetableEditVector.begin() - 1)
        {
            TTCurrentEntryPtr = TimetableEditVector.end() - 1;
        }
        else
        {
            TTCurrentEntryPtr = TimetableEditVector.begin() + OldVectorPos;
        }
        Level1Mode = TimetableMode;
        SetLevel1Mode(120);
        AllEntriesTTListBox->TopIndex = TopPos; // reset it after SetLevel1Mode to prevent the scroll position changing
        Utilities->CallLogPop(1648);
    }
    catch(const Exception &e)
    {
        ErrorLog(103, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::CompileAllEntriesMemoAndSetPointers(int Caller)
{
    enum
    {
        PreStartTime, ActiveSegment, PostEnd
    } Segment;
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CompileAllEntriesMemoAndSetPointers");
    AllEntriesTTListBox->Clear();
    TEVPtr = TimetableEditVector.end();
    TTStartTimePtr = TimetableEditVector.end();
    TTFirstServicePtr = TimetableEditVector.end();
    TTLastServicePtr = TimetableEditVector.end();
    if(TimetableEditVector.empty())
    {
        TTCurrentEntryPtr = TimetableEditVector.end();
        Utilities->CallLogPop(1681);
        return;
    }
    Segment = PreStartTime;
    for(TEVPtr = TimetableEditVector.begin(); TEVPtr != TimetableEditVector.end(); TEVPtr++)
    {
        if(Segment == PreStartTime) // looking for the start time
        {
            TDateTime TempTime; // dummy
            if(TrainController->CheckTimeValidity(33, *TEVPtr, TempTime))
            {
                TTStartTimePtr = TEVPtr; // TTStartTimeBox text set in TTHandler
                AllEntriesTTListBox->Items->Add("START " + (*TEVPtr).SubString(1, 5));
                Segment = ActiveSegment;
                continue;
            }
            else
            {
                if(*TEVPtr == "")
                {
                    AllEntriesTTListBox->Items->Add("- Blank");
                }
                else
                {
                    AnsiString CurrentStr = *TEVPtr;
                    if(CurrentStr != "") // strip any non alphanumeric characters (specifically \r or \n)
                    {
                        CurrentStr = CurrentStr.SubString(1, 10); // limit length for LH window
                        for(int x = 1; x < CurrentStr.Length(); x++)
                        {
                            if((CurrentStr[x] < 32) || (CurrentStr[1] > 126))
                            {
                                CurrentStr = CurrentStr.SubString(1, (x - 1));
                            }
                        }
                    }
                    AllEntriesTTListBox->Items->Add("- " + CurrentStr);
                }
                continue;
            }
        }
        if(Segment == ActiveSegment)
        {
            if(*TEVPtr != "")
            {
                if((*TEVPtr)[1] != '*')
                {
                    TrainController->StripSpaces(5, *TEVPtr);
                    ConvertCRLFsToCommas(0, *TEVPtr); // This needed because an entry intended as a service might have skipped the conversion in
                    // SaveTTEntryButtonClick - see comment in that function
                    if(TTFirstServicePtr == TimetableEditVector.end())
                    {
                        TTFirstServicePtr = TEVPtr;
                    }
                    TTLastServicePtr = TEVPtr;
                }
                AnsiString Entry = *TEVPtr;

/* dropped at v2.9.1 so comment entries more meaningful, they self truncate to AllEntriesTTListBox width
                if(Entry[1] == '*')
                {
                    Entry = "Comment";
                }
*/
                if(Entry[1] != '*')  //changed from 'else' at v2.9.1
                {
                    int SCPos = Entry.Pos(';'); // semicolon
                    int CPos = Entry.Pos(','); // comma
                    // 5 possibilities: no comma & no semicolon - just text - enter 1st 12 characters
                    // both, comma before semicolon, i.e text on its own line, semicolon on next line - e.g. service headcode but no
                    // description - enter the text up to the comma
                    // both, semicolon before comma, normal - enter text up to the semicolon
                    // comma & no semicolon, one or more lines of text without any semicolons - enter the text up to the comma
                    // semicolon & no comma - enter text up to the semicolon
                    if((CPos == 0) && (SCPos == 0))
                    {
                        Entry = Entry.SubString(1, 12);
                    }
                    else if((CPos > 0) && (SCPos > 0) && (CPos < SCPos))
                    {
                        Entry = Entry.SubString(1, CPos - 1);
                    }
                    else if((CPos > 0) && (SCPos > 0) && (CPos > SCPos))
                    {
                        Entry = Entry.SubString(1, SCPos - 1);
                    }
                    else if((CPos > 0) && (SCPos == 0))
                    {
                        Entry = Entry.SubString(1, CPos - 1);
                    }
                    else
                    {
                        Entry = Entry.SubString(1, SCPos - 1);
                    }
                }
                AllEntriesTTListBox->Items->Add(Entry);
                continue;
            }
            else
            {
                Segment = PostEnd;
                AllEntriesTTListBox->Items->Add("END (Blank)");
                continue;
            }
        }
        if(Segment == PostEnd)
        {
            if(*TEVPtr == "")
            {
                AllEntriesTTListBox->Items->Add("+ Blank");
            }
            else
            {
                AnsiString CurrentStr = *TEVPtr;
                if(CurrentStr != "") // strip any non alphanumeric characters (specifically \r or \n)
                {
                    CurrentStr = CurrentStr.SubString(1, 10);
                    for(int x = 1; x < CurrentStr.Length(); x++)
                    {
                        if((CurrentStr[x] < 32) || (CurrentStr[1] > 126))
                        {
                            CurrentStr = CurrentStr.SubString(1, (x - 1));
                        }
                    }
                }
                AllEntriesTTListBox->Items->Add("+ " + CurrentStr);
            }
            continue;
        }
    }
    if(TTStartTimePtr == TimetableEditVector.end())
    {
        TTStartTimeBox->Text = "";
    }
    TTCurrentEntryPtr = TTLastServicePtr; // may well be reset outside this function but need to ensure that it has a valid value on exit, even if it's null
    Utilities->CallLogPop(1680);
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::AZOrderButtonClick(TObject *Sender)
{
    try
    {
        if(TimetableEditVector.empty())
        {
            return; // should be able to access this if it is but keep in for safety
        }
        TrainController->LogEvent("AZOrderClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",AZOrderClick");
        if(AZOrderButton->Caption == AnsiString("A-Z Order"))
        {
            TTEVPtr SortStart, SortEnd;
            UnicodeString MessageStr =
                "If you wish to preserve the original order don't save any changes whilst in alphabetical order.\n\n" "To preserve the original order use alphabetical order to find the service required, click it to display it,"
                " then revert to the original order where the same service will be displayed and can be changed.";
            Application->MessageBox(MessageStr.c_str(), L"Please Note:", MB_OK | MB_ICONWARNING);
            TTSelectedEntry = *TTCurrentEntryPtr;
            OriginalTimetableEditVector = TimetableEditVector;
            SortStart = TimetableEditVector.begin(); // if no start time set sort from beginning
            if(TTFirstServicePtr != TimetableEditVector.end())
            {
                SortStart = TTFirstServicePtr;
            }
            SortEnd = TimetableEditVector.end(); // if no last service set sort to end
            if(TTLastServicePtr != TimetableEditVector.end())
            {
                SortEnd = TTLastServicePtr + 1;
            }
            std::sort(SortStart, SortEnd);
            CompileAllEntriesMemoAndSetPointers(11);
            bool CurrentEntryChanged = false;
            for(TTimetableEditVector::iterator x = TimetableEditVector.begin(); x < TimetableEditVector.end(); x++)
            {
                if(TTSelectedEntry == *x)
                {
                    TTCurrentEntryPtr = x;
                    CurrentEntryChanged = true;
                }
            }
            if(!CurrentEntryChanged)
            {
                TTCurrentEntryPtr = TTStartTimePtr;
            }
            AZOrderButton->Caption = AnsiString("Original Order");
            AZOrderButton->Hint = AnsiString("Arrange services in original order       Toggle with Shift+ Z");
        }
        else
        {
            if(TimetableChangedInAZOrderFlag)
            {
                UnicodeString MessageStr =
                    "Reverting to the original order will discard any changes made whilst in alphabetical order.\n\nTo preserve the changes click 'No', then save the timetable or use 'save as' if you wish to keep the original timetable.\n\nDo you wish to proceed?";
                int button = Application->MessageBox(MessageStr.c_str(), L"Warning!", MB_YESNO | MB_ICONWARNING);
                if(button == IDNO)
                {
                    TimetableChangedFlag = true;
                    TimetableValidFlag = false;
                    Level1Mode = TimetableMode;
                    SetLevel1Mode(135);
                    Utilities->CallLogPop(2166);
                    return;
                }
            }
            TTSelectedEntry = *TTCurrentEntryPtr;
            TimetableEditVector = OriginalTimetableEditVector;
            CompileAllEntriesMemoAndSetPointers(12);
            bool CurrentEntryChanged = false;
            for(TTimetableEditVector::iterator x = TimetableEditVector.begin(); x < TimetableEditVector.end(); x++)
            {
                if(TTSelectedEntry == *x)
                {
                    TTCurrentEntryPtr = x;
                    CurrentEntryChanged = true;
                }
            }
            if(!CurrentEntryChanged)
            {
                TTCurrentEntryPtr = TTStartTimePtr;
            }
            AZOrderButton->Caption = AnsiString("A-Z Order");
            AZOrderButton->Hint = AnsiString("Arrange services in alphabetical order       Toggle with Shift+ Z");
        }
//        TimetableChangedFlag = true;   dropped for v2.11.0
        TimetableValidFlag = false;
        TimetableChangedInAZOrderFlag = false;
        Level1Mode = TimetableMode;
        SetLevel1Mode(136);
        Utilities->CallLogPop(2165);
    }
    catch(const Exception &e)
    {
        ErrorLog(211, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::ConvertCRLFsToCommas(int Caller, AnsiString &ConvStr)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ConvertCRLFsToCommas," + ConvStr);
    AnsiString OutStr = "";
    int x = 1; // AnsiString arrays start at 1

    while(x < ConvStr.Length()) // skip the last character as looking for CRLF pairs, i.e. '\r' followed by '\n'
    {
        if((ConvStr[x] == '\r') && (ConvStr[x + 1] == '\n'))
        {
            OutStr += ',';
            x++;
            x++;
        }
        else
        {
            OutStr += ConvStr[x];
            x++;
        }
    }
    if(x == ConvStr.Length())
    {
        OutStr += ConvStr[x]; // add the last character

    }
// strip any excess commas from the end
    if(OutStr != "")
    {
        while(OutStr[OutStr.Length()] == ',')
        {
            OutStr = OutStr.SubString(1, OutStr.Length() - 1);
            if(OutStr == "")
            {
                break; // if consisted of just commas then without this would fail on range error when becomes a null string
            }
        }
    }
    ConvStr = OutStr;
    if(ConvStr == "")
    {
        ConvStr = ','; // don't return a null or will fail, OK to return a comma on its own as will be ignored during ProcessOneTimetableLine
    }
    // when AllCommas will be true
    Utilities->CallLogPop(1846);
}

// ---------------------------------------------------------------------------

void TInterface::TimetableHandler()
{
/* CreateEditTTFileName set if a TT file loaded (even if empty), the pointers TTStartTimePtr, TTFirstServicePtr, TTLastServicePtr provide
   relevant information - if null then not set.  TTCurrentEntryPtr is set to the Entry to be displayed or null if there's no start time or no
   entries
*/
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TimetableHandler");
    PreviousTTEntryButton->Enabled = false;
    NextTTEntryButton->Enabled = false;
    AddMinsButton->Enabled = false;
    SubMinsButton->Enabled = false;
    CopyTTEntryButton->Enabled = false;
    CutTTEntryButton->Enabled = false;
    PasteTTEntryButton->Enabled = false;
    DeleteTTEntryButton->Enabled = false;
    SaveTTEntryButton->Enabled = false;
    SaveTTButton->Enabled = false;
    SaveTTAsButton->Enabled = false;
    ValidateTimetableButton->Enabled = false;
    AZOrderButton->Enabled = false;
    TTServiceSyntaxCheckButton->Enabled = false;
    InvertTTEntryButton->Enabled = false;
    NewTTEntryButton->Enabled = false;
    MoveTTEntryUpButton->Enabled = false;
    MoveTTEntryDownButton->Enabled = false;
    CancelTTEntryButton->Enabled = false;
    RestoreTTButton->Enabled = false;
    ExportTTButton->Enabled = false;
    ConflictAnalysisButton->Enabled = false;
    ExitTTModeButton->Enabled = true;

    if(!TimetableEditVector.empty() && !TTEntryChangedFlag && !NewEntryInPreparationFlag)
    {
        AZOrderButton->Enabled = true;
    }
    if(TimetableChangedFlag)
    {
        TimetableValidFlag = false; // should always be the case anyway but include here to be sure

    }
    if(CreateEditTTFileName == "")
    {
        TimetableNameLabel->Caption = "Creating new timetable: not yet saved";
    }
    else
    {
        TimetableNameLabel->Caption = "Editing timetable: " + CreateEditTTTitle;
    }
    if(TTStartTimePtr != TimetableEditVector.end()) // Null means start time not yet set
    {
        TTStartTimeBox->Text = (*TTStartTimePtr).SubString(1, 5); // 1st 5 chars = time if validity check OK
    }
// start time now set & displayed

    if(!TTEntryChangedFlag && !NewEntryInPreparationFlag)
    {
        InfoPanel->Visible = true;
        InfoPanel->Caption = "Select option or change entry";
        if(RailwayTitle != "")
        {
            ShowHideTTButton->Enabled = true;
        }
        else
        {
            ShowHideTTButton->Enabled = false;
        }
        ExitTTModeButton->Enabled = true;
        AllEntriesTTListBox->Enabled = true;
        AnsiString AnsiAddSubText(AddSubMinsBox->Text);
        if((AnsiAddSubText != "") && AreAnyTimesInCurrentEntry())
        {
            bool ValidFlag = true;
            for(int x = 1; x <= AnsiAddSubText.Length(); x++)
            {
                if((AnsiAddSubText[x] > '9') || (AnsiAddSubText[x] < '0'))
                {
                    ValidFlag = false;
                    break;
                }
            }
            if(ValidFlag)
            {
                if(AnsiAddSubText.ToInt() != 0)
                {
                    AddMinsButton->Enabled = true;
                    SubMinsButton->Enabled = true;
                }
            }
        }
        if((CreateEditTTFileName != "") && TimetableChangedFlag)
        {
            RestoreTTButton->Enabled = true;
        }
        if(!TimetableValidFlag && RlyFile && !TimetableChangedFlag && (CreateEditTTFileName != ""))
        {
            // Need !TimetableChangedFlag because the changed TT must be saved before validation - it's the TT file that is checked
            // so if it is changed but not saved, the 'correct' file will check OK but the changed TT may well not be valid
            ValidateTimetableButton->Enabled = true;
        }
        if(TimetableValidFlag && RlyFile && (CreateEditTTFileName != ""))
        {
            ExportTTButton->Enabled = true;
            ConflictAnalysisButton->Enabled = true;
        }
        if(TTCurrentEntryPtr != TimetableEditVector.end())
        {
            CopyTTEntryButton->Enabled = true;
            CutTTEntryButton->Enabled = true;
            DeleteTTEntryButton->Enabled = true;
        }
        if((TimetableChangedFlag) && !TimetableEditVector.empty())
        {
            SaveTTButton->Enabled = true;
        }
        if(!TimetableEditVector.empty())
        {
            SaveTTAsButton->Enabled = true;
        }
        if(!NewEntryInPreparationFlag)
        {
            NewTTEntryButton->Enabled = true;
        }
        if((TTCurrentEntryPtr != TimetableEditVector.end()) && !TimetableEditVector.empty())
        {
            if((TimetableEditVector.end() - 1) > TTCurrentEntryPtr)
            {
                NextTTEntryButton->Enabled = true;
                MoveTTEntryDownButton->Enabled = true;
            }
            if(TimetableEditVector.begin() < TTCurrentEntryPtr)
            {
                PreviousTTEntryButton->Enabled = true;
                MoveTTEntryUpButton->Enabled = true;
            }
        }
        if(TTCurrentEntryPtr != TimetableEditVector.end())
        {
            if(*TTCurrentEntryPtr != "")
            {
                if((TTCurrentEntryPtr >= TTFirstServicePtr) && (TTCurrentEntryPtr <= TTLastServicePtr) && ((*TTCurrentEntryPtr)[1] != '*'))
                {
                    TTServiceSyntaxCheckButton->Enabled = true;
                    InvertTTEntryButton->Enabled = true;
                }
            }
        }
        if(CopiedEntryFlag)
        {
            PasteTTEntryButton->Enabled = true;
        }
        OneEntryTimetableMemo->Clear(); // don't clear if Entry changed
        if(TTCurrentEntryPtr != TimetableEditVector.end())
        {
// if(*TTCurrentEntryPtr != "")  leave this out or fails to highlight blank line entries
            if((TTCurrentEntryPtr > TTStartTimePtr) && (TTCurrentEntryPtr <= TTLastServicePtr) && ((*TTCurrentEntryPtr)[1] != '*'))
            {
                bool ServiceEntry = true;
                DisplayOneTTLineInPanel(0, *TTCurrentEntryPtr, ServiceEntry);
            }
            else
            {
                bool ServiceEntry = false;
                DisplayOneTTLineInPanel(1, *TTCurrentEntryPtr, ServiceEntry);
            }
        }
    }
    else
    {
        CancelTTEntryButton->Enabled = true;
        SaveTTEntryButton->Enabled = true;
        ShowHideTTButton->Enabled = false;
        ExitTTModeButton->Enabled = false;
        AllEntriesTTListBox->Enabled = false; // to stop entries being selected
        InfoPanel->Caption = "Add or change entry then save it, or cancel";
        InfoPanel->Visible = true;
    }
    Utilities->CallLogPop(1600);
}

// ---------------------------------------------------------------------------
void TInterface::DisplayOneTTLineInPanel(int Caller, AnsiString Data, bool ServiceEntry)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",DisplayOneTTLineInPanel," + Data + ", " +
                                 AnsiString((short)ServiceEntry));
    OneEntryTimetableMemo->Clear();
    if(ServiceEntry)
    {
        TrainController->StripSpaces(1, Data);
        while(true)
        {
            int CommaPos = Data.Pos(',');
            if((CommaPos == 0) && (Data != ""))
            {
                CommaPos = Data.Length() + 1;
            }
            OneEntryTimetableMemo->Lines->Add(Data.SubString(1, CommaPos - 1));
            if(Data.Length() <= CommaPos)
            {
                break;
            }
            Data = Data.SubString(CommaPos + 1, Data.Length() - CommaPos);
        }
    }
    else
    {
        OneEntryTimetableMemo->Text = Data;
    }
    int TotalLines = OneEntryTimetableMemo->Lines->Count; // remove excess lines at bottom

    while((OneEntryTimetableMemo->Lines->Strings[TotalLines - 1] == "") || (OneEntryTimetableMemo->Lines->Strings[TotalLines - 1] == "\r\n"))
    {
        OneEntryTimetableMemo->Lines->Delete(TotalLines - 1);
        TotalLines--;
        if(TotalLines < 1)
        {
            break;
        }
    }
    OneEntryTimetableMemo->HideSelection = true;
    OneEntryTimetableMemo->SelStart = 0; // need this & next command to set cursor to the top
    OneEntryTimetableMemo->SelLength = 0;
    OneEntryTimetableContents = OneEntryTimetableMemo->Text;
    Utilities->CallLogPop(1602);
}
// ---------------------------------------------------------------------------

void TInterface::HighlightOneEntryInAllEntriesTTListBox(int Caller, int Position)
{ //not used from v2.13.0 as clicking an entry does all that is required
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",HighlightOneEntryInAllEntriesTTListBox," + AnsiString(Position));
    if(TimetableEditVector.empty() || (AllEntriesTTListBox->Items->Count == 0))
    {
        HighlightPanel->Top = 32;
        HighlightPanel->Caption = "";
        HighlightPanel->Width = 100;
        HighlightPanel->Visible = false;
    }
    else
    {
        AnsiString CurrentStr = AllEntriesTTListBox->Items->Strings[Position];
        if(CurrentStr != "") // strip any non alphanumeric characters (specifically \r or \n)
        {
            for(int x = 1; x < CurrentStr.Length(); x++)
            {
                if((CurrentStr[x] < 32) || (CurrentStr[1] > 126))
                {
                    CurrentStr = CurrentStr.SubString(1, (x - 1));
                }
            }
        }
        HighlightPanel->Top = 32 + (Position * 13) - (AllEntriesTTListBox->TopIndex * 13);
        if(HighlightPanel->Top < 32)
        {
            HighlightPanel->Visible = false;
        }
        else
        {
            HighlightPanel->Visible = true; // doesn't matter if goes off the bottom as it becomes invisible as then it's off its parent panel
        }
        HighlightPanel->Caption = CurrentStr;
        if(AllEntriesTTListBox->Items->Count > 47) // because the scrollbar will be present
        {
            HighlightPanel->Width = 82;
        }
        else
        {
            HighlightPanel->Width = 100;
        }
    }
    Utilities->CallLogPop(1709);
}

// ---------------------------------------------------------------------------
bool TInterface::AreAnyTimesInCurrentEntry()
{
    if((TTCurrentEntryPtr == TimetableEditVector.end()) || (*TTCurrentEntryPtr == ""))
    {
        return(false);
    }
    TDateTime DummyTime;
    bool TimesPresent = false;

    for(int x = 0; x < OneEntryTimetableMemo->Lines->Count; x++)
    {
        for(int y = 1; y < (OneEntryTimetableMemo->Lines->Strings[x].Length() - 3); y++)
        {
            if(TrainController->CheckTimeValidity(20, OneEntryTimetableMemo->Lines->Strings[x].SubString(y, 5), DummyTime))
            {
                TimesPresent = true;
                break;
            }
        }
        if(TimesPresent)
        {
            break;
        }
    }
    return(TimesPresent);
}

// ---------------------------------------------------------------------------
// end of Timetable editing functions
// ---------------------------------------------------------------------------
void __fastcall TInterface::ExitMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ExitMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ExitMenuItemClick");
/* Dropped at v2.9.1 as serves no apparent purpose
        if(!FileChangedFlag && !(Track->IsTrackFinished()) && (EveryPrefDir->PrefDirSize() > 0))
        {
            UnicodeString MessageStr =
                "Note that leaving the track unlinked will cause preferred directions to be lost on reloading.  Prevent by linking the track then resaving.  Do you still wish to exit?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Utilities->CallLogPop(1711);
                return;
            }
        }
*/
        if(FileChangedFlag)
        {
            UnicodeString MessageStr = "The railway has changed, exit without saving?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Utilities->CallLogPop(1180);
                return;
            }
        }
        if((TempTTFileName != "") && FileExists(TempTTFileName))
        {
            DeleteFile(TempTTFileName);
        }
        Utilities->CallLogPop(1181);
        Application->Terminate();
    }
    catch(const Exception &e)
    {
        ErrorLog(140, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::TrackInfoOnOffMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TrackInfoOnOffMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TrackInfoOnOffMenuItemClick");
        if(TrackInfoOnOffMenuItem->Caption == "Show")
        {
            TrackInfoOnOffMenuItem->Caption = "Hide";
        }
        else
        {
            TrackInfoOnOffMenuItem->Caption = "Show";
        }
        Utilities->CallLogPop(1183);
    }
    catch(const Exception &e)
    {
        ErrorLog(173, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::TrainStatusInfoOnOffMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TrainStatusInfoOnOffMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TrainStatusInfoOnOffMenuItemClick");
        if(TrainStatusInfoOnOffMenuItem->Caption == "Show Status")
        {
            TrainStatusInfoOnOffMenuItem->Caption = "Hide Status";
        }
        else
        {
            TrainStatusInfoOnOffMenuItem->Caption = "Show Status";
        }
        Utilities->CallLogPop(1184);
    }
    catch(const Exception &e)
    {
        ErrorLog(141, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TrainTTInfoOnOffMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TrainTTInfoOnOffMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TrainTTInfoOnOffMenuItemClick");
        if(TrainTTInfoOnOffMenuItem->Caption == "Show Timetable")
        {
            TrainTTInfoOnOffMenuItem->Caption = "Hide Timetable";
        }
        else
        {
            TrainTTInfoOnOffMenuItem->Caption = "Show Timetable";
        }
        Utilities->CallLogPop(1185);
    }
    catch(const Exception &e)
    {
        ErrorLog(142, e.Message);
    }
}

// ---------------------------------------------------------------------------
// Mouse Functions
// ---------------------------------------------------------------------------
void __fastcall TInterface::MainScreenMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
// caller function - stops master clock
{
// have to allow in zoom out mode
    try
    {
        AnsiString AnsiButton = "mbLeft";
        if(Button == mbRight)
        {
            AnsiButton = "mbRight";
        }

        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MainScreenMouseDown," + AnsiButton + "," + AnsiString(X) + "," + AnsiString(Y));
        bool ClockState = Utilities->Clock2Stopped;
        Utilities->Clock2Stopped = true;

        RestoreFocusPanel->Enabled = true; // these added at v2.0.0 to restore navigation keys to move screen when a panel had focus
        RestoreFocusPanel->Visible = true; // because then these buttons just cycled through the panel buttons.  Added in place of the
        RestoreFocusPanel->SetFocus(); // section in ClockTimer2 where focus restored every clock cycle, because then the help screen
        RestoreFocusPanel->Visible = false; // was hidden.  At least now help is only hidden when the screen clicked, which is normal
        RestoreFocusPanel->Enabled = false; // behaviour, and can tell user that can restore navigation keys just by clicking the screen
        MMoveTrackSelFlag = false;
        MMovePrefDirSelFlag = false;
        MMoveCopyCutSelPickedUpFlag = false;
        MMoveTextGraphicTextFoundFlag = false;
        MMoveTextGraphicUserGraphicFoundFlag = false;

        if(!Track->RouteFlashFlag && !Track->PointFlashFlag)
        {
            if(!Display->ZoomOutFlag)
            {
                MainScreenMouseDown2(0, Button, Shift, X, Y);
            }
            else
            {
                MainScreenMouseDown3(0, Button, Shift, X, Y);
            }
        }
        Utilities->Clock2Stopped = ClockState;
        Utilities->CallLogPop(33);
    }
    catch(const Exception &e)
    {
        ErrorLog(19, e.Message);
    }
}

// ---------------------------------------------------------------------------
void TInterface::MainScreenMouseDown2(int Caller, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    try
    {
        AnsiString AnsiButton = "mbLeft";
        if(Button == mbRight)
        {
            AnsiButton = "mbRight";
        }
        TrainController->LogEvent("MainScreenMouseDown2," + AnsiButton + "," + AnsiString(X) + "," + AnsiString(Y));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",MainScreenMouseDown2," + AnsiButton + "," + AnsiString(X) +
                                     "," + AnsiString(Y));
        // unplot GapFlash graphics if plotted & cancel gap flashing if left mouse button pressed (so can move display with right mouse button)
        // but not in ZoomOut mode - so can switch between modes & keep gaps flashing
        HideTTActionsListBox(0); //get rid of this for any click on screen
        if(Track->GapFlashFlag && !Display->ZoomOutFlag && (Button == mbLeft))
        {
            Track->GapFlashGreen->PlotOriginal(35, Display);
            Track->GapFlashRed->PlotOriginal(36, Display);
            Track->GapFlashFlag = false;
        }
        int HLoc, VLoc;
        Track->GetTrackLocsFromScreenPos(1, HLoc, VLoc, X, Y);
        int NoOffsetX, NoOffsetY;
        Track->GetTruePositionsFromScreenPos(0, NoOffsetX, NoOffsetY, X, Y);
        if(Button == mbRight) // track, PrefDir or text erase, PrefDir/route truncate, or take signaller control of train
        {
            // this routine new at v2.1.0.  Allows railway moving for zoom-in mode when no element at HLoc & VLoc
            int Dummy; // unused in next function
            AnsiString Text = ""; // needed for TextFound but not used
            SkipTTTrainMousePosX = X;
            SkipTTTrainMousePosY = Y;
            if(!Track->TrackElementPresentAtHV(0, HLoc, VLoc) && !Track->InactiveTrackElementPresentAtHV(0, HLoc, VLoc) && !Track->UserGraphicPresentAtHV(0, X,
                                                                                                                                                          Y, Dummy) && !TextHandler->TextFound(0, X + (Display->DisplayOffsetH * 16), Y + (Display->DisplayOffsetV * 16), Text))
            {
                StartWholeRailwayMoveHPos = X;
                StartWholeRailwayMoveVPos = Y;
                WholeRailwayMoving = true;
                Screen->Cursor = TCursor(-22); // Four arrows;
            }

            else if(Level2TrackMode == AddText)
            {
                TrainController->LogEvent("mbRight + AddText");
// ResetChangedFileDataAndCaption(, true);  moved from here after 2.7.0 in case no changes made
                if(TextHandler->TextFound(1, NoOffsetX, NoOffsetY, Text))
                {
                    if(TextHandler->TextErase(0, NoOffsetX, NoOffsetY, Text)) // erase text in vector
                    {
                        ResetChangedFileDataAndCaption(2, true); // moved to here after 2.7.0
                        ClearandRebuildRailway(4);
                        if(NoRailway())
                        {
                            EditMenu->Enabled = false;
                        }
                        else
                        {
                            EditMenu->Enabled = true;
                        }
                    }
                }
                SetLevel2TrackMode(57); // to remove 'move text' if last text item removed
                Utilities->CallLogPop(34);
                return;
            }
            else if(Level2TrackMode == AddGraphic)
            {
                TrainController->LogEvent("mbRight + AddGraphic");
                if(Track->UserGraphicVector.empty()) // no user graphics
                {
                    Utilities->CallLogPop(2180);
                    return;
                }
                int UGIVecPos;
                if(Track->UserGraphicPresentAtHV(1, X, Y, UGIVecPos))
                {
                    Track->UserGraphicVector.erase(Track->UserGraphicVector.begin() + UGIVecPos);
                    ClearandRebuildRailway(78);
                    if(NoRailway())
                    {
                        EditMenu->Enabled = false;
                    }
                    else
                    {
                        EditMenu->Enabled = true;
                    }
                }
                Utilities->CallLogPop(2181);
                return;
            }

            else if(Level2TrackMode == AddTrack)
            {
                TrainController->LogEvent("mbRight + AddTrack");
                bool TrackEraseSuccessfulFlag;
                int ErasedTrackVectorPosition;
                Screen->Cursor = TCursor(-11); // Hourglass;
                Track->EraseTrackElement(1, HLoc, VLoc, ErasedTrackVectorPosition, TrackEraseSuccessfulFlag, true);
                if(TrackEraseSuccessfulFlag)
                {
                    if(ErasedTrackVectorPosition > -1) //may have been an inactive element
                    {
                        EveryPrefDir->RealignAfterTrackErase(0, ErasedTrackVectorPosition);
                    }
                    ResetChangedFileDataAndCaption(3, true);
                    SetTrackBuildImages(9);
                    ClearandRebuildRailway(5); // to ensure location named elements plotted correctly & replot the grid if required
                    SetGapsButton->Enabled = false; // if conditions have changed need to reset buttons, best not calling SetLevel2TrackMode as that
                    TrackOKButton->Enabled = false; // calls Clearand.. if gridflag set & takes a long time
                    if(Track->GapsUnset(1))
                    {
                        SetGapsButton->Enabled = true;
                    }
                    // only enable if there are gaps still to be set (returns false for no track)
                    else
                    {
                        if(!(Track->NoActiveTrack(0)) && !(Track->IsTrackFinished()))
                        {
                            TrackOKButton->Enabled = true;
                        }
                        // TrackOK only enabled if track exists, there are no unset gaps, and track not finished
                    }
                    if(!(Track->IsTrackFinished())) // can only set lengths for several elements together if TrackFinished
                    {
                        SetLengthsButton->Enabled = false;
                    }
// if(NoRailway()) dropped at v2.6.0 to allow edits during AddTrack
// {
// EditMenu->Enabled = false;
// }
// else
                    EditMenu->Enabled = true;
                }
                Screen->Cursor = TCursor(-2); // Arrow
                Utilities->CallLogPop(35);
                return;
            }
            else if(Level2TrackMode == DistanceContinuing) // new for extended distances (similar to PrefDirContinuing)
            {
                TrainController->LogEvent("mbRight + DistanceContinuing");
// ResetChangedFileDataAndCaption(, true); dropped after 2.7.0 as may only be checking existing distances/speeds.  Moved to button clicks in TrackLengthPanel
                bool LeadingPointsAtLastElement = false;
                if(ConstructPrefDir->GetPrefDirTruncateElement(0, HLoc, VLoc))
                {
                    if(ConstructPrefDir->PrefDirSize() == 0)
                    {
                        Level1Mode = TrackMode;
                        SetLevel1Mode(64);
                        Level2TrackMode = DistanceStart;
                        SetLevel2TrackMode(51); // calls ClearandRebuildRailway to show length erased & sets back to start
                        Utilities->CallLogPop(1526);
                        return;
                    }
                    ConstructPrefDir->PrefDirMarker(1, PrefDirCall, true, Display);
                    OverallDistance = 0, OverallSpeedLimit = -1;
                    ConstructPrefDir->CalcDistanceAndSpeed(0, OverallDistance, OverallSpeedLimit, LeadingPointsAtLastElement);
                    if(!LeadingPointsAtLastElement)
                    {
                        TrackLengthPanel->Visible = true;
                        TrackLengthPanel->SetFocus();
                        InfoPanel->Visible = true;
                        InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Continue or set values (overall length), or right click to cancel/truncate";
                        RestoreAllDefaultLengthsButton->Enabled = true;
                        ResetDefaultLengthButton->Enabled = true;
                        LengthOKButton->Enabled = true;
                        DistanceBox->Text = AnsiString(OverallDistance);
                        if(OverallSpeedLimit > -1)
                        {
                            SpeedLimitBox->Text = AnsiString(OverallSpeedLimit);
                        }
                        else
                        {
                            SpeedLimitBox->Text = "Mixed";
                        }
                    }
                    else
                    {
                        TrackLengthPanel->Visible = true;
                        TrackLengthPanel->SetFocus();
                        InfoPanel->Visible = true;
                        InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Can't end on leading points, continue or truncate";
                        RestoreAllDefaultLengthsButton->Enabled = false;
                        ResetDefaultLengthButton->Enabled = false;
                        LengthOKButton->Enabled = false;
                    }
                    ClearandRebuildRailway(53);
                }
                Utilities->CallLogPop(36);
                return;
            }

            else if(Level2PrefDirMode == PrefDirContinuing) // truncate
            {
                TrainController->LogEvent("mbRight + PrefDirContinuing");
// ResetChangedFileDataAndCaption(, false);  moved to later after 2.7.0 as may not change anything
// RlyFile = false; - don't alter this just for PrefDir changes
                if(ConstructPrefDir->GetPrefDirTruncateElement(1, HLoc, VLoc))
                {
                    if(ConstructPrefDir->PrefDirSize() == 0)
                    {
                        Level1Mode = PrefDirMode;
                        SetLevel1Mode(14); // all PrefDir truncated
                        Utilities->CallLogPop(37);
                        return;
                    }
                    ConstructPrefDir->PrefDirMarker(8, PrefDirCall, true, Display);
                    ResetChangedFileDataAndCaption(5, false); // moved to here after 2.7.0
                }
                Level2PrefDirMode = PrefDirContinuing;
                SetLevel2PrefDirMode(0); // calls ClearandRebuildRailway to show length erased & sets back to start
                Utilities->CallLogPop(38);
                return;
            }

            else if((Level1Mode == PrefDirMode) && (Level2PrefDirMode != PrefDirContinuing) && (Level2PrefDirMode != PrefDirSelecting)) // delete element
            {
                TrainController->LogEvent("mbRight + != PrefDirContinuing");
                ResetChangedFileDataAndCaption(6, false);
// RlyFile = false; - don't alter this just for PrefDir changes
                EveryPrefDir->EraseFromPrefDirVectorAnd4MultiMap(0, HLoc, VLoc);
                Level1Mode = PrefDirMode;
                SetLevel1Mode(15); // calls ClearandRebuildRailway to show length erased & sets back to start
                Utilities->CallLogPop(39);
                return;
            }

            else if((Level2OperMode == Operating) || (Level2OperMode == PreStart)) // disallow when paused, but allow some parts in prestart
            {
                TrainController->LogEvent("mbRight + OperMode");
                bool FoundFlag;
                int VecPos = Track->GetVectorPositionFromTrackMap(1, HLoc, VLoc, FoundFlag);
                if(FoundFlag && (Level2OperMode != PreStart)) // disallow train popup menu in PreStart
                {
                    SelectedTrainID = Track->TrackElementAt(426, VecPos).TrainIDOnElement;
                    // display popup menu for the train
                    if(SelectedTrainID > -1)
                    {
                        TTrain &Train = TrainController->TrainVectorAtIdent(23, SelectedTrainID);
                        Train.LeavingUnderSigControlAtContinuation = false;
                        if(Train.TrainMode == Signaller)
                        {
                            if((Train.LeadElement == -1) || (Track->TrackElementAt(788, Train.LeadElement).Conn[Train.LeadExitPos] == -1)) //train front off continuation or on it
                            {
                                Train.LeavingUnderSigControlAtContinuation = true;
                            }
                            else if(!Train.Stopped() && (Track->TrackElementAt(1450, (Track->TrackElementAt(1451, Train.LeadElement).Conn[Train.LeadExitPos])).TrackType == Continuation))
                            {                                                            //added at v2.13.0 to prevent popup menu when train moving and front next to continuation
                                Train.LeavingUnderSigControlAtContinuation = true;
                            }
                        }
                        if((Train.Stopped()) || (Train.TrainFailed && !(Train.TrainMode == Signaller)) ||
                           ((Train.TrainMode == Signaller) && !Train.SignallerStoppingFlag && !Train.LeavingUnderSigControlAtContinuation &&
                            !Train.StepForwardFlag))
                        // don't allow signaller popup menu unless stopped, when failed in timetable mode, or in signaller mode provided that
                        // train isn't stopping, leaving at a continuation or stepping forward
                        {
                            // don't allow selection if another stopped train at a bridge position
                            if(Track->TrackElementAt(630, VecPos).TrackType == Bridge)
                            {
                                int TrainID01 = Track->TrackElementAt(631, VecPos).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
                                int TrainID23 = Track->TrackElementAt(632, VecPos).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
                                if((TrainID01 > -1) && (TrainID23 > -1))
                                {
                                    TrainController->StopTTClockMessage(0, "Can't select a train at a bridge when another train is at the same bridge");
                                    Utilities->CallLogPop(1103);
                                    return;
                                }
                            }
                            if(Train.TrainMode == Timetable)
                            {
                                TakeSignallerControlMenuItem->Enabled = true;
                                TakeSignallerControlMenuItem->Visible = true;
                                TimetableControlMenuItem->Enabled = false;
                                TimetableControlMenuItem->Visible = false;
                                ChangeDirectionMenuItem->Enabled = false;
                                ChangeDirectionMenuItem->Visible = false;
                                SkipTimetabledActionsMenuItem->Enabled = false;
                                SkipTimetabledActionsMenuItem->Visible = false;
                                MoveForwardsMenuItem->Enabled = false;
                                MoveForwardsMenuItem->Visible = false;
                                SignallerJoinedByMenuItem->Enabled = false;
                                SignallerJoinedByMenuItem->Visible = false;
                                RepairFailedTrainMenuItem->Enabled = false;
                                RepairFailedTrainMenuItem->Visible = false;
                                StepForwardMenuItem->Enabled = false;
                                StepForwardMenuItem->Visible = false;
                                RemoveTrainMenuItem->Enabled = false;
                                RemoveTrainMenuItem->Visible = false;
                                PassRedSignalMenuItem->Enabled = false;
                                PassRedSignalMenuItem->Visible = false;
                                SignallerControlStopMenuItem->Enabled = false;
                                SignallerControlStopMenuItem->Visible = false;
                                if((Train.StoppedAtSignal || Train.StoppedAtLocation) && !Train.ActionsSkippedFlag) //Exclude TreatPassAsTimeLocDeparture, otherwise skipping
                                {                                                                                   //events causes problems that are best avoided
                                    SkipTimetabledActionsMenuItem->Enabled = true;
                                    SkipTimetabledActionsMenuItem->Visible = true;
                                }
                                BecomeNewServiceMenuItem->Enabled = false;
                                BecomeNewServiceMenuItem->Visible = false;
                                if(IsBecomeNewServiceAvailable(0, SelectedTrainID, Train.FollowOnServiceRef))
                                {
                                    BecomeNewServiceMenuItem->Enabled = true;
                                    BecomeNewServiceMenuItem->Visible = true;
                                }
                            }
                            else // signaller mode
                            {
                                TakeSignallerControlMenuItem->Enabled = false;
                                TakeSignallerControlMenuItem->Visible = false;
                                SkipTimetabledActionsMenuItem->Enabled = false;
                                SkipTimetabledActionsMenuItem->Visible = false;
                                BecomeNewServiceMenuItem->Enabled = false;
                                BecomeNewServiceMenuItem->Visible = false;
                                if((Train.Crashed) || (Train.Derailed))
                                {
                                    TimetableControlMenuItem->Enabled = false;
                                    TimetableControlMenuItem->Visible = false;
                                    ChangeDirectionMenuItem->Enabled = false;
                                    ChangeDirectionMenuItem->Visible = false;
                                    MoveForwardsMenuItem->Enabled = false;
                                    MoveForwardsMenuItem->Visible = false;
                                    SignallerJoinedByMenuItem->Enabled = false;
                                    SignallerJoinedByMenuItem->Visible = false;
                                    RepairFailedTrainMenuItem->Enabled = false;
                                    RepairFailedTrainMenuItem->Visible = false;
                                    StepForwardMenuItem->Enabled = false;
                                    StepForwardMenuItem->Visible = false;
                                    PassRedSignalMenuItem->Enabled = false;
                                    PassRedSignalMenuItem->Visible = false;
                                    SignallerControlStopMenuItem->Enabled = false;
                                    SignallerControlStopMenuItem->Visible = false;
                                    RemoveTrainMenuItem->Enabled = true;
                                    RemoveTrainMenuItem->Visible = true;
                                }
                                else if(Train.Stopped())
                                {
                                    if(Train.TimetableFinished)
                                    {
                                        TimetableControlMenuItem->Enabled = false;
                                        TimetableControlMenuItem->Visible = false;
                                    }
                                    else
                                    {
                                        if(Train.RestoreTimetableLocation == "") // en route
                                        {
                                            TimetableControlMenuItem->Enabled = true;
                                            TimetableControlMenuItem->Visible = true;
                                        }
                                        else
                                        {
                                            // obtain train location & check if OK for restoration of tt control
                                            AnsiString LocName = "";
                                            if(Train.LeadElement > -1)
                                            {
                                                LocName = Track->TrackElementAt(802, Train.LeadElement).ActiveTrackElementName;
                                            }
                                            if((LocName == "") && (Train.MidElement > -1))
                                            {
                                                LocName = Track->TrackElementAt(803, Train.MidElement).ActiveTrackElementName;
                                            }
                                            if(Train.RestoreTimetableLocation == LocName)
                                            {
                                                TimetableControlMenuItem->Enabled = true;
                                                TimetableControlMenuItem->Visible = true;
                                            }
                                            else
                                            {
                                                TimetableControlMenuItem->Enabled = false;
                                                TimetableControlMenuItem->Visible = false;
                                            }
                                        }
                                    }
// don't allow ChangeDirection if lead or mid elements (but not lag or next) -1, or lead, mid, lag or next elements continuations
                                    ChangeDirectionMenuItem->Enabled = true;
                                    ChangeDirectionMenuItem->Visible = true;
                                    if(Train.LeadElement > -1)
                                    {
                                        if(Track->TrackElementAt(794, Train.LeadElement).TrackType == Continuation)
                                        {
                                            ChangeDirectionMenuItem->Enabled = false;
                                            ChangeDirectionMenuItem->Visible = false;
                                        }
/* drop this at v2.12.0, allow cdt for train stopped & leadelement next to exit continuation
                                        if(Track->TrackElementAt(, Train.LeadElement).Conn[Train.LeadExitPos] > -1)
                                        {
                                            if(Track->TrackElementAt(, (Track->TrackElementAt(, Train.LeadElement).Conn[Train.LeadExitPos])).TrackType == Continuation)
                                            {
                                                ChangeDirectionMenuItem->Enabled = false;
                                                ChangeDirectionMenuItem->Visible = false;
                                            }
                                        }
*/
                                    }
                                    else
                                    {
                                        ChangeDirectionMenuItem->Enabled = false;
                                        ChangeDirectionMenuItem->Visible = false;
                                    }
                                    if(Train.MidElement > -1) //entering or exiting at a continuation
                                    {
                                        if(Track->TrackElementAt(795, Train.MidElement).TrackType == Continuation)
                                        {
                                            ChangeDirectionMenuItem->Enabled = false;
                                            ChangeDirectionMenuItem->Visible = false;
                                        }
                                    }
                                    else
                                    {
                                        ChangeDirectionMenuItem->Enabled = false;
                                        ChangeDirectionMenuItem->Visible = false;
                                    }
                                    if(Train.LagElement > -1)
                                    {
                                        if(Track->TrackElementAt(796, Train.LagElement).TrackType == Continuation)
                                        {
                                            ChangeDirectionMenuItem->Enabled = false;
                                            ChangeDirectionMenuItem->Visible = false;
                                        }
                                    }
                                    RemoveTrainMenuItem->Enabled = true;
                                    RemoveTrainMenuItem->Visible = true;
                                    SignallerControlStopMenuItem->Enabled = false;
                                    SignallerControlStopMenuItem->Visible = false;
                                    SignallerJoinedByMenuItem->Enabled = false;
                                    SignallerJoinedByMenuItem->Visible = false;
                                    RepairFailedTrainMenuItem->Enabled = false;
                                    RepairFailedTrainMenuItem->Visible = false;
                                    StepForwardMenuItem->Enabled = false;
                                    StepForwardMenuItem->Visible = false;
                                    MoveForwardsMenuItem->Enabled = false;
                                    MoveForwardsMenuItem->Visible = false;
                                    PassRedSignalMenuItem->Enabled = false;
                                    PassRedSignalMenuItem->Visible = false;
                                    if(Train.AbleToMove(0) && !Train.TreatPassAsTimeLocDeparture) //TreatPassAsTimeLocDeparture added at v2.12.0 to prevent signaller movements
                                    {                                                             //for 'pseudo' TimeLoc departures
                                        MoveForwardsMenuItem->Enabled = true;
                                        MoveForwardsMenuItem->Visible = true;
                                        if((!Train.LeavingUnderSigControlAtContinuation) && (Track->TrackElementAt(791, Train.LeadElement).Conn[Train.LeadExitPos] > -1))
                                        {   //added check for adjacent element not being a continuation at v2.12.0 as dont allow step forward as wouldn't stop
                                            if(Track->TrackElementAt(792, (Track->TrackElementAt(793, Train.LeadElement).Conn[Train.LeadExitPos])).TrackType != Continuation)
                                            {
                                             StepForwardMenuItem->Enabled = true; // added 'if' condition for v1.3.2 due to Carwyn Thomas error,
                                             StepForwardMenuItem->Visible = true;
                                            }
                                        }
                                    } // fails on trying to calc AutoSig time delay for resetting signals

                                    if(Train.AbleToMoveButForSignal(0) && !Train.TreatPassAsTimeLocDeparture) // may not be in AutoSigs route but disallow anyway as not needed at continuation
                                    {                                                                         //TreatPassAsTimeLocDeparture addesd at v2.12.0 as above
                                        PassRedSignalMenuItem->Enabled = true;
                                        PassRedSignalMenuItem->Visible = true;
                                        StepForwardMenuItem->Enabled = true;
                                        StepForwardMenuItem->Visible = true;
                                    }
                                    TTrain *AdjacentTrain;
                                    if(Train.IsThereAnAdjacentTrain(0, AdjacentTrain))
                                    {
                                        SignallerJoinedByMenuItem->Enabled = true;
                                        SignallerJoinedByMenuItem->Visible = true;
                                    }
                                    if(Train.TrainFailed)
                                    {
                                        RepairFailedTrainMenuItem->Enabled = true;
                                        RepairFailedTrainMenuItem->Visible = true;
                                    }
                                }
                                else // train moving under signaller control - only permit restoration of TT control when stopped as could be in
                                     // mid move, & SetTrainMovementValues only intended to be called when stopped
                                {
                                    TimetableControlMenuItem->Enabled = false;
                                    TimetableControlMenuItem->Visible = false;
                                    ChangeDirectionMenuItem->Enabled = false;
                                    ChangeDirectionMenuItem->Visible = false;
                                    RemoveTrainMenuItem->Enabled = false;
                                    RemoveTrainMenuItem->Visible = false;
                                    MoveForwardsMenuItem->Enabled = false;
                                    MoveForwardsMenuItem->Visible = false;
                                    SignallerJoinedByMenuItem->Enabled = false;
                                    SignallerJoinedByMenuItem->Visible = false;
                                    RepairFailedTrainMenuItem->Enabled = false;
                                    RepairFailedTrainMenuItem->Visible = false;
                                    PassRedSignalMenuItem->Enabled = false;
                                    PassRedSignalMenuItem->Visible = false;
                                    StepForwardMenuItem->Enabled = false;
                                    StepForwardMenuItem->Visible = false;
                                    SignallerControlStopMenuItem->Enabled = true;
                                    SignallerControlStopMenuItem->Visible = true;
                                }
                            }
                            TrainHeadCodeMenuItem->Caption = Train.HeadCode + ":";
                            BecomeNewServiceMenuItem->Caption = "Terminate here and become follow-on service " + Train.FollowOnServiceRef;    //added at v2.12.0
                            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
                            TrainController->RestartTime = TrainController->TTClockTime;
                            PopupMenu->Popup(MainScreen->Left + X, MainScreen->Top + Y + 43); // menu stops everything so reset timetable time when restarts,
                            // new at v2.6.1, displays so that can't inadvertently click on a selection if click twice
                            // 43 is the distance from the top of the screen to the top of TInterface
                            TrainController->BaseTime = TDateTime::CurrentDateTime();
                            TrainController->StopTTClockFlag = false;
                            Utilities->CallLogPop(40);
                            return;
                        }
                    }
                }
                if(RouteMode == RouteContinuing) // clear a single element (clears whether use left or right mouse button) +allow in PreStart
                {
                    TrainController->LogEvent("mbRight + RouteContinuing");
                    RevertToOriginalRouteSelector(0);
                    Utilities->CallLogPop(41);
                    return;
                }

                else if(RouteCancelFlag) // allow in PreStart
                {
                    TrainController->LogEvent("mbRight + RouteCancelFlag");
                    Screen->Cursor = TCursor(-11); // Hourglass;
                    // stop clock as sometimes takes several seconds
                    TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
                    TrainController->RestartTime = TrainController->TTClockTime;
                    if(AllRoutes->SearchAllRoutesAndTruncate(0, HLoc, VLoc, PreferredRoute)) // updates LockedRouteClass
                    {
                        ClearandRebuildRailway(6); // to replot new shorter route
                    }
                    RevertToOriginalRouteSelector(1);
                    TrainController->BaseTime = TDateTime::CurrentDateTime();
                    TrainController->StopTTClockFlag = false;
                    Screen->Cursor = TCursor(-2); // Arrow
                }

                else // gap flashing, don't allow to interfere with RouteCancelFlag
                {
                    TrainController->LogEvent("mbRight, GapFlashingInOperOrPreStartMode");
                    int Position;
                    TTrackElement TrackElement;
                    if(Track->FindNonPlatformMatch(4, HLoc, VLoc, Position, TrackElement))
                    {
                        ;
                    }
                    {
                        if((TrackElement.TrackType == GapJump) && (TrackElement.Conn[0] > -1))
                        {
                            if((TrackElement.TrainIDOnElement == -1) && (Track->TrackElementAt(818, TrackElement.Conn[0]).TrainIDOnElement == -1))
                            {
                                // don't flash if train on either gap element
                                Track->GapFlashGreenPosition = TrackElement.Conn[0];
                                Track->GapFlashGreen->SetScreenHVSource(5, Track->TrackElementAt(434, Track->GapFlashGreenPosition).HLoc * 16,
                                                                        Track->TrackElementAt(435, Track->GapFlashGreenPosition).VLoc * 16);
                                Track->GapFlashGreen->LoadOriginalExistingGraphic(1, 4, 4, 8, 8,
                                                                                  Track->TrackElementAt(436, Track->GapFlashGreenPosition).GraphicPtr);
                                Track->GapFlashRedPosition = Position;
                                Track->GapFlashRed->SetScreenHVSource(6, Track->TrackElementAt(437, Track->GapFlashRedPosition).HLoc * 16,
                                                                      Track->TrackElementAt(438, Track->GapFlashRedPosition).VLoc * 16);
                                Track->GapFlashRed->LoadOriginalExistingGraphic(2, 4, 4, 8, 8,
                                                                                Track->TrackElementAt(439, Track->GapFlashRedPosition).GraphicPtr);
                                Track->GapFlashFlag = true;
                            }
                        }
                    }
                    Utilities->CallLogPop(42);
                    return; // covers above else & included here in case any more usermodes added later
                }
            }
            // deal with gap selection - if no other right button selection - apply for any mode (also included in OperMode above)
            TrainController->LogEvent("mbRight, GapFlashingNotOperOrPreStartMode");
            int Position;
            TTrackElement TrackElement;
            if(Track->FindNonPlatformMatch(18, HLoc, VLoc, Position, TrackElement))
            {
                ;
            }
            {
                if((TrackElement.TrackType == GapJump) && (TrackElement.Conn[0] > -1))
                {
                    if((TrackElement.TrainIDOnElement == -1) && (Track->TrackElementAt(819, TrackElement.Conn[0]).TrainIDOnElement == -1))
                    {
                        // don't flash if train on either gap element
                        Track->GapFlashGreenPosition = TrackElement.Conn[0];
                        Track->GapFlashGreen->SetScreenHVSource(7, Track->TrackElementAt(806, Track->GapFlashGreenPosition).HLoc * 16,
                                                                Track->TrackElementAt(807, Track->GapFlashGreenPosition).VLoc * 16);
                        Track->GapFlashGreen->LoadOriginalExistingGraphic(3, 4, 4, 8, 8, Track->TrackElementAt(808, Track->GapFlashGreenPosition).GraphicPtr);
                        Track->GapFlashRedPosition = Position;
                        Track->GapFlashRed->SetScreenHVSource(8, Track->TrackElementAt(809, Track->GapFlashRedPosition).HLoc * 16,
                                                              Track->TrackElementAt(810, Track->GapFlashRedPosition).VLoc * 16);
                        Track->GapFlashRed->LoadOriginalExistingGraphic(4, 4, 4, 8, 8, Track->TrackElementAt(811, Track->GapFlashRedPosition).GraphicPtr);
                        Track->GapFlashFlag = true;
                    }
                }
            }
            Utilities->CallLogPop(67);
            return; // covers above else & included here in case any more usermodes added later
        }

// Left Mouse Button Functions
        if(RouteCancelFlag)
        {
            RevertToOriginalRouteSelector(2);
        }
        mbLeftDown = true;

        if(Level2TrackMode == AddTrack)
        {
            TrainController->LogEvent("mbLeft + AddTrack");
            Screen->Cursor = TCursor(-11); // Hourglass;
            ResetChangedFileDataAndCaption(7, true);
            bool TrackLinkingRequiredFlag;
            int CurrentTag;
            TSpeedButton *TempSpeedButton = 0;
            if(CurrentSpeedButton)
            {
                CurrentTag = CurrentSpeedButton->Tag;
                TempSpeedButton = CurrentSpeedButton;
            }
            else
            {
                CurrentTag = 0;
            }
            bool InternalChecks = true;
            Track->PlotAndAddTrackElement(1, CurrentTag, 0, HLoc, VLoc, TrackLinkingRequiredFlag, InternalChecks);
            // above now has extra zero 'Aspect' parameter at v2.2.0 so can distinguish between adding track and pasting
            EditMenu->Enabled = true;
            if(Track->NamedLocationElementAt(1, HLoc, VLoc))
            {
                ClearandRebuildRailway(7); // so named location graphics plotted correctly
            }
            if(TrackLinkingRequiredFlag)
            {
                Track->SetTrackFinished(false);
            }
            SetTrackBuildImages(10);
            SetGapsButton->Enabled = false; // if conditions have changed need to reset buttons, best not calling SetLevel2TrackMode as that
            TrackOKButton->Enabled = false; // calls Clearand.. if gridflag set & takes a long time
            if(Track->GapsUnset(2))
            {
                SetGapsButton->Enabled = true;
            }
            // only enable if there are gaps still to be set (returns false for no track)
            else
            {
                if(!(Track->NoActiveTrack(1)) && !(Track->IsTrackFinished()))
                {
                    TrackOKButton->Enabled = true;
                }
                // TrackOK only enabled if track exists, there are no unset gaps, and track not finished
            }
            if(!(Track->IsTrackFinished())) // can only set lengths for several elements together if TrackFinished
            {
                SetLengthsButton->Enabled = false;
            }
            if(TempSpeedButton) // restore button if was pressed
            {
                CurrentSpeedButton = TempSpeedButton;
                CurrentSpeedButton->Down = true;
            }
            Screen->Cursor = TCursor(-2); // Arrow
            Utilities->CallLogPop(44);
            return;
        }

        else if(Level2TrackMode == AddGraphic)
        {
            TrainController->LogEvent("mbLeft + AddGraphic");
// ResetChangedFileDataAndCaption(, false); //moved to later after 2.7.0 in case can't find it
            TUserGraphicItem NewGI;
            TTrack::TUserGraphicMap::iterator UGMIt = Track->UserGraphicMap.find(SelectedGraphicFileName);
            if(UGMIt != Track->UserGraphicMap.end()) // if it is the end then nothing was found
            {
                NewGI.UserGraphic = UGMIt->second;
                NewGI.Width = UGMIt->second->Width;
                NewGI.Height = UGMIt->second->Height;
                NewGI.FileName = SelectedGraphicFileName;
                NewGI.HPos = X + (Display->DisplayOffsetH * 16);
                NewGI.VPos = Y + (Display->DisplayOffsetV * 16);
                Track->UserGraphicVector.push_back(NewGI);
                Display->PlotAndAddUserGraphic(1, NewGI);
                ResetChangedFileDataAndCaption(24, false); // moved to here after 2.7.0
            }
            else
            {
                ShowMessage("Unable to find graphic file " + SelectedGraphicFileName + ". Check it still exists.");
                Utilities->CallLogPop(2195);
                return;
            }
            MoveTextOrGraphicButton->Enabled = true;
            EditMenu->Enabled = true;
            Utilities->CallLogPop(2182);
            return;
        }

        else if(Level2TrackMode == AddLocationName)
        {
            TrainController->LogEvent("mbLeft + AddLocationName");
// ResetChangedFileDataAndCaption(, true); moved after 2.7.0 to LocationNameKeyUp in case nothing changed
            bool FoundFlag;
            TTrackElement TrackElement;
            AnsiString NameString;
            TTrack::TIMPair InactivePair = Track->GetVectorPositionsFromInactiveTrackMap(1, HLoc, VLoc, FoundFlag);
            if(!FoundFlag)
            {
                Utilities->CallLogPop(45);
                return; // inactive element not found (has to be a platform or named non-station location, can't select any other element)
            }
            TTrackElement& InactiveTrackElement1 = Track->InactiveTrackElementAt(28, InactivePair.first);
            TTrackElement& InactiveTrackElement2 = Track->InactiveTrackElementAt(29, InactivePair.second); // may be same element if only 1
            TTrackElement& ValidElement = InactiveTrackElement1;
            unsigned int ValidPosition;
            if((InactiveTrackElement1.TrackType != Platform) && (InactiveTrackElement2.TrackType != Platform) &&
               (InactiveTrackElement1.TrackType != NamedNonStationLocation) && (InactiveTrackElement2.TrackType != NamedNonStationLocation) &&
               (InactiveTrackElement1.TrackType != Concourse) && (InactiveTrackElement2.TrackType != Concourse))
            {
                Utilities->CallLogPop(46);
                return; // element not valid
            }
            if((InactiveTrackElement1.TrackType == Platform) || (InactiveTrackElement1.TrackType == NamedNonStationLocation) ||
               (InactiveTrackElement1.TrackType == Concourse))
            {
                ValidElement = InactiveTrackElement1;
                ValidPosition = InactivePair.first;
            }
            else if((InactiveTrackElement2.TrackType == Platform) || (InactiveTrackElement2.TrackType == NamedNonStationLocation) ||
                    (InactiveTrackElement2.TrackType == Concourse))
            {
                ValidElement = InactiveTrackElement2;
                ValidPosition = InactivePair.second;
            }
            // now have required element as ValidElement & position in InactiveTrackvector as ValidPosition

            // put a square box round element to show selection
            Display->Rectangle(0, HLoc * 16, VLoc * 16, clB0G0R5, 0, 2);
            LocationNameTextBox->Visible = true;
            LocationNameTextBox->SetFocus();
            NameString = Track->GetLocationName(ValidPosition);
            LocationNameTextBox->Text = NameString;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "NAMING LOCATIONS:  Enter name, 'Carriage Return' to accept, 'Escape' to quit";

            Track->LNPendingList.clear();
            Track->LNPendingList.insert(Track->LNPendingList.end(), ValidPosition);
            Level2TrackMode = NoTrackMode; // if leave as AddLocationName can select other squares before enter name
            Utilities->CallLogPop(47);
            return;
        }

        else if(Level2TrackMode == DistanceStart) // new for extended distances - similar to !PrefDirContinuing
                                                  // prior to selecting start element
        {
            TrainController->LogEvent("mbLeft + DistanceStart");
// ResetChangedFileDataAndCaption(, true);  dropped after 2.7.0 in case only checking, moved to buttons in TracklengthPanel
            if(ConstructPrefDir->GetPrefDirStartElement(0, HLoc, VLoc))
            {
                ConstructPrefDir->PrefDirMarker(9, PrefDirCall, true, Display);
                Level1Mode = TrackMode;
                SetLevel1Mode(65);
                Level2TrackMode = DistanceContinuing;
                SetLevel2TrackMode(30);
            }
            Utilities->CallLogPop(48);
            return;
        }

        else if(Level2TrackMode == DistanceContinuing) // new for extended distances - similar to PrefDirContinuing
                                                       // prior to selecting finish element
        {
            TrainController->LogEvent("mbLeft + DistanceContinuing");
// ResetChangedFileDataAndCaption(, true);   dropped after 2.7.0 in case only checking, moved to buttons in TracklengthPanel
            bool FinishElement = false, LeadingPointsAtLastElement = false;
            Screen->Cursor = TCursor(-11); // Hourglass;
            if((ConstructPrefDir->PrefDirSize() != 1) || (ConstructPrefDir->GetFixedPrefDirElementAt(181, 0).HLoc != HLoc) ||
               (ConstructPrefDir->GetFixedPrefDirElementAt(182, 0).VLoc != VLoc))
            {
                // not same as start element
                if(ConstructPrefDir->GetNextPrefDirElement(0, HLoc, VLoc, FinishElement))
                {
                    ConstructPrefDir->PrefDirMarker(3, PrefDirCall, true, Display);
                    OverallDistance = 0, OverallSpeedLimit = -1;
                    ConstructPrefDir->CalcDistanceAndSpeed(1, OverallDistance, OverallSpeedLimit, LeadingPointsAtLastElement);
                    /*drop this condition as don't want to finish automatically because may have found an inappropriate path, changed at v2.13.0
                    if(FinishElement)
                    {
                        TrackLengthPanel->Visible = true;
                        TrackLengthPanel->SetFocus();
                        InfoPanel->Visible = true;
                        InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Set values (overall length), or right click to cancel/truncate";
                        RestoreAllDefaultLengthsButton->Enabled = true;
                        ResetDefaultLengthButton->Enabled = true;
                        LengthOKButton->Enabled = true;
                        DistanceBox->Text = AnsiString(OverallDistance);
                        if(OverallSpeedLimit > -1)
                        {
                            SpeedLimitBox->Text = AnsiString(OverallSpeedLimit);
                        }
                        else
                        {
                            SpeedLimitBox->Text = "Mixed";
                        }
                        ClearandRebuildRailway(52);
                        Screen->Cursor = TCursor(-2); // Arrow
                        Utilities->CallLogPop(1527);
                        return;
                    } */
//                    else
                    {
                        if(!LeadingPointsAtLastElement)
                        {
                            TrackLengthPanel->Visible = true;
                            TrackLengthPanel->SetFocus();
                            InfoPanel->Visible = true;
                            InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Continue or set values (overall length), or right click to cancel/truncate";
                            RestoreAllDefaultLengthsButton->Enabled = true;
                            ResetDefaultLengthButton->Enabled = true;
                            LengthOKButton->Enabled = true;
                            DistanceBox->Text = AnsiString(OverallDistance);
                            if(OverallSpeedLimit > -1)
                            {
                                SpeedLimitBox->Text = AnsiString(OverallSpeedLimit);
                            }
                            else
                            {
                                SpeedLimitBox->Text = "Mixed";
                            }
                            // Level2TrackMode = DistanceContinuing;
                            // SetLevel2TrackMode();
                        }
                        else
                        {
                            TrackLengthPanel->Visible = true;
                            TrackLengthPanel->SetFocus();
                            InfoPanel->Visible = true;
                            InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Can't end on leading points, need to continue or truncate";
                            RestoreAllDefaultLengthsButton->Enabled = false;
                            ResetDefaultLengthButton->Enabled = false;
                            LengthOKButton->Enabled = false;
                            // Level2TrackMode = DistanceContinuing;
                            // SetLevel2TrackMode();
                        }
                    }
                }
            }
            else // same as start element
            {
                ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
                Level2TrackMode = DistanceStart;
                SetLevel2TrackMode(54);
                Screen->Cursor = TCursor(-2); // Arrow
                Utilities->CallLogPop(1713);
                return;
            }
            ClearandRebuildRailway(51);
            Screen->Cursor = TCursor(-2); // Arrow
            Utilities->CallLogPop(1490);
            return;
        }

        else if(Level2TrackMode == GapSetting)
        {
            TrainController->LogEvent("mbLeft + GapSetting");
// ResetChangedFileDataAndCaption(, true);  moved to later after 2.7.0 in case can't set it
            // HighLightOneGap already called once from SetLevel2TrackMode so have all gap element values set
            // & it is highlighted
            if(!(Track->FindSetAndDisplayMatchingGap(1, HLoc, VLoc)))
            {
                Utilities->CallLogPop(50);
                return; // true if finds one
            }
            ResetChangedFileDataAndCaption(11, true); // moved to here after 2.7.0 in case can't set it
            InfoPanel->Visible = true;
            InfoPanel->Caption = "CONNECTING GAPS:  Connecting element selected";
            Display->Update(); // resurrected when Update() dropped from PlotOutput etc
            Delay(0, 500); // 500 msec delay before next selection requested

            // ClearandRebuildRailway(8);//get rid of gap selections
            // need to call this later when new gap displayed, else old gap remains

            // now back to highlighting next gap
            // bool LocError = false;
            if(!(HighLightOneGap(1, HLoc, VLoc)))
            {
                // all gaps set
                ShowMessage("All gaps set");
                if(Level2TrackMode == AddTrack)
                {
                    Level1Mode = TrackMode;
                    SetLevel1Mode(66);
                    SetLevel2TrackMode(31);
                }
                else
                {
                    Level1Mode = TrackMode;
                    SetLevel1Mode(37);
                }
                ClearandRebuildRailway(9); // get rid of last gap ellipse
                Utilities->CallLogPop(51);
                return;
            }
            // here if one gap highlighted so return to user to allow corresponding gap to be selected
            // by another call to MainScreenMouseDown
        }

        else if(Level2TrackMode == AddText)
        {
            TrainController->LogEvent("mbLeft + AddText");
// ResetChangedFileDataAndCaption(, true); moved after 2.7.0 to TextBoxKeyPress in case nothing changed
            // X & Y are relative to Display output, but TextBox is placed relative to Form
            // if mouse position on first character of an existing piece of text reload it into the editor

            bool TextFoundFlag = false;
            int TrueX = 0, TrueY = 0;
            AnsiString ExistingText = "";
            TTextHandler::TTextVectorIterator TextPtr;
            TFont *ExistingTextFont = new TFont;
            int ExistingTextHPos = 0, ExistingTextVPos = 0;
            Track->GetTruePositionsFromScreenPos(1, TrueX, TrueY, X, Y);
            if(!TextHandler->TextVector.empty())
            {
                for(TextPtr = (TextHandler->TextVector.end() - 1); TextPtr >= TextHandler->TextVector.begin(); TextPtr--)
                {
                    if((TrueX >= TextPtr->HPos) && (TrueX < (TextPtr->HPos + abs(TextPtr->Font->Height))) && (TrueY >= TextPtr->VPos) && (TrueY <
                                                                                                                                          (TextPtr->VPos + abs(TextPtr->Font->Height))))
                    {
                        ExistingText = TextPtr->TextString;
                        ExistingTextFont->Assign(TextPtr->Font);
                        ExistingTextHPos = TextPtr->HPos;
                        ExistingTextVPos = TextPtr->VPos;
                        TextFoundFlag = true;
                        TextHandler->TextErase(9, TrueX, TrueY, ExistingText);
                        break;
                    } // if ....

                } // for TextPtr...
            } // if !TextVector...

            if(TextFoundFlag)
            {
                TextBox->Left = ExistingTextHPos + Display->Left() - (Display->DisplayOffsetH * 16) - 3;
                TextBox->Top = ExistingTextVPos + Display->Top() - (Display->DisplayOffsetV * 16) - 3;
                TextBox->Font->Assign(ExistingTextFont);
                Display->SetFont(ExistingTextFont);
                Text_X = ExistingTextHPos;
                Text_Y = ExistingTextVPos;
            }
            else
            {
                TextBox->Left = (TextOrUserGraphicGridVal * div((Display->Left() + X), TextOrUserGraphicGridVal).quot) - 3;
                TextBox->Top = (TextOrUserGraphicGridVal * div((Display->Top() + Y), TextOrUserGraphicGridVal).quot) - 3;
                TextBox->Font->Assign(Display->GetFont());
                Text_X = TextOrUserGraphicGridVal * div(NoOffsetX, TextOrUserGraphicGridVal).quot;
                Text_Y = TextOrUserGraphicGridVal * div(NoOffsetY, TextOrUserGraphicGridVal).quot;
            }
            TextBox->Visible = true;
            TextBox->SetFocus();
            if(TextFoundFlag)
            {
                TextBox->Text = ExistingText;
            }
            else
            {
                TextBox->Text = "New Text: CR=end, ESC=quit";
            }
            TextBox->Width = (abs(TextBox->Font->Height) * TextBox->Text.Length() * 0.7);
            TextBox->SelectAll();
            delete ExistingTextFont;
            ClearandRebuildRailway(29); // to remove old text if replaced
            Level2TrackMode = AddText;
            Utilities->CallLogPop(1775);
            return; // If text input go no further
        }

        else if(Level2TrackMode == MoveTextOrGraphic)
        {
            TrainController->LogEvent("mbLeft + MoveTextOrGraphic");
// ResetChangedFileDataAndCaption(, true); moved after 2.7.0 to later in case nothing found
            // int HPosInput;// = X + (Display->DisplayOffsetH * 16);
            // int VPosInput;// = Y + (Display->DisplayOffsetV * 16);
            // Track->GetTruePositionsFromScreenPos(HPosInput, VPosInput, X, Y);
            // StartX = X + (Display->DisplayOffsetH * 16);
            // StartY = Y + (Display->DisplayOffsetV * 16);
            Track->GetTruePositionsFromScreenPos(2, StartX, StartY, X, Y);
            TextHandler->TextMove(0, StartX, StartY, TextItem, TextMoveHPos, TextMoveVPos, TextFoundFlag);
            if(!TextFoundFlag) // give precedence to text
            {
                Track->UserGraphicMove(0, StartX, StartY, UserGraphicVectorNumber, UserGraphicMoveHPos, UserGraphicMoveVPos, UserGraphicFoundFlag);
                if(UserGraphicFoundFlag)
                {
                    ResetChangedFileDataAndCaption(13, true); // moved here after 2.7.0 to save only if something found
                }
            }
            else
            {
                ResetChangedFileDataAndCaption(27, true); // and here
            }
            Utilities->CallLogPop(53);
            return; // if text move selected don't permit anything else
        }

        else if(Level2TrackMode == TrackSelecting)
        /* When 'select' chosen from the Edit menu (only available in 'AddTrack') conditions are set ready to enclose a rectangular screen area
                   using MouseMove.  When MouseDown occurs the starting point is marked (wrt whole railway, not just the screen) and stored in
                   SelectStartPair.  If the mouse button is released and a new start position selected then the earlier one is discarded.  Providing the
                   button is held down subsequent actions occur during MouseMove (to display the changing rectangle) and MouseUp to define the final
                   selected rectangle.
        */
        {
            TrainController->LogEvent("mbLeft + TrackSelecting");
            ClearandRebuildRailway(10); // to get rid of earlier rectangles
            SelectStartPair.first = HLoc;
            SelectStartPair.second = VLoc;
        }

        else if((Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving))
        /* The same actions apply on MouseDown whether Copy or Cut selected from the menu.  First the horizontal and vertical mouse position is
                   checked and unless it lies within the selected rectangle and not within 4 pixels of an edge the pickup fails and the function returns.
                   Otherwise flag SelectPickedUp is set to true (to allow it to move during MouseMove and remain in place at MouseUp) and the mouse position
                   is saved in SelectBitmapMouseLocX & Y for use later in MouseMove & MouseUp.
        */
        {
            TrainController->LogEvent("mbLeft + CopyMoving or CutMoving");
// ResetChangedFileDataAndCaption(, true);  moved after 2.7.0 to later in case don't proceed
            if((X < ((SelectBitmapHLoc - Display->DisplayOffsetH) * 16) + 4) ||
               (X > ((SelectBitmapHLoc + (SelectBitmap->Width / 16) - Display->DisplayOffsetH) * 16) - 4))
            {
                SelectPickedUp = false;
                Utilities->CallLogPop(54);
                return; // within 4 pixels of outside of horizontal area (4 pixels are so can't push selection off edge of screen)
            }
            if((Y < ((SelectBitmapVLoc - Display->DisplayOffsetV) * 16) + 4) ||
               (Y > ((SelectBitmapVLoc + (SelectBitmap->Height / 16) - Display->DisplayOffsetV) * 16) - 4))
            {
                SelectPickedUp = false;
                Utilities->CallLogPop(55);
                return; // within 4 pixels of outside of vertical area (4 pixels are so can't push selection off edge of screen)
            }
            else
            {
                SelectPickedUp = true;
            }
            ResetChangedFileDataAndCaption(14, true); // moved here after 2.7.0 in case don't proceed
            SelectBitmapMouseLocX = X;
            SelectBitmapMouseLocY = Y;
        }

        else if((Level1Mode == PrefDirMode) && (Level2PrefDirMode != PrefDirContinuing) && (Level2PrefDirMode != PrefDirSelecting))
        {
            TrainController->LogEvent("mbLeft + != PrefDirContinuing");
// ResetChangedFileDataAndCaption(, false); //moved after 2.7.0 to later in case don't click on element
// RlyFile = false; - don't alter this just for PrefDir changes
            if(ConstructPrefDir->GetPrefDirStartElement(1, HLoc, VLoc))
            {
                ResetChangedFileDataAndCaption(15, false); // moved after 2.7.0 to here
                ConstructPrefDir->PrefDirMarker(2, PrefDirCall, true, Display);
                Level2PrefDirMode = PrefDirContinuing;
                SetLevel2PrefDirMode(1);
            }
            Utilities->CallLogPop(56);
            return;
        }

        else if(Level2PrefDirMode == PrefDirContinuing)
        {
            TrainController->LogEvent("mbLeft + PrefDirContinuing");
// ResetChangedFileDataAndCaption(, false);  //moved after 2.7.0 to later in case don't click on element
// RlyFile = false; - don't alter this just for PrefDir changes
            bool FinishElement;
            Screen->Cursor = TCursor(-11); // Hourglass;
            if((ConstructPrefDir->PrefDirSize() != 1) || (ConstructPrefDir->GetFixedPrefDirElementAt(183, 0).HLoc != HLoc) ||
               (ConstructPrefDir->GetFixedPrefDirElementAt(184, 0).VLoc != VLoc))
            {
                // not same as start element
                if(ConstructPrefDir->GetNextPrefDirElement(1, HLoc, VLoc, FinishElement))
                {
                    ConstructPrefDir->PrefDirMarker(10, PrefDirCall, true, Display);
                    ResetChangedFileDataAndCaption(16, false); // moved after 2.7.0 to here
                    /*drop this condisiton as don't want to finish automatically because may have found an inappropriate path, changed at v2.13.0
                    {
                        ShowMessage("Preferred direction added");
                        EveryPrefDir->ConsolidatePrefDirs(1, ConstructPrefDir); // at 31
                        Level1Mode = PrefDirMode;
                        SetLevel1Mode(16);
                        Screen->Cursor = TCursor(-2); // Arrow
                        Utilities->CallLogPop(57);
                        return;
                    }
                    */
//                    else
                    {
                        Level2PrefDirMode = PrefDirContinuing;
                        SetLevel2PrefDirMode(2);
                    }
                    // set again since 1st time
                    // PrefDir vector only had start element & Truncate wasn't enabled, also need
                    // to do the checks for Loop & End for each element as it is added
                }
            }
            else // same as start element
            {
                ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
                Level1Mode = PrefDirMode;
                SetLevel1Mode(121);
                Screen->Cursor = TCursor(-2); // Arrow
                Utilities->CallLogPop(1714);
                return;
            }
            Screen->Cursor = TCursor(-2); // Arrow
            Utilities->CallLogPop(58);
            return;
        }

        else if(Level2PrefDirMode == PrefDirSelecting)
        {
            TrainController->LogEvent("mbLeft + PrefDirSelecting");
            ClearandRebuildRailway(56); // to get rid of earlier rectangles
            SelectStartPair.first = HLoc;
            SelectStartPair.second = VLoc;
        }

        else if(Level1Mode == OperMode)
        {
            if((Level2OperMode == Operating) && CallingOnButton->Down && CallingOnButton->Enabled)
            {
                TrainController->LogEvent("mbLeft + Operating & CallingOnButton->Down");
                int Position;
                TTrackElement TrackElement;
                if(Track->FindNonPlatformMatch(2, HLoc, VLoc, Position, TrackElement))
                {
                    if(TrackElement.TrackType != SignalPost)
                    {
                        CallingOnButton->Down = false;
// InfoPanel->Visible = false;  //dropped at v1.3.0, not sure what purpose intended to serve but don't want to lose the info panel as did with this here also added line below to reset
                        RevertToOriginalRouteSelector(16);
                        Utilities->CallLogPop(59);
                        return;
                    }
                    for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
                    {
                        if(TrainController->TrainVectorAt(8, x).CallingOnFlag)
                        {
                            if((Track->TrackElementAt(428, TrainController->TrainVectorAt(26, x).LeadElement).Conn[TrainController->TrainVectorAt(27,
                                x).LeadExitPos] == Position) && (TrackElement.Config[Track->TrackElementAt(429, TrainController->TrainVectorAt(28,
                                x).LeadElement).ConnLinkPos[TrainController->TrainVectorAt(12, x).LeadExitPos]] == Connection))
                            {
                                // found it!
/*
                            if(TrackElement.SpeedTag == 68)
                                {
                                Display->PlotOutput(0, (HLoc * 16), (VLoc * 16), RailGraphics->bm68CallingOn);
                                }
                            if(TrackElement.SpeedTag == 69)
                                {
                                Display->PlotOutput(1, (HLoc * 16), (VLoc * 16), RailGraphics->bm69CallingOn);
                                }
                            if(TrackElement.SpeedTag == 70)
                                {
                                Display->PlotOutput(2, (HLoc * 16), (VLoc * 16), RailGraphics->bm70CallingOn);
                                }
                            if(TrackElement.SpeedTag == 71)
                                {
                                Display->PlotOutput(3, (HLoc * 16), (VLoc * 16), RailGraphics->bm71CallingOn);
                                }
                            if(TrackElement.SpeedTag == 72)
                                {
                                Display->PlotOutput(4, (HLoc * 16), (VLoc * 16), RailGraphics->bm72CallingOn);
                                }
                            if(TrackElement.SpeedTag == 73)
                                {
                                Display->PlotOutput(5, (HLoc * 16), (VLoc * 16), RailGraphics->bm73CallingOn);
                                }
                            if(TrackElement.SpeedTag == 74)
                                {
                                Display->PlotOutput(6, (HLoc * 16), (VLoc * 16), RailGraphics->bm74CallingOn);
                                }
                            if(TrackElement.SpeedTag == 75)
                                {
                                Display->PlotOutput(7, (HLoc * 16), (VLoc * 16), RailGraphics->bm75CallingOn);
                                }
*/
                                Track->TrackElementAt(430, Position).CallingOnSet = true;
                                Track->PlotSignal(13, Track->TrackElementAt(893, Position), Display);
// added at v 1.3.0 in place of the above to ensure ground signals (as well as others) plot correctly for proceed
                                // have to call after CallingOnSet becomes true & can't use TrackElement as that still has CallingOnSet false
                                ClearandRebuildRailway(69); // added at v1.3.0 to replot route on element after PlotSignal above
                                TrainController->TrainVectorAt(14, x).AllowedToPassRedSignal = true;
                                TrainController->TrainVectorAt(29, x).BeingCalledOn = true;
                                CallingOnButton->Down = false;
                                SetRouteButtonsInfoCaptionAndRouteNotStarted(10);

// set an unrestricted route into the station (just to the first platform) from the stop signal (note that it may be last in an autosigs
// route) but remove any single route elements first (can't reach here if constructing a route), else may try to extend a route that
// has been removed (only a precaution, shouldn't cause any probs whether single route set or not)
                                for(unsigned int x = 0; x < AllRoutes->AllRoutesSize(); x++)
                                {
                                    if(AllRoutes->GetFixedRouteAt(192, x).PrefDirSize() == 1)
                                    {
                                        // only allow route element to be removed if not selected for a route start otherwise
                                        // StartSelectionRouteID will be set & will fail at convert
                                        if(AllRoutes->GetFixedRouteAt(195, x).RouteID != ConstructRoute->StartSelectionRouteID.GetInt())
                                        {
                                            TPrefDirElement PDE = AllRoutes->GetFixedRouteAt(193, x).GetFixedPrefDirElementAt(212, 0);
                                            AllRoutes->RemoveRouteElement(21, PDE.HLoc, PDE.VLoc, PDE.GetELink());
                                            TrainController->LogEvent("SingleRouteElementRemovedDuringCallon, H = " + AnsiString(PDE.HLoc) + ", V = " +
                                                                      AnsiString(PDE.VLoc));
                                        }
                                    }
                                }

// find the correct entry in CallonVector - i.e. where Position == RouteStartEntry
                                for(unsigned int x = 0; x < AllRoutes->CallonVector.size(); x++)
                                {
                                    if(AllRoutes->CallonVector.at(x).RouteStartPosition == Position)
                                    {
                                        // found it
                                        if(!(AllRoutes->CallonVector.at(x).RouteOrPartRouteSet))
                                        // if RouteOrPartRouteSet false then set an unrestricted route into platform
                                        {
                                            bool PointsChanged = false;
                                            IDInt ReqPosRouteID(-1);
                                            TOneRoute *NewRoute = new TOneRoute;
                                            bool CallonTrue = true;
                                            if(NewRoute->GetNonPreferredRouteStartElement(1,
                                                                                          Track->TrackElementAt(841, AllRoutes->CallonVector.at(x).RouteStartPosition).HLoc,
                                                                                          Track->TrackElementAt(842, AllRoutes->CallonVector.at(x).RouteStartPosition).VLoc, CallonTrue))
                                            {
                                                if(NewRoute->GetNextNonPreferredRouteElement(1,
                                                                                             Track->TrackElementAt(843, AllRoutes->CallonVector.at(x).PlatformPosition).HLoc,
                                                                                             Track->TrackElementAt(844, AllRoutes->CallonVector.at(x).PlatformPosition).VLoc, CallonTrue,
                                                                                             ReqPosRouteID, PointsChanged))
                                                {
                                                    if(!PointsChanged) // shouldn't be changed, something wrong if true so don't plot route
                                                    {
                                                        NewRoute->ConvertAndAddNonPreferredRouteSearchVector(3, ReqPosRouteID);
                                                        ClearandRebuildRailway(67); // to plot the route (only finds one so won't call repeatedly)
                                                    }
                                                }
                                            }
                                            delete NewRoute;
                                        }
                                    }
                                }
// InfoPanel->Visible = false;
                                Utilities->CallLogPop(60);
                                return;
                            }
                        }
                    }
                }
                CallingOnButton->Down = false;
                RevertToOriginalRouteSelector(3);
                Utilities->CallLogPop(61);
                return;
            }
/* get 1st element, first check if selected points, not in existing route, & in RouteNotStarted mode
               if so, set all the flash values, Track->PointFlashFlag & start time, then exit for flasher to take over.
               If any of above conditions not met then treat as route selection, setting route flasher if
               route continuing.
*/

            if((Level2OperMode == Operating) || (Level2OperMode == PreStart)) // not 'else if' as both may apply
                                                                              // disallow route setting if paused
            {
                if(Level2OperMode == PreStart)
                {
                    PointsFlashDuration = 0.0;
                    Track->LevelCrossingBarrierUpFlashDuration = 0.0;
                    Track->LevelCrossingBarrierDownFlashDuration = 0.0;
                }
                else
                {
                    float TempSpeedVal = 1; // added for v2.3.0 to keep durations same as x1 values for slow speeds
                    if(TTClockSpeed < 1)
                    {
                        TempSpeedVal = TTClockSpeed;
                    }
                    PointsFlashDuration = AllRoutes->PointsDelay * TempSpeedVal;
                    Track->LevelCrossingBarrierUpFlashDuration = AllRoutes->LevelCrossingBarrierUpDelay * TempSpeedVal;
                    Track->LevelCrossingBarrierDownFlashDuration = AllRoutes->LevelCrossingBarrierDownDelay * TempSpeedVal;
                }
                if(RouteMode == RouteNotStarted)
                {
                    TrainController->LogEvent("mbLeft + RouteNotStarted");
                    int Position;
                    TTrackElement TrackElement;
                    if(Track->FindNonPlatformMatch(3, HLoc, VLoc, Position, TrackElement))
                    {
                        if((TrackElement.TrackType == Points) && !(AllRoutes->TrackIsInARoute(1, Position, 0))
                           && !Track->PointFlashFlag && !Track->RouteFlashFlag)
                        // Flash selected points & changeover if appropriate
                        // need !Track->PointFlashFlag to prevent another point being selected while another is flashing, & !Track->RouteFlashFlag
                        // to ensure user only does one thing at a time
                        {
                            if(TrackElement.TrainIDOnElement > -1)
                            {
                                TrainController->StopTTClockMessage(1, "Can't change points under a train!");
                                Utilities->CallLogPop(62);
                                return;
                            }
                            PointFlash->SetScreenHVSource(1, TrackElement.HLoc * 16, TrackElement.VLoc * 16);
/*
                               This used to try to allow any linked trailing edges to cause both points to change, but no good if
                               there are two adjacent crossovers, where both trailing edges are linked to two different points.
                               The wrong link might be chosen.  Also doubtful if applying a strict order of checks would work, since
                               may be obscure configurations that would be wrong.  This function bypasses the MatchingPoint check, which
                               ensures that there are no obscure links.  Hence better to stick with original.

                               //check if trailing edge linked to another point trailing edge
                                            int DivergingPosition = TrackElement.Conn[1];
                                            TTrackElement DivergingElement = Track->TrackElementAt(431, TrackElement.Conn[1]);
                                            DivergingPointVectorPosition = -1;
                                            if((DivergingElement.TrackType == Points) &&
                                                    ((DivergingElement.Conn[1] == Position) || (DivergingElement.Conn[3] == Position)))
                                                {
                                                if(AllRoutes->TrackIsInARoute(, DivergingPosition))
                                                    {
                                                    ShowMessage("Linked points Locked");
                                                    }
                                                else DivergingPointVectorPosition = DivergingPosition;
                                                }
                                            else
                                                {
                                                DivergingPosition = TrackElement.Conn[3];
                                                DivergingElement = Track->TrackElementAt(432, TrackElement.Conn[3]);
                                                if((DivergingElement.TrackType == Points) &&
                                                        ((DivergingElement.Conn[1] == Position) || (DivergingElement.Conn[3] == Position)))
                                                    {
                                                    if(AllRoutes->TrackIsInARoute(, DivergingPosition))
                                                        {
                                                        ShowMessage("Linked points locked");
                                                        }
                                                    else DivergingPointVectorPosition = DivergingPosition;
                                                    }
                                                }
                                            Track->PointFlashFlag = true;
                                            PointFlashVectorPosition = Position;
                                            PointFlashStartTime = TrainController->TTClockTime;
                                            [close curly bracket -  if include it matches earlier non-commented one!]
*/
                            TTrackElement DivergingElement = Track->TrackElementAt(433, TrackElement.Conn[3]);
                            int DivergingPosition = TrackElement.Conn[3];
                            if((DivergingElement.TrackType == Points) && (DivergingElement.Conn[3] == Position) && (Track->MatchingPoint(1, Position,
                                 DivergingPosition))) // full match inc same attributes
                            {
                                if(AllRoutes->TrackIsInARoute(4, DivergingPosition, 0))
                                {
                                    TrainController->StopTTClockMessage(2, "Linked points locked");
                                }
                                else if(Track->TrackElementAt(1506, Position).Failed) //this point failed
                                {
                                    TrainController->StopTTClockMessage(124, "Points failed, unable to change");
                                }
                                else //this point may still fail
                                {
                                    //not failed when mouse down, but either may fail in trying to change
                                    {
                                        bool SkipFlashing = false;
                                        if(Utilities->FailureMode != FNil)
                                        {
                                            if(random(Utilities->PointChangeEventsPerFailure) == 0)
                                            {
                                                TTrack::TInfrastructureFailureEntry IFE;
                                                TTrackElement &TE = Track->TrackElementAt(1507, Position); //this point
                                                IFE.TVPos = Position;
                                                TE.Failed = true; //new value to signify failed & can't be changed (keeps original value as last bit)
                                                TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TE.SpeedLimit01; //store these values temporarily, points aren't bridges so can use these
                                                TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = TE.SpeedLimit23;
                                                TE.SpeedLimit01 = 10; //values while failed
                                                TE.SpeedLimit23 = 10;
                                                Display->WarningLog(16, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Points failed at " + TE.ElementID);
                                                PerfLogForm->PerformanceLog(39, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: Points failed at " + TE.ElementID);
                                                AllRoutes->RebuildRailwayFlag = true; //force ClearandRebuildRailway at next clock tick
                        //set repair time, random value in minutes between 10 and 179
                                                double FailureMinutes = double(random(Utilities->MaxRandomRepairTime) + Utilities->FixedMinRepairTime);
                                                TDateTime RepairTime = TrainController->TTClockTime + TDateTime(FailureMinutes / 1440);
                                                IFE.RepairTime = RepairTime;
                                                IFE.FailureTime = TrainController->TTClockTime;
                                                Track->FailedPointsVector.push_back(IFE);
                                                SkipFlashing = true;
                                                TrainController->StopTTClockMessage(125, "Points at " + TE.ElementID + " failed during an attempt to change manually.");
                                            }
                                            if(random(Utilities->PointChangeEventsPerFailure) == 0)
                                            {
                                                TTrack::TInfrastructureFailureEntry IFE;
                                                TTrackElement &TE = Track->TrackElementAt(1508, DivergingPosition); //diverging point
                                                if(!TE.Failed) //can't fail twice
                                                {
                                                    IFE.TVPos = DivergingPosition;
                                                    TE.Failed = true; //new value to signify failed & can't be changed (keeps original value as last bit)
                                                    TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TE.SpeedLimit01; //store these values temporarily, points aren't bridges so can use these
                                                    TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = TE.SpeedLimit23;
                                                    TE.SpeedLimit01 = 10; //values while failed
                                                    TE.SpeedLimit23 = 10;
                                                    Display->WarningLog(17, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Points failed at " + TE.ElementID);
                                                    PerfLogForm->PerformanceLog(40, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: Points failed at " + TE.ElementID);
                                                    AllRoutes->RebuildRailwayFlag = true; //force ClearandRebuildRailway at next clock tick
                            //set repair time, random value in minutes between 10 and 179
                                                    double FailureMinutes = double(random(Utilities->MaxRandomRepairTime) + Utilities->FixedMinRepairTime);
                                                    TDateTime RepairTime = TrainController->TTClockTime + TDateTime(FailureMinutes / 1440);
                                                    IFE.RepairTime = RepairTime;
                                                    IFE.FailureTime = TrainController->TTClockTime;
                                                    Track->FailedPointsVector.push_back(IFE);
                                                    SkipFlashing = true;
                                                    TrainController->StopTTClockMessage(126, "Points at " + TE.ElementID + " failed during an attempt to change manually.");
                                                }
                                            }
                                        }
                                        if(!SkipFlashing)
                                        {
                                            Track->PointFlashFlag = true;
                                            PointFlashVectorPosition = Position;
                                            if(!Track->TrackElementAt(1509, DivergingPosition).Failed) //don't change if failed
                                            {
                                                DivergingPointVectorPosition = DivergingPosition;
                                            }
                                            PointFlashStartTime = TrainController->TTClockTime;
                                        }
                                    }
                                }
                            }
                            else // no matching point, just change this point, but it might fail
                            {
                                if(Track->TrackElementAt(1510, Position).Failed) //this point failed
                                {
                                    TrainController->StopTTClockMessage(127, "Points failed, unable to change");
                                }
                                else
                                {
                                    bool SkipFlashing = false;
                                    if(Utilities->FailureMode != FNil)
                                    {
                                        if(random(Utilities->PointChangeEventsPerFailure) == 0)
                                        {
                                            TTrack::TInfrastructureFailureEntry IFE;
                                            TTrackElement &TE = Track->TrackElementAt(1511, Position); //this point
                                            IFE.TVPos = Position;
                                            TE.Failed = true; //new value to signify failed & can't be changed (keeps original value as last bit)
                                            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TE.SpeedLimit01; //store these values temporarily, points aren't bridges so can use these
                                            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = TE.SpeedLimit23;
                                            TE.SpeedLimit01 = 10; //values while failed
                                            TE.SpeedLimit23 = 10;
                                            Display->WarningLog(18, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Points failed at " + TE.ElementID);
                                            PerfLogForm->PerformanceLog(41, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: Points failed at " + TE.ElementID);
                                            AllRoutes->RebuildRailwayFlag = true; //force ClearandRebuildRailway at next clock tick
                    //set repair time, random value in minutes between 10 and 179
                                            double FailureMinutes = double(random(Utilities->MaxRandomRepairTime) + Utilities->FixedMinRepairTime);
                                            TDateTime RepairTime = TrainController->TTClockTime + TDateTime(FailureMinutes / 1440);
                                            IFE.RepairTime = RepairTime;
                                            IFE.FailureTime = TrainController->TTClockTime;
                                            Track->FailedPointsVector.push_back(IFE);
                                            TrainController->StopTTClockMessage(128, "Points at " + TE.ElementID + " failed during an attempt to change manually.");
                                            SkipFlashing = true;
                                        }
                                    }
                                    if(!SkipFlashing)
                                    {
                                        Track->PointFlashFlag = true;
                                        PointFlashVectorPosition = Position;
                                        DivergingPointVectorPosition = -1;
                                        PointFlashStartTime = TrainController->TTClockTime;
                                    }
                                }
                            }
                        }

                        else if(Track->IsLCAtHV(59, HLoc, VLoc) && !Track->PointFlashFlag && !Track->RouteFlashFlag)
                        // level crossing   added at v2.6.0 to allow manual LC changing
                        {
                            if(Track->GetInactiveTrackElementFromTrackMap(5, HLoc, VLoc).Attribute != 2) // 2 = LC changing state, can't click if changing
                            {
                                Track->LCChangeFlag = true;
                                bool TrainPresent = false;
                                if(Track->IsLCBarrierDownAtHV(4, HLoc, VLoc)) // if true then may be able to raise barriers
                                {
                                    // first need to identify the LC in the BarriersDownVector
                                    int BDVectorPos = -1;
                                    if(Track->AnyLinkedBarrierDownVectorManual(1, HLoc, VLoc, BDVectorPos)) // looking for same position & manually closed
                                    {
                                        // this largely copied from ClockTimer2
                                        if(!Track->AnyLinkedLevelCrossingElementsWithRoutesOrTrains(0, Track->BarriersDownVector.at(BDVectorPos).HLoc,
                                                                                                    Track->BarriersDownVector.at(BDVectorPos).VLoc, ConstructRoute->SearchVector, TrainPresent))
                                        // returns true for route set or being set or train, and TrainPresent true if train on LC
                                        {
                                            TTrack::TActiveLevelCrossing CLC = Track->BarriersDownVector.at(BDVectorPos);
                                            // check if have exceeded the allowance (3 minutes for a train having passed or 0 for not) and add it to the overall excess time
                                            TDateTime TempExcessLCDownTime;
                                            if(Track->BarriersDownVector.at(BDVectorPos).ReducedTimePenalty)
                                            // this set in ClockTimer2, relies on train being on LC for >= 1 second
                                            {
                                                // get the 3 mins allowance - hard to imagine will pass in less than a second!
                                                TempExcessLCDownTime = TrainController->TTClockTime - CLC.StartTime - TDateTime(180.0 / 86400);
                                            }
                                            else
                                            {
                                                TempExcessLCDownTime = TrainController->TTClockTime - CLC.StartTime;
                                            }
                                            if(TempExcessLCDownTime > TDateTime(0))
                                            {
                                                TrainController->ExcessLCDownMins += (double(TempExcessLCDownTime) * 1440);
                                            }
                                            CLC.StartTime = TrainController->TTClockTime; // reset these 3 members
                                            CLC.ChangeDuration = Track->LevelCrossingBarrierUpFlashDuration;
                                            CLC.BarrierState = TTrack::Raising;
                                            Track->SetLinkedLevelCrossingBarrierAttributes(7, CLC.HLoc, CLC.VLoc, 2); // set attr to 2 for changing state
                                            Track->ChangingLCVector.push_back(CLC);
                                            Track->BarriersDownVector.erase(Track->BarriersDownVector.begin() + BDVectorPos);
                                        }
                                    }
                                }
                                else // lowering
                                {
                                    // this largely copied from SetLCChangeValues
                                    TTrack::TActiveLevelCrossing ALC; // constructor sets ReducedTimePenalty to false
                                    ALC.HLoc = HLoc;
                                    ALC.VLoc = VLoc;
                                    ALC.StartTime = TrainController->TTClockTime;
                                    ALC.BaseElementSpeedTag = TrackElement.SpeedTag;
                                    ALC.ChangeDuration = Track->LevelCrossingBarrierDownFlashDuration;
                                    ALC.BarrierState = TTrack::Lowering;
                                    ALC.TypeOfRoute = 2;
                                    Track->SetLinkedManualLCs(0, HLoc, VLoc);
// this sets all linked LC ConsecSignals values to 2 for manually lowered - differs from SetLCChangeValues which uses the route type
                                    Track->SetLinkedLevelCrossingBarrierAttributes(6, HLoc, VLoc, 2); // set attr to 2 for changing state
                                    Track->ChangingLCVector.push_back(ALC);
                                    if(!LCManualLowerBarriersMessageSent)
                                    {
                                        AnsiString Message =
                                            AnsiString("This will open the level crossing manually (it will show in green).\n\nA manually opened"
                                                       " level crossing must be manually closed, and as soon as possible to avoid time penalties.\n\n" "This message will not be shown again."
                                                       );
                                        TrainController->StopTTClockMessage(93, Message);
                                        LCManualLowerBarriersMessageSent = true;
                                    }
                                }
                            }
                        }
                        else // route start
                        {
                            if(AutoSigsFlag)
                            {
                                AutoRouteStartMarker->SetScreenHVSource(2, TrackElement.HLoc * 16, TrackElement.VLoc * 16);
                                AutoRouteStartMarker->LoadOriginalScreenGraphic(0);
                            }
                            else if(PreferredRoute) // added at v2.7.0, was ConsecSignalsRoute
                            {
                                SigRouteStartMarker->SetScreenHVSource(3, TrackElement.HLoc * 16, TrackElement.VLoc * 16);
                                SigRouteStartMarker->LoadOriginalScreenGraphic(1);
                            }
                            else
                            {
                                NonSigRouteStartMarker->SetScreenHVSource(4, TrackElement.HLoc * 16, TrackElement.VLoc * 16);
                                NonSigRouteStartMarker->LoadOriginalScreenGraphic(2);
                            }
                            if(PreferredRoute)
                            {
                                if(!Track->PointFlashFlag && !Track->RouteFlashFlag) // don't allow a route to start if a point changing or
                                // another route building
                                {
                                    ConstructRoute->ClearRoute(); // in case not empty though should be
                                    if(ConstructRoute->GetPreferredRouteStartElement(0, HLoc, VLoc, EveryPrefDir, AutoSigsFlag))
                                    {
                                        if(AutoSigsFlag)
                                        {
                                            AutoRouteStartMarker->PlotOverlay(1, Display);
                                        }
                                        else
                                        {
                                            SigRouteStartMarker->PlotOverlay(2, Display);
                                        }
                                        RouteMode = RouteContinuing;
                                        InfoPanel->Visible = true;
                                        if(Level2OperMode == PreStart)
                                        {
                                            InfoPanel->Caption = "PRE-START:  Select next route location";
                                        }
                                        else
                                        {
                                            InfoPanel->Caption = "OPERATING:  Select next route location";
                                        }
                                    }
                                }
                                Utilities->CallLogPop(63);
                                return;
                            }
                            else // nonpreferred route
                            {
                                if(!Track->PointFlashFlag && !Track->RouteFlashFlag) // don't allow a route to start if a point changing or
                                // another route building
                                {
                                    ConstructRoute->ClearRoute(); // in case not empty though should be
                                    bool CallonFalse = false;
                                    if(ConstructRoute->GetNonPreferredRouteStartElement(0, HLoc, VLoc, CallonFalse))
                                    {
                                        NonSigRouteStartMarker->PlotOverlay(3, Display);
                                        RouteMode = RouteContinuing;
                                        InfoPanel->Visible = true;
                                        if(Level2OperMode == PreStart)
                                        {
                                            InfoPanel->Caption = "PRE-START:  Select next route location";
                                        }
                                        else
                                        {
                                            InfoPanel->Caption = "OPERATING:  Select next route location";
                                        }
                                    }
                                }
                                Utilities->CallLogPop(64);
                                return;
                            } // NonPreferred route

                        } // TrackType != Points

                    } // if(Track->FindNonPlatformMatch(HLoc, VLoc, Position, TrackElement))

                } // if(RouteMode == RouteNotStarted)
                else // RouteContinuing
                {
                    TrainController->LogEvent("mbLeft + RouteContinuing");
                    TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
                    TrainController->RestartTime = TrainController->TTClockTime;
                    RouteMode = RouteNotStarted;
                    AutoRouteStartMarker->PlotOriginal(14, Display); // if overlay not plotted will ignore
                    SigRouteStartMarker->PlotOriginal(15, Display); // if overlay not plotted will ignore
                    NonSigRouteStartMarker->PlotOriginal(16, Display); // if overlay not plotted will ignore
                    Screen->Cursor = TCursor(-11); // Hourglass - also set to an hourglass when flashing, after found required
                    // element, but this sets it to an hourglass while searching
                    bool PointsChanged = false;
                    if(PreferredRoute)
                    {
                        // route added to AllRoutes in GetNextRouteElement if valid
                        // int ReqPosRouteNumber;
                        if(ConstructRoute->GetNextPreferredRouteElement(0, HLoc, VLoc, EveryPrefDir, ConsecSignalsRoute, AutoSigsFlag,
                                                                        ConstructRoute->ReqPosRouteID, PointsChanged))
                        {
                            Track->RouteFlashFlag = true;
                            PreferredRouteFlag = true;
                            float TempSpeedVal = 1; // added for v2.3.0 to keep durations same as x1 values for slow speeds
                            if(TTClockSpeed < 1)
                            {
                                TempSpeedVal = TTClockSpeed;
                            }
                            if(Level2OperMode == PreStart)
                            {
                                RouteFlashDuration = 0.0;
                            }
                            else if(PointsChanged)
                            {
                                RouteFlashDuration = AllRoutes->PointsDelay * TempSpeedVal;
                            }
                            else
                            {
                                RouteFlashDuration = AllRoutes->SignalsDelay * TempSpeedVal;
                            }
                            ConstructRoute->SetRouteFlashValues(1, AutoSigsFlag, true); // true for PrefDirRoute
                            RouteFlashStartTime = TrainController->TTClockTime;
                        }
                        else
                        {
                            RevertToOriginalRouteSelector(4);
                        }
                        Screen->Cursor = TCursor(-2); // Arrow
                        TrainController->BaseTime = TDateTime::CurrentDateTime();
                        TrainController->StopTTClockFlag = false;
                        Utilities->CallLogPop(65);
                        return;
                    }
                    else
                    {
                        bool CallonFalse = false;
                        if(ConstructRoute->GetNextNonPreferredRouteElement(0, HLoc, VLoc, CallonFalse, ConstructRoute->ReqPosRouteID, PointsChanged))
                        {
                            Track->RouteFlashFlag = true;
                            PreferredRouteFlag = false;
                            float TempSpeedVal = 1; // added for v2.3.0 to keep durations same as x1 values for slow speeds
                            if(TTClockSpeed < 1)
                            {
                                TempSpeedVal = TTClockSpeed;
                            }
                            if(Level2OperMode == PreStart)
                            {
                                RouteFlashDuration = 0.0;
                            }
                            else if(PointsChanged)
                            {
                                RouteFlashDuration = AllRoutes->PointsDelay * TempSpeedVal;
                            }
                            else
                            {
                                RouteFlashDuration = AllRoutes->SignalsDelay * TempSpeedVal;
                            }
                            ConstructRoute->SetRouteFlashValues(2, false, false);
                            RouteFlashStartTime = TrainController->TTClockTime;
                        }
                        else
                        {
                            RevertToOriginalRouteSelector(5);
                        }
                    }
                    TrainController->BaseTime = TDateTime::CurrentDateTime();
                    TrainController->StopTTClockFlag = false;
                    Screen->Cursor = TCursor(-2); // Arrow
                }
                Utilities->CallLogPop(66);
                return;
            }
        }
        Utilities->CallLogPop(68);
    }
    catch(const Exception &e)
    {
        ErrorLog(20, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::MainScreenMouseDown3(int Caller, TMouseButton Button, TShiftState Shift, int X, int Y)
// ZoomOut mode
{
// NB: DisplayZoomOutOffsetH & V take account of the Min & Max H & V values so don't need these again
    try
    {
        AnsiString AnsiButton = "mbLeft";
        if(Button == mbRight)
        {
            AnsiButton = "mbRight";
        }

        TrainController->LogEvent("MainScreenMouseDown3," + AnsiButton + "," + AnsiString(X) + "," + AnsiString(Y));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",MainScreenMouseDown3," + AnsiButton + "," + AnsiString(X) +
                                     "," + AnsiString(Y));
        if(Button != mbLeft)
        {
            // this routine new at v2.1.0.  Allows railway moving for zoom-out mode
            StartWholeRailwayMoveHPos = X;
            StartWholeRailwayMoveVPos = Y;
            WholeRailwayMoving = true;
            Screen->Cursor = TCursor(-22); // Four arrows;
        }
        else
        {
            InfoPanel->Visible = false; // reset infopanel in case not set later
            InfoPanel->Caption = "";
            int HRounding, VRounding;
            int TruePosH = (X / 4) + Display->DisplayZoomOutOffsetH;
            int TruePosV = (Y / 4) + Display->DisplayZoomOutOffsetV;
            // find nearest screen centre - from 30 to 210 horiz & from 18 to 126 vert
            if(TruePosH < 0)
            {
                HRounding = -(Utilities->ScreenElementWidth / 4);
            }
            else
            {
                HRounding = (Utilities->ScreenElementWidth / 4);
            }
            int CentreH = (((TruePosH + HRounding) / (Utilities->ScreenElementWidth / 2)) * (Utilities->ScreenElementWidth / 2));
            while((CentreH - Track->GetHLocMax()) >= (Utilities->ScreenElementWidth / 2))
            {
                CentreH -= (Utilities->ScreenElementWidth / 2);
            }
            while((Track->GetHLocMin() - CentreH) >= (Utilities->ScreenElementWidth / 2))
            {
                CentreH += (Utilities->ScreenElementWidth / 2);
            }
            if(TruePosV < 0)
            {
                VRounding = -(Utilities->ScreenElementHeight / 4);
            }
            else
            {
                VRounding = (Utilities->ScreenElementHeight / 4);
            }
            int CentreV = (((TruePosV + VRounding) / (Utilities->ScreenElementHeight / 2)) * (Utilities->ScreenElementHeight / 2));
            while((CentreV - Track->GetVLocMax()) >= (Utilities->ScreenElementHeight / 2))
            {
                CentreV -= (Utilities->ScreenElementHeight / 2);
            }
            while((Track->GetVLocMin() - CentreV) >= (Utilities->ScreenElementHeight / 2))
            {
                CentreV += (Utilities->ScreenElementHeight / 2);
            }
            Display->DisplayOffsetH = CentreH - (Utilities->ScreenElementWidth / 2);
            Display->DisplayOffsetV = CentreV - (Utilities->ScreenElementHeight / 2);

            TLevel2OperMode TempLevel2OperMode = Level2OperMode;
            if(Level1Mode == BaseMode)
            {
                SetLevel1Mode(17);
            }
            else if(Level1Mode == TrackMode)
            {
                // set edit menu items
                SetTrackModeEditMenu(0);
                PreventGapOffsetResetting = true; // when return from zoom by clicking screen don't force a return to the
                                                  // displayed gap, user wants to display the clicked area
                SetLevel2TrackMode(32); // revert to earlier track mode from zoom
                PreventGapOffsetResetting = false;
            }
            else if(Level1Mode == PrefDirMode)
            {
                if(Level2PrefDirMode == PrefDirContinuing)
                {
                    SetLevel2PrefDirMode(3); // revert to earlier PrefDir mode from zoom
                }
                else
                {
                    SetLevel1Mode(33); // if PrefDirSelecting revert to normap PrefDirMode
                }
            }
            // else if(Level1Mode == TrackMode) SetLevel1Mode();//just revert to basic track mode from zoom
            // else if(Level1Mode == PrefDirMode) SetLevel1Mode();//just revert to basic PrefDir mode from zoom
            else if(Level1Mode == TimetableMode)
            {
                InfoPanel->Visible = false;
            }
            // Not OperMode or RestartSessionOperMode as that resets the performance file
            else if(TempLevel2OperMode == Operating) // similar to SetLevel2OperMode but without resetting BaseTime
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "PauseGraphic");
                ExitOperationButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(0);
            }
            else if(TempLevel2OperMode == Paused) // similar to SetLevel2OperMode but without resetting RestartTime
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
                ExitOperationButton->Enabled = true;
                TTClockAdjButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(6);
                DisableRouteButtons(0);
            }
            else if(TempLevel2OperMode == PreStart)
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
                ExitOperationButton->Enabled = true;
                TTClockAdjButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(8);
            }
            Display->ZoomOutFlag = false; // reset this after level modes called so gap flash stays set if set to begin with
            SetPausedOrZoomedInfoCaption(0);
            ClearandRebuildRailway(44);
        }
        Utilities->CallLogPop(69);
    }
    catch(const Exception &e)
    {
        ErrorLog(21, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::MainScreenMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
    try
    {
        // TrainController->LogEvent("MainScreenMouseMove," + AnsiString(X) + "," + AnsiString(Y));    //dropped at v0.6, too many events
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MainScreenMouseMove," + AnsiString(X) + "," + AnsiString(Y));

        if(!mbLeftDown && WholeRailwayMoving) // new at v2.1.0
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            if(X < 0)
            {
                X = 0; // ensure pointer stays within display area
            }
            if(X > (MainScreen->Width - 1))
            {
                X = MainScreen->Width - 1;
            }
            if(Y < 0)
            {
                Y = 0;
            }
            if(Y > (MainScreen->Height - 1))
            {
                Y = MainScreen->Height - 1;
            }
            if(!Display->ZoomOutFlag)
            {
                int StartOffsetX = (X - StartWholeRailwayMoveHPos) % 16;
                int StartOffsetY = (Y - StartWholeRailwayMoveVPos) % 16;
                if((abs(X - StartWholeRailwayMoveHPos) >= 16) || (abs(Y - StartWholeRailwayMoveVPos) >= 16))
                {
                    int NewH = X - StartWholeRailwayMoveHPos;
                    int NewV = Y - StartWholeRailwayMoveVPos;
                    Display->DisplayOffsetH -= NewH / 16;
                    Display->DisplayOffsetV -= NewV / 16;
                    StartWholeRailwayMoveHPos = X - StartOffsetX;
                    StartWholeRailwayMoveVPos = Y - StartOffsetY;
                    ClearandRebuildRailway(71);
                    if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
                    {
                        Display->PlotDashedRect(3, SelectRect);
                    }
                }
            }

            else
            {
                int StartZOffsetX = (X - StartWholeRailwayMoveHPos) % 4;
                int StartZOffsetY = (Y - StartWholeRailwayMoveVPos) % 4;
                if((abs(X - StartWholeRailwayMoveHPos) >= 4) || (abs(Y - StartWholeRailwayMoveVPos) >= 4))
                {
                    int NewH = X - StartWholeRailwayMoveHPos;
                    int NewV = Y - StartWholeRailwayMoveVPos;
                    Display->DisplayZoomOutOffsetH -= NewH / 4;
                    Display->DisplayZoomOutOffsetV -= NewV / 4;
                    StartWholeRailwayMoveHPos = X - StartZOffsetX;
                    StartWholeRailwayMoveVPos = Y - StartZOffsetY;
                    Display->ClearDisplay(10);
                    Track->PlotSmallRailway(8, Display);
                }
            }
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
        }

        else if(mbLeftDown)
        {
            if(Level2TrackMode == TrackSelecting)
            /* [Repeated from MouseDown] - When 'select' chosen from the Edit menu (only available in 'AddTrack') conditions are set ready to enclose a rectangular screen area
                                            using MouseMove.  When MouseDown occurs the starting point is marked (wrt whole railway, not just the screen) and stored in
                                            SelectStartPair.  If the mouse button is released and a new start position selected then the earlier one is discarded.  Providing the
                                            button is held down subsequent actions occur during MouseMove (to display the changing rectangle) and MouseUp to define the final
                                            selected rectangle.
                                            [New] At this point the select starting position has been defined in SelectStartPair, and the current mouse position is defined (wrt whole
                                            railway) in HLoc & VLoc from the screen positions X & Y by GetTrackLocsFromScreenPos.  Both are incremented so that the rectangle
                                            includes the current point (if no mouse movement at all occurs then a 1 x 1 rectangle is displayed).  Limits are set to prevent the
                                            displayed rectangle extending off screen.  Edges are set at 60 & 36 rather than 59 & 35 because the defined rectangle excludes the
                                            rightmost and bottom HLoc & VLoc values, if 59 & 35 were used the right & bottom screen edges wouldn't be reached.  A TRect is then
                                            defined from SelectStartPair and the HLoc/VLoc values, Clearand... called to clear earlier rectangles, and a dashed edge drawn round
                                            the selection.
            */
            {
                if(!MMoveTrackSelFlag)
                {
                    TrainController->LogEvent("MouseMove + TrackSelecting");
                    MMoveTrackSelFlag = true;
                }
                int CurrentHLoc, CurrentVLoc, StartHLoc = SelectStartPair.first, StartVLoc = SelectStartPair.second;
                Track->GetTrackLocsFromScreenPos(2, CurrentHLoc, CurrentVLoc, X, Y);
                // to make the rectangle inclusive of the start and current points, need to increase the HLoc value of the
                // rightmost point and the VLoc value of the bottommost point
                if(CurrentHLoc >= StartHLoc)
                {
                    CurrentHLoc++;
                }
                else
                {
                    StartHLoc++;
                }
                if(CurrentVLoc >= StartVLoc)
                {
                    CurrentVLoc++;
                }
                else
                {
                    StartVLoc++;
                }
                if(CurrentHLoc - Display->DisplayOffsetH > Utilities->ScreenElementWidth)
                {
                    CurrentHLoc = Display->DisplayOffsetH + Utilities->ScreenElementWidth;
                }
                if(CurrentVLoc - Display->DisplayOffsetV > Utilities->ScreenElementHeight)
                {
                    CurrentVLoc = Display->DisplayOffsetV + Utilities->ScreenElementHeight;
                }
                if(CurrentHLoc - Display->DisplayOffsetH < 0)
                {
                    CurrentHLoc = Display->DisplayOffsetH;
                }
                if(CurrentVLoc - Display->DisplayOffsetV < 0)
                {
                    CurrentVLoc = Display->DisplayOffsetV;
                }
                TRect TempRect(StartHLoc, StartVLoc, CurrentHLoc, CurrentVLoc);
                ClearandRebuildRailway(14); // to clear earlier rectangles
                Display->PlotDashedRect(0, TempRect);
                Display->Update(); // resurrected when Update() dropped from PlotOutput etc
            }

            else if(Level2PrefDirMode == PrefDirSelecting)
            {
                if(!MMovePrefDirSelFlag)
                {
                    TrainController->LogEvent("MouseMove + PrefDirSelecting");
                    MMovePrefDirSelFlag = true;
                }

                int CurrentHLoc, CurrentVLoc, StartHLoc = SelectStartPair.first, StartVLoc = SelectStartPair.second;
                Track->GetTrackLocsFromScreenPos(5, CurrentHLoc, CurrentVLoc, X, Y);
                // to make the rectangle inclusive of the start and current points, need to increase the HLoc value of the
                // rightmost point and the VLoc value of the bottommost point
                if(CurrentHLoc >= StartHLoc)
                {
                    CurrentHLoc++;
                }
                else
                {
                    StartHLoc++;
                }
                if(CurrentVLoc >= StartVLoc)
                {
                    CurrentVLoc++;
                }
                else
                {
                    StartVLoc++;
                }
                if(CurrentHLoc - Display->DisplayOffsetH > Utilities->ScreenElementWidth)
                {
                    CurrentHLoc = Display->DisplayOffsetH + Utilities->ScreenElementWidth;
                }
                if(CurrentVLoc - Display->DisplayOffsetV > Utilities->ScreenElementHeight)
                {
                    CurrentVLoc = Display->DisplayOffsetV + Utilities->ScreenElementHeight;
                }
                if(CurrentHLoc - Display->DisplayOffsetH < 0)
                {
                    CurrentHLoc = Display->DisplayOffsetH;
                }
                if(CurrentVLoc - Display->DisplayOffsetV < 0)
                {
                    CurrentVLoc = Display->DisplayOffsetV;
                }
                TRect TempRect(StartHLoc, StartVLoc, CurrentHLoc, CurrentVLoc);
                ClearandRebuildRailway(57); // to clear earlier rectangles
                Display->PlotDashedRect(2, TempRect);
                Display->Update(); // need to keep this since Update() not called for PlotSmallOutput as too slow
            }

            else if(((Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving)) && SelectPickedUp)
            /* [Repeated from MouseDown] - The same actions apply on MouseDown whether Copy or Cut selected from the menu.  First the horizontal and vertical mouse position is
                                           checked and unless it lies within the selected rectangle and not within 4 pixels of an edge the pickup fails and the function returns.
                                           Otherwise flag SelectPickedUp is set to true (to allow it to move during MouseMove and remain in place at MouseUp) and the mouse position
                                           is saved in SelectBitmapMouseLocX & Y for use later in MouseMove & MouseUp.
                                           [New] - The same actions apply on MouseMove whether Copy or Cut selected from the menu.  The X & Y mouse positions are checked and set to
                                           stay within the display area.  Then the current selection H & V positions are stored in NewSelectBitmapHLoc & VLoc.
                                           These change continually while the mouse and the selection are moving, they are only read on MouseUp to retain the position that it then
                                           occupies.  Clearand... is called finally to clear earlier selection displays.
            */
            {
                if(!MMoveCopyCutSelPickedUpFlag)
                {
                    TrainController->LogEvent("MouseMove + Copy or CutMoving & SelectPickedUp");
                    MMoveCopyCutSelPickedUpFlag = true;
                }
                if(X < 0)
                {
                    X = 0; // ensure pointer stays within display area
                }
                if(X > (MainScreen->Width - 1))
                {
                    X = MainScreen->Width - 1;
                }
                if(Y < 0)
                {
                    Y = 0;
                }
                if(Y > (MainScreen->Height - 1))
                {
                    Y = MainScreen->Height - 1;
                }
                NewSelectBitmapHLoc = (X - SelectBitmapMouseLocX) / 16 + SelectBitmapHLoc;
                NewSelectBitmapVLoc = (Y - SelectBitmapMouseLocY) / 16 + SelectBitmapVLoc;
                ClearandRebuildRailway(15); // plots SelectBitmap at the position given by NewSelectBitmapHLoc & ...VLoc
            }

            else if((Level2TrackMode == MoveTextOrGraphic) && TextFoundFlag)
            {
                if(!MMoveTextGraphicTextFoundFlag)
                {
                    TrainController->LogEvent("MouseMove + MoveTextOrGraphic & TextFoundFlag");
                    MMoveTextGraphicTextFoundFlag = true;
                }
                int NewHPos = TextOrUserGraphicGridVal * (div(X - StartX, TextOrUserGraphicGridVal).quot) + TextMoveHPos + Display->DisplayOffsetH * 16;
                NewHPos = TextOrUserGraphicGridVal * (div(NewHPos, TextOrUserGraphicGridVal).quot);
                int NewVPos = TextOrUserGraphicGridVal * (div(Y - StartY, TextOrUserGraphicGridVal).quot) + TextMoveVPos + Display->DisplayOffsetV * 16;
                NewVPos = TextOrUserGraphicGridVal * (div(NewVPos, TextOrUserGraphicGridVal).quot);

                TextHandler->TextPtrAt(26, TextItem)->HPos = NewHPos;
                TextHandler->TextPtrAt(27, TextItem)->VPos = NewVPos;
                ClearandRebuildRailway(41);
            }

            else if((Level2TrackMode == MoveTextOrGraphic) && UserGraphicFoundFlag)
            {
                if(!MMoveTextGraphicUserGraphicFoundFlag)
                {
                    TrainController->LogEvent("MouseMove + MoveTextOrGraphic & UserGraphicFoundFlag");
                    MMoveTextGraphicUserGraphicFoundFlag = true;
                }
                int NewHPos = TextOrUserGraphicGridVal * (div(X - StartX, TextOrUserGraphicGridVal).quot) + UserGraphicMoveHPos + Display->DisplayOffsetH * 16;
                NewHPos = TextOrUserGraphicGridVal * (div(NewHPos, TextOrUserGraphicGridVal).quot);
                int NewVPos = TextOrUserGraphicGridVal * (div(Y - StartY, TextOrUserGraphicGridVal).quot) + UserGraphicMoveVPos + Display->DisplayOffsetV * 16;
                NewVPos = TextOrUserGraphicGridVal * (div(NewVPos, TextOrUserGraphicGridVal).quot);

                Track->UserGraphicVectorAt(24, UserGraphicVectorNumber).HPos = NewHPos;
                Track->UserGraphicVectorAt(25, UserGraphicVectorNumber).VPos = NewVPos;
                ClearandRebuildRailway(79);
            }
        }
        Utilities->CallLogPop(70);
    }
    catch(const Exception &e)
    {
        ErrorLog(22, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::MainScreenMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
/* [Repeated from MouseDown] - When 'select' chosen from the Edit menu (only available in 'AddTrack') conditions are set ready to enclose a rectangular screen area
   using MouseMove.  When MouseDown occurs the starting point is marked (wrt whole railway, not just the screen) and stored in
   SelectStartPair.  If the mouse button is released and a new start position selected then the earlier one is discarded.  Providing the
   button is held down subsequent actions occur during MouseMove (to display the changing rectangle) and MouseUp to define the final
   selected rectangle.
   [Repeated from MouseMove] - At this point the select starting position has been defined in SelectStartPair, and the current mouse position is defined (wrt whole
   railway) in HLoc & VLoc from the screen positions X & Y by GetTrackLocsFromScreenPos.  Both are incremented so that the rectangle
   includes the current point (if no mouse movement at all occurs then a 1 x 1 rectangle is displayed).  Limits are set to prevent the
   displayed rectangle extending off screen.  Edges are set at 60 & 36 rather than 59 & 35 because the defined rectangle excludes the
   rightmost and bottom HLoc & VLoc values, if 59 & 35 were used the right & bottom screen edges wouldn't be reached.  A TRect is then
   defined from SelectStartPair and the HLoc/VLoc values, Clearand... called to clear earlier rectangles, and a dashed edge drawn round
   the selection.
   [New] This function can take some time so an hourglass cursor is displayed.  The rectangle is fully defined, so the final screen X & Y
   values are translated into HLoc & VLoc values (wrt whole railway) and SelectEndPair set using them.  The rectangle can be defined in any
   direction, so the end points may be before or after the starting points for both horizontal and vertical directions.  Therefore the
   rectangle that will be used subsequently - SelectRect - is defined from SelectStart and SelectEnd allowing for any direction.  Screen
   limits are set as during MouseMove, and a dashed edge drawn as before.  Then a check is made to see if the final rectangle has any area,
   and if not 'Select' mode is kept and the function ends so that a new rectangle can be drawn, otherwise new menu items Cut, Copy & Delete,
   are enabled.  Now the SelectBitmap is made ready by filling with white prior to the track bitmaps being copied.  If this isn't done the
   track bitmaps are loaded from the top left hand corner and the rest becomes black - not what is wanted!  The SelectVector (defined in
   TrackUnit) is then loaded with the elements enclosed by the rectangle, top to bottom and left to right, active track elements first then
   inactive track elements.  Empty squares are ignored as are default (erased) elements.  Now the SelectVector is read and the corresponding
   element bitmaps transferred to SelectBitmap in the appropriate positions, then a dashed border added.  Finally the cursor is changed back
   to an arrow.
*/
    try
    {
        AnsiString AnsiButton = "mbLeft";
        if(Button == mbRight)
        {
            AnsiButton = "mbRight";
        }
        TrainController->LogEvent("MainScreenMouseUp," + AnsiButton + "," + AnsiString(X) + "," + AnsiString(Y));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MainScreenMouseUp," + AnsiButton + "," + AnsiString(X) + "," + AnsiString(Y));
        WholeRailwayMoving = false; // added at v2.1.0
        Screen->Cursor = TCursor(-2); // Arrow; (to reset from four arrows when moving) added at v2.1.0
        MMoveTrackSelFlag = false;
        MMovePrefDirSelFlag = false;
        MMoveCopyCutSelPickedUpFlag = false;
        MMoveTextGraphicTextFoundFlag = false;
        MMoveTextGraphicUserGraphicFoundFlag = false;

        if((Level2TrackMode == TrackSelecting) && mbLeftDown)
        {
            TrainController->LogEvent("MouseUp + TrackSelecting + mbLeftDown");
            Screen->Cursor = TCursor(-11); // Hourglass;
            int EndHLoc, EndVLoc, StartHLoc = SelectStartPair.first, StartVLoc = SelectStartPair.second;
            Track->GetTrackLocsFromScreenPos(3, EndHLoc, EndVLoc, X, Y); // these values don't allow for offsets so add in later
// to make the rectangle inclusive of the start and current points, need to increase the HLoc value of the
// rightmost point and the VLoc value of the bottommost point
            if(EndHLoc >= StartHLoc)
            {
                EndHLoc++;
            }
            else
            {
                StartHLoc++;
            }
            if(EndVLoc >= StartVLoc)
            {
                EndVLoc++;
            }
            else
            {
                StartVLoc++;
            }
            if(StartHLoc >= EndHLoc)
            {
                SelectRect.left = EndHLoc;
                SelectRect.right = StartHLoc;
            }
            else
            {
                SelectRect.left = StartHLoc;
                SelectRect.right = EndHLoc;
            }
            if(StartVLoc >= EndVLoc)
            {
                SelectRect.top = EndVLoc;
                SelectRect.bottom = StartVLoc;
            }
            else
            {
                SelectRect.top = StartVLoc;
                SelectRect.bottom = EndVLoc;
            }
            if(SelectRect.right - Display->DisplayOffsetH > Utilities->ScreenElementWidth)
            {
                SelectRect.right = Display->DisplayOffsetH + Utilities->ScreenElementWidth;
            }
            if(SelectRect.bottom - Display->DisplayOffsetV > Utilities->ScreenElementHeight)
            {
                SelectRect.bottom = Display->DisplayOffsetV + Utilities->ScreenElementHeight;
            }
            if(SelectRect.left - Display->DisplayOffsetH < 0)
            {
                SelectRect.left = Display->DisplayOffsetH;
            }
            if(SelectRect.top - Display->DisplayOffsetV < 0)
            {
                SelectRect.top = Display->DisplayOffsetV;
            }
            Level2TrackMode = AddTrack; // Level1Mode must be TrackMode
            SetLevel2TrackMode(69); // add all track elements so area can be filled with an element, must come before PlotDashedRect as calls Clearand...
            Level2TrackMode = TrackSelecting; // reset from AddTrack
            Display->PlotDashedRect(1, SelectRect);
            SelectBitmapHLoc = SelectRect.left;
            SelectBitmapVLoc = SelectRect.top;
            if((SelectRect.top == SelectRect.bottom) || (SelectRect.left == SelectRect.right))
            {
                SelectionValid = false;
                SetTrackModeEditMenu(1);
                mbLeftDown = false;
                Screen->Cursor = TCursor(-2); // Arrow;
                Utilities->CallLogPop(71);
                return; // no rectangle
            }
            else
            {
                ReselectMenuItem->Enabled = false;
                CutMenuItem->Enabled = true;
                CopyMenuItem->Enabled = true;
                FlipMenuItem->Enabled = true;
                MirrorMenuItem->Enabled = true;
                RotRightMenuItem->Enabled = true;
                RotLeftMenuItem->Enabled = true;
                RotateMenuItem->Enabled = true;

// PasteWithAttributesMenuItem->Enabled = false;  //new menu item for v2.2.0 only enabled after cutting (dropped at 2.4.0 as all pastes are with attributes)
                DeleteMenuItem->Enabled = true;
                if(Track->IsTrackFinished())
                {
                    SelectLengthsMenuItem->Enabled = true; // only permit if finished because reverts to DistanceStart
                }
                else
                {
                    SelectLengthsMenuItem->Enabled = false; // and that can only be used if track linked
                }
                SelectBiDirPrefDirsMenuItem->Visible = false;
                CheckPrefDirConflictsMenuItem->Visible = false;
                CancelSelectionMenuItem->Enabled = true;
                // set SelectBitmap
                SelectBitmap->Width = (SelectRect.right - SelectRect.left) * 16;
                SelectBitmap->Height = (SelectRect.bottom - SelectRect.top) * 16;

                // fill it with transparent white (i.e. use Draw) else graphics all plot from top left hand corner
                for(int H = 0; H < (SelectBitmap->Width) / 16; H++)
                {
                    for(int V = 0; V < (SelectBitmap->Height) / 16; V++)
                    {
                        SelectBitmap->Canvas->Draw(H * 16, V * 16, RailGraphics->bmSolidBgnd);
                        // NB in above if use bmTransparent it ISN'T transparent, but if use the non-transparent bmSolidBgnd it IS transparent
                        // presumably superimposing a transparent bitmap onto a transparent bitmap makes the result non-transparent!
                    }
                }

                Track->SelectVectorClear();
                TTrackElement TempElement; // default element
                bool FoundFlag;
                //store active elements
                for(int x = SelectRect.left; x < SelectRect.right; x++)
                {
                    for(int y = SelectRect.top; y < SelectRect.bottom; y++)
                    {
                        int ATVecPos = Track->GetVectorPositionFromTrackMap(2, x, y, FoundFlag);
                        if(FoundFlag)
                        {
                            TempElement = Track->TrackElementAt(440, ATVecPos);
                            if(TempElement.SpeedTag > 0)
                            {
                                Track->SelectPush(TempElement); // don't store erase elements
                            }
                        }
                    }
                }
                // now store inactive elements
                for(int x = SelectRect.left; x < SelectRect.right; x++)
                {
                    for(int y = SelectRect.top; y < SelectRect.bottom; y++)
                    {
                        TTrack::TIMPair IATVecPair = Track->GetVectorPositionsFromInactiveTrackMap(2, x, y, FoundFlag);
                        if(FoundFlag)
                        {
                            TempElement = Track->InactiveTrackElementAt(30, IATVecPair.first);
                            Track->SelectPush(TempElement); // only want SpeedTag & location set, rest defaults
                            if(IATVecPair.second != IATVecPair.first) // 2 elements stored at location, i.e. platforms
                            {
                                TempElement = Track->InactiveTrackElementAt(31, IATVecPair.second);
                                Track->SelectPush(TempElement);
                            }
                        }
                    }
                }

                //store preferred directions //added at v2.9.0
                int PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3;
                TPrefDirElement TempPrefDirElement;
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                for(int x = SelectRect.left; x < SelectRect.right; x++)
                {
                    for(int y = SelectRect.top; y < SelectRect.bottom; y++)
                    {
                        EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(11, x, y, FoundFlag, PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3);
                        if(FoundFlag)
                        {
                            if(PrefDirPos0 > -1)
                            {
                                TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(2, PrefDirPos0);
                                SelectPrefDir->ExternalStorePrefDirElement(6, TempPrefDirElement);
                            }
                            if(PrefDirPos1 > -1)
                            {
                                TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(3, PrefDirPos1);
                                SelectPrefDir->ExternalStorePrefDirElement(7, TempPrefDirElement);
                            }
                            if(PrefDirPos2 > -1)
                            {
                                TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(4, PrefDirPos2);
                                SelectPrefDir->ExternalStorePrefDirElement(8, TempPrefDirElement);
                            }
                            if(PrefDirPos3 > -1)
                            {
                                TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(5, PrefDirPos3);
                                SelectPrefDir->ExternalStorePrefDirElement(9, TempPrefDirElement);
                            }
                        }
                    }
                }

                // store text items
                int LowSelectHPos = SelectRect.left * 16;
                int HighSelectHPos = SelectRect.right * 16;
                int LowSelectVPos = SelectRect.top * 16;
                int HighSelectVPos = SelectRect.bottom * 16;
                TextHandler->SelectTextVector.clear();
                if(!TextHandler->TextVector.empty()) // skip iteration if empty else have an error
                {
                    for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr < TextHandler->TextVector.end(); TextPtr++)
                    {
                        if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos <
                                                                                                                                        HighSelectVPos))
                        {
                            // have to create a new TextItem in order to create a new Font object
                            // BUT: only create new items where they don't appear as named location names
                            // in SelectVector, since those names shouldn't be copied or pasted.
                            // NB:  altered for PasteWithAttributes - at v2.2.0 save the named element but prefix it with "##**"
                            // so can paste or not depending on which type of paste is being used (unlikely to use that in a real name)
                            bool SelectVectorNamedElement = false;
                            AnsiString SelectTextString; // new at v2.2.0
                            for(unsigned int x = 0; x < Track->SelectVector.size(); x++)
                            {
                                if(Track->SelectVector.at(x).LocationName == TextPtr->TextString)
                                {
                                    SelectVectorNamedElement = true;
                                    break;
                                }
                            }
                            if(SelectVectorNamedElement) // changed at v2.2.0
                            {
                                SelectTextString = "##**" + TextPtr->TextString; // new at v2.2.0
                            }
                            else // new at v2.2.0
                            {
                                SelectTextString = TextPtr->TextString;
                            }
                            TTextItem TextItem(TextPtr->HPos, TextPtr->VPos, SelectTextString, TextPtr->Font);
                            TextHandler->SelectTextVector.push_back(TextItem); // changed at v2.2.0
                        }
                    }
                }
                // store graphic items, but first clear SelectGraphicVector
                Track->SelectGraphicVector.clear();
                if(!Track->UserGraphicVector.empty()) // skip iteration if empty else have an error
                {
                    for(TTrack::TUserGraphicVector::iterator UserGraphicPtr = Track->UserGraphicVector.begin(); UserGraphicPtr < Track->UserGraphicVector.end();
                        UserGraphicPtr++)
                    {
                        if((UserGraphicPtr->HPos >= LowSelectHPos) && ((UserGraphicPtr->HPos + UserGraphicPtr->Width) < HighSelectHPos) &&
                           (UserGraphicPtr->VPos >= LowSelectVPos) && ((UserGraphicPtr->VPos + UserGraphicPtr->Height) < HighSelectVPos))
                        {
                            Track->SelectGraphicVector.push_back(*UserGraphicPtr);
                        }
                    }
                }
// new method - direct copying of existing selection so text included
                TRect Dest(0, 0, SelectBitmap->Width, SelectBitmap->Height);
                TRect Source(((SelectRect.left - Display->DisplayOffsetH) * 16), ((SelectRect.top - Display->DisplayOffsetV) * 16),
                             ((SelectRect.right - Display->DisplayOffsetH) * 16), ((SelectRect.bottom - Display->DisplayOffsetV) * 16));
                SelectBitmap->Canvas->CopyRect(Dest, MainScreen->Canvas, Source);
                SelectionValid = true;
            }
            Screen->Cursor = TCursor(-2); // Arrow;
        }

        else if((Level2PrefDirMode == PrefDirSelecting) && mbLeftDown)
        {
            TrainController->LogEvent("MouseUp + PrefDirSelecting + mbLeftDown");
            Screen->Cursor = TCursor(-11); // Hourglass;

            int EndHLoc, EndVLoc, StartHLoc = SelectStartPair.first, StartVLoc = SelectStartPair.second;
            Track->GetTrackLocsFromScreenPos(6, EndHLoc, EndVLoc, X, Y); // these values don't allow for offsets so add in later
// to make the rectangle inclusive of the start and current points, need to increase the HLoc value of the
// rightmost point and the VLoc value of the bottommost point
            if(EndHLoc >= StartHLoc)
            {
                EndHLoc++;
            }
            else
            {
                StartHLoc++;
            }
            if(EndVLoc >= StartVLoc)
            {
                EndVLoc++;
            }
            else
            {
                StartVLoc++;
            }
            if(StartHLoc >= EndHLoc)
            {
                SelectRect.left = EndHLoc;
                SelectRect.right = StartHLoc;
            }
            else
            {
                SelectRect.left = StartHLoc;
                SelectRect.right = EndHLoc;
            }
            if(StartVLoc >= EndVLoc)
            {
                SelectRect.top = EndVLoc;
                SelectRect.bottom = StartVLoc;
            }
            else
            {
                SelectRect.top = StartVLoc;
                SelectRect.bottom = EndVLoc;
            }
            if(SelectRect.right - Display->DisplayOffsetH > Utilities->ScreenElementWidth)
            {
                SelectRect.right = Display->DisplayOffsetH + Utilities->ScreenElementWidth;
            }
            if(SelectRect.bottom - Display->DisplayOffsetV > Utilities->ScreenElementHeight)
            {
                SelectRect.bottom = Display->DisplayOffsetV + Utilities->ScreenElementHeight;
            }
            if(SelectRect.left - Display->DisplayOffsetH < 0)
            {
                SelectRect.left = Display->DisplayOffsetH;
            }
            if(SelectRect.top - Display->DisplayOffsetV < 0)
            {
                SelectRect.top = Display->DisplayOffsetV;
            }
            Display->PlotDashedRect(9, SelectRect);
            SelectBitmapHLoc = SelectRect.left;
            SelectBitmapVLoc = SelectRect.top;
            if((SelectRect.top == SelectRect.bottom) || (SelectRect.left == SelectRect.right))
            {
                SetInitialPrefDirModeEditMenu();
                mbLeftDown = false;
                Screen->Cursor = TCursor(-2); // Arrow;
                Utilities->CallLogPop(1551);
                return; // no rectangle
            }
            else
            {
                SelectBiDirPrefDirsMenuItem->Enabled = true;
                CheckPrefDirConflictsMenuItem->Enabled = false;
                CancelSelectionMenuItem->Enabled = true;
                // don't need SelectBitmap for PrefDir selection

                // store active elements in Track->SelectVector, ignore inactive elements
                // clear the vector first
                Track->SelectVectorClear();
                TTrackElement TempElement; // default element
                bool FoundFlag;
                for(int x = SelectRect.left; x < SelectRect.right; x++)
                {
                    for(int y = SelectRect.top; y < SelectRect.bottom; y++)
                    {
                        int ATVecPos = Track->GetVectorPositionFromTrackMap(43, x, y, FoundFlag);
                        if(FoundFlag)
                        {
                            TempElement = Track->TrackElementAt(729, ATVecPos);
                            if(TempElement.SpeedTag > 0)
                            {
                                Track->SelectPush(TempElement); // don't store erase elements
                            }
                        }
                    }
                }
            }
            Screen->Cursor = TCursor(-2); // Arrow;
        }

        else if(((Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving)) && mbLeftDown && SelectPickedUp)
        /* [Repeated from MouseDown] - The same actions apply on MouseDown whether Copy or Cut selected from the menu.  First the horizontal and vertical mouse position is
                           checked and unless it lies within the selected rectangle and not within 4 pixels of an edge the pickup fails and the function returns.
                           Otherwise flag SelectPickedUp is set to true (to allow it to move during MouseMove and remain in place at MouseUp) and the mouse position
                           is saved in SelectBitmapMouseLocX & Y for use later in MouseMove & MouseUp.
                           [Repeated from MouseMove] - The same actions apply on MouseMove whether Copy or Cut selected from the menu.  The X & Y mouse positions are checked and set to
                           stay within the display area.  Then the current selection H & V positions are stored in NewSelectBitmapHLoc & VLoc.
                           These change continually while the mouse and the selection are moving, they are only read on MouseUp to retain the position that it then
                           occupies.  Clearand... is called finally to clear earlier selection displays.
                           [New] - The only action here is to transfer the values of NewSelectBitmapHLoc & VLoc to SelectBitmapHLoc & VLoc so that the selection
                           stays in the same position (Clearand... checks whether the mouse is moving (both mbLeftDown & SelectPickedUp true) or stopped (either
                           mbLeftDown or SelectPickedUp false) and uses NewSelectBitmapHLoc & VLoc or SelectBitmapHLoc & SelectBitmapVLoc respectively.
        */
        {
            TrainController->LogEvent("MouseUp + Copy or CutMoving + mbLeftDown + SelectPickedUp");
            SelectBitmapHLoc = NewSelectBitmapHLoc;
            SelectBitmapVLoc = NewSelectBitmapVLoc;
        }
        mbLeftDown = false;
        Track->CalcHLocMinEtc(11);
        Utilities->CallLogPop(72);
    }
    catch(const Exception &e)
    {
        ErrorLog(23, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::MasterClockTimer(TObject *Sender)
{
    try
    {
        // don't call LogEvent here as would occur too often
        // have to allow in zoomout mode
        if(ErrorLogCalledFlag)
        {
            return; // don't continue after an error
        }
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MasterClockTimer");
        // put counter outside Clock2 as that may be missed
        LCResetCounter++;
// this checks LCs every 20 clock ticks (1 sec) & raises barriers if no route & no train present, to avoid delays due to too frequent calls
        if(LCResetCounter > 19)
        {
            LCResetCounter = 0;
        }
        WarningFlashCount++;
        if(WarningFlashCount > 4)
        {
            WarningFlashCount = 0;
        }
        if(WarningFlashCount == 0)
        {
            WarningFlash = !WarningFlash;
        }
        if(Utilities->CallLog.size() > 50) // use CTRL ALT 2 to see CallLogSize as program operates
        {
            throw Exception("Warning - Utilities->CallLog contains more than 50 items"); // check before clock stopped
        }
        if(!TrainController->StopTTClockFlag && (Level2OperMode == Operating))
        // stopped during 'Paused', when modal windows appear - Popup menu & ShowMessage, and at other times
        {
            // RestartTime is TTClockTime when operation pauses (timetable start time initially),
            // BaseTime is CurrentDateTime() when operation restarts

// clock speed multiplier
            double RealTimeDouble = double(TDateTime::CurrentDateTime() - TrainController->BaseTime);
            TrainController->TTClockTime = TDateTime(TTClockSpeed * RealTimeDouble) + TrainController->RestartTime;
// TrainController->TTClockTime = TDateTime::CurrentDateTime() - TrainController->BaseTime + TrainController->RestartTime;
        }

/*
//elapsed time investigations - lose ~20% of ticks when nothing loaded & ~30% for a busy session
//even lose ~20% without ClockTimer2.  but this is when running in IDE, try outside - exactly the same.
//see https://www.tek-tips.com/viewthread.cfm?qid=672717 - TTimer is very inaccurate, and the minimum interval is about 56ms because
//of the PC clock frequency which is about 18Hz, so it always runs slow at short intervals.  In light of this the 30% loss for a busy
//session isn't too bad, it represents about 12% loss in reality.

//Set breakpoint at int x = 4, load railway, start timer with Alt Ctrl 4 then check elapsed time when stops
//no need to reload between checks,

        if(ElapsedTimeTestFunctionStart) //set in test function CTRL ALT 4
        {
            Start = double(GetTime()) * 86400; //secs
            ElapsedTimerRunning = true;
            TotalTicks = 0;
            ElapsedTimeTestFunctionStart = false;
        }

        if(ElapsedTimerRunning && TotalTicks < 100) //should take 5secs at 50ms, it's about 6.25secs with nothing loaded
        {
            TotalTicks++;
        }
        else if(ElapsedTimerRunning && TotalTicks >= 100)
        {
            End = double(GetTime()) * 86400;
            ElapsedTimerRunning = false;

            ElapsedTime = End - Start; //secs

            int x = 4; //breakpoint
        }   //TrainController->TrainVector.size() <- Ctrl copy & paste into debugger window to examine
//end of elapsed time code
*/
        if(Utilities->Clock2Stopped)
        {
            Utilities->CallLogPop(774);
            return;
        }
        Utilities->Clock2Stopped = true; // don't allow overlapping calls
        ClockTimer2(0);
        Utilities->Clock2Stopped = false;
        Utilities->CallLogPop(73);

    }
    catch(const Exception &e)
    {
        ErrorLog(24, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::ClockTimer2(int Caller)
{
// called every 50mSec
    try
    {
        // have to allow in zoomout mode
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ClockTimer2");

        // dropped at 2.0.0 because RestoreFocusPanel->SetFocus(); hides the help screen
        // If a button holds focus then all that is needed is to click the screen and the arrow keys work correctly

/* Dropped when new .chm help file introduced at v2.0.0 - this hid it after ~20ms.  Replaced by a new section in
           MainScreenMouseDown where focus restored to screen when click anywhere on screen, allowing navigation keys to
           move screen when clicked if focus had been captured by another panel when these keys just cycle through the panel buttons

           bool FocusRestoreAllowedFlag = true; //added at v1.3.0

           if(TextBox->Focused() || DistanceBox->Focused() || SpeedLimitBox->Focused() || LocationNameTextBox->Focused() || MileEdit->Focused() || ChainEdit->Focused() || YardEdit->Focused() ||
                SpeedEditBox2->Focused() || LocationNameComboBox->Focused() || AddSubMinsBox->Focused() || SpeedEditBox->Focused() || PowerEditBox->Focused() || OneEntryTimetableMemo->Focused() ||
                AddPrefDirButton->Focused()) //Added at v1.3.0.  If any of these has focus then they keep it until they release it.  AddPrefDirButton is included as it should keep focus
            FocusRestoreAllowedFlag = false; //when it has it - eases the setting of PrefDirs, also this button becomes disabled after use so focus returns to Interface naturally

           if(!Focused() && FocusRestoreAllowedFlag && (GetAsyncKeyState(VK_LBUTTON) >= 0) && (GetAsyncKeyState(VK_RBUTTON) >= 0)) //condition added at v1.3.0 to ensure focus returned to
           //Interface (so arrow keys work to move screen) & not left at any of the buttons or other Windows controls
           //include the Windows API functions to test that the mouse buttons are not down (strictly only need left but user may have mapped the left onto the right so test both) - if not
           //tested then don't always respond to button clicks on navigation and other buttons because the focus can be grabbed back from the button by RestoreFocusPanel before the button
           //can respond (takes about 200mSec from click to response) a delay is also included to doubly avoid the button losing focus as above
            {
            ClockTimer2Count++; //doesn't matter what value it starts at on first use, it will soon revert to 0
            if(ClockTimer2Count > 10) ClockTimer2Count = 0; //half second delay
            if(ClockTimer2Count == 0)
                {
                RestoreFocusPanel->Visible = true;
                RestoreFocusPanel->Enabled = true;
                RestoreFocusPanel->BringToFront();
                //RestoreFocusPanel->SetFocus();    //to remove focus from anything else
                RestoreFocusPanel->Enabled = false; //to remove focus from RestoreFocusPanel & return it to Interface
                RestoreFocusPanel->Visible = false;
                }
            }
           else ClockTimer2Count = 0; //reset to 0 so ensure full delay occurs before RestoreFocusPanel grabs focus from anything else
*/
        CallLogTickerLabel->Caption = Utilities->CallLog.size(); // diagnostic test function to ensure all CallLogs are popped - visibility
        // toggled by 'Ctrl Alt 2' when Interface form has focus

        // set current time
        TDateTime Now = TrainController->TTClockTime;

        if((ActionsDueForm->Visible) && (LCResetCounter == 0)) //set every second, LCResetCounter used for convenience as that  resets every second
        {                                                      //delay is
            ADFTop = ActionsDueForm->Top; //stores the ADForm position for re-use when becomes visible.  This form intermittently jumped to other monitor
            ADFLeft = ActionsDueForm->Left; //but hasn't done it recently.  This is a safeguard to hopefully prevent it in future.
        }

        //repair any failed infrastructure
        //points
        if(!Track->FailedPointsVector.empty() && (Level2OperMode != Paused) && !TrainController->StopTTClockFlag) //don't repair if clock stopped or adj panel open
        {
            for(TTrack::TFailedElementVector::iterator FPVIt = Track->FailedPointsVector.begin(); FPVIt < Track->FailedPointsVector.end(); FPVIt++)
            {
                if(Now > FPVIt->RepairTime)
                {
                    Track->RepairFailedPoints(FPVIt);
                    break; //stop after repaired one as erased from vector, if others then will repair in later clock cycles
                }
            }
        }
        //signals
        if(!Track->FailedSignalsVector.empty() && (Level2OperMode != Paused) && !TrainController->StopTTClockFlag) //don't repair if clock stopped or adj panel open
        {
            for(TTrack::TFailedElementVector::iterator FPVIt = Track->FailedSignalsVector.begin(); FPVIt < Track->FailedSignalsVector.end(); FPVIt++)
            {
                if(Now > FPVIt->RepairTime)
                {
                    Track->RepairFailedSignals(FPVIt);
                    break; //stop after repaired one as erased from vector, if others then will repair in later clock cycles
                }
            }
        }
        //TSRs
        if(!Track->TSRVector.empty() && (Level2OperMode != Paused) && !TrainController->StopTTClockFlag) //don't repair if clock stopped or adj panel open
        {
            for(TTrack::TFailedElementVector::iterator FPVIt = Track->TSRVector.begin(); FPVIt < Track->TSRVector.end(); FPVIt++)
            {
                if(Now > FPVIt->RepairTime)
                {
                    Track->RepairTSR(FPVIt);
                    break; //stop after repaired one as erased from vector, if others then will repair in later clock cycles
                }
            }
        }

//check if Temporary Speed Restriction (TSR) needed - check every minute of timetable time - added at v2.13.0   //changed from 5 mins to 1 min at v2.14.0
        if((TrainController->TTClockTime - Utilities->LastTSRCheckTime) > TDateTime(1.0 / 1440))
        {
            //check due now
            if((Utilities->FailureMode != FNil) && !Track->SimpleVector.empty() && (Level2OperMode != Paused) && (Level2OperMode != PreStart) && !TrainController->StopTTClockFlag)
            {                                                                                 //(Level2OperMode != PreStart) added at v2.13.2 to prevent a TSR before starts
                Utilities->LastTSRCheckTime = TrainController->TTClockTime;
                int TSRRandVal = (Utilities->MTBTSRs * 1440) / Track->SimpleVector.size();  //1440 = no. of mins/day
                if(TSRRandVal < 2)
                {
                    TSRRandVal = 2; //in case so many simple elements that one fails every minute, this gives at least 2 mins between failures
                }
                if(random(TSRRandVal) == 0) //chance of one failure in the railway with MTBTSRs in days/simple element
                {
                    //now identify the specific simple element
                    int SimpleTVPos = Track->SimpleVector.at(random(Track->SimpleVector.size())); //vector of simple elements in the railway
                    TTrackElement &TE = Track->TrackElementAt(1531, SimpleTVPos);
                    if(!TE.Failed) //skip if already failed, added at v2.13.2 in response to Thomas Groenewold error file sent in 24/09/22
                    {              //error file showed that the same element had failed twice, so after repaired the first time .Failed was set to false
                                   //but the element remained in the TSRVector and crashed when tried to repair a second time
                        TTrack::TInfrastructureFailureEntry IFE;
                        IFE.TVPos = SimpleTVPos;
                        TE.Failed = true;
                        TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TE.SpeedLimit01; //store these values temporarily, points aren't bridges so can use these
                        TE.SpeedLimit01 = 10; //value while failed
                        Display->WarningLog(23, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Temporary Speed Restriction at " + TE.ElementID);
                        PerfLogForm->PerformanceLog(46, Utilities->Format96HHMMSS(TrainController->TTClockTime) + " WARNING: Temporary Speed Restriction at " + TE.ElementID);
                        TrainController->StopTTClockMessage(133, "Temporary Speed Restriction imposed at " + TE.ElementID +
                            "\nSpeed limit of 10km/hour applies until track repaired.");
                        AllRoutes->RebuildRailwayFlag = true; //force ClearandRebuildRailway at next clock tick
        //set repair time, random value in minutes between 10 and 179
                        double FailureMinutes = double(random(Utilities->MaxRandomRepairTime) + Utilities->FixedMinRepairTime); //between 10 and 179 minutes at random
                        TDateTime RepairTime = TrainController->TTClockTime + TDateTime(FailureMinutes / 1440);
                        IFE.RepairTime = RepairTime;
                        IFE.FailureTime = TrainController->TTClockTime;
                        Track->TSRVector.push_back(IFE);
                    }
                }
            }
        }
        if(!ActionsDueForm->ActionsDueListBox->MouseInClient) // added at v2.7.0 to reset this flag whenever mouse not in ActionsDueListBox
        {
            ActionsDueForm->ActionsDueListBoxRightMouseButtonDown = false;
        }
        if(!ClipboardChecked)
        {
            if((Level1Mode == TrackMode) && !SelectionValid && (ClpBrdValid != "RlyClpBrd_Cut") && (ClpBrdValid != "RlyClpBrdCopy"))
            // reset the menu for the new app (when !SelectionValid) & don't keep resetting when ClpBrdValid
            //before 2.10.0 one '&' was missing before '(ClpBrdValid != "RlyClpBrd_Cut")' making it into an address which would always be > 0 i.e.true
            {
                SetTrackModeEditMenu(2); // to reset the menu in case select a new app for pasting
                ClipboardChecked = true;
            }
        }
// Update Displayed Clock - resets to 0 at 96hours
        ClockLabel->Caption = Utilities->Format96HHMMSS(TrainController->TTClockTime);

//timers
        TrainController->OpTimeToActUpdateCounter++;
///<new v2.2.0, controls 1 second updating for OpTimeToActPanel
        if(TrainController->OpTimeToActUpdateCounter >= 20)
        {
            TrainController->OpTimeToActUpdateCounter = 0;
        }
        if(ActionsDueForm->Visible)
        {
            TrainController->OpActionPanelHintDelayCounter++;
        }
///<new v2.2.0, delay on start operation
        if(TrainController->OpActionPanelHintDelayCounter >= 60)
        {
            TrainController->OpActionPanelHintDelayCounter = 60; // new at v2.2.0
        }
        TrainController->RandomFailureCounter++; // new at v2.4.0 counts up for 53 seconds then resets
        if(TrainController->RandomFailureCounter >= 1060)
        {
            TrainController->RandomFailureCounter = 0;
        }

//multiplayer functions - disabled at v2.12.0 as not needed yet
/*
        PlayerFiveSecondTimer++; // new for multiplayer for player send cycle
        if(PlayerFiveSecondTimer >= 100)
        {
            PlayerFiveSecondTimer = 0;
        }

        PlayerOneSecondTimer++; // new for multiplayer for player cancel
        if(PlayerOneSecondTimer >= 20)
        {
            PlayerOneSecondTimer = 0;
        }

        HostMultiplayInProgressFlag = false;
        PlayerMultiplayInProgressFlag = false;
        if(MultiplayerHostPanel->Visible || HostInSessionFlag)
        {
            HostMultiplayInProgressFlag = true;
        }
        else if(MultiplayerPlayerPanel->Visible || PlayerInSessionFlag)
        {
            PlayerMultiplayInProgressFlag = true;
        }

        if(Level2OperMode == PreStart)
        {
            if(!MultiplayerHostPanel->Visible && !MultiplayerPlayerPanel->Visible)
            {
                MultiplayerMenu->Enabled = true;
                MultiplayerHostSessionMenuItem->Enabled = true;
                SaveMultiplayerSessionMenuItem->Enabled = false;
                EndSimulationMenuItem->Enabled = false;
                ShowHideStringGridMenuItem->Enabled = false;
                JoinMultiplayerSessionMenuItem->Enabled = true;
                ExitSimulationMenuItem->Enabled = false;
            }
            else
            {
                MultiplayerMenu->Enabled = false;
            }
        }

        if(HostInSessionFlag && !PlayerInSessionFlag)
        {

            MultiplayerMenu->Enabled = true;
            MultiplayerHostSessionMenuItem->Enabled = false;
            SaveMultiplayerSessionMenuItem->Enabled = true;
            EndSimulationMenuItem->Enabled = true;
            ShowHideStringGridMenuItem->Enabled = true;
            JoinMultiplayerSessionMenuItem->Enabled = false;
            ExitSimulationMenuItem->Enabled = false;
        }
        else if(!HostInSessionFlag && PlayerInSessionFlag)
        {

            MultiplayerMenu->Enabled = true;
            MultiplayerHostSessionMenuItem->Enabled = false;
            SaveMultiplayerSessionMenuItem->Enabled = false;
            EndSimulationMenuItem->Enabled = false;
            ShowHideStringGridMenuItem->Enabled = false;
            JoinMultiplayerSessionMenuItem->Enabled = false;
            ExitSimulationMenuItem->Enabled = true;
        }

        if(HostMultiplayInProgressFlag)
        {
            HostHandshakingActions();
        }
        else if(PlayerMultiplayInProgressFlag)
        {
            PlayerHandshakingActions();
        }
*/
//end of multiplayer functions

// Below added at v2.1.0 to ensure WholeRailwayMoving flag reset when not moving (when rh mouse button up) as sometimes misses
// MouseUp events, probably due to a clash between a moving event and a mouse up event. Note that checks that both mouse buttons are up because
// function only checks the physical buttons, not the logical buttons.  Most sig bit of return value set form key down.
        if(WholeRailwayMoving && (GetAsyncKeyState(VK_LBUTTON) >= 0) && (GetAsyncKeyState(VK_RBUTTON) >= 0))
        {
            WholeRailwayMoving = false;
            Screen->Cursor = TCursor(-2); // Arrow
        }
// save session if required
        if(SaveSessionFlag)
        {
            SaveSession(0);
            SaveSessionFlag = false;
        }
// load session if required
        if(LoadSessionFlag)
        {
            if(ClearEverything(3))
            {
                LoadSession(0);
            }
            LoadSessionFlag = false;
        }
// check if any LCs need barriers raising

        if((Level1Mode == OperMode) && ((Level2OperMode == Operating) || (Level2OperMode == PreStart)))
        {
            if((LCResetCounter == 0) && !TrainController->StopTTClockFlag)
            {
                for(int x = Track->BarriersDownVector.size() - 1; x >= 0; x--) // iterate downwards because erase element
                {
                    bool TrainPresent = false;
                    if(Track->AnyLinkedLevelCrossingElementsWithRoutesOrTrains(1, Track->BarriersDownVector.at(x).HLoc,
                                                                               Track->BarriersDownVector.at(x).VLoc, ConstructRoute->SearchVector, TrainPresent)) // returns true for route (set or being set) or train, and TrainPresent true if train on LC
                    {
                        if(TrainPresent)
                        {
                            Track->BarriersDownVector.at(x).ReducedTimePenalty = true;
// to allow 3 mins before time penalty starts to clock up, if no train passes then no time allowance
                        }
                    }
                    else
                    {
                        if(Track->BarriersDownVector.at(x).TypeOfRoute != 2) // added at v2.6.0 for manual LC operation
                        {
                            Track->LCChangeFlag = true;
                            TTrack::TActiveLevelCrossing CLC = Track->BarriersDownVector.at(x);
                            // check if have exceeded the allowance (3 minutes for a train having passed or 0 for not) and add it to the overall excess time
                            TDateTime TempExcessLCDownTime;
                            if(Track->BarriersDownVector.at(x).ReducedTimePenalty)
                            {
                                TempExcessLCDownTime = TrainController->TTClockTime - CLC.StartTime - TDateTime(180.0 / 86400);
                            }
                            else
                            {
                                TempExcessLCDownTime = TrainController->TTClockTime - CLC.StartTime;
                            }
                            if(TempExcessLCDownTime > TDateTime(0))
                            {
                                TrainController->ExcessLCDownMins += (double(TempExcessLCDownTime) * 1440);
                            }
                            CLC.StartTime = TrainController->TTClockTime; // reset these 3 members
                            CLC.ChangeDuration = Track->LevelCrossingBarrierUpFlashDuration;
                            CLC.BarrierState = TTrack::Raising;
                            Track->SetLinkedLevelCrossingBarrierAttributes(0, CLC.HLoc, CLC.VLoc, 2); // set attr to 2 for changing state
                            Track->ChangingLCVector.push_back(CLC);
                            Track->BarriersDownVector.erase(Track->BarriersDownVector.begin() + x);
                        }
                    }
                }
            }
        }
// clear LCChangeFlag if no LCs changing
        if(Track->ChangingLCVector.empty())
        {
            Track->LCChangeFlag = false;
        }
// remove any single route elements if operating, but only if not constructing a route, else if extending the single route
// element it may be removed prior to conversion & cause an error

// note that if a train enters at a continuation and a signal is next but one to the continuation then the route element at that
// signal won't be removed because the train's LagElement is still -1 and trains only remove route elements when LagElement is > -1.
// This also means that a preferred route can't be cancelled as it's under a train, but it's probably not worth adding a patch just for
// this, it shouldn't interfere with operation.
        if((Level1Mode == OperMode) && (Level2OperMode == Operating) && !Track->RouteFlashFlag)
        {
            bool ElementRemovedFlag = false; // introduced at v0.6 to avoid calling Clearand.... multiple times
            for(unsigned int x = 0; x < AllRoutes->AllRoutesSize(); x++)
            {
                if(AllRoutes->GetFixedRouteAt(187, x).PrefDirSize() == 1)
                {
                    // only allow route element to be removed if not selected for a route start otherwise StartSelectionRouteID will be
                    // set & will fail at convert
                    if(AllRoutes->GetFixedRouteAt(194, x).RouteID != ConstructRoute->StartSelectionRouteID.GetInt())
                    {
                        TPrefDirElement PDE = AllRoutes->GetFixedRouteAt(188, x).GetFixedPrefDirElementAt(198, 0);
                        // also don't remove if it links two automatic signal routes (reported by Daniel Gill for Darlington via discord on 13/12/20)
                        // added at v2.6.1
                        // note that a train will still remove the route element when it reaches it because of the 3rd condition below, but it will be removed when the train
                        // is half on the preceding element rather than fully on it, in other cases the train has to be fully on the element because the route only becomes a
                        // single element at that stage
                        unsigned int LinkFromTVNumber = Track->TrackElementAt(1007, PDE.GetTrackVectorPosition()).Conn[PDE.GetELinkPos()];
                        unsigned int LinkToTVNumber = Track->TrackElementAt(1008, PDE.GetTrackVectorPosition()).Conn[PDE.GetXLinkPos()];
                        int RouteNumber1, RouteNumber2, TrainID; // not used
                        if((AllRoutes->GetRouteTypeAndNumber(37, LinkFromTVNumber, PDE.GetELinkPos(), RouteNumber1) != TAllRoutes::AutoSigsRoute) ||
                           (AllRoutes->GetRouteTypeAndNumber(38, LinkToTVNumber, PDE.GetXLinkPos(), RouteNumber2) != TAllRoutes::AutoSigsRoute) ||
                           (Track->TrackElementAt(1009, LinkFromTVNumber).TrainIDOnElement > -1))
                        // don't need to test for it being a bridge as then LinkFromTVNumber can't be
                        // an autosigs route
                        {
                            AllRoutes->RemoveRouteElement(20, PDE.HLoc, PDE.VLoc, PDE.GetELink());
                            ElementRemovedFlag = true;
                            TrainController->LogEvent("SingleRouteElementRemoved, H = " + AnsiString(PDE.HLoc) + ", V = " + AnsiString(PDE.VLoc));
                        }
                    }
                }
            }
            if(!Display->ZoomOutFlag && ElementRemovedFlag)
            {
                ClearandRebuildRailway(66);
            }
            // if zoomed out ignore, will display correctly when zoom in
            // if leave the Zoomout condition out then the zoom out will spontaneously cancel and the track won't display because
            // PlotOutput returns if zoomed out, and the zoom out flag isn't reset until the end of Clearand.....
            // this was moved outside the for.. next.. loop in v0.6 as it could be called multiple times and slowed down operation (noticeable with a fast clock)
        }

// stop clock if hover over a warning
        bool WH1 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog1->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog1->Width + OutputLog1->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog1->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog1->Height + OutputLog1->Top))
            && OutputLog1->Caption != "";
        bool WH2 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog2->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog2->Width + OutputLog2->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog2->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog2->Height + OutputLog2->Top))
            && OutputLog2->Caption != "";
        bool WH3 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog3->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog3->Width + OutputLog3->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog3->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog3->Height + OutputLog3->Top))
            && OutputLog3->Caption != "";
        bool WH4 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog4->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog4->Width + OutputLog4->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog4->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog4->Height + OutputLog4->Top))
            && OutputLog4->Caption != "";
        bool WH5 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog5->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog5->Width + OutputLog5->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog5->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog5->Height + OutputLog5->Top))
            && OutputLog5->Caption != "";
        bool WH6 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog6->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog6->Width + OutputLog6->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog6->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog6->Height + OutputLog6->Top))
            && OutputLog6->Caption != "";
        bool WH7 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog7->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog7->Width + OutputLog7->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog7->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog7->Height + OutputLog7->Top))
            && OutputLog7->Caption != "";
        bool WH8 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog8->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog8->Width + OutputLog8->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog8->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog8->Height + OutputLog8->Top))
            && OutputLog8->Caption != "";
        bool WH9 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog9->Left) && (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog9->Width + OutputLog9->Left))
            && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog9->Top) && (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog9->Height + OutputLog9->Top))
            && OutputLog9->Caption != "";
        bool WH10 = (Mouse->CursorPos.x >= ClientOrigin.x + OutputLog10->Left) &&
            (Mouse->CursorPos.x < (ClientOrigin.x + OutputLog10->Width + OutputLog10->Left)) && (Mouse->CursorPos.y >= ClientOrigin.y + OutputLog10->Top) &&
            (Mouse->CursorPos.y < (ClientOrigin.y + OutputLog10->Height + OutputLog10->Top)) && OutputLog10->Caption != "";

        if(WH1 || WH2 || WH3 || WH4 || WH5 || WH6 || WH7 || WH8 || WH9 || WH10 || SkipTTActionsListBox->Visible)
        {
            if(!WarningHover)
            {
                TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
                TrainController->RestartTime = TrainController->TTClockTime;
                WarningHover = true;
            }
        }
        else if(WarningHover)
        {
            WarningHover = false;
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
        }

        //below added at v2.13.2 so focus restored after actions due or perflog windows take focus by enabling, disabling or
        //moving.  Otherwise the track info shortcut keys don't work (& probably others)
        bool MouseInInterface = ((Mouse->CursorPos.x >= ClientOrigin.x) && (Mouse->CursorPos.x < (ClientOrigin.x + Interface->Width))
        && (Mouse->CursorPos.y >= ClientOrigin.y) && (Mouse->CursorPos.y < (ClientOrigin.y + Interface->Height)));

        if(!Interface->Active && MouseInInterface)
        {
            Interface->SetFocus();
        }

// development panel - visibility toggled by 'Ctrl Alt 3' when Interface form has focus
        if(DevelopmentPanel->Visible)
        {
            int Position;
            TTrackElement TrackElement;
            AnsiString Type[15] =
            {
                "Simple", "Crossover", "Points", "Buffers", "Bridge", "SignalPost", "Continuation", "Platform", "GapJump", "FootCrossing", "Unused", "Concourse",
                "Parapet", "NamedNonStationLocation", "Erase"
            };

            int ScreenX = Mouse->CursorPos.x - MainScreen->ClientOrigin.x;
            int ScreenY = Mouse->CursorPos.y - MainScreen->ClientOrigin.y;
            int HLoc, VLoc;
            AnsiString MouseStr = "Posx: " + AnsiString(ScreenX) + "; Posy: " + AnsiString(ScreenY);
            DevelopmentPanel->Caption = CurDir + " " + MouseStr;
            Track->GetTrackLocsFromScreenPos(7, HLoc, VLoc, ScreenX, ScreenY);

            AnsiString InARoute = "No";    //added at v2.15.0 for diagnostics
            THVPair HVPair;
            HVPair.first = HLoc;
            HVPair.second = VLoc;
            int RouteNumber = 0;
            unsigned int RoutePrefDirPos = 0;
            TAllRoutes::TRoute2MultiMapIterator R2It;

            if(Track->FindNonPlatformMatch(1, HLoc, VLoc, Position, TrackElement))
            {
                if(AllRoutes->TrackIsInARoute(21, Position, 0)) //added at v2.15.0 for diagnostics
                {
                    InARoute = "Yes";
                    R2It = AllRoutes->Route2MultiMap.find(HVPair);
                    RouteNumber = R2It->second.first;
                    RoutePrefDirPos = R2It->second.second;
                }

                DevelopmentPanel->Caption = MouseStr + "; TVPos: " + AnsiString(Position) + "; H: " + AnsiString(HLoc) + "; V: " + AnsiString(VLoc) +
                    "; SpTg: " + AnsiString(TrackElement.SpeedTag) + "; Type: " + Type[TrackElement.TrackType] + "; Att: " + AnsiString(TrackElement.Attribute)
                    + "; TrID: " + AnsiString(TrackElement.TrainIDOnElement) + "; TrID01: " + AnsiString(TrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01) +
                    "; TrID23: " + AnsiString(TrackElement.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23) + "; " + TrackElement.LocationName + "; " +
                    TrackElement.ActiveTrackElementName + "; InRoute " + InARoute + "; RtNum " + RouteNumber + "; PDVecPos " + RoutePrefDirPos;
// + "; OAHintCtr: " + TrainController->OpActionPanelHintDelayCounter;
            }
            else
            {//below used in elapsed time investigations
//                DevelopmentPanel->Caption = FormatFloat("#####00.000", (ElapsedTime * 3600 * 24)) + " " + AnsiString(TotalTicks);
            }
        }
        if(Level1Mode == TimetableMode)
        {
/* These are for Shift Key shortcuts. Unless 'Click()' execution occurs after the key is pressed Windows stores the key until after any code is executed then selects
the timetable entry that begins with the letter corresponding to the key.  See DevHistory.txt for the version at v2.5.0 for details.

First make sure the selected entry is the Highlighted entry, but only if both mouse buttons are up, to make sure AllEntriesTTListBoxMouseUp runs first or TopIndex
likely to be set to the wrong position since when ...Selected... runs it sets TopIndex accordingly.  Then when  ...MouseUp runs it will use the wrong value and select
the entry that the mouse is now on rather than the one that was chosen.
Later addition: Set member variable AllEntriesTTListBox->TopIndex here if any flag set so when Copy or any other key function runs the top index is correct
*/
            if((GetKeyState(VK_LBUTTON) >= 0) && (GetKeyState(VK_RBUTTON) >= 0) && (TTCurrentEntryPtr != TimetableEditVector.end())) //no mouse key down & pointer > 0
            // high order bit set to 1 when button down, so arithmetically it is negative
            {
                // TTCurrentEntryPtr == 0 when create a timetable
                AllEntriesTTListBox->Selected[TTCurrentEntryPtr - TimetableEditVector.begin()] = true; //selects the current entry &
            }                                                                                          //makes it visible in the listbox
            if(AnyTTKeyFlagSet()) // true if any of the below flags set
            {
                AllEntriesTTListBox->TopIndex = AllEntriesTTListBoxTopPosition; // reset it to the value before the key press changes it (see FormKeyDown)
            }
            if(PreviousTTEntryKeyFlag)
            {
                PreviousTTEntryButton->Click();
                SetTopIndex(0);
                PreviousTTEntryKeyFlag = false;
            }
            else if(NextTTEntryKeyFlag)
            {
                NextTTEntryButton->Click();
                SetTopIndex(1);
                NextTTEntryKeyFlag = false;
            }
            else if(MoveTTEntryUpKeyFlag)
            {
                MoveTTEntryUpButton->Click();
                SetTopIndex(2);
                MoveTTEntryUpKeyFlag = false;
            }
            else if(MoveTTEntryDownKeyFlag)
            {
                MoveTTEntryDownButton->Click();
                SetTopIndex(3);
                MoveTTEntryDownKeyFlag = false;
            }
            else if(CopyTTEntryKeyFlag)
            {
                CopyTTEntryButton->Click();
                SetTopIndex(4);
                CopyTTEntryKeyFlag = false;
            }
            else if(InvertTTEntryKeyFlag)
            {
                InvertTTEntryButton->Click();
                SetTopIndex(19);
                InvertTTEntryKeyFlag = false;
            }
            else if(CutTTEntryKeyFlag)
            {
                CutTTEntryButton->Click();
                SetTopIndex(5);
                CutTTEntryKeyFlag = false;
            }
            else if(PasteTTEntryKeyFlag)
            {
                PasteTTEntryButton->Click();
                SetTopIndex(6);
                PasteTTEntryKeyFlag = false;
            }
            else if(DeleteTTEntryKeyFlag)
            {
                DeleteTTEntryButton->Click();
                SetTopIndex(7);
                DeleteTTEntryKeyFlag = false;
            }
            else if(NewTTEntryKeyFlag)
            {
                NewTTEntryButton->Click();
                SetTopIndex(8);
                NewTTEntryKeyFlag = false;
            }
            else if(AZOrderKeyFlag)
            {
                AZOrderButton->Click();
                SetTopIndex(9);
                AZOrderKeyFlag = false;
            }
            else if(TTServiceSyntaxCheckKeyFlag)
            {
                TTServiceSyntaxCheckButton->Click();
                SetTopIndex(12);
                TTServiceSyntaxCheckKeyFlag = false;
            }
            else if(ValidateTimetableKeyFlag)
            {
                ValidateTimetableButton->Click();
                SetTopIndex(13);
                ValidateTimetableKeyFlag = false;
            }
            else if(SaveTTKeyFlag)
            {
                SaveTTButton->Click();
                SetTopIndex(14);
                SaveTTKeyFlag = false;
            }
            else if(SaveTTAsKeyFlag)
            {
                SaveTTAsButton->Click();
                SetTopIndex(15);
                SaveTTAsKeyFlag = false;
            }
            else if(RestoreTTKeyFlag)
            {
                RestoreTTButton->Click();
                SetTopIndex(16);
                RestoreTTKeyFlag = false;
            }
            else if(ExportTTKeyFlag)
            {
                ExportTTButton->Click();
                SetTopIndex(17);
                ExportTTKeyFlag = false;
            }
            else if(ConflictAnalysisKeyFlag)
            {
                ConflictAnalysisButton->Click();
                SetTopIndex(18);
                ConflictAnalysisKeyFlag = false;
            }
// highlight timetable entry if in tt mode (have to call this regularly so will scroll with the listbox)
//dropped at v2.13.0 as clicking an entry does all that is required
/*
            if(!TimetableEditVector.empty() && (TTCurrentEntryPtr != TimetableEditVector.end()))
            {
                HighlightOneEntryInAllEntriesTTListBox(1, TTCurrentEntryPtr - TimetableEditVector.begin());
            }
            else
            {
                HighlightOneEntryInAllEntriesTTListBox(2, 0);
            }
*/
        }

// set cursor
        if(Track->PointFlashFlag || Track->RouteFlashFlag)
        {
            if(!TempCursorSet)
            {
                TempCursor = Screen->Cursor;
                TempCursorSet = true;
            }
            Screen->Cursor = TCursor(-11); // Hourglass
        }
        else
        {
            if(TempCursorSet)
            {
                Screen->Cursor = TempCursor;
                TempCursorSet = false;
            }
        }
        if(Level2OperMode == Operating)
        {
            TrainController->Operate(0); // ensure this called AFTER the single element route removal to ensure any single elements removed
                                         // prior to CallingOnAllowed being called (in UpdateTrain) as that sets a route from the stop signal
            if((TrainController->OpTimeToActUpdateCounter == 0) && (ActionsDueForm->Visible))
            {
                UpdateActionsDuePanel(0); // new at v2.2.0 to update panel when train OpTimeToAct updated (updated earlier)
            }
            TrainController->SignallerTrainRemovedOnAutoSigsRoute = false; // added at v1.3.0 to ensure doesn't persist beyond one call
        }
        else if((Level2OperMode == Paused) || (Level2OperMode == PreStart)) // added at v2.5.0 to show actions due after a session file reloaded
        {                                                                   // modified at v2.10.0 to add PreStart
            THVShortPair ExitPair;
            ExitPair.first = -1;
            ExitPair.second = -1;
            if((TrainController->OpTimeToActUpdateCounter == 0) && (ActionsDueForm->Visible))
            {
                for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
                {
                    float LastTimeToExit = TrainController->TrainVectorAt(78, x).TimeToExit;
                    TrainController->TrainVectorAt(73, x).OpTimeToAct = TrainController->TrainVectorAt(74, x).CalcTimeToAct(1, LastTimeToExit, ExitPair);
                    TrainController->TrainVectorAt(79, x).TimeToExit = LastTimeToExit; //this was updated in CalcTimeToAct
                    TrainController->TrainVectorAt(80, x).ExitPair = ExitPair;
                }
                TrainController->RebuildOpTimeToActMultimap(1);
                UpdateActionsDuePanel(1);
            }
            if(TrainController->OpTimeToActUpdateCounter == 0)
            {
                TrainController->RebuildTimeToExitMultiMap(1);
            }
        }

        // plot trains in ZoomOut mode & flash trains where attention needed alternately on & off at each call
// by examining Flash
        if((Level1Mode == OperMode) && (Display->ZoomOutFlag))
        {
            TrainController->PlotAllTrainsInZoomOutMode(0, WarningFlash);
        }
//deal with any manual LCs with barriers down in zoomout mode - these flash as reminder that need to re-open

        ManualLCDownAttentionWarning =  false;
        for(unsigned int x = 0; x < Track->BarriersDownVector.size(); x++)
        {
            if((Track->BarriersDownVector.at(x).BarrierState == TTrack::Down) && (Track->BarriersDownVector.at(x).TypeOfRoute == 2))
            {
                //manual crossing down, but maybe a route across it
                bool TrainPresent; //not used outside function
                if(!Track->AnyLinkedLevelCrossingElementsWithRoutesOrTrains(2, Track->BarriersDownVector.at(x).HLoc, Track->BarriersDownVector.at(x).VLoc,
                                                                            ConstructRoute->SearchVector, TrainPresent)) //no warning raised if a route or train present
                {
                    ManualLCDownAttentionWarning =  true;
                    if((WarningFlashCount == 0) && WarningFlash && Display->ZoomOutFlag)
                    {
                        Track->PlotSmallFlashingLinkedLevelCrossings(0, Track->BarriersDownVector.at(x).HLoc, Track->BarriersDownVector.at(x).VLoc,
                                                                     RailGraphics->smLC, Display); //smLC
                    }
                    else if((WarningFlashCount == 0) && !WarningFlash && Display->ZoomOutFlag)
                    {
                        Track->PlotSmallFlashingLinkedLevelCrossings(1, Track->BarriersDownVector.at(x).HLoc, Track->BarriersDownVector.at(x).VLoc,
                                                                     RailGraphics->smSolidBgnd, Display); //SMOrange
                    }
                }
            }
        }

// Deal with any flashing graphics
        if((WarningFlashCount == 0) && !TrainController->StopTTClockFlag)
        {
            FlashingGraphics(0, Now); // only call when WarningFlash changes
            if(Level1Mode == OperMode)
            {
                if(WarningFlash)
                {
                    if(TrainController->CrashWarning)
                    {
                        CrashImage->Visible = true;
                    }
                    if(TrainController->DerailWarning)
                    {
                        DerailImage->Visible = true;
                    }
                    if(TrainController->SPADWarning)
                    {
                        SPADImage->Visible = true;
                    }
                    if(TrainController->TrainFailedWarning)
                    {
                        TrainFailedImage->Visible = true;
                    }
                    if(TrainController->CallOnWarning)
                    {
                        CallOnImage->Visible = true;
                    }
                    if(TrainController->SignalStopWarning)
                    {
                        SignalStopImage->Visible = true;
                    }
                    if(TrainController->BufferAttentionWarning)
                    {
                        BufferAttentionImage->Visible = true;
                    }
                    if(ManualLCDownAttentionWarning) //added at v2.9.0
                    {
                        ManualLCDownImage->Visible = true;
                    }
                }
                else
                {
                    CrashImage->Visible = false;
                    DerailImage->Visible = false;
                    SPADImage->Visible = false;
                    TrainFailedImage->Visible = false;
                    CallOnImage->Visible = false;
                    SignalStopImage->Visible = false;
                    BufferAttentionImage->Visible = false;
                    ManualLCDownImage->Visible = false;
                }
            }
            else
            {
                CrashImage->Visible = false;
                DerailImage->Visible = false;
                SPADImage->Visible = false;
                TrainFailedImage->Visible = false;
                CallOnImage->Visible = false;
                SignalStopImage->Visible = false;
                BufferAttentionImage->Visible = false;
                ManualLCDownAttentionWarning = false;
            }
        } // if(WarningFlashCount == 0)

        // set buttons etc as appropriate
        SetSaveMenuAndButtons(0);
        // if forced route cancellation flag set redisplay to clear the cancelled route
        if(AllRoutes->RebuildRailwayFlag && !Display->ZoomOutFlag)
        {
            ClearandRebuildRailway(16);
//            AllRoutes->RebuildRailwayFlag = false;  //dropped at v2.14.0 & moved to ClearandRebuildRailway so it isn't called again if it is called before reaching this location
        }
        // deal with approach locking
        ApproachLocking(0, TrainController->TTClockTime);
        // deal with ContinuationAutoSigList
        ContinuationAutoSignals(0, TrainController->TTClockTime);
        // FloatingLabel function
        if((TrackInfoOnOffMenuItem->Caption == "Hide") || (TrainStatusInfoOnOffMenuItem->Caption == "Hide Status") ||
           (TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable"))
        {
            TrackTrainFloat(0);
        }
        else
        {
            FloatingPanel->Visible = false;
        }
        // PerformanceLog check function

        if(IsPerfLogFormObscuringFloatingLabel(0) && (ShowPerfLogForm))
        {
            PerfLogForm->Visible = false;
        }
        else
        {
            if(ShowPerfLogForm)
            {
                PerfLogForm->Visible = true;
            }
            else
            {
                PerfLogForm->Visible = false;
            }
        }
        if(IsActionsDueFormObscuringFloatingLabel(0) && (ShowActionsDueForm))
        {
            ActionsDueForm->Visible = false;
        }
        else
        {
            if(ShowActionsDueForm)
            {
                if(ActionsDueForm->Visible == false)
                {
                    ActionsDueForm->Top = ADFTop;
                    ActionsDueForm->Left = ADFLeft;
                }
                ActionsDueForm->Visible = true;
            }
            else
            {
                ActionsDueForm->Visible = false;
            }
        }

        // check if a moving train is present on a route-under-construction start element & cancel it if so
        if(RouteMode == RouteContinuing)
        {
            bool FoundFlag;
            int RouteStartVecPos;
            if(AutoSigsFlag)
            {
                RouteStartVecPos = Track->GetVectorPositionFromTrackMap(7, (AutoRouteStartMarker->GetHPos()) / 16, (AutoRouteStartMarker->GetVPos()) / 16,
                                                                        FoundFlag);
            }
            else if(PreferredRoute) // added at v2.7.0, was ConsecSignalsRoute
            {
                RouteStartVecPos = Track->GetVectorPositionFromTrackMap(8, (SigRouteStartMarker->GetHPos()) / 16, (SigRouteStartMarker->GetVPos()) / 16,
                                                                        FoundFlag);
            }
            else
            {
                RouteStartVecPos = Track->GetVectorPositionFromTrackMap(9, (NonSigRouteStartMarker->GetHPos()) / 16, (NonSigRouteStartMarker->GetVPos()) / 16,
                                                                        FoundFlag);
            }
            if(FoundFlag && (RouteStartVecPos > -1))
            {
                TTrackElement TrackElement = Track->TrackElementAt(485, RouteStartVecPos);
                if(TrackElement.TrainIDOnElement > -1)
                {
                    if(!(TrainController->TrainVectorAtIdent(2, TrackElement.TrainIDOnElement).Stopped()))
                    {
                        RevertToOriginalRouteSelector(10);
                        // replot train as above erases the front element of the train
                        TrainController->TrainVectorAtIdent(3, TrackElement.TrainIDOnElement).PlotTrain(1, Display);
                    }
                }
            }
        }
        Utilities->CallLogPop(81);
    }
    catch(const EIdException &e) //non-error catch
//if no response from peer then get a 'connection reset by peer' message which isn't valid
    {
//        ShowMessage(EIdExceptionSource + " " + e.Message); //<--temporary - remove this message eventually
        Utilities->CallLogPop(2406);
    }
    catch(const Exception &e)
    {
        ErrorLog(25, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CallingOnButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CallingOnButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CallingOnButtonClick");
        if(CallingOnButton->Down)
        {
            // CallingOnButton->Down = true;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "CALLING ON:  Select signal for call on";
        }
        else
        {
            // CallingOnButton->Down = false;
            RevertToOriginalRouteSelector(11);
        }
        AutoRouteStartMarker->PlotOriginal(29, Display); // if overlay not plotted will ignore
        SigRouteStartMarker->PlotOriginal(30, Display); // if overlay not plotted will ignore
        NonSigRouteStartMarker->PlotOriginal(31, Display); // if overlay not plotted will ignore
        CallingOnButton->Enabled = false;
// added at v1.3.0 to ensure doesn't retain focus - will be re-enabled during ClockTimer2 (in SetSaveMenuAndButtons) if required
        Utilities->CallLogPop(82);
    }
    catch(const Exception &e)
    {
        ErrorLog(26, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ScreenLeftButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("ScreenLeftButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ScreenLeftButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Screen->Cursor = TCursor(-11); // Hourglass;
        ScreenLeftButton->Enabled = false; // to make multiple key presses less likely (not entirely successful)
        if(!Display->ZoomOutFlag)
        {
            if(CtrlKey)
            {
                Display->DisplayOffsetH -= 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayOffsetH -= Utilities->ScreenElementWidth;
            }
            else
            {
                Display->DisplayOffsetH -= Utilities->ScreenElementWidth / 2;
            }
            ClearandRebuildRailway(22);
            if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
            {
                Display->PlotDashedRect(10, SelectRect);
            }
        }
        else
        {
            if(CtrlKey)
            {
                Display->DisplayZoomOutOffsetH -= 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayZoomOutOffsetH -= (4 * Utilities->ScreenElementWidth);
            }
            else
            {
                Display->DisplayZoomOutOffsetH -= Utilities->ScreenElementWidth;
            }
            Display->ClearDisplay(0);
            Track->PlotSmallRailway(2, Display);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(0);
            }
        }
        ScreenLeftButton->Enabled = true;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(83);
    }
    catch(const Exception &e)
    {
        ErrorLog(27, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ScreenRightButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("ScreenRightButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ScreenRightButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Screen->Cursor = TCursor(-11); // Hourglass;
        ScreenRightButton->Enabled = false; // to make multiple key presses less likely (not entirely successful)
        if(!Display->ZoomOutFlag)
        {
            if(CtrlKey)
            {
                Display->DisplayOffsetH += 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayOffsetH += Utilities->ScreenElementWidth;
            }
            else
            {
                Display->DisplayOffsetH += Utilities->ScreenElementWidth / 2;
            }
            ClearandRebuildRailway(23);
            if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
            {
                Display->PlotDashedRect(4, SelectRect);
            }
        }
        else
        {
            if(CtrlKey)
            {
                Display->DisplayZoomOutOffsetH += 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayZoomOutOffsetH += (4 * Utilities->ScreenElementWidth);
            }
            else
            {
                Display->DisplayZoomOutOffsetH += Utilities->ScreenElementWidth;
            }
            Display->ClearDisplay(1);
            Track->PlotSmallRailway(3, Display);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(1);
            }
        }
        ScreenRightButton->Enabled = true;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(84);
    }
    catch(const Exception &e)
    {
        ErrorLog(28, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ScreenDownButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("ScreenDownButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ScreenDownButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Screen->Cursor = TCursor(-11); // Hourglass;
        ScreenDownButton->Enabled = false; // to make multiple key presses less likely (not entirely successful)
        // BUT - it does prevent it from retaining focus - so can use the cursor keys to scroll the display without being captured by the buttons
        if(!Display->ZoomOutFlag)
        {
            if(CtrlKey)
            {
                Display->DisplayOffsetV += 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayOffsetV += Utilities->ScreenElementHeight;
            }
            else
            {
                Display->DisplayOffsetV += Utilities->ScreenElementHeight / 2;
            }
            ClearandRebuildRailway(24);
            if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
            {
                Display->PlotDashedRect(5, SelectRect);
            }
        }
        else
        {
            if(CtrlKey)
            {
                Display->DisplayZoomOutOffsetV += 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayZoomOutOffsetV += (4 * Utilities->ScreenElementHeight);
            }
            else
            {
                Display->DisplayZoomOutOffsetV += Utilities->ScreenElementHeight;
            }
            Display->ClearDisplay(2);
            Track->PlotSmallRailway(4, Display);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(2);
            }
        }
        ScreenDownButton->Enabled = true;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(85);
    }
    catch(const Exception &e)
    {
        ErrorLog(29, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ScreenUpButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("ScreenUpButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ScreenUpButtonClick" + AnsiString((short)ShiftKey) + AnsiString((short)CtrlKey));
        Screen->Cursor = TCursor(-11); // Hourglass;
        ScreenUpButton->Enabled = false; // to make multiple key presses less likely (not entirely successful)
        if(!Display->ZoomOutFlag)
        {
            if(CtrlKey)
            {
                Display->DisplayOffsetV -= 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayOffsetV -= Utilities->ScreenElementHeight;
            }
            else
            {
                Display->DisplayOffsetV -= Utilities->ScreenElementHeight / 2;
            }
            ClearandRebuildRailway(25);
            if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
            {
                Display->PlotDashedRect(6, SelectRect);
            }
        }
        else
        {
            if(CtrlKey)
            {
                Display->DisplayZoomOutOffsetV -= 2;
            }
            else if(ShiftKey)
            {
                Display->DisplayZoomOutOffsetV -= (4 * Utilities->ScreenElementHeight);
            }
            else
            {
                Display->DisplayZoomOutOffsetV -= Utilities->ScreenElementHeight;
            }
            Display->ClearDisplay(3);
            Track->PlotSmallRailway(5, Display);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(3);
            }
        }
        ScreenUpButton->Enabled = true;
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(86);
    }
    catch(const Exception &e)
    {
        ErrorLog(30, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::ZoomButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("ZoomButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ZoomButtonClick");
        Screen->Cursor = TCursor(-11); // Hourglass;
        ZoomButton->Enabled = false; // this takes focus away so the arrow keys can move the display (v2.0.0)
        if(Display->ZoomOutFlag) // i.e resume zoomed in view
        {
            TrainController->LogEvent("ZoomButtonClick + ZoomOutFlag");
// TLevel2OperMode TempLevel2OperMode = Level2OperMode;
            if(Level1Mode == BaseMode)
            {
                InfoPanel->Visible = false; // reset infopanel in case not set later
                InfoPanel->Caption = "";
                SetLevel1Mode(18);
            }
            else if(Level1Mode == TrackMode)
            {
                InfoPanel->Visible = false; // reset infopanel in case not set later
                InfoPanel->Caption = "";
                // set edit menu items
                SetTrackModeEditMenu(3);
                SetLevel2TrackMode(33); // revert to earlier track mode from zoom
            }
            else if(Level1Mode == PrefDirMode)
            {
                if(Level2PrefDirMode != PrefDirContinuing)
                {
                    SetLevel1Mode(19); // to redisplay infopanel caption "...select start..."
                }
                else
                {
                    SetLevel2PrefDirMode(4); // revert to PrefDirContinuing PrefDir mode
                }
            }
// else if(Level1Mode == TrackMode) SetLevel1Mode();//just revert to basic track mode from zoom
// else if(Level1Mode == PrefDirMode) SetLevel1Mode();//just revert to basic PrefDir mode from zoom
            else if(Level1Mode == TimetableMode)
            {
                InfoPanel->Visible = false;
            }
            // Don't include OperMode or RestartSessionOperMode as they reset the performance file
            else if(Level2OperMode == Operating) // similar to SetLevel2OperMode but without resetting BaseTime
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "PauseGraphic");
                ExitOperationButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(1);
            }
            else if(Level2OperMode == Paused) // similar to SetLevel2OperMode but without resetting RestartTime
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
                ExitOperationButton->Enabled = true;
                TTClockAdjButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(5);
                DisableRouteButtons(1);
            }
            else if(Level2OperMode == PreStart)
            {
                OperateButton->Enabled = true;
                OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
                ExitOperationButton->Enabled = true;
                TTClockAdjButton->Enabled = true;
                SetRouteButtonsInfoCaptionAndRouteNotStarted(9);
            }
            Display->ZoomOutFlag = false; // reset this after level modes called so gap flash stays set if set to begin with
            SetPausedOrZoomedInfoCaption(1);
            ClearandRebuildRailway(43); // need to call this after ZoomOutFlag reset to display track, even if Clearand... already called
                                        // earlier during level mode setting - because until ZoomOutFlag reset PlotOutput plots nothing
        }
        else // set zoomed out view
        {
            TrainController->LogEvent("ZoomButtonClick + != ZoomOutFlag");
            Display->ZoomOutFlag = true;
            SetPausedOrZoomedInfoCaption(2);
            FileMenu->Enabled = false;
            ModeMenu->Enabled = false;
            EditMenu->Enabled = false;
            TextBox->Visible = false;
            LocationNameTextBox->Visible = false;
            TTClockAdjButton->Enabled = false;
// DisablePanelsStoreMainMenuStates();//ensure Display->ZoomOutFlag set true before calling
            // start assuming normal view is at centre of ZoomOut & calc excesses at each side
            int OVOffH_NVCentre = Display->DisplayOffsetH - (1.5 * Utilities->ScreenElementWidth);
// start zoomout centre at DisplayOffsetH + 30 - zoomout width/2 = -(1.5 * 60)
            int LeftExcess = OVOffH_NVCentre - Track->GetHLocMin();
            int RightExcess = Track->GetHLocMax() - OVOffH_NVCentre - ((4 * Utilities->ScreenElementWidth) - 1);
            if((LeftExcess > 0) && (RightExcess > 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre;
            }
            else if((LeftExcess > 0) && (RightExcess <= 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre + ((RightExcess) / (Utilities->ScreenElementWidth / 2)) *
                    (Utilities->ScreenElementWidth / 2); // normalise to nearest screen
            }
            else if((LeftExcess <= 0) && (RightExcess > 0))
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre - ((LeftExcess) / (Utilities->ScreenElementWidth / 2)) * (Utilities->ScreenElementWidth / 2);
            }
            else
            {
                Display->DisplayZoomOutOffsetH = OVOffH_NVCentre; // no excess at either side, so display in centre

            }
            int OVOffV_NVCentre = Display->DisplayOffsetV - (1.5 * Utilities->ScreenElementHeight);
            int TopExcess = OVOffV_NVCentre - Track->GetVLocMin();
            int BotExcess = Track->GetVLocMax() - OVOffV_NVCentre - ((4 * Utilities->ScreenElementHeight) - 1);
            if((TopExcess > 0) && (BotExcess > 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre;
            }
            else if((TopExcess > 0) && (BotExcess <= 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre + ((BotExcess) / (Utilities->ScreenElementHeight / 2)) *
                    (Utilities->ScreenElementHeight / 2); // normalise to nearest half screen
            }
            else if((TopExcess <= 0) && (BotExcess > 0))
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre - ((TopExcess) / (Utilities->ScreenElementHeight / 2)) * (Utilities->ScreenElementHeight / 2);
            }
            else
            {
                Display->DisplayZoomOutOffsetV = OVOffV_NVCentre; // no excess at either side, so display in centre

            }
            Display->ClearDisplay(4);
            Track->PlotSmallRailway(6, Display);
            TrainController->PlotAllTrainsInZoomOutMode(1, WarningFlash);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(4);
            }
            ZoomButton->Glyph->LoadFromResourceName(0, "ZoomIn");
        }
        Screen->Cursor = TCursor(-2); // Arrow
        ZoomButton->Enabled = true; // restore, see above
        Utilities->CallLogPop(87);
    }
    catch(const Exception &e)
    {
        ErrorLog(31, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::HomeButtonClick(TObject *Sender)
{
    try
    {
        // have to allow in zoomout mode
        TrainController->LogEvent("HomeButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",HomeButtonClick");
        Screen->Cursor = TCursor(-11); // Hourglass;
        HomeButton->Enabled = false; // this takes focus away so the arrow keys can move the display (v2.0.0)
        if(!Display->ZoomOutFlag) // zoomed in mode
        {
            TrainController->LogEvent("HomeButtonClick + zoomed in mode");
            Display->ResetZoomInOffsets();
            ClearandRebuildRailway(27);
            if((Level2TrackMode == TrackSelecting) || (Level2PrefDirMode == PrefDirSelecting))
            {
                Display->PlotDashedRect(7, SelectRect);
            }
        }
        else
        {
            // zoomed out mode
            // start assuming normal view is at centre of ZoomOut & calc excesses at each side
            TrainController->LogEvent("HomeButtonClick + zoomed out mode");
            Display->ResetZoomOutOffsets();
            Display->ClearDisplay(9);
            Track->PlotSmallRailway(7, Display);
            if(Level2TrackMode == GapSetting)
            {
                Track->PlotSmallRedGap(5);
            }
        }
        Screen->Cursor = TCursor(-2); // Arrow
        HomeButton->Enabled = true; // restore, see above
        Utilities->CallLogPop(88);
    }
    catch(const Exception &e)
    {
        ErrorLog(32, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::NewHomeButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("NewHomeButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",NewHomeButtonClick");
        NewHomeButton->Enabled = false; // this takes focus away so the arrow keys can move the display (v2.0.0)
        if(!Display->ZoomOutFlag) // zoomed in mode
        {
            Display->DisplayOffsetHHome = Display->DisplayOffsetH;
            Display->DisplayOffsetVHome = Display->DisplayOffsetV;
            ResetChangedFileDataAndCaption(23, false); // false because no major changes made
        }
        else
        {
            Display->DisplayZoomOutOffsetHHome = Display->DisplayZoomOutOffsetH;
            Display->DisplayZoomOutOffsetVHome = Display->DisplayZoomOutOffsetV;
        }
        Utilities->CallLogPop(1188);
        NewHomeButton->Enabled = true; // restore, see above
    }
    catch(const Exception &e)
    {
        ErrorLog(174, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::EditMenuClick(TObject *Sender)
// added at v2.1.0 to allow CTRL+X, CTRL+C & CTRL+V in edit menu (see case BaseMode for more information)
{
    try
    {
        CopyMenuItem->ShortCut = TextToShortCut("Ctrl+C");
        CutMenuItem->ShortCut = TextToShortCut("Ctrl+X");
        PasteMenuItem->ShortCut = TextToShortCut("Ctrl+V");
    }
    catch(const Exception &e)
    {
        ErrorLog(196, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::SelectMenuItemClick(TObject *Sender)
{
// draw a rectangle with the left mouse button, enclosing whole 16 x 16 squares
    try
    {
        TrainController->LogEvent("SelectMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SelectMenuItemClick");
        if(Level1Mode == TrackMode)
        {
            SelectionValid = false;
            Level2TrackMode = TrackSelecting;
            SetLevel2TrackMode(34);
            if(!PasteWarningSentFlag)
            {
                ShowMessage("Please be aware when pasting that anything inside the pasted area will be overwritten.\n\nThis warning will not be shown again.");
                PasteWarningSentFlag = true;
            }
        }
        else if(Level1Mode == PrefDirMode)
        {
            Level2PrefDirMode = PrefDirSelecting;
            SetLevel2PrefDirMode(5);
        }
        Utilities->CallLogPop(1189);
    }
    catch(const Exception &e)
    {
        ErrorLog(145, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::ReselectMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ReselectMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ReselectMenuItemClick");
        if((SelectBitmap->Height == 0) || (SelectBitmap->Width == 0))
        {
            Utilities->CallLogPop(1424);
            return;
        }
        int TLHCH = SelectBitmapHLoc;
        int TLHCV = SelectBitmapVLoc;
        int BRHCH = TLHCH + (SelectBitmap->Width / 16);
        int BRHCV = TLHCV + (SelectBitmap->Height / 16);
        TRect NewSelectRect(TLHCH, TLHCV, BRHCH, BRHCV);
        SelectRect = NewSelectRect;
        Display->PlotDashedRect(8, SelectRect);
        // set bitmap to reselected area (may be different if flip or mirror had been selected earlier)
        TRect Dest(0, 0, SelectBitmap->Width, SelectBitmap->Height);
        TRect Source(((SelectRect.left - Display->DisplayOffsetH) * 16), ((SelectRect.top - Display->DisplayOffsetV) * 16),
                     ((SelectRect.right - Display->DisplayOffsetH) * 16), ((SelectRect.bottom - Display->DisplayOffsetV) * 16));
        SelectBitmap->Canvas->CopyRect(Dest, MainScreen->Canvas, Source);

        SelectionValid = true;
        ReselectMenuItem->Enabled = false;
        CutMenuItem->Enabled = true;
        CopyMenuItem->Enabled = true;
        FlipMenuItem->Enabled = true;
        MirrorMenuItem->Enabled = true;
        RotRightMenuItem->Enabled = true;
        RotLeftMenuItem->Enabled = true;
        RotateMenuItem->Enabled = true;
        PasteMenuItem->Enabled = false;
        DeleteMenuItem->Enabled = true;
        if(Track->IsTrackFinished())
        {
            SelectLengthsMenuItem->Enabled = true; // only permit if finished because reverts to DistanceStart
        }
        else
        {
            SelectLengthsMenuItem->Enabled = false; // and that can only be used if track linked
        }
        SelectBiDirPrefDirsMenuItem->Visible = false;
        CheckPrefDirConflictsMenuItem->Visible = false;
        CancelSelectionMenuItem->Enabled = true;
        mbLeftDown = false;
        // Level1Mode = TrackMode;
        // SetLevel1Mode(68);
        Level2TrackMode = TrackSelecting;
        SetLevel2TrackMode(47);
        Utilities->CallLogPop(1425);
    }
    catch(const Exception &e)
    {
        ErrorLog(146, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::CutMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CutMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CutMenuItemClick");
        // Level1Mode = TrackMode;
        // SetLevel1Mode(69);
        CopySelected = false; // new at v2.8.0
        LoadClipboard(0); // new at v2.8.0
        Level2TrackMode = CutMoving;
        SetLevel2TrackMode(35);
        Utilities->CallLogPop(1190);
    }
    catch(const Exception &e)
    {
        ErrorLog(147, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::CopyMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CopyMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CopyMenuItemClick");
        // Level1Mode = TrackMode;
        // SetLevel1Mode(70);
        CopySelected = true; // new at v2.8.0
        LoadClipboard(1); // new at v2.8.0
        Level2TrackMode = CopyMoving;
        SetLevel2TrackMode(36);
        Utilities->CallLogPop(1191);
    }
    catch(const Exception &e)
    {
        ErrorLog(148, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::FlipMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("FlipMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",FlipMenuItemClick");
        // reset values in SelectVector
        int VerSum = SelectRect.top + SelectRect.bottom - 1;
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            // Note:  (changed again in v2.4.0 to keep attributes) need to change flip, mirror & 180deg functions as only change speedtag without changing anything else.
            // This didn't matter before new paste with attributes added at v2.2.0 as a new element was built from the speedtag,
            // but now if do a reselect then cut and paste with attributes the wrong graphic is pasted and all other attributes
            // are wrong. Need to rebuild a new TrackElement from the new speedtag and use that in the select vector.
            // Note that if use Flip, mirror etc then all attributes lost anyway so ok to build a basic element.
            int VLoc = VerSum - Track->SelectVectorAt(8, x).VLoc;
            int HLoc = Track->SelectVectorAt(7, x).HLoc;
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(0, Track->FlipArray[Track->SelectVectorAt(0, x).SpeedTag]);
            TE.VLoc = VLoc;
            TE.HLoc = HLoc;

            TE.ActiveTrackElementName = Track->SelectVectorAt(37, x).ActiveTrackElementName; // these new in v2.4.0 so keeps attributes
            TE.LocationName = Track->SelectVectorAt(38, x).LocationName;
            TE.Length01 = Track->SelectVectorAt(39, x).Length01;
            TE.Length23 = Track->SelectVectorAt(40, x).Length23;
            TE.SpeedLimit01 = Track->SelectVectorAt(41, x).SpeedLimit01;
            TE.SpeedLimit23 = Track->SelectVectorAt(42, x).SpeedLimit23;
            TE.SigAspect = Track->SelectVectorAt(43, x).SigAspect;
            Track->SelectVectorAt(26, x) = TE;
        }

        int FlipLinkArray[10] = 
        {
            0, 7, 8, 9, 4, 5, 6, 1, 2, 3
        };                                                      //0 & 5 are never used

        TrainController->LogEvent("Flip-track ok");
        // now reset the pref dirs
        for(unsigned int x = 0; x < SelectPrefDir->PrefDirSize(); x++)
        {
            int OriginalHLoc = SelectPrefDir->PrefDirVector.at(x).HLoc;  //added at v2.9.1
            int OriginalVLoc = SelectPrefDir->PrefDirVector.at(x).VLoc;
            int VLoc = VerSum - SelectPrefDir->PrefDirVector.at(x).VLoc;
            int HLoc = SelectPrefDir->PrefDirVector.at(x).HLoc;
            int ELink = FlipLinkArray[SelectPrefDir->PrefDirVector.at(x).GetELink()];
            int XLink = FlipLinkArray[SelectPrefDir->PrefDirVector.at(x).GetXLink()];
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(6, Track->FlipArray[SelectPrefDir->PrefDirVector.at(x).SpeedTag]);
            //the above line caused errors when Track->GetTrackElementFromAnyTrackMap in RecoverClipboard had Vector passed in by value,
            //causing a bad returned value for SpeedTag and other properties.  Passing it in by reference fixed it
            TPrefDirElement PDE(TE);  //this has Link[4]
            PDE.HLoc = HLoc;
            PDE.VLoc = VLoc;
            PDE.SetELink(ELink);
            PDE.SetXLink(XLink);
            bool ELinkPosFound = false, XLinkPosFound = false; //these ensure that the link pos is set as low as possible for points
            for(int y = 0; y < 4; y++)  //changed to y at v2.9.1
            {
                if(!ELinkPosFound && (PDE.Link[y] == ELink))
                {
                    PDE.SetELinkPos(y);
                    ELinkPosFound = true;
                }
                if(!XLinkPosFound && (PDE.Link[y] == XLink))
                {
                    PDE.SetXLinkPos(y);
                    XLinkPosFound = true;
                }
            }
            //set the CheckCount as before - added at v2.9.1
            PDE.SetCheckCount(9); //explicitly set to 9 at v2.9.2
            PDE.SetEXGraphicPtr(PDE.GetPrefDirGraphicPtr());
            PDE.SetEntryDirectionGraphicPtr(PDE.GetDirectionPrefDirGraphicPtr());

            //set the TrackVectorPosition to correspond to the corresponding TrackElement added at v2.9.1
            bool FoundFlag = false;
            PDE.SetTrackVectorPosition(Track->GetVectorPositionFromTrackMap(61, OriginalHLoc, OriginalVLoc, FoundFlag));  //uses original TV position as TrackMap hasn't changed yet
            if(PDE.GetSignedIntTrackVectorPosition() < 0)
            {
                FoundFlag = false; //probably will be anyway but reset to be sure & test below
            }
            //!PDE.EntryExitNumber() sets the EntryExitNumber
            if(!PDE.EntryExitNumber() || !ELinkPosFound || !XLinkPosFound || !FoundFlag) //error if can't set the number, any link pos not set or !FoundFlag
            {
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                ShowMessage("Unable to re-orientate the preferred directions, these won't be set in the rotated selection");
                break;
            }
            SelectPrefDir->PrefDirVector.at(x) = PDE;
        }

        TrainController->LogEvent("Flip-prefdirs ok");
        // reset values in SelectTextVector
        for(unsigned int x = 0; x < TextHandler->SelectTextVectorSize(0); x++)
        {
            TTextItem *TextItem = TextHandler->SelectTextPtrAt(0, x);
            // also subtract font height, brings position approximately right
            TextItem->VPos = ((VerSum * 16) + 15) - TextItem->VPos - abs(TextItem->Font->Height);
        }
        TrainController->LogEvent("Flip-text ok");
        // reset values in SelectGraphicVector so the midpoint of the graphic flips about the midline of the selection
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidVPosBeforeFlip = Track->SelectGraphicVector.at(x).VPos + (Track->SelectGraphicVector.at(x).Height) / 2;
            int MidVPosAfterFlip = ((VerSum * 16) + 15) - MidVPosBeforeFlip;
            int TopPosAfterFlip = MidVPosAfterFlip - (Track->SelectGraphicVector.at(x).Height) / 2;
            Track->SelectGraphicVector.at(x).VPos = TopPosAfterFlip;
        }
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(48);
        Utilities->CallLogPop(1426);
    }
    catch(const Exception &e)
    {
        ErrorLog(149, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::MirrorMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MirrorMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MirrorMenuItemClick");
        // reset values in SelectVector
        int HorSum = SelectRect.left + SelectRect.right - 1;
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            // See note above for FlipMenuItem relating to mods for v2.2.0
            int VLoc = Track->SelectVectorAt(22, x).VLoc;
            int HLoc = HorSum - Track->SelectVectorAt(6, x).HLoc;
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(1, Track->MirrorArray[Track->SelectVectorAt(27, x).SpeedTag]);
            TE.VLoc = VLoc;
            TE.HLoc = HLoc;

            TE.ActiveTrackElementName = Track->SelectVectorAt(44, x).ActiveTrackElementName; // these new in v2.4.0 so keeps attributes
            TE.LocationName = Track->SelectVectorAt(45, x).LocationName;
            TE.Length01 = Track->SelectVectorAt(46, x).Length01;
            TE.Length23 = Track->SelectVectorAt(47, x).Length23;
            TE.SpeedLimit01 = Track->SelectVectorAt(48, x).SpeedLimit01;
            TE.SpeedLimit23 = Track->SelectVectorAt(49, x).SpeedLimit23;
            TE.SigAspect = Track->SelectVectorAt(50, x).SigAspect;

// if(Track->SelectVectorAt(28, x).TrackType == SignalPost) TE.SigAspect = Track->SelectVectorAt(29, x).SigAspect;//TrackType will be the same
            Track->SelectVectorAt(30, x) = TE;
// Track->SelectVectorAt(, x).HLoc = HorSum - Track->SelectVectorAt(, x).HLoc;
// Track->SelectVectorAt(, x).SpeedTag = Track->MirrorArray[Track->SelectVectorAt(, x).SpeedTag];
        }

        int MirrorLinkArray[10] = 
        {
            0, 3, 2, 1, 6, 5, 4, 9, 8, 7
        };                                                        //0 & 5 are never used

        TrainController->LogEvent("Mirror-track ok");
        // now reset the pref dirs
        for(unsigned int x = 0; x < SelectPrefDir->PrefDirSize(); x++)
        {
            int OriginalHLoc = SelectPrefDir->PrefDirVector.at(x).HLoc;  //added at v2.9.1
            int OriginalVLoc = SelectPrefDir->PrefDirVector.at(x).VLoc;
            int HLoc = HorSum - SelectPrefDir->PrefDirVector.at(x).HLoc;
            int VLoc = SelectPrefDir->PrefDirVector.at(x).VLoc;
            int ELink = MirrorLinkArray[SelectPrefDir->PrefDirVector.at(x).GetELink()];
            int XLink = MirrorLinkArray[SelectPrefDir->PrefDirVector.at(x).GetXLink()];
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(7, Track->MirrorArray[SelectPrefDir->PrefDirVector.at(x).SpeedTag]);
            //the above line caused errors when Track->GetTrackElementFromAnyTrackMap in RecoverClipboard had Vector passed in by value,
            //causing a bad returned value for SpeedTag and other properties.  Passing it in by reference fixed it
            TPrefDirElement PDE(TE);  //this has Link[4]
            PDE.HLoc = HLoc;
            PDE.VLoc = VLoc;
            PDE.SetELink(ELink);
            PDE.SetXLink(XLink);
            bool ELinkPosFound = false, XLinkPosFound = false; //these ensure that the link pos is set as low as possible for points
            for(int y = 0; y < 4; y++)  //changed to y at v2.9.1
            {
                if(!ELinkPosFound && (PDE.Link[y] == ELink))
                {
                    PDE.SetELinkPos(y);
                    ELinkPosFound = true;
                }
                if(!XLinkPosFound && (PDE.Link[y] == XLink))
                {
                    PDE.SetXLinkPos(y);
                    XLinkPosFound = true;
                }
            }
            //set the CheckCount as before - added at v2.9.1
            PDE.SetCheckCount(9); //explicitly set to 9 at v2.9.2
            PDE.SetEXGraphicPtr(PDE.GetPrefDirGraphicPtr());
            PDE.SetEntryDirectionGraphicPtr(PDE.GetDirectionPrefDirGraphicPtr());
            //set the TrackVectorPosition to correspond to the corresponding TrackElement added at v2.9.1
            bool FoundFlag = false;
            PDE.SetTrackVectorPosition(Track->GetVectorPositionFromTrackMap(62, OriginalHLoc, OriginalVLoc, FoundFlag));  //uses original TV position as TrackMap hasn't changed yet
            if(PDE.GetSignedIntTrackVectorPosition() < 0)
            {
                FoundFlag = false; //probably will be anyway but reset to be sure & test below
            }
            //!PDE.EntryExitNumber() sets the EntryExitNumber
            if(!PDE.EntryExitNumber() || !ELinkPosFound || !XLinkPosFound || !FoundFlag) //error if can't set the number, any link pos not set or !FoundFlag
            {
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                ShowMessage("Unable to re-orientate the preferred directions, these won't be set in the rotated selection");
                break;
            }
            SelectPrefDir->PrefDirVector.at(x) = PDE;
        }

        TrainController->LogEvent("Mirror-PDs ok");
        // reset values in SelectTextVector
        for(unsigned int x = 0; x < TextHandler->SelectTextVectorSize(1); x++)
        {
            TTextItem *TextItem = TextHandler->SelectTextPtrAt(1, x);
            // also subtract half font height for each letter of text, brings position approximately right
            TextItem->HPos = ((HorSum * 16) + 15) - TextItem->HPos - (TextItem->TextString.Length() * 0.5 * abs(TextItem->Font->Height));
        }
        TrainController->LogEvent("Mirror-text ok");
        // reset values in SelectGraphicVector so the midpoint of the graphic mirrors about the midline of the selection
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidHPosBeforeMirror = Track->SelectGraphicVector.at(x).HPos + (Track->SelectGraphicVector.at(x).Width) / 2;
            int MidHPosAfterMirror = ((HorSum * 16) + 15) - MidHPosBeforeMirror;
            int LeftPosAfterMirror = MidHPosAfterMirror - (Track->SelectGraphicVector.at(x).Width) / 2;
            if(LeftPosAfterMirror < (SelectRect.left * 16)) // shouldn't go below left but check
            {
                LeftPosAfterMirror = SelectRect.left * 16;
            }
            Track->SelectGraphicVector.at(x).HPos = LeftPosAfterMirror;
        }
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(49);
        Utilities->CallLogPop(1427);
    }
    catch(const Exception &e)
    {
        ErrorLog(150, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::RotateMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("Rotate180MenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",Rotate180MenuItemClick");

        // reset values in SelectVector
        int HorSum = SelectRect.left + SelectRect.right - 1;
        int VerSum = SelectRect.top + SelectRect.bottom - 1;
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            // See note above for FlipMenuItem relating to mods for v2.2.0
            int VLoc = VerSum - Track->SelectVectorAt(23, x).VLoc;
            int HLoc = HorSum - Track->SelectVectorAt(36, x).HLoc;
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(2, Track->MirrorArray[Track->FlipArray[Track->SelectVectorAt(31, x).SpeedTag]]);
            TE.VLoc = VLoc;
            TE.HLoc = HLoc;

            TE.ActiveTrackElementName = Track->SelectVectorAt(51, x).ActiveTrackElementName; // these new in v2.4.0 so keeps attributes
            TE.LocationName = Track->SelectVectorAt(52, x).LocationName;
            TE.Length01 = Track->SelectVectorAt(53, x).Length01;
            TE.Length23 = Track->SelectVectorAt(54, x).Length23;
            TE.SpeedLimit01 = Track->SelectVectorAt(55, x).SpeedLimit01;
            TE.SpeedLimit23 = Track->SelectVectorAt(56, x).SpeedLimit23;
            TE.SigAspect = Track->SelectVectorAt(57, x).SigAspect;

// if(Track->SelectVectorAt(32, x).TrackType == SignalPost) TE.SigAspect = Track->SelectVectorAt(33, x).SigAspect; dropped in v2.4.0 for above
            Track->SelectVectorAt(34, x) = TE;
// TTrackElement &TempEl = Track->SelectVectorAt(13, x);
// TempEl.HLoc = HorSum - TempEl.HLoc;
// TempEl.VLoc = VerSum - TempEl.VLoc;
// TempEl.SpeedTag = Track->MirrorArray[Track->FlipArray[TempEl.SpeedTag]];
        }

        int Rot180LinkArray[10] =
        {
            0, 9, 8, 7, 6, 5, 4, 3, 2, 1
        };                                                        //0 & 5 are never used
        TrainController->LogEvent("Rotate-track ok");
        // now reset the pref dirs
        for(unsigned int x = 0; x < SelectPrefDir->PrefDirSize(); x++)
        {
            int OriginalHLoc = SelectPrefDir->PrefDirVector.at(x).HLoc;  //added at v2.9.1
            int OriginalVLoc = SelectPrefDir->PrefDirVector.at(x).VLoc;
            int HLoc = HorSum - SelectPrefDir->PrefDirVector.at(x).HLoc;
            int VLoc = VerSum - SelectPrefDir->PrefDirVector.at(x).VLoc;
            int ELink = Rot180LinkArray[SelectPrefDir->PrefDirVector.at(x).GetELink()];
            int XLink = Rot180LinkArray[SelectPrefDir->PrefDirVector.at(x).GetXLink()];
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(8, Track->MirrorArray[Track->FlipArray[SelectPrefDir->PrefDirVector.at(x).SpeedTag]]);
            //the above line caused errors when Track->GetTrackElementFromAnyTrackMap in RecoverClipboard had Vector passed in by value,
            //causing a bad returned value for SpeedTag and other properties.  Passing it in by reference fixed it
            TPrefDirElement PDE(TE);  //this has Link[4]
            PDE.HLoc = HLoc;
            PDE.VLoc = VLoc;
            PDE.SetELink(ELink);
            PDE.SetXLink(XLink);
            bool ELinkPosFound = false, XLinkPosFound = false; //these ensure that the link pos is set as low as possible for points
            for(int y = 0; y < 4; y++)  //changed to y at v2.9.1
            {
                if(!ELinkPosFound && (PDE.Link[y] == ELink))
                {
                    PDE.SetELinkPos(y);
                    ELinkPosFound = true;
                }
                if(!XLinkPosFound && (PDE.Link[y] == XLink))
                {
                    PDE.SetXLinkPos(y);
                    XLinkPosFound = true;
                }
            }
            //set the CheckCount as before - added at v2.9.1
            PDE.SetCheckCount(9); //explicitly set to 9 at v2.9.2
            PDE.SetEXGraphicPtr(PDE.GetPrefDirGraphicPtr());
            PDE.SetEntryDirectionGraphicPtr(PDE.GetDirectionPrefDirGraphicPtr());
            //set the TrackVectorPosition to correspond to the corresponding TrackElement added at v2.9.1
            bool FoundFlag = false;
            PDE.SetTrackVectorPosition(Track->GetVectorPositionFromTrackMap(63, OriginalHLoc, OriginalVLoc, FoundFlag));  //uses original TV position as TrackMap hasn't changed yet
            if(PDE.GetSignedIntTrackVectorPosition() < 0)
            {
                FoundFlag = false; //probably will be anyway but reset to be sure & test below
            }
            //!PDE.EntryExitNumber() sets the EntryExitNumber
            if(!PDE.EntryExitNumber() || !ELinkPosFound || !XLinkPosFound || !FoundFlag) //error if can't set the number, any link pos not set or !FoundFlag
            {
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                ShowMessage("Unable to re-orientate the preferred directions, these won't be set in the rotated selection");
                break;
            }
            SelectPrefDir->PrefDirVector.at(x) = PDE;
        }
        TrainController->LogEvent("Rotate-PDs ok");
        // reset values in SelectTextVector
        for(unsigned int x = 0; x < TextHandler->SelectTextVectorSize(2); x++)
        {
            TTextItem *TextItem = TextHandler->SelectTextPtrAt(2, x);
            // also subtract half font height for each letter of text, brings position approximately right horizontally
            TextItem->HPos = ((HorSum * 16) + 15) - TextItem->HPos - (TextItem->TextString.Length() * 0.5 * abs(TextItem->Font->Height));
            // also subtract font height, brings position approximately right vertically
            TextItem->VPos = ((VerSum * 16) + 15) - TextItem->VPos - abs(TextItem->Font->Height);
        }
        TrainController->LogEvent("Rotate-text ok");
        // reset flip values in SelectGraphicVector so the midpoint of the graphic flips about the midline of the selection
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidVPosBeforeFlip = Track->SelectGraphicVector.at(x).VPos + (Track->SelectGraphicVector.at(x).Height) / 2;
            int MidVPosAfterFlip = ((VerSum * 16) + 15) - MidVPosBeforeFlip;
            int TopPosAfterFlip = MidVPosAfterFlip - (Track->SelectGraphicVector.at(x).Height) / 2;
            if(TopPosAfterFlip < (SelectRect.top * 16)) // shouldn't go above top but check
            {
                TopPosAfterFlip = SelectRect.top * 16;
            }
            Track->SelectGraphicVector.at(x).VPos = TopPosAfterFlip;
        }
        // reset mirror in SelectGraphicVector so the midpoint of the graphic mirrors about the midline of the selection
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidHPosBeforeMirror = Track->SelectGraphicVector.at(x).HPos + (Track->SelectGraphicVector.at(x).Width) / 2;
            int MidHPosAfterMirror = ((HorSum * 16) + 15) - MidHPosBeforeMirror;
            int LeftPosAfterMirror = MidHPosAfterMirror - (Track->SelectGraphicVector.at(x).Width) / 2;
            if(LeftPosAfterMirror < (SelectRect.left * 16)) // shouldn't go below left but check
            {
                LeftPosAfterMirror = SelectRect.left * 16;
            }
            Track->SelectGraphicVector.at(x).HPos = LeftPosAfterMirror;
        }
        // Level1Mode = TrackMode;
        // SetLevel1Mode(73);
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(50);
        Utilities->CallLogPop(1435);
    }
    catch(const Exception &e)
    {
        ErrorLog(151, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::RotRightMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("RotateRightMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RotateRightMenuItemClick");
        Screen->Cursor = TCursor(-11); // Hourglass
        // check first if a square and if not give message & quit
        if((SelectRect.right - SelectRect.left) != (SelectRect.bottom - SelectRect.top))
        {
            // use left vertical side to make square & keep top lh corner unless rhs would exceed display, in which case use the right vertical & keep to rh corner
            int VertSize = SelectRect.bottom - SelectRect.top;
            if((SelectRect.left + VertSize - Display->DisplayOffsetH) > Utilities->ScreenElementWidth)
            {
                // use right hand vertical & make square to left of that
                SelectRect.left = SelectRect.right - VertSize;
            }
            else
            {
                SelectRect.right = SelectRect.left + VertSize;
            }
            ClearandRebuildRailway(74);
            Display->PlotDashedRect(11, SelectRect);
            int button = Application->MessageBox
                    (L"Original selection adjusted to make it square. 'OK' to keep this selection or 'Cancel' to make a new selection",
                    L"Left click and hold here to move this message box", MB_OKCANCEL);
            if(button == IDCANCEL)
            {
                ResetSelectRect();
                Level1Mode = TrackMode; // call this first to clear everything, then set PrefDir mode
                SetLevel1Mode(133);
                Level2TrackMode = TrackSelecting;
                SetLevel2TrackMode(59);
                ClearandRebuildRailway(75);
                Screen->Cursor = TCursor(-2); // Arrow
                Utilities->CallLogPop(2121);
                return;
            }
        }
        // set SelectBitmap (only need the dimensions here as not moving the selection)
        SelectBitmapHLoc = SelectRect.left;
        SelectBitmapVLoc = SelectRect.top;
        SelectBitmap->Width = (SelectRect.right - SelectRect.left) * 16;
        SelectBitmap->Height = (SelectRect.bottom - SelectRect.top) * 16;

        // store track elements and text in select vectors - have to store here because original selection might well have changed
        Track->SelectVectorClear();
        TTrackElement TempElement; // default element
        bool FoundFlag;
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                int ATVecPos = Track->GetVectorPositionFromTrackMap(57, x, y, FoundFlag);
                if(FoundFlag)
                {
                    TempElement = Track->TrackElementAt(959, ATVecPos);
                    if(TempElement.SpeedTag > 0)
                    {
                        Track->SelectPush(TempElement);
                    }
                }
            }
        }
        // now store inactive elements
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                TTrack::TIMPair IATVecPair = Track->GetVectorPositionsFromInactiveTrackMap(28, x, y, FoundFlag);
                if(FoundFlag)
                {
                    TempElement = Track->InactiveTrackElementAt(126, IATVecPair.first);
                    Track->SelectPush(TempElement); // only want SpeedTag & location set, rest defaults
                    if(IATVecPair.second != IATVecPair.first) // 2 elements stored at location, i.e. platforms
                    {
                        TempElement = Track->InactiveTrackElementAt(127, IATVecPair.second);
                        Track->SelectPush(TempElement);
                    }
                }
            }
        }
        TrainController->LogEvent("RotRight-trackstore ok");
        //store preferred directions //added at v2.9.0
        int PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3;
        TPrefDirElement TempPrefDirElement;
        SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(12, x, y, FoundFlag, PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3);
                if(FoundFlag)
                {
                    if(PrefDirPos0 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(6, PrefDirPos0);
                        SelectPrefDir->ExternalStorePrefDirElement(12, TempPrefDirElement);
                    }
                    if(PrefDirPos1 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(7, PrefDirPos1);
                        SelectPrefDir->ExternalStorePrefDirElement(13, TempPrefDirElement);
                    }
                    if(PrefDirPos2 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(8, PrefDirPos2);
                        SelectPrefDir->ExternalStorePrefDirElement(14, TempPrefDirElement);
                    }
                    if(PrefDirPos3 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(9, PrefDirPos3);
                        SelectPrefDir->ExternalStorePrefDirElement(15, TempPrefDirElement);
                    }
                }
            }
        }
        TrainController->LogEvent("RotRight-PDstore ok");
        // store text items
        int LowSelectHPos = SelectRect.left * 16;
        int HighSelectHPos = SelectRect.right * 16;
        int LowSelectVPos = SelectRect.top * 16;
        int HighSelectVPos = SelectRect.bottom * 16;
        TextHandler->SelectTextVector.clear();
        if(!TextHandler->TextVector.empty()) // skip iteration if empty else have an error
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr < TextHandler->TextVector.end(); TextPtr++)
            {
                if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos < HighSelectVPos))
                {
                    // have to create a new TextItem in order to create a new Font object
                    // BUT: only create new items where they don't appear as named location names
                    // in SelectVector, since those names shouldn't be copied or pasted.
                    // NB:  altered for PasteWithAttributes - at v2.2.0 save the named element but prefix it with "##**"
                    // so can paste or not depending on which type of paste is being used (unlikely to use that in a real name)
                    bool SelectVectorNamedElement = false;
                    AnsiString SelectTextString; // new at v2.2.0
                    for(unsigned int x = 0; x < Track->SelectVector.size(); x++)
                    {
                        if(Track->SelectVector.at(x).LocationName == TextPtr->TextString)
                        {
                            SelectVectorNamedElement = true;
                            break;
                        }
                    }
                    if(SelectVectorNamedElement) // changed at v2.2.0
                    {
                        SelectTextString = "##**" + TextPtr->TextString; // new at v2.2.0
                    }
                    else // new at v2.2.0
                    {
                        SelectTextString = TextPtr->TextString;
                    }
                    TTextItem TextItem(TextPtr->HPos, TextPtr->VPos, SelectTextString, TextPtr->Font);
                    TextHandler->SelectTextVector.push_back(TextItem); // changed at v2.2.0
                }
            }
        }
        TrainController->LogEvent("RotRight-textstore ok");
        // store graphic items, but first clear SelectGraphicVector
        Track->SelectGraphicVector.clear();
        if(!Track->UserGraphicVector.empty()) // skip iteration if empty else have an error
        {
            for(TTrack::TUserGraphicVector::iterator UserGraphicPtr = Track->UserGraphicVector.begin(); UserGraphicPtr < Track->UserGraphicVector.end();
                UserGraphicPtr++)
            {
                if((UserGraphicPtr->HPos >= LowSelectHPos) && ((UserGraphicPtr->HPos + UserGraphicPtr->Width) < HighSelectHPos) && (UserGraphicPtr->VPos >=
                                                                                                                                    LowSelectVPos) && ((UserGraphicPtr->VPos + UserGraphicPtr->Height) < HighSelectVPos))
                {
                    Track->SelectGraphicVector.push_back(*UserGraphicPtr);
                }
            }
        }
        TrainController->LogEvent("RotRight-graphicstore ok");
        // now transform the H & V for rh rotate
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            int HLoc = SelectRect.bottom - 1 + SelectRect.left - Track->SelectVectorAt(74, x).VLoc;
            int VLoc = SelectRect.top - SelectRect.left + Track->SelectVectorAt(75, x).HLoc;
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(3, Track->RotRightArray[Track->SelectVectorAt(78, x).SpeedTag]);
            TE.VLoc = VLoc;
            TE.HLoc = HLoc;

            TE.ActiveTrackElementName = Track->SelectVectorAt(58, x).ActiveTrackElementName; // these new in v2.4.0 so keeps attributes
            TE.LocationName = Track->SelectVectorAt(59, x).LocationName;
            TE.Length01 = Track->SelectVectorAt(60, x).Length01;
            TE.Length23 = Track->SelectVectorAt(61, x).Length23;
            TE.SpeedLimit01 = Track->SelectVectorAt(62, x).SpeedLimit01;
            TE.SpeedLimit23 = Track->SelectVectorAt(63, x).SpeedLimit23;
            TE.SigAspect = Track->SelectVectorAt(64, x).SigAspect;
            Track->SelectVectorAt(65, x) = TE;
        }

        int RotRightLinkArray[10] =
        {
            0, 3, 6, 9, 2, 5, 8, 1, 4, 7
        };                                                          //0 & 5 are never used
        TrainController->LogEvent("RotRight-trackrotate ok");
        // now transform the pref dirs
        for(unsigned int x = 0; x < SelectPrefDir->PrefDirSize(); x++)
        {
            int OriginalHLoc = SelectPrefDir->GetFixedPrefDirElementAt(250, x).HLoc;  //added at v2.9.1
            int OriginalVLoc = SelectPrefDir->GetFixedPrefDirElementAt(251, x).VLoc;
            int HLoc = SelectRect.bottom - 1 + SelectRect.left - OriginalVLoc;
            int VLoc = SelectRect.top - SelectRect.left + OriginalHLoc;
            int ELink = RotRightLinkArray[SelectPrefDir->GetFixedPrefDirElementAt(252, x).GetELink()];
            int XLink = RotRightLinkArray[SelectPrefDir->GetFixedPrefDirElementAt(253, x).GetXLink()];
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(9, Track->RotRightArray[SelectPrefDir->GetFixedPrefDirElementAt(254, x).SpeedTag]);
            //the above line caused errors when Track->GetTrackElementFromAnyTrackMap in RecoverClipboard had Vector passed in by value,
            //causing a bad returned value for SpeedTag and other properties.  Passing it in by reference fixed it
            TPrefDirElement PDE(TE);  //this has Link[4]
            PDE.HLoc = HLoc;
            PDE.VLoc = VLoc;
            PDE.SetELink(ELink);
            PDE.SetXLink(XLink);
            bool ELinkPosFound = false, XLinkPosFound = false; //these ensure that the link pos is set as low as possible for points
            for(int y = 0; y < 4; y++)  //changed to y at v2.9.1
            {
                if(!ELinkPosFound && (PDE.Link[y] == ELink))
                {
                    PDE.SetELinkPos(y);
                    ELinkPosFound = true;
                }
                if(!XLinkPosFound && (PDE.Link[y] == XLink))
                {
                    PDE.SetXLinkPos(y);
                    XLinkPosFound = true;
                }
            }
            //set the CheckCount as before - added at v2.9.1
            PDE.SetCheckCount(9); //explicitly set to 9 at v2.9.2
            PDE.SetEXGraphicPtr(PDE.GetPrefDirGraphicPtr());
            PDE.SetEntryDirectionGraphicPtr(PDE.GetDirectionPrefDirGraphicPtr());
            //set the TrackVectorPosition to correspond to the corresponding TrackElement added at v2.9.1
            bool FoundFlag = false;
            PDE.SetTrackVectorPosition(Track->GetVectorPositionFromTrackMap(64, OriginalHLoc, OriginalVLoc, FoundFlag));  //uses original TV position as TrackMap hasn't changed yet
            if(PDE.GetSignedIntTrackVectorPosition() < 0)
            {
                FoundFlag = false; //probably will be anyway but reset to be sure & test below
            }
            //!PDE.EntryExitNumber() sets the EntryExitNumber
            if(!PDE.EntryExitNumber() || !ELinkPosFound || !XLinkPosFound || !FoundFlag) //error if can't set the number, any link pos not set or !FoundFlag
            {
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                ShowMessage("Unable to re-orientate the preferred directions, these won't be set in the rotated selection");
                break;
            }
            SelectPrefDir->PrefDirVector.at(x) = PDE;
        }
        TrainController->LogEvent("RotRight-PDrotate ok");
        // reset values in SelectTextVector
        for(unsigned int x = 0; x < TextHandler->SelectTextVectorSize(3); x++)
        {
// no point trying to locate text properly as it stays horizontal so will always be wrongly placed, just list all itels vertically at lhs
// & if a lot then some will extend beyond the selection
            TTextItem *TextItem = TextHandler->SelectTextPtrAt(3, x);
            // also subtract half font height for each letter of text, brings position approximately right horizontally
            TextItem->HPos = (SelectRect.left) * 16;
            TextItem->VPos = (SelectRect.top + x) * 16;
        }
        TrainController->LogEvent("RotRight-textrotate ok");
        // reset values in SelectGraphicVector
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidHPosBeforeRotate = Track->SelectGraphicVector.at(x).HPos + Track->SelectGraphicVector.at(x).Width / 2;
            int MidVPosBeforeRotate = Track->SelectGraphicVector.at(x).VPos + Track->SelectGraphicVector.at(x).Height / 2;
            int MidHPosAfterRotate = ((SelectRect.bottom * 16) - 1) + (SelectRect.left * 16) - MidVPosBeforeRotate;
            int MidVPosAfterRotate = ((SelectRect.top - SelectRect.left) * 16) + MidHPosBeforeRotate;
            int LeftPosAfterRotate = MidHPosAfterRotate - (Track->SelectGraphicVector.at(x).Width) / 2;
            int TopPosAfterRotate = MidVPosAfterRotate - (Track->SelectGraphicVector.at(x).Height) / 2;
            Track->SelectGraphicVector.at(x).HPos = LeftPosAfterRotate;
            Track->SelectGraphicVector.at(x).VPos = TopPosAfterRotate;
        }
        Screen->Cursor = TCursor(-2); // Arrow
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(60);
        Utilities->CallLogPop(2122);
    }
    catch(const Exception &e)
    {
        ErrorLog(205, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::RotLeftMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("RotateLeftMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RotateLeftMenuItemClick");
        Screen->Cursor = TCursor(-11); // Hourglass;
        // check first if a square and if not give message & quit
        if((SelectRect.right - SelectRect.left) != (SelectRect.bottom - SelectRect.top))
        {
            // use left vertical side to make square & keep top lh corner unless rhs would exceed display, in which case use the right vertical & keep to rh corner
            int VertSize = SelectRect.bottom - SelectRect.top;
            if((SelectRect.left + VertSize - Display->DisplayOffsetH) > Utilities->ScreenElementWidth)
            {
                // use right hand vertical & make square to left of that
                SelectRect.left = SelectRect.right - VertSize;
            }
            else
            {
                SelectRect.right = SelectRect.left + VertSize;
            }
            ClearandRebuildRailway(76);
            Display->PlotDashedRect(12, SelectRect);
            int button = Application->MessageBox
                    (L"Original selection adjusted to make it square. 'OK' to keep this selection or 'Cancel' to make a new selection",
                    L"Left click and hold here to move this message box", MB_OKCANCEL);
            if(button == IDCANCEL)
            {
                ResetSelectRect();
                Level1Mode = TrackMode; // call this first to clear everything, then set PrefDir mode
                SetLevel1Mode(134);
                Level2TrackMode = TrackSelecting;
                SetLevel2TrackMode(61);
                ClearandRebuildRailway(77);
                Screen->Cursor = TCursor(-2); // Arrow
                Utilities->CallLogPop(2123);
                return;
            }
        }
        // set SelectBitmap (only need the dimensions here as not moving the selection)
        SelectBitmapHLoc = SelectRect.left;
        SelectBitmapVLoc = SelectRect.top;
        SelectBitmap->Width = (SelectRect.right - SelectRect.left) * 16;
        SelectBitmap->Height = (SelectRect.bottom - SelectRect.top) * 16;

        // store track elements and text in select vectors - have to store here because original selection might well have changed
        Track->SelectVectorClear();
        TTrackElement TempElement; // default element
        bool FoundFlag;
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                int ATVecPos = Track->GetVectorPositionFromTrackMap(58, x, y, FoundFlag);
                if(FoundFlag)
                {
                    TempElement = Track->TrackElementAt(960, ATVecPos);
                    if(TempElement.SpeedTag > 0)
                    {
                        Track->SelectPush(TempElement);
                    }
                }
            }
        }
        // now store inactive elements
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                TTrack::TIMPair IATVecPair = Track->GetVectorPositionsFromInactiveTrackMap(29, x, y, FoundFlag);
                if(FoundFlag)
                {
                    TempElement = Track->InactiveTrackElementAt(128, IATVecPair.first);
                    Track->SelectPush(TempElement); // only want SpeedTag & location set, rest defaults
                    if(IATVecPair.second != IATVecPair.first) // 2 elements stored at location, i.e. platforms
                    {
                        TempElement = Track->InactiveTrackElementAt(129, IATVecPair.second);
                        Track->SelectPush(TempElement);
                    }
                }
            }
        }
        TrainController->LogEvent("RotLeft-trackstore ok");
        //store preferred directions //added at v2.9.0
        int PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3;
        TPrefDirElement TempPrefDirElement;
        SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
        for(int x = SelectRect.left; x < SelectRect.right; x++)
        {
            for(int y = SelectRect.top; y < SelectRect.bottom; y++)
            {
                EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(13, x, y, FoundFlag, PrefDirPos0, PrefDirPos1, PrefDirPos2, PrefDirPos3);
                if(FoundFlag)
                {
                    if(PrefDirPos0 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(10, PrefDirPos0);
                        SelectPrefDir->ExternalStorePrefDirElement(16, TempPrefDirElement);
                    }
                    if(PrefDirPos1 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(11, PrefDirPos1);
                        SelectPrefDir->ExternalStorePrefDirElement(17, TempPrefDirElement);
                    }
                    if(PrefDirPos2 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(12, PrefDirPos2);
                        SelectPrefDir->ExternalStorePrefDirElement(18, TempPrefDirElement);
                    }
                    if(PrefDirPos3 > -1)
                    {
                        TempPrefDirElement = EveryPrefDir->GetModifiablePrefDirElementAt(13, PrefDirPos3);
                        SelectPrefDir->ExternalStorePrefDirElement(19, TempPrefDirElement);
                    }
                }
            }
        }
        TrainController->LogEvent("RotLeft-PDstore ok");
        // store text items
        int LowSelectHPos = SelectRect.left * 16;
        int HighSelectHPos = SelectRect.right * 16;
        int LowSelectVPos = SelectRect.top * 16;
        int HighSelectVPos = SelectRect.bottom * 16;
        TextHandler->SelectTextVector.clear();
        if(!TextHandler->TextVector.empty()) // skip iteration if empty else have an error
        {
            for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->TextVector.begin(); TextPtr < TextHandler->TextVector.end(); TextPtr++)
            {
                if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos < HighSelectVPos))
                {
                    // have to create a new TextItem in order to create a new Font object
                    // BUT: only create new items where they don't appear as named location names
                    // in SelectVector, since those names shouldn't be copied or pasted.
                    // NB:  altered for PasteWithAttributes - at v2.2.0 save the named element but prefix it with "##**"
                    // so can paste or not depending on which type of paste is being used (unlikely to use that in a real name)
                    bool SelectVectorNamedElement = false;
                    AnsiString SelectTextString; // new at v2.2.0
                    for(unsigned int x = 0; x < Track->SelectVector.size(); x++)
                    {
                        if(Track->SelectVector.at(x).LocationName == TextPtr->TextString)
                        {
                            SelectVectorNamedElement = true;
                            break;
                        }
                    }
                    if(SelectVectorNamedElement) // changed at v2.2.0
                    {
                        SelectTextString = "##**" + TextPtr->TextString; // new at v2.2.0
                    }
                    else // new at v2.2.0
                    {
                        SelectTextString = TextPtr->TextString;
                    }
                    TTextItem TextItem(TextPtr->HPos, TextPtr->VPos, SelectTextString, TextPtr->Font);
                    TextHandler->SelectTextVector.push_back(TextItem); // changed at v2.2.0
                }
            }
        }
        TrainController->LogEvent("RotLeft-textstore ok");
        // store graphic items, but first clear SelectGraphicVector
        Track->SelectGraphicVector.clear();
        if(!Track->UserGraphicVector.empty()) // skip iteration if empty else have an error
        {
            for(TTrack::TUserGraphicVector::iterator UserGraphicPtr = Track->UserGraphicVector.begin(); UserGraphicPtr < Track->UserGraphicVector.end();
                UserGraphicPtr++)
            {
                if((UserGraphicPtr->HPos >= LowSelectHPos) && ((UserGraphicPtr->HPos + UserGraphicPtr->Width) < HighSelectHPos) && (UserGraphicPtr->VPos >=
                                                                                                                                    LowSelectVPos) && ((UserGraphicPtr->VPos + UserGraphicPtr->Height) < HighSelectVPos))
                {
                    Track->SelectGraphicVector.push_back(*UserGraphicPtr);
                }
            }
        }
        TrainController->LogEvent("RotLeft-graphicstore ok");
        // now transform the H & V for lh rotate
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            int HLoc = SelectRect.left - SelectRect.top + Track->SelectVectorAt(76, x).VLoc;
            int VLoc = SelectRect.bottom - 1 + SelectRect.left - Track->SelectVectorAt(77, x).HLoc;
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(4, Track->RotLeftArray[Track->SelectVectorAt(79, x).SpeedTag]);
            TE.VLoc = VLoc;
            TE.HLoc = HLoc;

            TE.ActiveTrackElementName = Track->SelectVectorAt(66, x).ActiveTrackElementName; // these new in v2.4.0 so keeps attributes
            TE.LocationName = Track->SelectVectorAt(67, x).LocationName;
            TE.Length01 = Track->SelectVectorAt(68, x).Length01;
            TE.Length23 = Track->SelectVectorAt(69, x).Length23;
            TE.SpeedLimit01 = Track->SelectVectorAt(70, x).SpeedLimit01;
            TE.SpeedLimit23 = Track->SelectVectorAt(71, x).SpeedLimit23;
            TE.SigAspect = Track->SelectVectorAt(72, x).SigAspect;
            Track->SelectVectorAt(73, x) = TE;
        }

        int RotLeftLinkArray[10] = 
        {
            0, 7, 4, 1, 8, 5, 2, 9, 6, 3
        };                                                         //0 & 5 are never used
        TrainController->LogEvent("RotLeft-trackrotate ok");
        // now transform the pref dirs
        for(unsigned int x = 0; x < SelectPrefDir->PrefDirSize(); x++)
        {
            int OriginalHLoc = SelectPrefDir->GetFixedPrefDirElementAt(255, x).HLoc;  //added at v2.9.1
            int OriginalVLoc = SelectPrefDir->GetFixedPrefDirElementAt(256, x).VLoc;
            int HLoc = SelectRect.left - SelectRect.top + OriginalVLoc;
            int VLoc = SelectRect.bottom - 1 + SelectRect.left - OriginalHLoc;
            int ELink = RotLeftLinkArray[SelectPrefDir->GetFixedPrefDirElementAt(257, x).GetELink()];
            int XLink = RotLeftLinkArray[SelectPrefDir->GetFixedPrefDirElementAt(258, x).GetXLink()];
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(10, Track->RotLeftArray[SelectPrefDir->GetFixedPrefDirElementAt(259, x).SpeedTag]);
            //the above line caused errors when Track->GetTrackElementFromAnyTrackMap in RecoverClipboard had Vector passed in by value,
            //causing a bad returned value for SpeedTag and other properties.  Passing it in by reference fixed it
            TPrefDirElement PDE(TE);  //this has Link[4] set
            PDE.HLoc = HLoc;
            PDE.VLoc = VLoc;
            PDE.SetELink(ELink);
            PDE.SetXLink(XLink);
            bool ELinkPosFound = false, XLinkPosFound = false; //these ensure that the link pos is set as low as possible for points
            for(int y = 0; y < 4; y++)  //changed to y at v2.9.1
            {
                if(!ELinkPosFound && (PDE.Link[y] == ELink))
                {
                    PDE.SetELinkPos(y);
                    ELinkPosFound = true;
                }
                if(!XLinkPosFound && (PDE.Link[y] == XLink))
                {
                    PDE.SetXLinkPos(y);
                    XLinkPosFound = true;
                }
            }
            //set the CheckCount as before - added at v2.9.1
            PDE.SetCheckCount(9); //explicitly set to 9 at v2.9.2
            PDE.SetEXGraphicPtr(PDE.GetPrefDirGraphicPtr());
            PDE.SetEntryDirectionGraphicPtr(PDE.GetDirectionPrefDirGraphicPtr());
            //set the TrackVectorPosition to correspond to the corresponding TrackElement added at v2.9.1
            bool FoundFlag = false;
            PDE.SetTrackVectorPosition(Track->GetVectorPositionFromTrackMap(65, OriginalHLoc, OriginalVLoc, FoundFlag));  //uses original TV position as TrackMap hasn't changed yet
            if(PDE.GetSignedIntTrackVectorPosition() < 0)
            {
                FoundFlag = false; //probably will be anyway but reset to be sure & test below
            }
            //!PDE.EntryExitNumber() sets the EntryExitNumber
            if(!PDE.EntryExitNumber() || !ELinkPosFound || !XLinkPosFound || !FoundFlag) //error if can't set the number, any link pos not set or !FoundFlag
            {
                SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
                ShowMessage("Unable to re-orientate the preferred directions, these won't be set in the rotated selection");
                break;
            }
            SelectPrefDir->PrefDirVector.at(x) = PDE;
        }
        TrainController->LogEvent("RotLeft-PDrotate ok");
        // reset values in SelectTextVector
        for(unsigned int x = 0; x < TextHandler->SelectTextVectorSize(4); x++)
        {
// no point trying to locate text properly as it stays horizontal so will always be wrongly placed, just list all itels vertically at lhs
// & if a lot then some will extend beyond the selection
            TTextItem *TextItem = TextHandler->SelectTextPtrAt(4, x);
            // also subtract half font height for each letter of text, brings position approximately right horizontally
            TextItem->HPos = (SelectRect.left) * 16;
            TextItem->VPos = (SelectRect.top + x) * 16;
        }
        TrainController->LogEvent("RotLeft-textrotate ok");
        // reset values in SelectGraphicVector
        for(unsigned int x = 0; x < Track->SelectGraphicVector.size(); x++)
        {
            int MidHPosBeforeRotate = Track->SelectGraphicVector.at(x).HPos + Track->SelectGraphicVector.at(x).Width / 2;
            int MidVPosBeforeRotate = Track->SelectGraphicVector.at(x).VPos + Track->SelectGraphicVector.at(x).Height / 2;
            int MidHPosAfterRotate = ((SelectRect.left - SelectRect.top) * 16) + MidVPosBeforeRotate;
            int MidVPosAfterRotate = ((SelectRect.bottom * 16) - 1) + (SelectRect.left * 16) - MidHPosBeforeRotate;
            int LeftPosAfterRotate = MidHPosAfterRotate - (Track->SelectGraphicVector.at(x).Width) / 2;
            int TopPosAfterRotate = MidVPosAfterRotate - (Track->SelectGraphicVector.at(x).Height) / 2;
            Track->SelectGraphicVector.at(x).HPos = LeftPosAfterRotate;
            Track->SelectGraphicVector.at(x).VPos = TopPosAfterRotate;
        }
        Screen->Cursor = TCursor(-2); // Arrow
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(62);
        Utilities->CallLogPop(2124);
    }
    catch(const Exception &e)
    {
        ErrorLog(206, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::PasteMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PasteMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PasteMenuItemClick");
        // Level1Mode = TrackMode;
        // SetLevel1Mode(74);
        Level2TrackMode = Pasting;
        SetLevel2TrackMode(58);
        Utilities->CallLogPop(2060);
    }
    catch(const Exception &e)
    {
        ErrorLog(198, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::DeleteMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("DeleteMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",DeleteMenuItemClick");
        // Level1Mode = TrackMode;
        // SetLevel1Mode(75);
        Level2TrackMode = Deleting;
        SetLevel2TrackMode(38);
        Utilities->CallLogPop(1193);
    }
    catch(const Exception &e)
    {
        ErrorLog(153, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SelectLengthsMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SelectLengthsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SelectLengthsMenuItemClick");
        TrackElementPanel->Visible = false;
        TrackLengthPanel->Visible = true;
        TrackLengthPanel->SetFocus();
        SelectLengthsFlag = true;
        InfoPanel->Visible = true;
        InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Set values or leave blank for no change";
        if(!LengthWarningSentFlag)
        {
            ShowMessage("Note: length value will apply to each element's track within the selection.\n\nThis message will not be shown again.");
            LengthWarningSentFlag = true;
        }
        DistanceBox->Text = "";
        SpeedLimitBox->Text = "";
        SelectBitmapHLoc = SelectRect.left;
        SelectBitmapVLoc = SelectRect.top;
// ResetChangedFileDataAndCaption(, true); //don't need this here after 2.7.0 as included in TrackLengthPanel buttons
        Utilities->CallLogPop(1414);
    }
    catch(const Exception &e)
    {
        ErrorLog(154, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SelectBiDirPrefDirsMenuItemClick(TObject *Sender)
{
/* SelectVector contains all the track elements (and inactive elements but don't need them), so create up to 4 PrefDir
   elements from each one, and add each into ConstructPrefDir, then when all added use ConsolidatePrefDirs to add to EveryPrefDir
*/
    try
    {
        TrainController->LogEvent("SelectBiDirPrefDirsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SelectBiDirPrefDirsMenuItemClick");
        ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
        bool FoundFlag = false;
        if(Track->SelectVector.empty())
        {
            Utilities->CallLogPop(1550);
            return;
        }
        for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
        {
            TTrackElement TE = Track->SelectVectorAt(14, x);
            int VecPos = Track->GetVectorPositionFromTrackMap(42, TE.HLoc, TE.VLoc, FoundFlag);
            if(FoundFlag)
            {
                if((TE.TrackType == Points) || (TE.TrackType == Bridge) || (TE.TrackType == Crossover)) // 2-track element
                {
                    TPrefDirElement PE0(TE, TE.Link[0], 0, TE.Link[1], 1, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(0, PE0);
                    TPrefDirElement PE1(TE, TE.Link[1], 1, TE.Link[0], 0, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(1, PE1);
                    TPrefDirElement PE2(TE, TE.Link[2], 2, TE.Link[3], 3, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(2, PE2);
                    TPrefDirElement PE3(TE, TE.Link[3], 3, TE.Link[2], 2, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(3, PE3);
                }
                else if((TE.TrackType == Simple) || (TE.TrackType == Buffers) || (TE.TrackType == SignalPost) || (TE.TrackType == Continuation) ||
                        (TE.TrackType == GapJump) || (TE.TrackType == FootCrossing))
                // need to list these explicitly since inactive elements will still be 'found' if there is an active element
                // at the same position
                {
                    TPrefDirElement PE0(TE, TE.Link[0], 0, TE.Link[1], 1, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(4, PE0);
                    TPrefDirElement PE1(TE, TE.Link[1], 1, TE.Link[0], 0, VecPos);
                    ConstructPrefDir->ExternalStorePrefDirElement(5, PE1);
                }
            }
        }
        EveryPrefDir->ConsolidatePrefDirs(2, ConstructPrefDir);
        ResetChangedFileDataAndCaption(22, false);
        // RlyFile = false; - don't alter this just for PrefDir changes
        Level1Mode = BaseMode; // call this first to clear everything, then set PrefDir mode
        SetLevel1Mode(30);
        Level1Mode = PrefDirMode;
        SetLevel1Mode(31); // calls Clearand... to display all PrefDirs
        Utilities->CallLogPop(1549);
    }
    catch(const Exception &e)
    {
        ErrorLog(155, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CancelSelectionMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CancelSelectionClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CancelSelectionClick");
// ClearandRebuildRailway(46); //called below
        SelectionValid = false;
        CancelSelectionFlag = true; // used to avoid RecoverClipboard in pasting when CutMoving selected
        Track->CopyFlag = false;
        Track->SkipLocationNameMultiMapCheck = false;
        if(Level1Mode == TrackMode)
        {
            SetLevel1Mode(76); // CancelSelectionFlag needed here
            Level2TrackMode = AddTrack;
            SetLevel2TrackMode(68);
        }
        else if(Level1Mode == PrefDirMode)
        {
            SetLevel1Mode(32);
        }
        CancelSelectionFlag = false; // done with it
        ResetSelectRect();
        ClearandRebuildRailway(82); // to remove the selection outline
        Clipboard()->Clear();
        Clipboard()->Close();
        Utilities->CallLogPop(1413);
    }
    catch(const EClipboardException &e) // take no action  //non-error catch
    {
// Application->MessageBox(L"A clipboard error occurred in the cancel function", L"Message", MB_OK);
        TrainController->LogEvent("EClipboardException in CancelSelectionMenuItemClick - message = " + e.Message);
        Utilities->CallLogPop(2314);
    }
    catch(const Exception &e)
    {
        ErrorLog(156, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CheckPrefDirConflictsMenuItemClick(TObject *Sender)
{
//Conflicts consist of track elements without PDs, a preferred direction (PD) that links to a track element without a PD on it, or a PD that links to
//another PD that is set in the wrong direction.

//function changed to become more comprehensive at v2.13.0
    try
    {
        TrainController->LogEvent("CheckPrefDirConflictsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CheckPrefDirConflictsMenuItemClick");
		bool FoundFlag;
		int Count = 0;
		UnicodeString CountWord = "There are some track elements without preferred directions.\n\n"
                                  "Do you wish to highlight them (YES) or skip this part of the check (NO)?";

		int PD0, PD1, PD2, PD3, HLoc, VLoc, LastHLoc = -2000000, LastVLoc = -2000000; //well outside any conceivable range
        AnsiString TempInfo = InfoPanel->Caption;
        if(EveryPrefDir->PrefDirSize() <= 0)
        {
            ShowMessage("No preferred directions set.");
            Utilities->CallLogPop(2301);
            return;
        }
        else
		{
			InfoPanel->Visible = true;
			InfoPanel->Caption = "Checking preferred directions - please wait";
			InfoPanel->Update();
			THVShortPair LasTHVShortPair;
			LasTHVShortPair.first = -2000000;
			LasTHVShortPair.second = -2000000; //well outside any conceivable range
			Screen->Cursor = TCursor(-11); // Hourglass
//check PDs, iterate the map rather than the vector so that pref dirs at the same H & V are consecutive, & can prevent the same element showing more than once

			for(TOnePrefDir::TPrefDir4MultiMapIterator PDMMIt = EveryPrefDir->PrefDir4MultiMap.begin(); PDMMIt != EveryPrefDir->PrefDir4MultiMap.end(); PDMMIt++)
			{
				bool ELinkFound = false;//, BiDir = false;
				int ELink = EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetELink();
				int ELinkPos = EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetELinkPos();
				int ThisElementHLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).HLoc;
                int ThisElementVLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).VLoc;
                if((ELink > -1) && (EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[ELinkPos] > -1))
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(17, Track->TrackElementAt(1023, EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[ELinkPos]).HLoc,
																		 Track->TrackElementAt(1024, EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[ELinkPos]).VLoc, FoundFlag, PD0, PD1, PD2, PD3);
                    if((EveryPrefDir->PrefDirVector.at(PDMMIt->second).TrackType == GapJump) && (ELinkPos == 0)) //0 is the gap position
                    {
                        if(PD0 > -1)
                        {
                            if(EveryPrefDir->PrefDirVector.at(PD0).TrackType == GapJump) //the corresponding gap
                            {
                                if(EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos() == 0) // entry link is at the gap end so it corresponds
                                {
                                    ELinkFound = true;
                                }
                            }
                        }
                        if(PD1 > -1)
                        {
                            if(EveryPrefDir->PrefDirVector.at(PD1).TrackType == GapJump) //can only be PD0 or PD1 for a gap
                            {
                                if(EveryPrefDir->PrefDirVector.at(PD1).GetXLinkPos() == 0) // entry link is at the gap end so it corresponds
                                {
                                    ELinkFound = true;
                                }
                            }
                        }
                    }
					if(EveryPrefDir->BiDirectionalPrefDir(0, PDMMIt) &&
                            (Track->TrackElementAt(1454, EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetTrackVectorPosition()).
                                Config[EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetELinkPos()] == Signal))
                    {
                        ELinkFound = true; // ok if this element is a signal at exit end
                    }
                    if(BypassPDCrossoverMismatch(0, ThisElementHLoc,  ThisElementVLoc))
                    {
                        ELinkFound = true; // ok to skip linked points with bidirs on both links and single PDs on other legs
                    }
                    if(PD0 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD0).GetXLink() == (10 - ELink))
                        {
                            ELinkFound = true;
                        }
                        //ok if a signal at exit end of a single dir PD element for a conflict at the ELink end of a bidirectional PD element (applies for PD0 & 1 only)
                        else if(EveryPrefDir->BiDirectionalPrefDir(1, PDMMIt) &&
                            Track->TrackElementAt(1455, EveryPrefDir->PrefDirVector.at(PD0).GetTrackVectorPosition()).
                                Config[EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos()] == Signal)
                        {
                            ELinkFound = true;
                        }
                    }
                    if(PD1 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD1).GetXLink() == (10 - ELink))
                        {
                            ELinkFound = true;
                        }
                        //as above ok if a signal at exit end of a single PD element for a conflict at the ELink end of a bidirectional PD element (applies for PD0 & 1 only)
                        else if(EveryPrefDir->BiDirectionalPrefDir(2, PDMMIt) &&
                            Track->TrackElementAt(1456, EveryPrefDir->PrefDirVector.at(PD0).GetTrackVectorPosition()).
                                Config[EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos()] == Signal)
                        {
                            ELinkFound = true;
                        }
                    }
                    if(PD2 > -1) //if PD2/3 > -1 then can'#t be a signal
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD2).GetXLink() == (10 - ELink))
                        {
                            ELinkFound = true;
                        }
                    }
                    if(PD3 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD3).GetXLink() == (10 - ELink))
                        {
                            ELinkFound = true;
                        }
                    }
                }
                if(!ELinkFound && (EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[ELinkPos] > -1))
				{
					HLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).HLoc;
					VLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).VLoc;
					if((LastHLoc != HLoc) || (LastVLoc != VLoc))
					{
						LastHLoc = HLoc;
						LastVLoc = VLoc;
						while((Display->DisplayOffsetH - HLoc) > 0)
						{
							Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
						}
						while((HLoc - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
						{
							Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
						}
						while((Display->DisplayOffsetV - VLoc) > 0)
						{
							Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
						}
						while((VLoc - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
						{
							Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
						}
						ClearandRebuildRailway(85);
						Display->InvertElement(2, HLoc * 16, VLoc * 16);
						Screen->Cursor = TCursor(-2); // Arrow
						int Button = Application->MessageBox(L"Preferred direction mismatch at a link between the\n"
															 "highlighted element and an adjacent element.\n\n"
                                                             "The highlighted element may be behind this message\n"
                                                             "which can be moved by left clicking the mouse in the\n"
                                                             "title bar and dragging it.\n\n"
                                                             "The mismatch may or may not matter depending\n"
                                                             "on routing requirements during operation.\n\n"
                                                             "Click 'OK' to ignore and continue checking or 'Cancel'\n"
                                                             "to allow correction.", L"Warning", MB_OKCANCEL | MB_ICONWARNING);
						ClearandRebuildRailway(86); // to clear inversion
						if(Button == IDCANCEL)
						{
							InfoPanel->Caption = TempInfo;
							Utilities->CallLogPop(2303);
							return;
						}
						Screen->Cursor = TCursor(-11); //Hourglass
						Display->Update();
					}
				}

				bool XLinkFound = false;
				int XLink = EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetXLink();
				int XLinkPos = EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetXLinkPos();
				if((XLink > -1) && (EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[XLinkPos] > -1))
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(18, Track->TrackElementAt(1025, EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[XLinkPos]).HLoc,
																		 Track->TrackElementAt(1026, EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[XLinkPos]).VLoc, FoundFlag, PD0, PD1, PD2, PD3);
					if((EveryPrefDir->PrefDirVector.at(PDMMIt->second).TrackType == GapJump) && (XLinkPos == 0)) //0 is the gap position
					{
						if(PD0 > -1)
						{
							if(EveryPrefDir->PrefDirVector.at(PD0).TrackType == GapJump) //the corresponding gap
							{
								if(EveryPrefDir->PrefDirVector.at(PD0).GetELinkPos() == 0) // entry link is at the gap end so it corresponds
                                {
                                    XLinkFound = true;
                                }
                            }
                        }
                        if(PD1 > -1)
                        {
                            if(EveryPrefDir->PrefDirVector.at(PD1).TrackType == GapJump) //can only be PD0 or PD1 for a gap
                            {
                                if(EveryPrefDir->PrefDirVector.at(PD1).GetELinkPos() == 0) // entry link is at the gap end so it corresponds
                                {
                                    XLinkFound = true;
                                }
                            }
                        }
                    }
                    if(EveryPrefDir->BiDirectionalPrefDir(3, PDMMIt) &&
                            (Track->TrackElementAt(1457, EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetTrackVectorPosition()).
                                Config[EveryPrefDir->PrefDirVector.at(PDMMIt->second).GetXLinkPos()] == Signal))
                    {
                        XLinkFound = true; // ok if this element is a signal at exit end
                    }
                    if(BypassPDCrossoverMismatch(1, ThisElementHLoc,  ThisElementVLoc))
                    {
                        XLinkFound = true; // ok to skip linked points with bidirs on both links and single PDs on other legs
                    }
                    if(PD0 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD0).GetELink() == (10 - XLink))
                        {
                            XLinkFound = true;
                        }
                    }
                    if(PD1 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD1).GetELink() == (10 - XLink))
                        {
                            XLinkFound = true;
                        }
                    }
                    if(PD2 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD2).GetELink() == (10 - XLink))
                        {
                            XLinkFound = true;
                        }
                    }
                    if(PD3 > -1)
                    {
                        if(EveryPrefDir->PrefDirVector.at(PD3).GetELink() == (10 - XLink))
                        {
                            XLinkFound = true;
                        }
                    }
                }
                if(!XLinkFound && (EveryPrefDir->PrefDirVector.at(PDMMIt->second).Conn[XLinkPos] > -1))
                {
                    HLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).HLoc;
                    VLoc = EveryPrefDir->PrefDirVector.at(PDMMIt->second).VLoc;
                    if((LastHLoc != HLoc) || (LastVLoc != VLoc))
                    {
                        LastHLoc = HLoc;
                        LastVLoc = VLoc;
                        while((Display->DisplayOffsetH - HLoc) > 0)
                        {
                            Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
                        }
                        while((HLoc - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
                        {
                            Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
                        }
                        while((Display->DisplayOffsetV - VLoc) > 0)
                        {
                            Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
                        }
                        while((VLoc - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
                        {
                            Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
                        }
                        ClearandRebuildRailway(87);
                        Display->InvertElement(3, HLoc * 16, VLoc * 16);
                        Screen->Cursor = TCursor(-2); // Arrow
						int Button = Application->MessageBox(L"Preferred direction mismatch at a link between the\n"
															 "highlighted element and an adjacent element.\n\n"
                                                             "The highlighted element may be behind this message\n"
                                                             "which can be moved by left clicking the mouse in the\n"
                                                             "title bar and dragging it.\n\n"
                                                             "The mismatch may or may not matter depending\n"
                                                             "on routing requirements during operation.\n\n"
                                                             "Click 'OK' to ignore and continue checking or 'Cancel'\n"
                                                             "to allow correction.", L"Warning", MB_OKCANCEL | MB_ICONWARNING);
                        ClearandRebuildRailway(88); // to clear inversion
                        if(Button == IDCANCEL)
                        {
                            InfoPanel->Caption = TempInfo;
                            Utilities->CallLogPop(2304);
                            return;
                        }
                        Screen->Cursor = TCursor(-11); // Hourglass
                        Display->Update();
                    }
                }
			}
//now check every track element to make sure there's a PD set on it. Get H&V for each, and if single track element ensure PD0 set, else make
//sure both set, but first count them and if > 9 offer to skip
			for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
			{
				int HLoc = Track->TrackElementAt(1470, x).HLoc;
				int VLoc = Track->TrackElementAt(1471, x).VLoc;
				if((Track->TrackElementAt(1472, x).TrackType == Points) || (Track->TrackElementAt(1473, x).TrackType == Crossover) ||
					(Track->TrackElementAt(1474, x).TrackType == Bridge))
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(34, HLoc, VLoc, FoundFlag, PD0, PD1, PD2, PD3);
					//check if either track with no PDs: !Foundflag == none, PD1 == -1 == only one, and last condition covers one having a bidir PD & other none
					if(!FoundFlag) //none
					{
						Count += 2;
					}
					else if(PD1 == -1) // only one
					{
						Count++;
					}
					else if(((PD2 == -1) && (PD1 > -1) && (EveryPrefDir->PrefDirVector.at(PD1).GetELink() == EveryPrefDir->PrefDirVector.at(PD0).GetXLink()) &&
						(EveryPrefDir->PrefDirVector.at(PD1).GetXLink() == EveryPrefDir->PrefDirVector.at(PD0).GetELink()))) //only one, other has bidirs
					{
						Count++;
					}
				}
				else //single track element
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(35, HLoc, VLoc, FoundFlag, PD0, PD1, PD2, PD3);
					//check if either track with no PDs: !Foundflag == none, PD1 == -1 == only one, and last condition covers one having a bidir PD & other none
					if(!FoundFlag)
					{
						Count++;
					}
				}
			}
			if(Count > 20)
			{
				CountWord = "There are many track elements without preferred directions.\n\n"
							"Do you wish to highlight them (YES) or skip this part of the check (NO)?";
			}
			if(Count > 2)
			{
				Screen->Cursor = TCursor(-2); // Arrow
				int Button = Application->MessageBox(CountWord.c_str(), L"Skip option", MB_YESNO);
				ClearandRebuildRailway(96); // to clear inversion
				if(Button == IDNO)
				{
					InfoPanel->Caption = TempInfo;
            		ShowMessage("Finished");
					Utilities->CallLogPop(2484);
					return;
				}
				Screen->Cursor = TCursor(-11); //Hourglass
				Display->Update();
			}
//continue with the check if haven't returned
			for(unsigned int x = 0; x < Track->TrackVector.size(); x++)
			{
				int HLoc = Track->TrackElementAt(1465, x).HLoc;
				int VLoc = Track->TrackElementAt(1466, x).VLoc;
				if((Track->TrackElementAt(1467, x).TrackType == Points) || (Track->TrackElementAt(1468, x).TrackType == Crossover) ||
					(Track->TrackElementAt(1469, x).TrackType == Bridge))
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(32, HLoc, VLoc, FoundFlag, PD0, PD1, PD2, PD3);
					//check if either track with no PDs: !Foundflag == none, PD1 == -1 == only one, and last condition covers one having a bidir PD & other none
					if(!FoundFlag || (PD1 == -1) || ((PD2 == -1) && (PD1 > -1) && (EveryPrefDir->PrefDirVector.at(PD1).GetELink() == EveryPrefDir->PrefDirVector.at(PD0).GetXLink()) &&
						(EveryPrefDir->PrefDirVector.at(PD1).GetXLink() == EveryPrefDir->PrefDirVector.at(PD0).GetELink()))) //need to check both as points can meet just one with one PD on each track
					{
						if((LastHLoc != HLoc) || (LastVLoc != VLoc))
						{
							LastHLoc = HLoc;
							LastVLoc = VLoc;
							while((Display->DisplayOffsetH - HLoc) > 0)
							{
								Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
							}
							while((HLoc - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
							{
								Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
							}
							while((Display->DisplayOffsetV - VLoc) > 0)
							{
								Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
							}
							while((VLoc - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
							{
								Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
							}
							ClearandRebuildRailway(92);
							Display->InvertElement(4, HLoc * 16, VLoc * 16);
							Screen->Cursor = TCursor(-2); // Arrow
                            int Button = Application->MessageBox(L"Preferred direction missing at the highlighted element.\n\n"
                                                                 "The highlighted element may be behind this message\n"
                                                                 "which can be moved by left clicking the mouse in the\n"
                                                                 "title bar and dragging it.\n\n"
                                                                 "The omission may or may not matter depending\n"
                                                                 "on routing requirements during operation.\n\n"
                                                                 "Click 'OK' to ignore and continue checking or 'Cancel'\n"
                                                                 "to allow correction.", L"Warning", MB_OKCANCEL | MB_ICONWARNING);
							ClearandRebuildRailway(93); // to clear inversion
							if(Button == IDCANCEL)
							{
								InfoPanel->Caption = TempInfo;
								Utilities->CallLogPop(2482);
								return;
							}
							Screen->Cursor = TCursor(-11); //Hourglass
							Display->Update();
						}
					}
				}
				else //single track element
				{
					EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(33, HLoc, VLoc, FoundFlag, PD0, PD1, PD2, PD3);
					//check if either track with no PDs: !Foundflag == none, PD1 == -1 == only one, and last condition covers one having a bidir PD & other none
					if(!FoundFlag)
					{
						if((LastHLoc != HLoc) || (LastVLoc != VLoc))
						{
							LastHLoc = HLoc;
							LastVLoc = VLoc;
							while((Display->DisplayOffsetH - HLoc) > 0)
							{
								Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
							}
							while((HLoc - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
							{
								Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
							}
							while((Display->DisplayOffsetV - VLoc) > 0)
							{
								Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
							}
							while((VLoc - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
							{
								Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
							}
							ClearandRebuildRailway(94);
							Display->InvertElement(5, HLoc * 16, VLoc * 16);
							Screen->Cursor = TCursor(-2); // Arrow
                            int Button = Application->MessageBox(L"Preferred direction missing at the highlighted element.\n\n"
                                                                 "The highlighted element may be behind this message\n"
                                                                 "which can be moved by left clicking the mouse in the\n"
                                                                 "title bar and dragging it.\n\n"
                                                                 "The omission may or may not matter depending\n"
                                                                 "on routing requirements during operation.\n\n"
                                                                 "Click 'OK' to ignore and continue checking or 'Cancel'\n"
                                                                 "to allow correction.", L"Warning", MB_OKCANCEL | MB_ICONWARNING);
							ClearandRebuildRailway(95); // to clear inversion
							if(Button == IDCANCEL)
							{
								InfoPanel->Caption = TempInfo;
								Utilities->CallLogPop(2483);
								return;
							}
							Screen->Cursor = TCursor(-11); //Hourglass
							Display->Update();
						}
					}
				}
			}
		}
		Screen->Cursor = TCursor(-2); // Arrow
		ShowMessage("Finished");
		InfoPanel->Caption = TempInfo;
		Utilities->CallLogPop(2305);
	}
	catch(const Exception &e) //non-error catch
	{
		Screen->Cursor = TCursor(-2); // Arrow
		ShowMessage("Error in preferred direction checking, unable to complete the check");
		Utilities->CallLogPop(2306);
	}
}

//---------------------------------------------------------------------------

bool TInterface::BypassPDCrossoverMismatch(int Caller, int HLoc, int VLoc)
/* If there's a crossover between two lines that each have single PDs set on them and the crossover has bidirectioal PDs then ordinarily a mismatch would be flagged
for each crossover.  However since no PD route can be set over the crossover whatever PDs are set on them there's no point in flagging the mismatch.
This function checks if the element passed in is a point with 3 PDs set (PD2 > -1 &  PD3 == -1), i.e. only one leg has a bidir PD, and that this bidir PD leg is connected
to another point bidir leg with 3 PDs set.  If so it returns true, else false.
*/
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BypassPDCrossoverMismatch " + AnsiString(HLoc) + "," + AnsiString(VLoc));
    int PD0 = -1, PD1 = -1, PD2 = -1, PD3 = -1;
    int PDLinked0 = -1, PDLinked1 = -1, PDLinked2 = -1, PDLinked3 = -1;
    int BidirLinkPos = -1;
    bool FoundFlag = false, BidirOnLink = false;
    EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(19, HLoc, VLoc, FoundFlag, PD0, PD1, PD2, PD3);
    if((PD0 == -1) || (PD2 == -1) || (PD3 > -1))
    {
        Utilities->CallLogPop(2457);
        return false;
    }
    if(PD0 > -1)
    {
        if(EveryPrefDir->PrefDirVector.at(PD0).TrackType != Points)
        {
            Utilities->CallLogPop(2458);
            return false;
        }
    }
//here it's points with one bidir leg
//now find the link [1] or [3] that corresponds to the bidir leg and check it's another point with the same characteristics
    if((EveryPrefDir->PrefDirVector.at(PD0).GetXLink() == EveryPrefDir->PrefDirVector.at(PD1).GetELink()) &&
            (EveryPrefDir->PrefDirVector.at(PD1).GetXLink() == EveryPrefDir->PrefDirVector.at(PD0).GetELink()))
        {   // bidir leg is PD0 & PD1
            if(EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetELinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetELinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
        }
    else if((EveryPrefDir->PrefDirVector.at(PD0).GetXLink() == EveryPrefDir->PrefDirVector.at(PD2).GetELink()) &&
            (EveryPrefDir->PrefDirVector.at(PD2).GetXLink() == EveryPrefDir->PrefDirVector.at(PD0).GetELink()))
        {   // bidir leg is PD0 & PD2
            if(EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetXLinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetELinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD0).GetELinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
        }
    else if((EveryPrefDir->PrefDirVector.at(PD2).GetXLink() == EveryPrefDir->PrefDirVector.at(PD1).GetELink()) &&
            (EveryPrefDir->PrefDirVector.at(PD1).GetXLink() == EveryPrefDir->PrefDirVector.at(PD2).GetELink()))
        {   // bidir leg is PD1 & PD2
            if(EveryPrefDir->PrefDirVector.at(PD1).GetXLinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD1).GetXLinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD1).GetELinkPos() == 1)
            {
                BidirLinkPos = 1;
            }
            else if(EveryPrefDir->PrefDirVector.at(PD1).GetELinkPos() == 3)
            {
                BidirLinkPos = 3;
            }
        }
    if((BidirLinkPos == -1) || (BidirLinkPos > 3))//shouldn't be
    {
        Utilities->CallLogPop(2459);
        return false;
    }
//now find the linked element and check it's a point with 3 PDs set & link bidir
    int TVPos = Track->TrackElementAt(1458, EveryPrefDir->PrefDirVector.at(PD0).GetTrackVectorPosition()).Conn[BidirLinkPos];
    int TVLinkPos = Track->TrackElementAt(1459, EveryPrefDir->PrefDirVector.at(PD0).GetTrackVectorPosition()).ConnLinkPos[BidirLinkPos];
    if(TVPos == -1)
    {
        Utilities->CallLogPop(2460);
        return false;
    }
    if((TVLinkPos == 0) || (TVLinkPos == 2) || (TVLinkPos > 3))
    {
        Utilities->CallLogPop(2461);
        return false;
    }
    if(Track->TrackElementAt(1460, TVPos).TrackType  != Points)
    {
        Utilities->CallLogPop(2462);
        return false;
    }
    if((TVLinkPos != 1) && (TVLinkPos != 3)) //must be linked at trailing leg
    {
        Utilities->CallLogPop(2463);
        return false;
    }
    EveryPrefDir->GetVectorPositionsFromPrefDir4MultiMap(20, Track->TrackElementAt(1462, TVPos).HLoc,
         Track->TrackElementAt(1461, TVPos).VLoc, FoundFlag, PDLinked0, PDLinked1, PDLinked2, PDLinked3);
    if(!FoundFlag)
    {
        Utilities->CallLogPop(2464);
        return false;
    }
    if((PDLinked0 == -1) || (PDLinked2 == -1) || (PDLinked3 > -1)) //must have exactly 3 PDs
    {
        Utilities->CallLogPop(2465);
        return false;
    }
//now need bidir PDs on linked leg
    if((EveryPrefDir->PrefDirVector.at(PDLinked0).GetXLink() == EveryPrefDir->PrefDirVector.at(PDLinked1).GetELink()) &&
        (EveryPrefDir->PrefDirVector.at(PDLinked0).GetELink() == EveryPrefDir->PrefDirVector.at(PDLinked1).GetXLink()))
    {   //bidir leg is PDLinked0 & PDLinked1
        if(EveryPrefDir->PrefDirVector.at(PDLinked0).GetXLinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }
        if(EveryPrefDir->PrefDirVector.at(PDLinked0).GetELinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }

    }
    else if((EveryPrefDir->PrefDirVector.at(PDLinked0).GetXLink() == EveryPrefDir->PrefDirVector.at(PDLinked2).GetELink()) &&
        (EveryPrefDir->PrefDirVector.at(PDLinked0).GetELink() == EveryPrefDir->PrefDirVector.at(PDLinked2).GetXLink()))
    {   //bidir leg is PDLinked0 & PDLinked2
        if(EveryPrefDir->PrefDirVector.at(PDLinked0).GetXLinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }
        if(EveryPrefDir->PrefDirVector.at(PDLinked0).GetELinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }

    }
    else if((EveryPrefDir->PrefDirVector.at(PDLinked1).GetXLink() == EveryPrefDir->PrefDirVector.at(PDLinked2).GetELink()) &&
        (EveryPrefDir->PrefDirVector.at(PDLinked1).GetELink() == EveryPrefDir->PrefDirVector.at(PDLinked2).GetXLink()))
    {   //bidir leg is PDLinked0 & PDLinked2
        if(EveryPrefDir->PrefDirVector.at(PDLinked1).GetXLinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }
        if(EveryPrefDir->PrefDirVector.at(PDLinked1).GetELinkPos() == TVLinkPos)
        {
            BidirOnLink = true;
        }
    }
    if(!BidirOnLink)
    {
        Utilities->CallLogPop(2466);
        return false;
    }
    Utilities->CallLogPop(2467);
    return true;
}

//---------------------------------------------------------------------------

void __fastcall TInterface::LoadTimetableMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("LoadTimetableMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LoadTimetableMenuItemClick");
        TimetableDialog->Filter = "Timetable file (*.ttb)|*.ttb";
        // reset all message flags, stops them being given twice  new at v2.4.0
        TrainController->SSHigh = false;
        TrainController->MRSHigh = false;
        TrainController->MRSLow = false;
        TrainController->MassHigh = false;
        TrainController->BFHigh = false;
        TrainController->BFLow = false;
        TrainController->PwrHigh = false;
        TrainController->SigSHigh = false;
        TrainController->SigSLow = false;
        if(TimetableDialog->Execute())
        {
            if(TimetableDialog->InitialDir != TPath::GetDirectoryName(TimetableDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                TimetableDialog->InitialDir = TPath::GetDirectoryName(TimetableDialog->FileName);
                SaveTTDialog->InitialDir = TPath::GetDirectoryName(TimetableDialog->FileName);
            }
            TrainController->LogEvent("LoadTimetable " + TimetableDialog->FileName);
            bool CheckLocationsExistInRailwayTrue = true;
            if(TrainController->TimetableIntegrityCheck(0, AnsiString(TimetableDialog->FileName).c_str(), true, CheckLocationsExistInRailwayTrue))
            // true for GiveMessages
            {
                Screen->Cursor = TCursor(-11); // Hourglass;
                std::ifstream TTBLFile(AnsiString(TimetableDialog->FileName).c_str(), std::ios_base::binary);
                if(TTBLFile.is_open())
                {
                    bool SessionFileFalse = false;
                    if(BuildTrainDataVectorForLoadFile(0, TTBLFile, true, CheckLocationsExistInRailwayTrue, SessionFileFalse)) // true for GiveMessages
                    {
                        SaveTempTimetableFile(0, TimetableDialog->FileName);
                    } // don't need an 'else' as messages given in BuildTrainDataVectorForLoadFile

                }
                else
                {
                    ShowMessage("Failed to open timetable file, make sure it's spelled correctly, it exists and isn't open in another application");
                }
                Screen->Cursor = TCursor(-2); // Arrow
            } // if(TimetableIntegrityCheck
            else
            {
                ShowMessage("Timetable integrity check failed - unable to load " + TimetableDialog->FileName + ". If the file exists and is spelled correctly then it probably contains errors - check in 'Edit timetable' mode.");
                //message clarified at v2.14.0
            }
        } // if(TimetableDialog->Execute())

        // else ShowMessage("Load Aborted");
        Utilities->CallLogPop(752);
    }
    catch(const Exception &e)  //made a non-error catch at v2.14.0 following Albie Vowles error of 15/12/22
    {
        TrainController->StopTTClockMessage(137, "Timetable file failed to load - may be corrupt.\nError message: " + e.Message);
        Screen->Cursor = TCursor(-2); // Arrow;
        Utilities->CallLogPop(2553);
//        ErrorLog(34, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::TakeSignallerControlMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SignallerControl1Click");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SignallerControl1Click");
        TTrain &Train = TrainController->TrainVectorAtIdent(17, SelectedTrainID);
        Train.SignallerStoppingFlag = false;
        Train.TrainMode = Signaller;
        if(Train.MaxRunningSpeed > Train.SignallerMaxSpeed)
        {
            Train.MaxRunningSpeed = Train.SignallerMaxSpeed;
        }
        if(Train.Stopped())
        {
            Train.SignallerStopped = true; // condition added at v2.4.0 to allow for taking sig control of failed moving trains
        }
        Train.CallingOnFlag = false; // in case was set, wouldn't start anyway if called on as SignallerStopped = true
        RailGraphics->ChangeForegroundColour(25, Train.HeadCodePosition[0], Train.FrontCodePtr, clFrontCodeSignaller, Train.BackgroundColour);
        Train.PlotTrain(5, Display);
        AnsiString LocName = "";
        if(Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(633, Train.LeadElement).ActiveTrackElementName;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(634, Train.MidElement).ActiveTrackElementName;
        }
        // store the value that allow restoration of tt control or not - RestoreTimetableLocation
        if(Train.RevisedStoppedAtLoc() && (LocName != ""))
        {
            Train.RestoreTimetableLocation = LocName;
        }
        else
        {
            Train.RestoreTimetableLocation = "";
        }
        // check whether need to offer 'pass stop signal'
        if(!Train.StoppedAtSignal && Train.RevisedStoppedAtLoc())
        {
            int NextElementPosition = Track->TrackElementAt(775, Train.LeadElement).Conn[Train.LeadExitPos];
            int NextEntryPos = Track->TrackElementAt(776, Train.LeadElement).ConnLinkPos[Train.LeadExitPos];
            if((NextElementPosition > -1) && (NextEntryPos > -1))
            {
                if((Track->TrackElementAt(777, NextElementPosition).Config[Track->GetNonPointsOppositeLinkPos(NextEntryPos)] == Signal) &&
                   (Track->TrackElementAt(778, NextElementPosition).Attribute == 0))
                {
                    // set both StoppedAtLocation & StoppedAtSignal, so that 'pass stop signal' is offered in popup menu rather than move
                    // forwards, but don't change the background colour so still shows as stopped at location
                    Train.StoppedAtSignal = true;
                }
            }
        }
        // find element ID if no locname
        if((LocName == "") && Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(635, Train.LeadElement).ElementID;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(636, Train.MidElement).ElementID;
        }
        Train.LogAction(0, Train.HeadCode, "", TakeSignallerControl, LocName, TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        Utilities->CallLogPop(1772);
    }
    catch(const Exception &e)
    {
        ErrorLog(157, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TimetableControlMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TimetableControlMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TimetableControlMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(18, SelectedTrainID);
        Train.SignallerStoppingFlag = false;
        Train.TrainMode = Timetable;
        Train.SignallerStopped = false;
        Train.StoppedAfterSPAD = false;
        Train.SPADFlag = false;
        Train.MaxRunningSpeed = Train.TimetableMaxRunningSpeed;
        RailGraphics->ChangeForegroundColour(18, Train.HeadCodePosition[0], Train.FrontCodePtr, clFrontCodeTimetable, Train.BackgroundColour);
// red headcode[0]
        Train.PlotTrain(6, Display);
        AnsiString LocName = "", LeadElementLocName = "", MidElementLocName = "", RequiredLocName = Train.ActionVectorEntryPtr->LocationName;
        if(Train.LeadElement > -1)  //this naming procedure changed at v2.9.1 as a train might have one element at a station and the other at a non-station named location
                                    //but only one is the location in the timetable, and that is the RequiredLocName.  Discovered for LS41 at Lincoln.
        {
            LeadElementLocName = Track->TrackElementAt(645, Train.LeadElement).ActiveTrackElementName;
        }
        if(Train.MidElement > -1)
        {
            MidElementLocName = Track->TrackElementAt(647, Train.MidElement).ActiveTrackElementName;
        }
        if((LeadElementLocName == "") && (MidElementLocName == "") && (Train.LeadElement > -1))
        {
            LeadElementLocName = Track->TrackElementAt(646, Train.LeadElement).ElementID;
        }
        if((MidElementLocName == "") && (Train.MidElement > -1)) //changed from LeadElementLocName at v2.12.0 - must have been a mistake
        {
            MidElementLocName = Track->TrackElementAt(648, Train.MidElement).ElementID;
        }
        if((LeadElementLocName == RequiredLocName) || (MidElementLocName == RequiredLocName))
        {
            LocName = RequiredLocName;
        }
        else if(LeadElementLocName != "") //these two else ifs added at v2.12.0 as noticed that if a train is restored to tt control at
        {                                 //a loc that isn't RequiredLocName then LocName is ""
            LocName = LeadElementLocName; //LeadElement takes precedence if both named
        }
        else if(MidElementLocName != "")
        {
            LocName = MidElementLocName;
        }
        if(((Train.ActionVectorEntryPtr->LocationType == AtLocation) || Train.TreatPassAsTimeLocDeparture) && (LocName == Train.ActionVectorEntryPtr->LocationName))
        {//Train.TreatPassAsTimeLocDeparture added at v2.12.0 so background stays pale green after taking signaller control, as LocationType is EnRoute for a Pass
            if(Train.TreatPassAsTimeLocDeparture)     //this if... else... segment added at v2.12.0 to ensure one or the other true but not both
            {
                Train.StoppedAtLocation = false;
            }
            else
            {
                Train.StoppedAtLocation = true;
            }
            Train.StoppedAtSignal = false;
// added at v2.7.0 as if had been stopped at signal before tt control restored then background colour would change to normal when signal cleared even when not due to depart
            Train.LastActionTime = TrainController->TTClockTime; // by itself this only affects trains that have still to arrive, if waiting to
                                                                 // depart the departure time & TRS time have already been calculated so need to
                                                                 // force a recalculation - see below
//            Train.DepartureTimeSet = false; // force it to be recalculated based on new LastActionTime (if waiting to arrive this is false anyway)
//can't use the above after random delays introduced, as lose the delay when restore tt control (see FinsburyPark [discord name] error noted below)
            if(!Train.TrainFailed)
            {
                Train.PlotTrainWithNewBackgroundColour(28, clStationStopBackground, Display); // pale green
            } // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements

            if((Train.ActionVectorEntryPtr->FormatType == TimeLoc) && (Train.ActionVectorEntryPtr->ArrivalTime >= TDateTime(0)))
            {
                // Timetable indicates that train still waiting to arrive for a TimeLoc arrival so send message and mark as arrived
                Train.LogAction(28, Train.HeadCode, "", Arrive, LocName, Train.ActionVectorEntryPtr->ArrivalTime, Train.ActionVectorEntryPtr->Warning);
                Train.ActionVectorEntryPtr++; // advance pointer past arrival  //added at v1.2.0
            }
            else if((Train.ActionVectorEntryPtr->FormatType == TimeTimeLoc) && !(Train.TimeTimeLocArrived))
            {
                // Timetable indicates that train still waiting to arrive for a TimeTimeLoc arrival so send message and mark as arrived
                Train.LogAction(29, Train.HeadCode, "", Arrive, LocName, Train.ActionVectorEntryPtr->ArrivalTime, Train.ActionVectorEntryPtr->Warning);
                Train.TimeTimeLocArrived = true;
                // NB: No need for 'Train.ActionVectorEntryPtr++' because still to act on the departure time
            }

            TActionVectorEntry *AVE = Train.ActionVectorEntryPtr;
            if((AVE->DepartureTime >= TDateTime(0)) && ((AVE->FormatType == TimeLoc) || (AVE->FormatType == TimeTimeLoc)))
            {
                if((Train.ReleaseTime - Train.LastActionTime) < TDateTime(30.0 / 86400)) //due to release in less than 30 seconds, added at v2.13.0 to correct
                {                                                                      //FinsburyPark (discord name) error reported 29/05/22
                    Train.ReleaseTime = Train.LastActionTime + TDateTime(30.0 / 86400);
                    Train.TRSTime = Train.ReleaseTime - TDateTime(10.0/86400);  //added at v2.14.0 as this needs to be reset too to plot correct train b'gnd colour
                }
            }
        }
        else
        {
            int NextElementPos = -1; // addition for v1.3.2 due to Carwyn Thomas' error
            int NextEntryPos = -1; // ---ditto---
            if(Train.LeadElement > -1) // ---ditto---
            {
                // ---ditto---
                NextElementPos = Track->TrackElementAt(658, Train.LeadElement).Conn[Train.LeadExitPos]; // had 'int' prefix before additions
                NextEntryPos = Track->TrackElementAt(659, Train.LeadElement).ConnLinkPos[Train.LeadExitPos]; // ---ditto---
            } // ---ditto---

            // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
            if(!Train.TrainFailed)
            {
                Train.PlotTrainWithNewBackgroundColour(31, clNormalBackground, Display); // to remove other background if was present, moved from
            } // within Train.AbleToMove at v2.4.0 to cancel signal stop background

            if(Train.AbleToMove(1)) // if has no power
            {
                Train.EntrySpeed = 0; // moved from below for v1.3.2 after Carwyn Thomas error
                Train.EntryTime = TrainController->TTClockTime; // ---Ditto---
                Train.FirstHalfMove = true; // ---Ditto---
                if((NextElementPos > -1) && (NextEntryPos > -1)) // changed from if(NextElementPos >= 0) as above
                {
                    // Train.EntrySpeed = 0;
                    // Train.EntryTime = TrainController->TTClockTime;
                    // Train.FirstHalfMove = true;
                    Train.SetTrainMovementValues(15, NextElementPos, NextEntryPos);
                }
                // else follow the continuations   //added these 3 conditions for v1.3.2 after Carwyn Thomas error
                else if((Train.LeadElement > -1) && (Track->TrackElementAt(894, Train.LeadElement).TrackType == Continuation))
                {
                    Train.SetTrainMovementValues(21, Train.LeadElement, Train.LeadEntryPos); // Use LeadElement for calcs if lead is a continuation
                }
                else if((Train.MidElement > -1) && (Track->TrackElementAt(895, Train.MidElement).TrackType == Continuation))
                {
                    Train.SetTrainMovementValues(22, Train.MidElement, Train.MidEntryPos); // Use MidElement for calcs if Mid is a continuation
                }
                else if((Train.LagElement > -1) && (Track->TrackElementAt(896, Train.LagElement).TrackType == Continuation))
                {
                    Train.SetTrainMovementValues(23, Train.LagElement, Train.LagEntryPos); // Use LagElement for calcs if Lag is a continuation
                }
            }
            else if(Train.StoppedAtSignal)
            {
                // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
                if(!Train.TrainFailed)
                {
                    Train.PlotTrainWithNewBackgroundColour(45, clSignalStopBackground, Display);
                }
                // TrainController->LogActionError(42, Train.HeadCode, "", SignalHold, Track->TrackElementAt(757, NextElementPos).ElementID);
            }
        }
        Train.LogAction(1, Train.HeadCode, "", RestoreTimetableControl, LocName, TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        Utilities->CallLogPop(1195);
    }
    catch(const Exception &e)
    {
        ErrorLog(158, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ChangeDirectionMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ChangeDirectionMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ChangeDirectionMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(19, SelectedTrainID);
        Train.SignallerStoppingFlag = false;
        Train.SignallerChangeTrainDirection(0); // this unplots & replots train, which checks for facing signal and sets StoppedAtSignal if req'd
        Train.SignallerStopped = true;
        AnsiString LocName = "";
        if(Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(637, Train.LeadElement).ActiveTrackElementName;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(638, Train.MidElement).ActiveTrackElementName;
        }
        if((LocName == "") && Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(639, Train.LeadElement).ElementID;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(640, Train.MidElement).ElementID;
        }
        Train.LogAction(2, Train.HeadCode, "", SignallerChangeDirection, LocName, TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        Utilities->CallLogPop(1196);
    }
    catch(const Exception &e)
    {
        ErrorLog(159, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::MoveForwardsMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MoveForwardsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MoveForwardsMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(20, SelectedTrainID);
        if(Train.StoppedAtLocation && (Train.ActionVectorEntryPtr->DepartureTime > TDateTime(-1)) && !TrainLeaveWarningSent) //added at v2.14.0
        {
            UnicodeString MessageStr = "Please be aware that a train moved from a location prior to its departure time must be returned to that location "
                                       "in order to restore timetable control\n\nThis message will not be shown again\n\nOK to continue, Cancel to abort";
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_OKCANCEL);
            TrainLeaveWarningSent = true;
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDCANCEL)
            {
                Utilities->CallLogPop(2557);
                return;
            }
        }
        Train.SignallerStoppingFlag = false;
        if(!Train.AbleToMove(2))
        {
            // shouldn't be here as when unable to move MoveForwards shouldn't be enabled, but leave in as a precaution
            Utilities->CallLogPop(1197);
            return;
        }
        Train.SignallerStopped = false;
        Train.StoppedAfterSPAD = false; // in case had been set
        Train.SPADFlag = false;
        Train.StoppedAtLocation = false; // may not have been set but reset anyway
        // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
        Train.PlotTrainWithNewBackgroundColour(29, clNormalBackground, Display);
        Train.EntrySpeed = 0;
        Train.EntryTime = TrainController->TTClockTime;
        Train.FirstHalfMove = true;
        int NextElementPos = -1; // addition for v1.3.2 due to Carwyn Thomas error
        int NextEntryPos = -1; // ---ditto---
        if(Train.LeadElement > -1) // ---ditto---
        {
            // ---ditto---
            NextElementPos = Track->TrackElementAt(652, Train.LeadElement).Conn[Train.LeadExitPos]; // had 'int' prefix before additions
            NextEntryPos = Track->TrackElementAt(657, Train.LeadElement).ConnLinkPos[Train.LeadExitPos]; // ---ditto---
        } // ---ditto---

        if((NextElementPos > -1) && (NextEntryPos > -1))
        {
            Train.SetTrainMovementValues(14, NextElementPos, NextEntryPos); // NextElement is the element to be entered
        }
        // else follow the continuations
        else if((Train.LeadElement > -1) && (Track->TrackElementAt(784, Train.LeadElement).TrackType == Continuation))
        {
            Train.SetTrainMovementValues(17, Train.LeadElement, Train.LeadEntryPos); // Use LeadElement for calcs if lead is a continuation
        }
        else if((Train.MidElement > -1) && (Track->TrackElementAt(785, Train.MidElement).TrackType == Continuation))
        {
            Train.SetTrainMovementValues(18, Train.MidElement, Train.MidEntryPos); // Use MidElement for calcs if Mid is a continuation
        }
        else if((Train.LagElement > -1) && (Track->TrackElementAt(786, Train.LagElement).TrackType == Continuation))
        {
            Train.SetTrainMovementValues(19, Train.LagElement, Train.LagEntryPos); // Use LagElement for calcs if Lag is a continuation
        }
        Train.LogAction(3, Train.HeadCode, "", SignallerMoveForwards, "", TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        Utilities->CallLogPop(1198);
    }
    catch(const Exception &e)
    {
        ErrorLog(160, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SignallerJoinedByMenuItemClick(TObject *Sender)
{
    // new at v2.4.0
    try
    {
        TrainController->LogEvent("JoinedByMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",JoinedByMenuItemClick");
        TTrain *TrainToBeJoinedBy;
        TTrain &ThisTrain = TrainController->TrainVectorAtIdent(45, SelectedTrainID);
        if(ThisTrain.IsThereAnAdjacentTrain(1, TrainToBeJoinedBy)) // this must come before both powers zero check in order to set a valid TrainToBeJoinedBy
        {
            if(TrainToBeJoinedBy->TrainMode != Signaller)
            {
                TrainController->StopTTClockMessage(91, "Adjacent train must be under signaller control in order to join");
                Utilities->CallLogPop(2156);
                return;
            }
            // here if there is an adjacent train under signaller control
            if((TrainToBeJoinedBy->PowerAtRail < 1) && (ThisTrain.PowerAtRail < 1))
            {
                ShowMessage("Can't join two trains when both are without power");
                Utilities->CallLogPop(2157);
                return;
            }
            AnsiString UnableToJoinIfWaitingToJoinMessage = "Can't join two trains that are waiting to join under\n"
                                             "timetable control. Manoeuvre them both to the join\n"
                                             "location, make sure they are adjacent, and restore\n"
                                             "timetable control. They will then join at the timetabled\n"
                                             "time, or if that has passed then after 30 seconds.";
            //add condition for Micke's error reported 19/05/22 by email (add as 2 conditions for simplicity)
            if((TrainToBeJoinedBy->ActionVectorEntryPtr->Command == "Fjo") &&
                (TrainToBeJoinedBy->ActionVectorEntryPtr->LinkedTrainEntryPtr->ServiceReference == ThisTrain.TrainDataEntryPtr->ServiceReference))
            {
                ShowMessage(UnableToJoinIfWaitingToJoinMessage);
                Utilities->CallLogPop(2536);
                return;
            }
            if((TrainToBeJoinedBy->ActionVectorEntryPtr->Command == "jbo") &&
                (TrainToBeJoinedBy->ActionVectorEntryPtr->LinkedTrainEntryPtr->ServiceReference == ThisTrain.TrainDataEntryPtr->ServiceReference))
            {
                ShowMessage(UnableToJoinIfWaitingToJoinMessage);
                Utilities->CallLogPop(2537);
                return;
            }
            AnsiString TrainToBeJoinedByHeadCode = TrainToBeJoinedBy->HeadCode;
            // set new values for mass etc
            double OtherBrakeForce = TrainToBeJoinedBy->MaxBrakeRate * TrainToBeJoinedBy->Mass;
            double OwnBrakeForce = ThisTrain.MaxBrakeRate * ThisTrain.Mass;
            double CombinedBrakeRate = (OtherBrakeForce + OwnBrakeForce) / (TrainToBeJoinedBy->Mass + ThisTrain.Mass);

            // set new values for mass etc
            if(ThisTrain.MaxRunningSpeed > TrainToBeJoinedBy->MaxRunningSpeed)      //this added at v2.11.1 as had been omitted before
            {
                ThisTrain.MaxRunningSpeed = TrainToBeJoinedBy->MaxRunningSpeed;
            }
            ThisTrain.Mass += TrainToBeJoinedBy->Mass;
            ThisTrain.MaxBrakeRate = CombinedBrakeRate;
            ThisTrain.PowerAtRail += TrainToBeJoinedBy->PowerAtRail;
            ThisTrain.AValue = sqrt(2 * ThisTrain.PowerAtRail / ThisTrain.Mass);

            TrainToBeJoinedBy->TrainGone = true; // this will cause other train to be deleted
            TrainToBeJoinedBy->JoinedOtherTrainFlag = true;
            AnsiString LocName = "";
            if(ThisTrain.LeadElement > -1)
            {
                LocName = Track->TrackElementAt(979, ThisTrain.LeadElement).ActiveTrackElementName;
            }
            if((LocName == "") && (ThisTrain.MidElement > -1))
            {
                LocName = Track->TrackElementAt(980, ThisTrain.MidElement).ActiveTrackElementName;
            }
            if((LocName == "") && ThisTrain.LeadElement > -1)
            {
                LocName = Track->TrackElementAt(981, ThisTrain.LeadElement).ElementID;
            }
            if((LocName == "") && (ThisTrain.MidElement > -1))
            {
                LocName = Track->TrackElementAt(982, ThisTrain.MidElement).ElementID;
            }
            ThisTrain.StoppedWithoutPower = true;
            if(ThisTrain.PowerAtRail >= 1)
            {
                ThisTrain.StoppedWithoutPower = false;
            }
            ThisTrain.TrainFailed = false; // if had failed then no longer failed, even if joining train has no power
            if(!ThisTrain.RevisedStoppedAtLoc())
            {
                // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
                ThisTrain.PlotTrainWithNewBackgroundColour(49, clSignallerStopped, Display);
            }
            else
            {
                // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
                ThisTrain.PlotTrainWithNewBackgroundColour(50, clStationStopBackground, Display);
            }
            ThisTrain.SignallerStopped = true; // maybe as well as stopped without power, thought that takes precedence in floating window
            ThisTrain.LogAction(34, ThisTrain.HeadCode, TrainToBeJoinedBy->HeadCode, SignallerJoin, LocName, TDateTime(0), false); // TDateTime isn't used
            ThisTrain.ZeroPowerNoFrontSplitMessage = false; // added at v2.4.0, no need to include TrainToBeJoinedBy as that will be removed
            ThisTrain.ZeroPowerNoRearSplitMessage = false;
            ThisTrain.FailedTrainNoFinishJoinMessage = false;
            ThisTrain.ZeroPowerNoJoinedByMessage = false;
            ThisTrain.ZeroPowerNoCDTMessage = false;
            ThisTrain.ZeroPowerNoNewServiceMessage = false;
            ThisTrain.ZeroPowerNoNewShuttleFromNonRepeatMessage = false;
            ThisTrain.ZeroPowerNoRepeatShuttleMessage = false;
            ThisTrain.ZeroPowerNoRepeatShuttleOrNewServiceMessage = false;
            Utilities->CallLogPop(2158);
        }
    }
    catch(const Exception &e)
    {
        ErrorLog(207, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::RepairFailedTrainMenuItemClick(TObject *Sender)
{
    // added at v2.4.0
    try
    {
        TrainController->LogEvent("RepairFailedTrainMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RepairFailedTrainMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(46, SelectedTrainID);
        Train.TrainFailed = false;
        Train.StoppedWithoutPower = false;
        Train.SignallerStopped = true;
        if(!Train.RevisedStoppedAtLoc())
        {
            // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
            Train.PlotTrainWithNewBackgroundColour(51, clSignallerStopped, Display);
        }
        else
        {
            // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
            Train.PlotTrainWithNewBackgroundColour(52, clStationStopBackground, Display);
        }
        Train.PowerAtRail = Train.OriginalPowerAtRail; // recover from original value, new at v2.4.0
        Train.AValue = sqrt(2 * Train.PowerAtRail / Train.Mass);
        Train.SetTrainMovementValues(24, Train.LeadElement, Train.LeadEntryPos);
        AnsiString LocName = "";
        if(Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(983, Train.LeadElement).ActiveTrackElementName;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(984, Train.MidElement).ActiveTrackElementName;
        }
        if((LocName == "") && Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(985, Train.LeadElement).ElementID;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(986, Train.MidElement).ElementID;
        }
        Train.LogAction(35, Train.HeadCode, "", RepairFailedTrain, LocName, TrainController->TTClockTime, false); // false for no warning
        Train.ZeroPowerNoFrontSplitMessage = false;
        Train.ZeroPowerNoRearSplitMessage = false;
        Train.FailedTrainNoFinishJoinMessage = false;
        Train.ZeroPowerNoJoinedByMessage = false;
        Train.ZeroPowerNoCDTMessage = false;
        Train.ZeroPowerNoNewServiceMessage = false;
        Train.ZeroPowerNoNewShuttleFromNonRepeatMessage = false;
        Train.ZeroPowerNoRepeatShuttleMessage = false;
        Train.ZeroPowerNoRepeatShuttleOrNewServiceMessage = false;
        Utilities->CallLogPop(2159);
    }
    catch(const Exception &e)
    {
        ErrorLog(208, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SkipTimetabledActionsMenuItemClick(TObject *Sender)
{
/* Only enable this for stopped at signal or stopped at location.

If stopped at signal then next action will be TimeLoc arrival, TimeTimeLoc, Pass or Fer.

If stopped at a location then next action will be TimeTimeLoc dep/TimeLoc dep/jbo/fsp/rsp/cdt/Frh/Fns/Fjo/Frh-sh/Fns-sh/F-nshs.

FormatType:  NoFormat, TimeLoc, TimeTimeLoc, TimeCmd, StartNew, TimeCmdHeadCode, FinRemHere, FNSNonRepeatToShuttle, SNTShuttle, SNSShuttle,
SNSNonRepeatFromShuttle, FSHNewService, Repeat, PassTime, ExitRailway

SequenceType: NoSequence, StartSequence, FinishSequence, IntermediateSequence, SequTypeForRepeatEntry
*/
    try
    {
        TrainController->LogEvent("SkipTimetabledActionsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SkipTimetabledActionsMenuItemClick");
        TTrain Train = TrainController->TrainVectorAtIdent(55, SelectedTrainID); //Train not modified here so don't need reference
        SkipTTActionsListBox->Clear();
        SkipTTActionsListBox->ExtendedSelect = false; //this and the next allow only one item to be selected
        SkipTTActionsListBox->MultiSelect = false;

        //populate the listbox
        AnsiString TTStr = Train.FloatingTimetableString(2, Train.ActionVectorEntryPtr);
        AnsiString OneLine;
        int Count = 0;
        int NewLinePos = TTStr.Pos('\n');
        SkipTTActionsListBox->Width = 200;
        SkipListHeaderPanel->Width = 200;
        for(int x = 0; x < 30; x++)
        {
            if((TTStr.Length() > 1) && (NewLinePos <= TTStr.Length()) && (NewLinePos != 0)) //i.e. all lines apart from the last where there is no newline
            {
                OneLine = TTStr.SubString(1, NewLinePos); //includes the newline
                if(OneLine == "\n")
                {
                    break; //break before Count increment
                }
                if(OneLine == "Timetable:\n") //update TTStr & Newline but don't increment Count  //added at v2.13.0 as 'Timetable:' added
                {
                    TTStr = TTStr.SubString(NewLinePos + 1, TTStr.Length() - NewLinePos - 1);
                    NewLinePos = TTStr.Pos('\n');
                    continue;
                }
                Count++;
                SkipTTActionsListBox->Items->Add(OneLine);
                TTStr = TTStr.SubString(NewLinePos + 1, TTStr.Length() - NewLinePos - 1);
                NewLinePos = TTStr.Pos('\n');
            }
            else if((TTStr.Length() > 1) && (NewLinePos == 0) && ((TTStr.SubString(3, 1) == ':') || (TTStr.SubString(1, 5) == "Termi"))) //last line
            {
                OneLine = TTStr;
                Count++;
                SkipTTActionsListBox->Items->Add(OneLine);
                break;
            }
            if(TTStr.Length() <2)
            {
                break;
            }
            AnsiString EndStr = OneLine.SubString(8, 5);
            //need these last checks in case last floating line is an allowable exit or a new service departure time which aren't wanted in the skip list
            if((EndStr == "Form ") || (EndStr == "Join ") || (EndStr == "Exit ")) //all these are preceded by a time & start at character 8
            {
                break;
            }
        }
        if(Count == 0)
        {
            ShowMessage("No timetabled events");
            Utilities->CallLogPop(2428);
            return;
        }
        SkipTTActionsListBox->Height = (SkipTTActionsListBox->ItemHeight * Count) + 4;
//position listbox
        int Left = SkipTTTrainMousePosX + MainScreen->Left + 16; // so lhs of window is WindowOffset to the right of the mouse pos
        if((Left + SkipTTActionsListBox->Width) > MainScreen->Left + MainScreen->Width)
        {
            Left = SkipTTTrainMousePosX - SkipTTActionsListBox->Width + 16;
        }
        int Top = SkipTTTrainMousePosY + MainScreen->Top + 16; // so top of window is one element below the mouse pos (ScreenY + MainScreen->Top would be at mouse pos)
        if((Top + SkipTTActionsListBox->Height) > MainScreen->Top + MainScreen->Height)
        {
            Top = SkipTTTrainMousePosY - SkipTTActionsListBox->Height + 79; // so bottom of window is one element above the mouse pos (95 would be at mouse pos)
            if(Top < 30)
            {
                Top = 30;
            }
        }
        SkipTTActionsListBox->Left = Left; // new at v2.7.0 in place of above
        SkipListHeaderPanel->Left = Left;
        SkipTTActionsListBox->Top = Top;
        SkipListHeaderPanel->Top = Top - 34; //this panel has a height of 34
        ShowTTActionsListBox(0);
        Utilities->CallLogPop(2418);
    }
    catch(const Exception &e)
    {
        ErrorLog(241, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::SkipTTActionsListBoxMouseUp(TObject *Sender, TMouseButton Button,
          TShiftState Shift, int X, int Y)
/*
If stopped at signal then allowable next action will be TimeLoc arrival, TimeTimeLoc, Pass or Fer.

If stopped at a location then save the depart time then allowable next action will be TimeLoc arrival, TimeTimeLoc, Pass or Fer.

FormatType:  NoFormat, TimeLoc, TimeTimeLoc, TimeCmd, StartNew, TimeCmdHeadCode, FinRemHere, FNSNonRepeatToShuttle, SNTShuttle, SNSShuttle,
SNSNonRepeatFromShuttle, FSHNewService, Repeat, PassTime, ExitRailway

SequenceType: NoSequence, StartSequence, FinishSequence, IntermediateSequence, SequTypeForRepeatEntry
*/
{
    try
    {
        TrainController->LogEvent("SkipTTActionsListBoxMouseUp, " + AnsiString(X) + ',' + AnsiString(Y));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SkipTTActionsListBoxMouseUp");
        TTrain &Train = TrainController->TrainVectorAtIdent(56, SelectedTrainID); //Train actionvectorptr advance here so need reference
        Train.SkipPtrValue = 0;
        if(SkipTTActionsListBox->Items->Text != "") //not empty
        {
            Train.SelSkipString = SkipTTActionsListBox->Items->Strings[SkipTTActionsListBox->ItemIndex]; //index starts at 0
        }
        if(Train.StoppedAtSignal)
        {
            //Calc cumulative dwell times that are skipped
            int  Count = 0, PassNum = 0, SkippedEvents = 0;
            if(SkipTTActionsListBox->ItemIndex == 0)
            {
                ShowMessage("This is already the next event, nothing will be skipped");
                Utilities->CallLogPop(2436);
                return;
            }
            for(TActionVectorEntry *AVEPtr = Train.ActionVectorEntryPtr; Count < SkipTTActionsListBox->ItemIndex; AVEPtr++)
            {
                if((AVEPtr->FormatType == TimeTimeLoc) && (AVEPtr->ArrivalTime != AVEPtr->DepartureTime))
                {//arr & dep in a single AVEntry if different arr & dep times but two listings, if have same arr & dep time then only a single listing,
                    Count += 2;
                }
                else
                {
                    Count++;
                }
                PassNum++;
                if((AVEPtr->Command == "cdt") || (AVEPtr->Command == "pas") || ((AVEPtr->FormatType == TimeLoc) && (AVEPtr->DepartureTime != TDateTime(-1))))
                //don't count cdts, passes or departures as missed events (note that can't be a finish)
                {
                    continue;
                }
                else
                {
                    SkippedEvents++;
                }
            }
            AnsiString StartStr = Train.SelSkipString.SubString(8, 4);
            if((StartStr != "Arri") && (StartStr != "Pass") && (StartStr != "Exit"))
            {
                ShowMessage("When stopped at a signal the selected next event must be 'Arrive...', 'Pass...', or 'Exit railway...'");
                Utilities->CallLogPop(2429);
                return;
            }
            //advance the pointer but ask for confirmation first
            int button = Application->MessageBox(L"This will skip all events before the selection,\n\nOK to proceed?", L"", MB_YESNO);
            if(button == IDYES)
            {
                AnsiString SkipTTLBString  = AnsiString(SkipTTActionsListBox->Items->Strings[SkipTTActionsListBox->ItemIndex]); //added at v2.12.0 as doubt over newline in ListBox strings
                if(SkipTTLBString[SkipTTLBString.Length()] == '\n') //strip the newline if there is one as one is added after PerfStr sent to PerformanceFile
                {
                    SkipTTLBString = SkipTTLBString.SubString(1, (SkipTTLBString.Length() - 1));
                }
                Train.ActionVectorEntryPtr += PassNum;
                AnsiString PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " " + AnsiString(SkippedEvents)
                    + " significant events skipped until " + SkipTTLBString;
                Utilities->PerformanceFile << PerfStr.c_str() << '\n';
                Utilities->PerformanceFile.flush();  //added at v2.13.0
                TrainController->SkippedTTEvents += SkippedEvents;
                PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);

            }
            HideTTActionsListBox(2);
        }
        else if(Train.RevisedStoppedAtLoc())
        {
            //Calc cumulative dwell times that are skipped
            int  Count = 0, PassNum = 0, SkippedEvents = 0;
            TActionVectorEntry DepEntry;
            Train.SkippedDeparture = false;
            if(SkipTTActionsListBox->ItemIndex == 0)
            {
                ShowMessage("This is already the next event, nothing will be skipped");
                Utilities->CallLogPop(2437);
                return;
            }
            for(TActionVectorEntry *AVEPtr = Train.ActionVectorEntryPtr; Count < SkipTTActionsListBox->ItemIndex; AVEPtr++) //Count < rather than == because incremented at end
            {
                if(AVEPtr->DepartureTime > TDateTime(0)) //departure action
                {
                    if(AVEPtr->LocationName == Train.ActionVectorEntryPtr->LocationName)
                    {
                        Train.SkippedDeparture = true;
                    }
                }
                if((AVEPtr->FormatType == TimeTimeLoc) && (AVEPtr->ArrivalTime != AVEPtr->DepartureTime) && (AVEPtr != Train.ActionVectorEntryPtr))
                {//arr & dep in a single AVEntry if different arr & dep times but two listings, if have same arr & dep time then only a single listing,
                 //if first entry is a TimeTimeLoc departure then only one listing
                    Count += 2;
                }
                else
                {
                    Count++;
                }
                PassNum++;
                if((AVEPtr->Command == "cdt") || (AVEPtr->Command == "pas") ||
                    ((AVEPtr->FormatType == TimeLoc) && (AVEPtr->DepartureTime > TDateTime(0))) ||
                    (Train.SkippedDeparture && (AVEPtr == Train.ActionVectorEntryPtr)))
                //don't count cdts, passes or departures as missed events (note that can't be a finish), or first departure if SkippedDeparture is true
                {
                    continue;
                }
                else
                {
                    SkippedEvents++;
                }
            }
            TActionVectorEntry *AVEPtr = Train.ActionVectorEntryPtr + PassNum; //set to the selected action so can check if at same location
            Train.TrainSkippedEvents = SkippedEvents;
            AnsiString StartStr = Train.SelSkipString.SubString(8, 4);
            if(Train.SkippedDeparture && (AVEPtr->LocationName == Train.ActionVectorEntryPtr->LocationName) && (AVEPtr->ArrivalTime == TDateTime(-1)) && (AVEPtr->FormatType != PassTime))
            { //if selected action is at same location and SkippedDeparture is true (i.e returned to it after leaving), then keep SkippedDep provided that the action is arrive or pass
                Train.SkippedDeparture = false;
            }
            if((StartStr != "Arri") && (StartStr != "Pass") && (StartStr != "Exit") && (AVEPtr->LocationName != Train.ActionVectorEntryPtr->LocationName))
            {
                ShowMessage("When stopped at a location the selected next event must either occur at the same location or be 'Arrive...', 'Pass...', or 'Exit railway...'");
                Train.SkippedDeparture = false;
                Train.SkipPtrValue = 0;
                Utilities->CallLogPop(2435);
                return;
            }
            if(Train.SkippedDeparture)
            {
                Train.SkipPtrValue = AVEPtr - &(Train.TrainDataEntryPtr->ActionVector.at(0)); //i.e. ActionVectorEntryPtr value above start
            }                                                                                 //can't save pointer itself as will be stored in a session file
            //advance the pointer but ask for confirmation first
            UnicodeString Message = "This will skip all events before the selection.\n\nOK to proceed?";
            if(Train.SkippedDeparture)
            {
                Message = "This will skip all events between the departure and the selection.\n\n"
                    "Note that no more events may be skipped for this train until after\n"
                    "it departs from the current location\n\nOK to proceed?";
            }
			int button = Application->MessageBox(Message.c_str(), L"", MB_YESNO);
            if(button == IDYES)
            {
                AnsiString SkipTTLBString  = AnsiString(SkipTTActionsListBox->Items->Strings[SkipTTActionsListBox->ItemIndex]); //added at v2.12.0 as doubt over newline in
                //ListBox strings, mainly there is one but seemingly not always
                if(SkipTTLBString[SkipTTLBString.Length()] == '\n') //strip the newline if there is one as one is added after PerfStr sent to PerformanceFile
                {
                    SkipTTLBString = SkipTTLBString.SubString(1, (SkipTTLBString.Length() - 1));
                }
                if(!Train.SkippedDeparture)
                {
                    Train.ActionVectorEntryPtr += PassNum; //points to the next action, if a dep is skipped then the pointer is incremented later
                    AnsiString PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " " +
                        AnsiString(Train.TrainSkippedEvents) + " significant events skipped until " + SkipTTLBString;
                    TrainController->SkippedTTEvents += Train.TrainSkippedEvents;
                    Train.TrainSkippedEvents = 0;
                    Utilities->PerformanceFile << PerfStr.c_str() << '\n';
                    Utilities->PerformanceFile.flush(); //added at v2.13.0
                    PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);
                }
                else
                {
                    Train.ActionsSkippedFlag = true; //set to prevent any further skips until after the departure
                    AnsiString PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " " +
                        AnsiString(Train.TrainSkippedEvents) + " significant events skipped after the departure until " + SkipTTLBString;
                    Utilities->PerformanceFile << PerfStr.c_str() << '\n';
                    Utilities->PerformanceFile.flush(); //added at v2.13.0
                    PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);
                }
            }
            else
            {
                Train.SkippedDeparture = false;
                Train.SkipPtrValue = 0;
                Train.ActionsSkippedFlag = false;
            }
            HideTTActionsListBox(3);
        }
        Utilities->CallLogPop(2427);
    }
    catch(const Exception &e)
    {
        ErrorLog(242, e.Message);
    }
}

//---------------------------------------------------------------------------

void TInterface::ShowTTActionsListBox(int Caller)  //TTClock stopped in ClockTimer2
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ShowTTActionsListBox");
    if(SkipTTActionsListBox->Visible)
    {
        Utilities->CallLogPop(2430);
        return;
    }
    SkipTTActionsListBox->Visible = true;
    SkipListHeaderPanel->Visible = true;
    SkipTTActionsListBox->BringToFront();
    SkipListHeaderPanel->BringToFront();
    Utilities->CallLogPop(2431);
}

//---------------------------------------------------------------------------

void TInterface::HideTTActionsListBox(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",HideTTActionsListBox");
    if(!SkipTTActionsListBox->Visible)
    {
        Utilities->CallLogPop(2432);
        return;
    }
    SkipTTActionsListBox->Visible = false;
    SkipListHeaderPanel->Visible = false;
    Utilities->CallLogPop(2433);
}

//---------------------------------------------------------------------------

void __fastcall TInterface::SkipListExitImageClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SkipListExitImageClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SkipListExitImageClick");
        HideTTActionsListBox(4);
        Utilities->CallLogPop(2434);
    }
    catch(const Exception &e)
    {
        ErrorLog(243, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::BecomeNewServiceMenuItemClick(TObject *Sender) //added at v2.12.0
{
 //this is only accessible if the train is stopped at a location, there is a follow-on service (Fns, Fns-sh, Frh-sh, F-nshs) and that service stops at or passes the current
 // location.  Change to new service immediately & set its ActionVectorEntryPtr to this location
    try
    {
        TrainController->LogEvent("BecomeNewServiceClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BecomeNewServiceClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(58, SelectedTrainID);
        TActionVectorEntry *NewServiceActionEntryPtr = Train.ActionVectorEntryPtr; //set initially to current position
        while((NewServiceActionEntryPtr->Command != "Fns") && (NewServiceActionEntryPtr->Command != "Fns-sh") && (NewServiceActionEntryPtr->Command != "F-nshs"))
        {
            NewServiceActionEntryPtr++;
            if(NewServiceActionEntryPtr > &Train.TrainDataEntryPtr->ActionVector.back()) //failed to find a new service
            {
                ShowMessage("No follow-on service found, option unavailable");
                Utilities->CallLogPop(2445);
                return;
            }
        }
        int PtrAdvance = NewServiceActionEntryPtr - Train.ActionVectorEntryPtr;
        AnsiString CurrentLocationName = Train.ActionVectorEntryPtr->LocationName;
        UnicodeString MessageStr = "This action will skip all timetabled events until follow-on service " + Train.FollowOnServiceRef + " reaches this location\n\nOK to proceed?";
        if(NewServiceActionEntryPtr->Command == "Fns")
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Train.FollowOnServiceRef = ""; //cancel this as finished with it
                Utilities->CallLogPop(2446);
                return;
            }
            SkipAllEventsBeforeNewService(0, SelectedTrainID, PtrAdvance);
            Train.NewTrainService(1, true); //true for no logs
        }
        else if(NewServiceActionEntryPtr->Command == "Fns-sh")
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Train.FollowOnServiceRef = ""; //cancel this as finished with it
                Utilities->CallLogPop(2447);
                return;
            }
            SkipAllEventsBeforeNewService(1, SelectedTrainID, PtrAdvance);
            Train.RepeatShuttleOrNewNonRepeatService(1, true); //true for no logs
        }
        else if(NewServiceActionEntryPtr->Command == "Frh-sh")
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Train.FollowOnServiceRef = ""; //cancel this as finished with it
                Utilities->CallLogPop(2453);
                return;
            }
            SkipAllEventsBeforeNewService(2, SelectedTrainID, PtrAdvance);
            Train.RepeatShuttleOrRemainHere(1, true); //true for no logs;
        }
        else if(NewServiceActionEntryPtr->Command == "F-nshs")
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Train.FollowOnServiceRef = ""; //cancel this as finished with it
                Utilities->CallLogPop(2448);
                return;
            }
            SkipAllEventsBeforeNewService(3, SelectedTrainID, PtrAdvance);
            Train.NewShuttleFromNonRepeatService(1, true); //true for no logs;
        }
        else //invalid, shouldn't have been possible to select it
        {
            ShowMessage("Option unavailable");
        }

        SkipEventsBeforeSameLoc(0, SelectedTrainID, CurrentLocationName); //same train ID when becomes new service
        Train.DepartureTimeSet = false; //force a release time calculation in UpdateTrain
        Train.EntrySpeed = 0;
        Train.ExitSpeedHalf = 0;
        Train.ExitSpeedFull = 0;
        if(Train.ActionVectorEntryPtr->Command == "pas")
        {
            Train.StoppedAtLocation = false; //this is set in the functions called for the various finish types, so is reset here in the case of a pass
            Train.ExitSpeedHalf = 30;        //so earlier versions will still identify it as moving.  exit speed will be recalculated for v2.12.0 & upwards
            Train.ExitSpeedFull = 50;
        }
        Train.FollowOnServiceRef = ""; //cancel this as finished with it
        Utilities->CallLogPop(2449);
    }
    catch(const Exception &e)
    {
        ErrorLog(244, e.Message);
    }
}

//---------------------------------------------------------------------------

bool TInterface::IsBecomeNewServiceAvailable(int Caller, int TrainID, AnsiString &NextServiceRef)
{// 5 conditions: stopped at location, has power, no skipped departure pending, has follow-on service (Fns, Fns-sh, Frh-sh, F-nshs) and follow-on service stops at or passes this location
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ", BecomeNewServiceAvailable, " + AnsiString(TrainID));
    const TTrain &Train = TrainController->TrainVectorAtIdent(61, SelectedTrainID);
    bool Condition4Met = false;
    TTrainDataEntry *NextServiceEntryPtr;
    NextServiceRef = "";
    if(Train.RevisedStoppedAtLoc() && (Train.PowerAtRail > 1) && !Train.SkippedDeparture) //conditions 1 to 3
    {
        for(TActionVectorEntry *AVEPtr = Train.ActionVectorEntryPtr; AVEPtr <= &Train.TrainDataEntryPtr->ActionVector.back(); AVEPtr++)
        {
            if(AVEPtr->Command == "Fns")
            {
                Condition4Met = true;
                NextServiceEntryPtr = AVEPtr->LinkedTrainEntryPtr;
                NextServiceRef = NextServiceEntryPtr->ServiceReference;
                break;
            }
            if(AVEPtr->Command == "Fns-sh")
            {
                Condition4Met = true;
                if(Train.RepeatNumber >= (Train.TrainDataEntryPtr->NumberOfTrains - 1)) // finished all repeats
                {
                    NextServiceEntryPtr = AVEPtr->NonRepeatingShuttleLinkEntryPtr;
                    NextServiceRef = NextServiceEntryPtr->ServiceReference;
                }
                else
                {
                    NextServiceEntryPtr = AVEPtr->LinkedTrainEntryPtr;
                    NextServiceRef = NextServiceEntryPtr->ServiceReference;
                }
                break;
            }
            if(AVEPtr->Command == "Frh-sh")
            {
                if(Train.RepeatNumber >= (Train.TrainDataEntryPtr->NumberOfTrains - 1)) // finished all repeats
                {
                    break; //no follow-on service
                }
                else
                {
                Condition4Met = true;
                NextServiceEntryPtr = AVEPtr->LinkedTrainEntryPtr;
                NextServiceRef = NextServiceEntryPtr->ServiceReference;
                break;
                }
            }
            if(AVEPtr->Command == "F-nshs")
            {
                Condition4Met = true;
                NextServiceEntryPtr = AVEPtr->LinkedTrainEntryPtr;
                NextServiceRef = NextServiceEntryPtr->ServiceReference;
                break;
            }
        }
        if(Condition4Met) //condition 4
        {
            AnsiString CurLoc = Train.ActionVectorEntryPtr->LocationName;
            for(TActionVectorEntry *AVEPtr = &NextServiceEntryPtr->ActionVector.at(0); AVEPtr <= &NextServiceEntryPtr->ActionVector.back(); AVEPtr++)
            {
                if(AVEPtr->LocationName == CurLoc)
                {
                    if((AVEPtr->FormatType == TimeTimeLoc) || ((AVEPtr->FormatType == TimeLoc) && (AVEPtr->ArrivalTime > TDateTime(0))) || (AVEPtr->Command == "pas")                   )
                    {
                        Utilities->CallLogPop(2454);
                        return(true); //all conditions met
                    }
                }
            }
        }
    }
    Utilities->CallLogPop(2455);
    return(false); //one or more conditions not met
}

//---------------------------------------------------------------------------

void TInterface::SkipAllEventsBeforeNewService(int Caller, int TrainID, int PtrAdvance) //added at v2.12.0
{
    try
    {
        TrainController->LogEvent("SkipAllEventsBeforNewService");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ", SkipAllEventsBeforNewService");
        TTrain &Train = TrainController->TrainVectorAtIdent(59, TrainID);
        TActionVectorEntry *NewServiceActionEntryPtr = Train.ActionVectorEntryPtr + PtrAdvance;
        //Calc no. of skipped events
        int  SkippedEvents = 0;
        for(TActionVectorEntry *AVEPtr = Train.ActionVectorEntryPtr; AVEPtr < NewServiceActionEntryPtr; AVEPtr++)
        {
            if((AVEPtr->Command == "cdt") || (AVEPtr->Command == "pas") || (AVEPtr->SequenceType == FinishSequence) ||
                    ((AVEPtr->FormatType == TimeLoc) && (AVEPtr->DepartureTime != TDateTime(-1))))
            //don't count cdts, passes, finishes or departures as missed events (finish will be the new service and becomes new service at diff loc so it isn't missed)
            {
                continue;
            }
            else
            {
                SkippedEvents++;
            }
        }
        //report the action
        AnsiString PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " manually advanced to follow-on service " + Train.FollowOnServiceRef + " at " +
                Train.ActionVectorEntryPtr->LocationName;
        Utilities->PerformanceFile << PerfStr.c_str() << '\n';
        Utilities->PerformanceFile.flush(); //added at v2.13.0
        PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);
        //advance the pointer
        Train.ActionVectorEntryPtr = NewServiceActionEntryPtr; //points to the new service
        PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " " + AnsiString(SkippedEvents)
                + " significant events skipped before it became the new service";
        TrainController->SkippedTTEvents += SkippedEvents;
        Utilities->PerformanceFile << PerfStr.c_str() << '\n';
        Utilities->PerformanceFile.flush(); //added at v2.13.0
        PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);
        Utilities->CallLogPop(2450);
        return;
    }
    catch(const Exception &e)
    {
        ErrorLog(245, e.Message);
    }
}

//---------------------------------------------------------------------------

void TInterface::SkipEventsBeforeSameLoc(int Caller, int TrainID, AnsiString LocationName) //added at v2.12.0
{
    try
    {
        TrainController->LogEvent("SkipEventsBeforeSameLoc");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ", SkipEventsBeforeSameLoc");
        TTrain &Train = TrainController->TrainVectorAtIdent(60, TrainID);
        bool LocFound = false;
        //Calc no. of skipped events
        int SkippedEvents = 0;
        TActionVectorEntry *AVEPtr;
        for(AVEPtr = Train.ActionVectorEntryPtr; AVEPtr <= &Train.TrainDataEntryPtr->ActionVector.back(); AVEPtr++)
        {
            if(AVEPtr->LocationName != LocationName)
            {
                if((AVEPtr->Command == "cdt") || (AVEPtr->Command == "pas") || ((AVEPtr->FormatType == TimeLoc) && (AVEPtr->DepartureTime != TDateTime(-1))))
                //don't count cdts, passes or departures as missed events (can't be a finish)
                {
                    continue;
                }
                else
                {
                    SkippedEvents++;
                }
            }
            else if(AVEPtr->FormatType == TimeTimeLoc)
            {
                LocFound = true;
                break;
            }
            else if(AVEPtr->Command == "pas")
            {
                Train.TreatPassAsTimeLocDeparture = true; //when true the pas is treated by the train as a TimeLoc departure
                LocFound = true;
                break;
            }
            else if(((AVEPtr->FormatType == TimeLoc) && (AVEPtr->ArrivalTime > TDateTime(-1))) || (AVEPtr->Command == "cdt")) //increment past arrival & cdt events
            {                                                                                                                  //no skipped event as stops here
                continue;
            }
            else
            {
                LocFound = true;
                break;
            }
        }
        if(!LocFound)
        {
            Utilities->CallLogPop(2451);
            ShowMessage("New service location not found");
            return;
        }
        //advance the pointer
        Train.ActionVectorEntryPtr = AVEPtr;
        Train.ChangeTrainDirection(1, true); //most times this will be appropriate, i.e changed direction from other service train, true for No Logs
        AnsiString PerfStr = Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": " + Train.HeadCode + " " + AnsiString(SkippedEvents)
                + " significant events skipped before the new service arrived at " + LocationName;
        TrainController->SkippedTTEvents += SkippedEvents;
        Utilities->PerformanceFile << PerfStr.c_str() << '\n';
        Utilities->PerformanceFile.flush(); //added at v2.13.0
        PerfLogForm->PerformanceLogBox->Lines->Add(PerfStr);
        Utilities->CallLogPop(2452);
        return;
    }
    catch(const Exception &e)
    {
        ErrorLog(246, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::SignallerControlStopMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("SignallerControlStopMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SignallerControlStopMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(35, SelectedTrainID);
        Train.LeavingUnderSigControlAtContinuation = false;
        if(Train.LeadElement > -1)
        {
            if(Track->TrackElementAt(787, Train.LeadElement).Conn[Train.LeadExitPos] > -1)
            {
                Train.SignallerStoppingFlag = true;
                Train.SignallerStopBrakeRate = 0;
                Train.LogAction(24, Train.HeadCode, "", SignallerControlStop, "", TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
            }
            else
            {
                Train.LeavingUnderSigControlAtContinuation = true;
            }
        }
        else
        {
            Train.LeavingUnderSigControlAtContinuation = true;
        }
        Utilities->CallLogPop(1553);
    }
    catch(const Exception &e)
    {
        ErrorLog(161, e.Message);
    }
}

// ---------------------------------------------------------------------------
void __fastcall TInterface::PassRedSignalMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PassRedSignalMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PassRedSignalMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(21, SelectedTrainID);
        if(Train.StoppedAtLocation && (Train.ActionVectorEntryPtr->DepartureTime > TDateTime(-1)) && !TrainLeaveWarningSent) //added at v2.14.0
        {
            UnicodeString MessageStr = "Please be aware that a train moved from a location prior to its departure time must be returned to that location "
                                       "in order to restore timetable control\n\nThis message will not be shown again\n\nOK to continue, Cancel to abort";
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_OKCANCEL);
            TrainLeaveWarningSent = true;
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDCANCEL)
            {
                Utilities->CallLogPop(2558);
                return;
            }
        }
        Train.SignallerStoppingFlag = false;
        int NextElementPos = Track->TrackElementAt(712, Train.LeadElement).Conn[Train.LeadExitPos];
        if(NextElementPos < 0)
        {
            throw Exception("Error, no element in front in PassRedSignalMenuItemClick");
        }
        TTrackElement &TrackElement = Track->TrackElementAt(653, NextElementPos);
/* drop this error as may be some circumstances where behind a signal in sig mode but not stopped at signal
           if(!Train.StoppedAtSignal)
            {
            throw Exception("Error, not StoppedAtSignal in PassRedSignalMenuItemClick");
            }
*/
        if(TrackElement.TrackType != SignalPost)
        {
            throw Exception("Error, next element not a signal type in PassRedSignalMenuItemClick");
        }
        Train.SignallerStopped = false;
        Train.StoppedAtLocation = false; // may have started at station in signaller mode and also at a red signal, in this case both SignallerStopped
                                         // and StoppedAtLocation are set but the background colour stays pale green for station, not signal,
                                         // since no need to alert the user
        Train.StoppedAfterSPAD = false; // in case had been set
        Train.SPADFlag = false;
        // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
        Train.PlotTrainWithNewBackgroundColour(32, clNormalBackground, Display);
        Train.AllowedToPassRedSignal = true;
        Train.LogAction(4, Train.HeadCode, "", SignallerPassRedSignal, "", TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        Utilities->CallLogPop(1199);
    }
    catch(const Exception &e)
    {
        ErrorLog(162, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::StepForwardMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("StepForwardMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",StepForwardMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(24, SelectedTrainID);
        if(Train.StoppedAtLocation && (Train.ActionVectorEntryPtr->DepartureTime > TDateTime(-1)) && !TrainLeaveWarningSent) //added at v2.14.0
        {
            UnicodeString MessageStr = "Please be aware that a train moved from a location prior to its departure time must be returned to (or still be at) that location "
                                       "in order to restore timetable control\n\nThis message will not be shown again\n\nOK to continue, Cancel to abort";
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            int button = Application->MessageBox(MessageStr.c_str(), L"", MB_OKCANCEL);
            TrainLeaveWarningSent = true;
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDCANCEL)
            {
                Utilities->CallLogPop(2559);
                return;
            }
        }
        Train.SignallerStoppingFlag = false;
        Train.SignallerStopped = false;
        Train.StoppedAtLocation = false; // may have started at station in signaller mode and also at a red signal, in this case both SignallerStopped
                                         // and StoppedAtLocation are set but the background colour stays pale green for station, not signal,
                                         // since no need to alert the user
        Train.StoppedAfterSPAD = false; // in case had been set
        Train.SPADFlag = false;
        Train.StepForwardFlag = true;
        Train.AllowedToPassRedSignal = true; // in case at a signal, will clear when half-way into next element whether a signal or not
        // ok to call PlotTrainWithNewBackgroundColour here as PlotElements already set to Lead, Mid & Lag elements
        Train.PlotTrainWithNewBackgroundColour(46, clNormalBackground, Display);
        Train.LogAction(32, Train.HeadCode, "", SignallerStepForward, "", TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        int NextElementPos = -1;
// addition for v1.3.2 due to Carwyn Thomas error: can't select StepForwardMenuItem if exiting at a continuation but leave this in anyway
        int NextEntryPos = -1; // ---ditto---
        if(Train.LeadElement > -1) // ---ditto---
        {
            // ---ditto---
            NextElementPos = Track->TrackElementAt(804, Train.LeadElement).Conn[Train.LeadExitPos]; // had 'int' prefix before additions
            NextEntryPos = Track->TrackElementAt(805, Train.LeadElement).ConnLinkPos[Train.LeadExitPos]; // ---ditto---
        } // ---ditto---

        if((NextElementPos > -1) && (NextEntryPos > -1))
        {
            // call this after StepForwardFlag set
            Train.EntrySpeed = 0;
            Train.EntryTime = TrainController->TTClockTime;
            Train.FirstHalfMove = true;
            Train.SetTrainMovementValues(20, NextElementPos, NextEntryPos); // NextElement is the element to be entered
        }
        Utilities->CallLogPop(1800);
    }
    catch(const Exception &e)
    {
        ErrorLog(163, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::RemoveTrainMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("RemoveTrainMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RemoveTrainMenuItemClick");
        TTrain &Train = TrainController->TrainVectorAtIdent(22, SelectedTrainID);
        if((!Train.Derailed) && (!Train.Crashed))
        {
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            UnicodeString Message = UnicodeString(Train.HeadCode) + " will be removed from the railway - proceed?";
            int button = Application->MessageBox(Message.c_str(), L"Please confirm", MB_YESNO);
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            if(button == IDNO)
            {
                Utilities->CallLogPop(1801);
                return;
            }
        }
        Train.SignallerStoppingFlag = false;
        Train.TrainGone = true; // will be removed by TTrainController::Operate
        Train.SignallerRemoved = true;
        Train.TrainDataEntryPtr->TrainOperatingDataVector.at(Train.RepeatNumber).RunningEntry = Exited;
        AnsiString LocName = "";
        if(Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(641, Train.LeadElement).ActiveTrackElementName;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(642, Train.MidElement).ActiveTrackElementName;
        }
        if((LocName == "") && Train.LeadElement > -1)
        {
            LocName = Track->TrackElementAt(643, Train.LeadElement).ElementID;
        }
        if((LocName == "") && (Train.MidElement > -1))
        {
            LocName = Track->TrackElementAt(644, Train.MidElement).ElementID;
        }
        TTrackElement *TrackElementPtr;
        int RouteNumber;
        TAllRoutes::TRouteType RouteType;
        if(Train.LeadElement > -1)
        {
            TrackElementPtr = &(Track->TrackElementAt(673, Train.LeadElement));
            // remove TrainIDs from track element, added at v2.4.0
            if(TrackElementPtr->TrackType == Bridge)
            {
                if(Train.LeadExitPos > 1)
                {
                    TrackElementPtr->TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = -1;
                }
                else
                {
                    TrackElementPtr->TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = -1;
                }
            }
            else
            {
                TrackElementPtr->TrainIDOnElement = -1;
            }
            // reset any CallingOnSet flags for signals, if facing wrong way doesn't matter, shouldn't be set anyay
            if((TrackElementPtr->TrackType == SignalPost) && TrackElementPtr->CallingOnSet)
            {
                TrackElementPtr->CallingOnSet = false;
                Track->PlotSignal(6, *TrackElementPtr, Display);
            }
// [added at v1.3.0] here check if on an automatic signals route and if so reset signals for the entire route from the
// start of the route - after the train has been removed, use LeadElement and also MidElement (if no autosigs route at LeadElement) just to be sure
            RouteType = AllRoutes->GetRouteTypeAndNumber(27, Train.LeadElement, Train.LeadEntryPos, RouteNumber);
            if(RouteType == TAllRoutes::AutoSigsRoute)
            {
                AllRoutes->SignallerRemovedTrainAutoRoute = AllRoutes->GetFixedRouteAt(215, RouteNumber);
                TrainController->SignallerTrainRemovedOnAutoSigsRoute = true;
            }
// end of addition

// erase a stub route if there is one, added at v2.6.1
// first element of route is immediately in front of the train
            if(Train.LeadExitPos >= 0)
            {
                TTrackElement LeadTrackElement = Track->TrackElementAt(1013, Train.LeadElement);
                int FirstRouteElementVecPos = LeadTrackElement.Conn[Train.LeadExitPos];
                int FirstRouteLinkPos = LeadTrackElement.ConnLinkPos[Train.LeadExitPos];
                RouteType = AllRoutes->GetRouteTypeAndNumber(39, FirstRouteElementVecPos, FirstRouteLinkPos, RouteNumber);
                if(RouteType == TAllRoutes::NotAutoSigsRoute) // red or green route, if no route then ignore
                {
                    TOneRoute &OR = AllRoutes->GetModifiableRouteAt(30, RouteNumber);
                    TTrackElement TE = Track->TrackElementAt(1014, FirstRouteElementVecPos);
                    if((TE.TrackType != SignalPost) && (TE.TrackType != Continuation))
                    // all autosigs routes have signalpost or continuation at 0 so they are automatically excluded
                    {
                        bool FirstPass = true; //added at v2.8.0
                        while(OR.PrefDirSize() > 0)
                        // remove the route up to but not including the next facing signal, in case a route extends to another signal
                        {
                            TPrefDirElement PDE = OR.GetFixedPrefDirElementAt(249, 0);
// these will change at each element removal because OR is a reference to the real route
                            int TVPos2 = PDE.GetTrackVectorPosition();
                            if(FirstPass && (TVPos2 != FirstRouteElementVecPos)) //route is not directed away from cdt train, could be a call-on for another train (added at v2.8.0)
                            {
                                break;
                            }
                            TTrackElement TE2 = Track->TrackElementAt(1015, TVPos2);
                            if(Track->TrackElementAt(1016, PDE.GetTrackVectorPosition()).Config[PDE.GetXLinkPos()] != Signal)
                            {
                                AllRoutes->RemoveRouteElement(24, TE2.HLoc, TE2.VLoc, PDE.GetELink());
                            }
                            else
                            {
                                break;
                            }
                            FirstPass = false;
                        }
                        AllRoutes->RebuildRailwayFlag = true;
                        // to force ClearandRebuildRailway at next clock tick if not in zoom-out mode, to replot without stub route
                    }
                }
            }
// end of stub route removal addition
        }
        if(Train.MidElement > -1)
        {
            TrackElementPtr = &(Track->TrackElementAt(674, Train.MidElement));
            // remove TrainIDs from track element, added at v2.4.0
            if(TrackElementPtr->TrackType == Bridge)
            {
                if(Train.MidExitPos > 1)
                {
                    TrackElementPtr->TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = -1;
                }
                else
                {
                    TrackElementPtr->TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = -1;
                }
            }
            else
            {
                TrackElementPtr->TrainIDOnElement = -1;
            }
            if((TrackElementPtr->TrackType == SignalPost) && TrackElementPtr->CallingOnSet)
            {
                TrackElementPtr->CallingOnSet = false;
                Track->PlotSignal(7, *TrackElementPtr, Display);
            }
// [added at v1.3.0 as above]
            if(!TrainController->SignallerTrainRemovedOnAutoSigsRoute)
            {
                RouteType = AllRoutes->GetRouteTypeAndNumber(28, Train.MidElement, Train.MidEntryPos, RouteNumber);
                if(RouteType == TAllRoutes::AutoSigsRoute)
                {
                    AllRoutes->SignallerRemovedTrainAutoRoute = AllRoutes->GetFixedRouteAt(216, RouteNumber);
                    TrainController->SignallerTrainRemovedOnAutoSigsRoute = true;
                }
            }
// end of addition
        }
        if(Train.LeadElement > -1)
        // addition for v1.3.2 after Carwyn Thomas fault reported 24/05/15 - need to check if exiting at continuation (LeadElement == -1) as if so fails at next line
        {
            if(Track->TrackElementAt(675, Train.LeadElement).Conn[Train.LeadExitPos] > -1)
            {
                TrackElementPtr = &(Track->TrackElementAt(676, Track->TrackElementAt(677, Train.LeadElement).Conn[Train.LeadExitPos]));
                if((TrackElementPtr->TrackType == SignalPost) && TrackElementPtr->CallingOnSet)
                {
                    TrackElementPtr->CallingOnSet = false;
                    Track->PlotSignal(8, *TrackElementPtr, Display);
                }
            }
        }
        Train.LogAction(5, Train.HeadCode, "", RemoveTrain, LocName, TDateTime(0), false); // TDateTime is a dummy entry, false for no warning
        if(Train.ActionVectorEntryPtr->Command != "Frh") // if remaining at location no point in sending 'failed to terminate' message
        {
            Train.SendMissedActionLogs(0, -1, Train.ActionVectorEntryPtr); // -1 is a marker for send messages for all remaining
        } // entries, including Fer if present

        Utilities->CallLogPop(1200);
    }
    catch(const Exception &e)
    {
        ErrorLog(164, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ErrorButtonClick(TObject *Sender)
// to terminate after error message given
{
    ErrorMessage->Visible = false;
    ErrorMessageStoreImage->Visible = false;
    ErrorButton->Visible = false;
    Display->GetImage()->Visible = true;
    Application->Terminate();
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::FormClose(TObject *Sender, TCloseAction &Action)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",FormClose");
/* Dropped at v2.9.1 as serves no apparent purpose
        if(!FileChangedFlag && !(Track->IsTrackFinished()) && (EveryPrefDir->PrefDirSize() > 0))
        {
            UnicodeString MessageStr =
                "Note that leaving the track unlinked will cause preferred directions to be lost on reloading.  Prevent by linking the track then resaving.  Do you still wish to exit?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Action = caNone; // prevents form & application from closing
                Utilities->CallLogPop(1712);
                return;
            }
        }
*/
        if(FileChangedFlag || TimetableChangedFlag)
        {
            UnicodeString MessStr = "";
            if(FileChangedFlag && TimetableChangedFlag)
            {
                MessStr = UnicodeString("The railway and the timetable have both changed, exit without saving either?");
            }
            else if(FileChangedFlag)
            {
                MessStr = UnicodeString("The railway has changed, exit without saving?");
            }
            else
            {
                MessStr = UnicodeString("The timetable has changed, exit without saving?");
            }
            int button = Application->MessageBox(MessStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                Action = caNone; // prevents form & application from closing
                Utilities->CallLogPop(1133);
                return;
            }
        }
        if(Level1Mode == OperMode)
        {
            if((double(TrainController->TTClockTime - TrainController->LastSessionSaveTTClockTime) * 86400) >= 300)
            {
                UnicodeString MessageStr = "Please note that the session will be lost if it hasn't been saved.  Do you still wish to exit?";
                TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
                TrainController->RestartTime = TrainController->TTClockTime;
                int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
                TrainController->BaseTime = TDateTime::CurrentDateTime();
                TrainController->StopTTClockFlag = false;
                if(button == IDNO)
                {
                    Action = caNone; // prevents form & application from closing
                    Utilities->CallLogPop(969);
                    return;
                }
            }
            PerfLogForm->Close();
            TrainController->SendPerformanceSummary(1, Utilities->PerformanceFile);
            Utilities->PerformanceFile.close();
        }
        if((TempTTFileName != "") && FileExists(TempTTFileName))
        {
            DeleteFile(TempTTFileName);
        }
        Utilities->CallLogPop(971);
    }
    catch(const Exception &e)
    {
        ErrorLog(166, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::FormKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
// TrainController->LogEvent("FormKeyDown," + AnsiString(Key));
// drop event log as have too many spurious entries
    try
    {
        if((Shift.Contains(ssAlt)) && (Shift.Contains(ssCtrl)))
        {
            if(Key == '2')
            {
                if(CallLogTickerLabel->Visible)
                {
                    CallLogTickerLabel->Visible = false;
                }
                else
                {
                    CallLogTickerLabel->Visible = true;
                }
            }
            else if(Key == '3')
            {
                if(DevelopmentPanel->Visible)
                {
                    DevelopmentPanel->Visible = false;
                }
                else
                {
                    DevelopmentPanel->Visible = true;
                    DevelopmentPanel->BringToFront();
                }
            }
            else if(Key == '4')
            {
                TestFunction();
            }
            else if(Key == '5')
            {
                TMsgDlgButtons Buttons;
                Buttons << mbYes << mbNo;
                if(MessageDlg("Do you wish to allow signals next to bridges?  If so please be aware that routes cannot be truncated to these signals.",
                              mtWarning, Buttons, 0) == mrYes)
                {
                    Track->OverrideAndHideSignalBridgeMessage = true;
                }
                else
                {
                    Track->OverrideAndHideSignalBridgeMessage = false;
                }
            }
        }
        else if(Shift.Contains(ssCtrl) && !Shift.Contains(ssShift) && !Shift.Contains(ssAlt))
        {
            CtrlKey = true;
        }
        else if(Shift.Contains(ssShift) && !Shift.Contains(ssCtrl) && !Shift.Contains(ssAlt))
        {
            ShiftKey = true;
        }
// below added at v1.3.0 to allow keyboard scrolling as well as mouse button scrolling - see user suggestion on Features & Requests forum 30/09/12
// the NonCTRLOrSHIFTKeyUpFlag prevents repeated viewpoint movements without keys being re-pressed
// note that use the OnKeyDown event rather than OnKeyPress as suggested by the user so that the CTRL & SHIFT keys can be taken into account

// at v2.4.2 the flag changed to LastNonCtrlOrShiftKeyDown to make condition specific to last key, because when a message given the key up event
// is not seen as the form does not have focus, so with the flag no shortcut key will work on the first press, with this only the same shortcut key
// won't work on first press and that is less likely to be used a second time on either side of the message

        if((Key != VK_SHIFT) && (Key != VK_CONTROL))
        {
            if(LastNonCtrlOrShiftKeyDown == Key) // same key still down rejected
            {
                return;
            }
            else
            {
                LastNonCtrlOrShiftKeyDown = Key;
            }
        }
        if(Key == VK_UP)
        {
            if(ScreenUpButton->Enabled)
            {
                ScreenUpButton->Click();
            }
        }
        else if(Key == VK_DOWN)
        {
            if(ScreenDownButton->Enabled)
            {
                ScreenDownButton->Click();
            }
        }
        else if(Key == VK_LEFT)
        {
            if(ScreenLeftButton->Enabled)
            {
                ScreenLeftButton->Click();
            }
        }
        else if(Key == VK_RIGHT)
        {
            if(ScreenRightButton->Enabled)
            {
                ScreenRightButton->Click();
            }
        }
        else if(Key == VK_HOME)
        {
            if(HomeButton->Enabled)
            {
                HomeButton->Click();
            }
        }
// end of 1.3.0 addition
        else if(Key == VK_END) // added at v2.2.0 to toggle zoom using 'End' key
        {
            if(ZoomButton->Enabled)
            {
                ZoomButton->Click();
            }
        }
        else if(Key == VK_END) // added at v2.2.0 to toggle zoom using 'End' key
        {
            if(ZoomButton->Enabled)
            {
                ZoomButton->Click();
            }
        }
// below added for v2.4.2 to add more keyboard shortcuts
        if(DistanceBox->Focused() || SpeedLimitBox->Focused() || MileEdit->Focused() || ChainEdit->Focused() || YardEdit->Focused() ||
           SpeedEditBox2->Focused() || MTBFEditBox->Focused() || LocationNameTextBox->Focused() || TextBox->Focused() || PowerEditBox->Focused() ||
           SpeedEditBox->Focused() || AddSubMinsBox->Focused() || OneEntryTimetableMemo->Focused())
        {
            // prevent letter keys interfering when these boxes have focus - many are mutually exclusive but include them all
            return;
        }
        if(Shift.Contains(ssShift) && !Shift.Contains(ssAlt) && !Shift.Contains(ssCtrl) && NewHomeButton->Enabled && NewHomeButton->Visible)
        {
            if(Level1Mode != TimetableMode && (Key == 'H' || Key == 'h')) // TimetablePanel uses Shift H too so disable this when it's in use
            {
                NewHomeButton->Click();
            }
        }
// Operating panel
        if(Level1Mode == OperMode && OperatingPanel->Enabled && OperatingPanel->Visible && !Shift.Contains(ssShift) && !Shift.Contains(ssAlt) &&
        !MultiplayerPlayerPanel->Visible) //last condition added as these letters can be added in the edit boxes
        {
            // use Shift.Contains(ssShift etc instead of ShiftKey as that not set if pressed second after Ctrl key pressed
            if(!Shift.Contains(ssCtrl))
            {
                if(OperateButton->Visible && OperateButton->Enabled)
                {
                    if(Level2OperMode == Operating && (Key == 'P' || Key == 'p'))
                    {
                        OperateButton->Click();
                    }
                    else if((Level2OperMode == Paused || Level2OperMode == PreStart) && (Key == 'R' || Key == 'r'))
                    {
                        OperateButton->Click();
                    }
                }
                if(PresetAutoSigRoutesButton->Visible && PresetAutoSigRoutesButton->Enabled && (Key == 'A' || Key == 'a'))
                {
                    PresetAutoSigRoutesButton->Click();
                }
                if(PerformanceLogButton->Visible && PerformanceLogButton->Enabled && (Key == 'L' || Key == 'l'))
                {
                    PerformanceLogButton->Click();
                }
                if(CallingOnButton->Visible && CallingOnButton->Enabled && (Key == 'O' || Key == 'o'))
                {
                    CallingOnButton->Click();
                }
                if(OperatorActionButton->Visible && OperatorActionButton->Enabled && (Key == 'D' || Key == 'd'))
                {
                    OperatorActionButton->Click();
                }
                if(RouteCancelButton->Visible && RouteCancelButton->Enabled && (Key == 'C' || Key == 'c'))
                {
                    RouteCancelButton->Click();
                }
                if(TTClockAdjButton->Visible && TTClockAdjButton->Enabled && (Key == 'T' || Key == 't'))
                {
                    TTClockAdjButton->Click();
                }
                if(AutoSigsButton->Visible && AutoSigsButton->Enabled && Key == '1') // route buttons - autosigs consec
                {
                    AutoSigsButton->Click();
                }
                if(SigAutoNonConsecButton->Visible && SigAutoNonConsecButton->Enabled && Key == '4') // route buttons - autosigs non-consec added at v2.14.0
                {
                    SigAutoNonConsecButton->Click();
                }
                if(SigPrefConsecButton->Visible && SigPrefConsecButton->Enabled && Key == '2') // route buttons - prefdir consec
                {
                    SigPrefConsecButton->Click();
                }
                if(SigPrefNonConsecButton->Visible && SigPrefNonConsecButton->Enabled && Key == '5') // added at v2.7.0 for prefdir & any following signal
                {
                    SigPrefNonConsecButton->Click();
                }
                if(UnrestrictedButton->Visible && UnrestrictedButton->Enabled && Key == '3') // route buttons - unrestricted
                {
                    UnrestrictedButton->Click();
                }
                if(ExitOperationButton->Visible && ExitOperationButton->Enabled && Key == '\x1b')
                {
                    ExitOperationButton->Click();
                }
            }
            else // CtrlKey down
            {
                if(SaveSessionButton->Visible && SaveSessionButton->Enabled)
                {
                    SaveMenuItem->ShortCut = 0;
// It's normally 16467 (Ctrl S) & will be restored in FormKeyUp. Has to be reset or will grab the key combination
                    if(Key == 'S' || Key == 's') // so this will never execute
                    {
                        SaveSessionButton->Click();
                    }
                }
            }
        }
// Timetable clock adjust panel
        if(Level1Mode == OperMode && TTClockAdjPanel->Enabled && TTClockAdjPanel->Visible && !Shift.Contains(ssCtrl) && !Shift.Contains(ssAlt))
        {
            // use Shift.Contains(ssShift etc instead of ShiftKey as that not set if pressed second after Ctrl key pressed
            if(Shift.Contains(ssShift))
            {
                if(TTClockExitButton->Visible && TTClockExitButton->Enabled && (Key == 'A' || Key == 'a'))
                {
                    TTClockExitButton->Click();
                }
                if(TTClockResetButton->Visible && TTClockResetButton->Enabled && (Key == 'R' || Key == 'r'))
                {
                    TTClockResetButton->Click();
                }
            }
        }
// Track build panel
        if((Level1Mode == TrackMode) && TrackBuildPanel->Visible && TrackBuildPanel->Enabled)
        {
            if(Shift.Contains(ssShift) && !Shift.Contains(ssCtrl) && !Shift.Contains(ssAlt))
            {
                if(AddTrackButton->Visible && AddTrackButton->Enabled && (Key == 'A' || Key == 'a')) // add/remove track elements
                {
                    AddTrackButton->Click();
                }
                if(SigAspectButton->Visible && SigAspectButton->Enabled && (Key == 'S' || Key == 's')) // cycle through signal aspects
                {
                    SigAspectButton->Click();
                }
                if(TrackOKButton->Visible && TrackOKButton->Enabled && (Key == 'L' || Key == 'l')) // link track
                {
                    TrackOKButton->Click();
                }
                if(FontButton->Visible && FontButton->Enabled && (Key == 'F' || Key == 'f')) // change font
                {
                    FontButton->Click();
                }
                if(LocationNameButton->Visible && LocationNameButton->Enabled && (Key == 'N' || Key == 'n')) // name locations
                {
                    LocationNameButton->Click();
                }
                if(SetLengthsButton->Visible && SetLengthsButton->Enabled && (Key == 'D' || Key == 'd')) // set distances/speeds
                {
                    SetLengthsButton->Click();
                }
                if(AddTextButton->Visible && AddTextButton->Enabled && (Key == 'T' || Key == 't')) // add text
                {
                    AddTextButton->Click();
                }
                if(ScreenGridButton->Visible && ScreenGridButton->Enabled && (Key == 'G' || Key == 'g')) // toggle grid
                {
                    ScreenGridButton->Click();
                }
                if(MoveTextOrGraphicButton->Visible && MoveTextOrGraphicButton->Enabled && (Key == 'M' || Key == 'm')) // move text or graphic
                {
                    MoveTextOrGraphicButton->Click();
                }
                if(UserGraphicButton->Visible && UserGraphicButton->Enabled && (Key == 'I' || Key == 'i')) // insert image
                {
                    UserGraphicButton->Click();
                }
                if(SetGapsButton->Visible && SetGapsButton->Enabled && (Key == 'J' || Key == 'j')) // join gaps
                {
                    SetGapsButton->Click();
                }
            }
            if(Shift.Contains(ssCtrl) && !Shift.Contains(ssShift) && !Shift.Contains(ssAlt))
            {
                if(SaveRailwayTBPButton->Visible && SaveRailwayTBPButton->Enabled) // save railway in trackbuild mode
                {
                    SaveMenuItem->ShortCut = 0;
// It's normally 16467 (Ctrl S) & will be restored in FormKeyUp. Has to be reset or will grab the key combination
                    if(Key == 'S' || Key == 's') // so this will never execute
                    {
                        SaveRailwayTBPButton->Click();
                    }
                }
            }
            if(!Shift.Contains(ssCtrl) && !Shift.Contains(ssShift) && !Shift.Contains(ssAlt))
            {
                if((ExitTrackButton->Visible && ExitTrackButton->Enabled) && Key == '\x1b') // escape key
                {
                    ExitTrackButton->Click();
                }
            }
        }
// PrefDir panel
        if(Level1Mode == PrefDirMode && PrefDirPanel->Visible && PrefDirPanel->Enabled && !Shift.Contains(ssAlt))
        {
            if(!Shift.Contains(ssShift) && !Shift.Contains(ssCtrl))
            {
                if((ExitPrefDirButton->Visible && ExitPrefDirButton->Enabled) && Key == '\x1b') // escape key
                {
                    ExitPrefDirButton->Click();
                }
            }
            if(!Shift.Contains(ssShift) && Shift.Contains(ssCtrl))
            {
                if(SaveRailwayPDPButton->Visible && SaveRailwayPDPButton->Enabled)
                {
                    SaveMenuItem->ShortCut = 0;
// It's normally 16467 (Ctrl S) & will be restored in FormKeyUp. Has to be reset or will grab the key combination
                    if(Key == 'S' || Key == 's') // so this will never execute
                    {
                        SaveRailwayPDPButton->Click();
                    }
                }
            }
            if(Shift.Contains(ssShift) && !Shift.Contains(ssCtrl))
            {
                if(AddPrefDirButton->Visible && AddPrefDirButton->Enabled && (Key == 'A' || Key == 'a')) // add pref dir
                {
                    AddPrefDirButton->Click();
                }
                if(DeleteOnePrefDirButton->Visible && DeleteOnePrefDirButton->Enabled && (Key == 'D' || Key == 'd')) // delete one pref dir
                {
                    DeleteOnePrefDirButton->Click();
                }
                if(DeleteAllPrefDirButton->Visible && DeleteAllPrefDirButton->Enabled && (Key == 'C' || Key == 'c')) // delete all pref dirs
                {
                    DeleteAllPrefDirButton->Click();
                }
            }
        }
// Note that save button in BaseMode is handled by Ctrl S from the File menu

// Timetable panel
        if(Level1Mode == TimetableMode && TimetablePanel->Visible && TimetablePanel->Enabled && !Shift.Contains(ssAlt))
        {
            if(!Shift.Contains(ssShift) && !Shift.Contains(ssCtrl))
            {
                if(ExitTTModeButton->Visible && ExitTTModeButton->Enabled && Key == '\x1b') // escape key
                {
                    ExitTTModeButton->Click();
                }
            }
            if(Shift.Contains(ssShift) && !Shift.Contains(ssCtrl)) // show/hide timetable edit panel
            {
                if(ShowHideTTButton->Visible && ShowHideTTButton->Enabled)
                {
                    if(!TimetableEditPanel->Visible)
                    {
                        if(Key == 'S' || Key == 's')
                        {
                            ShowHideTTButton->Click();
                        }
                    }
                    else if(Key == 'H' || Key == 'h')
                    {
                        ShowHideTTButton->Click();
                    }
                }
            }
        }
// Timetable edit panel
// These just set flags.  The corresponding 'Click()' function executes separately to the keypress because Windows stores the key until after any directly linked key code
// is executed then selects the timetable entry that begins with the letter corresponding to the key.  Without this separation the list box is left with the wrong entry
// showing.  See DevHistory.txt for the version at v2.5.0 for details.
        if(Level1Mode == TimetableMode && TimetableEditPanel->Visible && TimetableEditPanel->Enabled && !Shift.Contains(ssAlt))
        {
            if(Shift.Contains(ssShift) && !Shift.Contains(ssCtrl))
            {
                AllEntriesTTListBoxTopPosition = AllEntriesTTListBox->TopIndex;
// store value here before the Windows key press function runs (it runs after any local code)
                if(PreviousTTEntryButton->Enabled && (Key == 'L' || Key == 'l'))
                {
                    PreviousTTEntryKeyFlag = true;
                }
                if(NextTTEntryButton->Enabled && (Key == 'N' || Key == 'n'))
                {
                    NextTTEntryKeyFlag = true;
                }
                if(MoveTTEntryUpButton->Enabled && (Key == 'U' || Key == 'u'))
                {
                    MoveTTEntryUpKeyFlag = true;
                }
                if(MoveTTEntryDownButton->Enabled && (Key == 'D' || Key == 'd'))
                {
                    MoveTTEntryDownKeyFlag = true;
                }
                if(CopyTTEntryButton->Enabled && (Key == 'C' || Key == 'c'))
                {
                    CopyTTEntryKeyFlag = true;
                }
                if(InvertTTEntryButton->Enabled && (Key == 'J' || Key == 'j'))
                {
                    InvertTTEntryKeyFlag = true;
                }
                if(CutTTEntryButton->Enabled && (Key == 'X' || Key == 'x'))
                {
                    CutTTEntryKeyFlag = true;
                }
                if(PasteTTEntryButton->Enabled && (Key == 'P' || Key == 'p'))
                {
                    PasteTTEntryKeyFlag = true;
                }
                if(DeleteTTEntryButton->Enabled && (Key == 'E' || Key == 'e'))
                {
                    DeleteTTEntryKeyFlag = true;
                }
/* if(SaveTTEntryButton->Enabled && (Key == 'E' || Key == 'e'))  //can't have save while editing entry as adds the letter to the entry
                {
                    SaveTTEntryKeyFlag = true;
                }
              if(CancelTTActionButton->Enabled && (Key == 'K' || Key == 'k')) //can't have cancel while editing entry as adds the letter to the entry
                {
                    CancelTTActionKeyFlag = true;
                }
*/
                if(NewTTEntryButton->Enabled && (Key == 'I' || Key == 'i'))
                {
                    NewTTEntryKeyFlag = true;
                }
                if(AZOrderButton->Enabled && (Key == 'Z' || Key == 'z'))
                {
                    AZOrderKeyFlag = true;
                }
/*
                if(AddMinsButton->Enabled && (Key == 'M' || Key == 'm'))  //can't have key here as adds the letter to the entry
                {
                    AddMinsKeyFlag = true;
                }
                if(SubMinsButton->Enabled && (Key == 'B' || Key == 'b'))  //can't have key here as adds the letter to the entry
                {
                    SubMinsKeyFlag = true;
                }
*/
                if(TTServiceSyntaxCheckButton->Enabled && (Key == 'Q' || Key == 'q'))
                {
                    TTServiceSyntaxCheckKeyFlag = true;
                }
                if(ValidateTimetableButton->Enabled && (Key == 'V' || Key == 'v'))
                {
                    ValidateTimetableKeyFlag = true;
                }
                if(SaveTTButton->Enabled && (Key == 'T' || Key == 't'))
                {
                    SaveTTKeyFlag = true;
                }
                if(SaveTTAsButton->Enabled && (Key == 'A' || Key == 'a'))
                {
                    SaveTTAsKeyFlag = true;
                }
                if(RestoreTTButton->Enabled && (Key == 'R' || Key == 'r'))
                {
                    RestoreTTKeyFlag = true;
                }
                if(ExportTTButton->Enabled && (Key == 'O' || Key == 'o'))
                {
                    ExportTTKeyFlag = true;
                }
                if(ConflictAnalysisButton->Enabled && (Key == 'F' || Key == 'f'))
                {
                    ConflictAnalysisKeyFlag = true;
                }
            }
        }
// Information menu
        if(FloatingInfoMenu->Enabled && !Shift.Contains(ssAlt) && Shift.Contains(ssCtrl) && Shift.Contains(ssShift))
        {
            if(Key == 'I' || Key == 'i') // toggle track info
            {
                TrackInfoOnOffMenuItem->Click();
            }
            else if(TrainInfoMenuItem->Enabled)
            {
                if(Key == 'S' || Key == 's') // toggle train status info
                {
                    TrainStatusInfoOnOffMenuItem->Click();
                }
                else if(Key == 'T' || Key == 't') // toggle train timetable info
                {
                    TrainTTInfoOnOffMenuItem->Click();
                }
            }
        }
// end of 2.4.2 addition

    }
    catch(const Exception &e)
    {
        ErrorLog(167, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::FormKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    if((Key != VK_SHIFT) && (Key != VK_CONTROL))
    {
        LastNonCtrlOrShiftKeyDown = -1; // reset value to no key down
    }
    CtrlKey = false;
    ShiftKey = false;
    SaveMenuItem->ShortCut = 16467; // restore Ctrl S for save menu in case set to 0 in FormKeyDown
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog1MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog1->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog2MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog2->Caption = "";
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog3MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog3->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog4MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog4->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog5MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog5->Caption = "";
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog6MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog6->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog7MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog7->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog8MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog8->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog9MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog9->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OutputLog10MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if((Button == mbRight) && Level2OperMode == Operating)
    {
        OutputLog10->Caption = "";
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::AboutMenuItemClick(TObject *Sender)
{
    try
    {
        if((Level1Mode == OperMode) && (Level2OperMode != PreStart))
        // if PreStart leave as is [Modified at v1.2.0 - formerly just 'if((Level1Mode == OperMode)']
        {
            Level2OperMode = Paused;
            SetLevel2OperMode(3);
            MasterClock->Enabled = false;
        }
        AboutForm->ShowModal();
    }
    catch(const Exception &e)
    {
        ErrorLog(168, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::OpenHelpMenuItemClick(TObject *Sender)
{
    try
    {
        // Helpfile allocated during construction of Interface
        Application->HelpKeyword(u"Introduction"); // added at v2.0.0 for .chm help file
    }
    catch(const Exception &e)
    {
        ErrorLog(175, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::RailwayWebSiteMenuItemClick(TObject *Sender)
{
    const UnicodeString Link = "http://www.railwayoperationsimulator.com";
    ::ShellExecute(Handle, NULL, (Link).c_str(), NULL, NULL, SW_SHOWNORMAL);
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::BlackBgndMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("BlackBgndMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BlackBgndMenuItemClick");
        TColor OldTransparentColour = Utilities->clTransparent;
        Utilities->clTransparent = TColor(0);
        SelectBitmap->TransparentColor = Utilities->clTransparent;
        RailGraphics->ChangeAllTransparentColours(Utilities->clTransparent, OldTransparentColour);
        RailGraphics->SetUpAllDerivitiveGraphics(Utilities->clTransparent);

        MainScreen->Canvas->Brush->Color = Utilities->clTransparent;
        MainScreen->Canvas->FillRect(MainScreen->ClientRect);
        Level1Mode = BaseMode;
        SetLevel1Mode(128);
        Utilities->CallLogPop(1797);
    }
    catch(const Exception &e)
    {
        ErrorLog(170, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::WhiteBgndMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("WhiteBgndMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",WhiteBgndMenuItemClick");
        TColor OldTransparentColour = Utilities->clTransparent;
        Utilities->clTransparent = TColor(0xFFFFFF);
        SelectBitmap->TransparentColor = Utilities->clTransparent;
        RailGraphics->ChangeAllTransparentColours(Utilities->clTransparent, OldTransparentColour);
        RailGraphics->SetUpAllDerivitiveGraphics(Utilities->clTransparent);

        MainScreen->Canvas->Brush->Color = Utilities->clTransparent;
        MainScreen->Canvas->FillRect(MainScreen->ClientRect);
        Level1Mode = BaseMode;
        SetLevel1Mode(129);
        Utilities->CallLogPop(1798);
    }
    catch(const Exception &e)
    {
        ErrorLog(171, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::BlueBgndMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("BlueBgndMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BlueBgndMenuItemClick");
        TColor OldTransparentColour = Utilities->clTransparent;
        Utilities->clTransparent = TColor(0x330000);
        SelectBitmap->TransparentColor = Utilities->clTransparent;
        RailGraphics->ChangeAllTransparentColours(Utilities->clTransparent, OldTransparentColour);
        RailGraphics->SetUpAllDerivitiveGraphics(Utilities->clTransparent);

        MainScreen->Canvas->Brush->Color = Utilities->clTransparent;
        MainScreen->Canvas->FillRect(MainScreen->ClientRect);
        Level1Mode = BaseMode;
        SetLevel1Mode(130);
        Utilities->CallLogPop(1799);
    }
    catch(const Exception &e)
    {
        ErrorLog(172, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::SpeedToggleButtonClick(TObject *Sender)
{
    if(SpeedTopLabel->Caption == "mph")
    {
        SpeedTopLabel->Caption = "km/h";
        SpeedBottomLabel->Caption = "mph";
    }
    else
    {
        SpeedTopLabel->Caption = "mph";
        SpeedBottomLabel->Caption = "km/h";
    }
    // swap values to match toggle state
    UnicodeString SavedTopValue = SpeedEditBox->Text;
    UnicodeString SavedBottomValue = SpeedVariableLabel->Caption;

    SpeedEditBox->Text = SavedBottomValue;
    SpeedVariableLabel->Caption = SavedTopValue;
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SpeedToggleButton2Click(TObject *Sender)
{
    if(SpeedTopLabel2->Caption == "mph")
    {
        SpeedTopLabel2->Caption = "km/h";
        SpeedBottomLabel2->Caption = "mph";
    }
    else
    {
        SpeedTopLabel2->Caption = "mph";
        SpeedBottomLabel2->Caption = "km/h";
    }
    // swap values to match toggle state
    UnicodeString SavedTopValue = SpeedEditBox2->Text;
    UnicodeString SavedBottomValue = SpeedVariableLabel2->Caption;

    SpeedEditBox2->Text = SavedBottomValue;
    SpeedVariableLabel2->Caption = SavedTopValue;
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SpeedEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("SpeedEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SpeedEditBoxKeyUp," + AnsiString(Key));
        bool ErrorFlag = false, TooBigFlag = false;
        if(SpeedEditBox->Text.Length() > 0)
        {
            if(SpeedEditBox->Text.Length() > 5)
            {
                TooBigFlag = true;
            }
            for(int x = 1; x <= SpeedEditBox->Text.Length(); x++)
            {
                if((SpeedEditBox->Text[x] < '0') || (SpeedEditBox->Text[x] > '9'))
                {
                    SpeedVariableLabel->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
                if(TooBigFlag)
                {
                    SpeedVariableLabel->Caption = "Too big";
                    break;
                }
            }
            if(!ErrorFlag && !TooBigFlag)
            {
/*
                  1 mph =  1.609344 km/h
                  1 km/h = 0.621371 mph
*/
                if(SpeedTopLabel->Caption == "mph")
                {
                    // do mph-to-km/h conversion
                    int MPH = SpeedEditBox->Text.ToInt();
                    int KPH = (MPH * 1.609344) + 0.5;
                    SpeedVariableLabel->Caption = UnicodeString(KPH);
                }
                else
                {
                    // do km/h-to-mph conversion
                    int KPH = SpeedEditBox->Text.ToInt();
                    int MPH = (KPH * 0.621371) + 0.5;
                    SpeedVariableLabel->Caption = UnicodeString(MPH);
                }
            }
        }
        else
        {
            SpeedVariableLabel->Caption = "";
        }
        Utilities->CallLogPop(1865);
    }
    catch(const EConvertError &ec) // thrown for ToInt() conversion error; shouldn't occur but include to prevent a crash //non-error catch
    {
        SpeedVariableLabel->Caption = "Entry error";
        Utilities->CallLogPop(2307);
    }
    catch(const Exception &e)
    {
        ErrorLog(176, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::PowerToggleButtonClick(TObject *Sender)
{
    if(PowerTopLabel->Caption == "HP")
    {
        PowerTopLabel->Caption = "kW";
        PowerBottomLabel->Caption = "HP";
    }
    else
    {
        PowerTopLabel->Caption = "HP";
        PowerBottomLabel->Caption = "kW";
    }
    // swap values to match toggle state
    UnicodeString SavedTopValue = PowerEditBox->Text;
    UnicodeString SavedBottomValue = PowerVariableLabel->Caption;

    PowerEditBox->Text = SavedBottomValue;
    PowerVariableLabel->Caption = SavedTopValue;
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::PowerEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("PowerEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PowerEditBoxKeyUp," + AnsiString(Key));
        bool ErrorFlag = false, TooBigFlag = false;
        if(PowerEditBox->Text.Length() > 0)
        {
            if(PowerEditBox->Text.Length() > 8)
            {
                TooBigFlag = true;
            }
            for(int x = 1; x <= PowerEditBox->Text.Length(); x++)
            {
                if((PowerEditBox->Text[x] < '0') || (PowerEditBox->Text[x] > '9'))
                {
                    PowerVariableLabel->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
                if(TooBigFlag)
                {
                    PowerVariableLabel->Caption = "Too big";
                    break;
                }
            }
            if(!ErrorFlag && !TooBigFlag)
            {
/*
                   1 kW = 1.340482574 HP
                   1 HP = 0.745699872 kW
*/
                if(PowerTopLabel->Caption == "HP")
                {
                    // do HP-to-kW conv
                    int HP = PowerEditBox->Text.ToInt();
                    int KW = (HP * 0.745699872) + 0.5;
                    PowerVariableLabel->Caption = UnicodeString(KW);
                }
                else
                {
                    // do kW-to-HP conv
                    int KW = PowerEditBox->Text.ToInt();
                    int HP = (KW * 1.340482574) + 0.5;
                    PowerVariableLabel->Caption = UnicodeString(HP);
                }
            }
        }
        else
        {
            PowerVariableLabel->Caption = "";
        }
        Utilities->CallLogPop(1868);
    }
    catch(const EConvertError &ec) // thrown for ToInt() conversion error; shouldn't occur but include to prevent a crash  //non-error catch
    {
        PowerVariableLabel->Caption = "Entry error";
        Utilities->CallLogPop(2308);
    }
    catch(const Exception &e)
    {
        ErrorLog(179, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SpeedEditBox2KeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("SpeedEditBox2KeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SpeedEditBox2KeyUp," + AnsiString(Key));
        bool ErrorFlag = false, TooBigFlag = false;
        if(SpeedEditBox2->Text.Length() > 0)
        {
            if(SpeedEditBox2->Text.Length() > 5)
            {
                TooBigFlag = true;
            }
            for(int x = 1; x <= SpeedEditBox2->Text.Length(); x++)
            {
                if((SpeedEditBox2->Text[x] < '0') || (SpeedEditBox2->Text[x] > '9'))
                {
                    SpeedVariableLabel2->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
                if(TooBigFlag)
                {
                    SpeedVariableLabel2->Caption = "Too big";
                    break;
                }
            }
            if(!ErrorFlag && !TooBigFlag)
            {
/*
                   1 mph =  1.609344 km/h
                   1 km/h = 0.621371 mph
*/
                if(SpeedTopLabel2->Caption == "mph")
                {
                    // do mph-to-km/h conversion
                    int MPH = SpeedEditBox2->Text.ToInt();
                    int KPH = (MPH * 1.609344) + 0.5;
                    SpeedVariableLabel2->Caption = AnsiString(KPH);
                }
                else
                {
                    // do km/h-to-mph conversion
                    int KPH = SpeedEditBox2->Text.ToInt();
                    int MPH = (KPH * 0.621371) + 0.5;
                    SpeedVariableLabel2->Caption = AnsiString(MPH);
                }
            }
        }
        else
        {
            SpeedVariableLabel2->Caption = "";
        }
        Utilities->CallLogPop(1866);
    }
    catch(const EConvertError &ec) // thrown for ToInt() conversion error; shouldn't occur but include to prevent a crash //non-error catch
    {
        SpeedVariableLabel2->Caption = "Entry error";
        Utilities->CallLogPop(2309);
    }
    catch(const Exception &e)
    {
        ErrorLog(177, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::LengthEditKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("LengthEditKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",LengthEditKeyUp," + AnsiString(Key));
        bool ErrorFlag = false, TooLongFlag = false;
        if((MileEdit->Text.Length() > 0) && (MileEdit->Text.Length() < 6))
        {
            for(int x = 1; x <= MileEdit->Text.Length(); x++)
            {
                if((MileEdit->Text[x] < '0') || (MileEdit->Text[x] > '9'))
                {
                    MetreVariableLabel->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
            }
        }
        if((ChainEdit->Text.Length() > 0) && (ChainEdit->Text.Length() < 6))
        {
            for(int x = 1; x <= ChainEdit->Text.Length(); x++)
            {
                if((ChainEdit->Text[x] < '0') || (ChainEdit->Text[x] > '9'))
                {
                    MetreVariableLabel->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
            }
        }
        if((YardEdit->Text.Length() > 0) && (YardEdit->Text.Length() < 6))
        {
            for(int x = 1; x <= YardEdit->Text.Length(); x++)
            {
                if((YardEdit->Text[x] < '0') || (YardEdit->Text[x] > '9'))
                {
                    MetreVariableLabel->Caption = "Entry error";
                    ErrorFlag = true;
                    break;
                }
            }
        }
        if((MileEdit->Text.Length() > 5) || (ChainEdit->Text.Length() > 5) || (YardEdit->Text.Length() > 5))
        {
            TooLongFlag = true;
            MetreVariableLabel->Caption = "Too big";
        }
        if(!ErrorFlag && !TooLongFlag)
        {
            int Miles = 0, Chains = 0, Yards = 0, Metres = 0;
            if(MileEdit->Text.Length() > 0)
            {
                Miles = MileEdit->Text.ToInt();
            }
            if(ChainEdit->Text.Length() > 0)
            {
                Chains = ChainEdit->Text.ToInt();
            }
            if(YardEdit->Text.Length() > 0)
            {
                Yards = YardEdit->Text.ToInt();
            }
            Metres = int((Miles * 1609.344) + (Chains * 20.1168) + (Yards * 0.9144) + 0.5);
            MetreVariableLabel->Caption = AnsiString(Metres);
        }
        if((MileEdit->Text.Length() == 0) && (ChainEdit->Text.Length() == 0) && (YardEdit->Text.Length() == 0))
        {
            MetreVariableLabel->Caption = "";
        }
        Utilities->CallLogPop(1867);
    }
    catch(const EConvertError &ec) // thrown for ToInt() conversion error; shouldn't occur but include to prevent a crash  //non-error catch
    {
        MetreVariableLabel->Caption = "Entry error";
        Utilities->CallLogPop(2310);
    }
    catch(const Exception &e)
    {
        ErrorLog(178, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockAdjButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockAdjButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockAdjButtonClick");
// Utilities->Clock2Stopped = true; // to keep panel buttons disabled, restarted on exit
        Display->HideWarningLog(0); // because this panel overwrites it
        TTClockAdjPanel->Visible = true;
        TTClockAdjButton->Enabled = false;
/*
        OperatingPanelLabel->Caption = "Disabled";   all these now dealt with in ClockTimer2
        OperatingPanel->Enabled = false;
        ZoomButton->Enabled = false;
        HomeButton->Enabled = false;
        NewHomeButton->Enabled = false;
        ScreenLeftButton->Enabled = false;
        ScreenRightButton->Enabled = false;
        ScreenUpButton->Enabled = false;
        ScreenDownButton->Enabled = false;
*/
        Utilities->CallLogPop(1875);
    }
    catch(const Exception &e)
    {
        ErrorLog(181, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockExitButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockExitButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockExitButtonClick");
        TTClockAdjPanel->Visible = false;
        TTClockAdjButton->Enabled = true;
/* these dealt with in ClockTimer2
        ZoomButton->Enabled = true;
        HomeButton->Enabled = true;
        NewHomeButton->Enabled = true;
        ScreenLeftButton->Enabled = true;
        ScreenRightButton->Enabled = true;
        ScreenUpButton->Enabled = true;
        ScreenDownButton->Enabled = true;
        OperatingPanel->Enabled = true;
        OperatingPanelLabel->Caption = "Operation";
*/
        Display->ShowWarningLog(0);
        double TTClockTimeChange = double(TrainController->RestartTime) - PauseEntryRestartTime;
        if((TTClockSpeed != PauseEntryTTClockSpeed) || (TTClockTimeChange > 0.000347))
        {
            // 30 seconds, min increase is 1 minute & don't trust doubles to stay exactly equal
            if(!TTClockAdjustWarningHide)
            {
                TTClockAdjustWarningPanel->Top = MainScreen->Top + ((MainScreen->Height - TTClockAdjustWarningPanel->Height) / 2);
                TTClockAdjustWarningPanel->Left = MainScreen->Left + ((MainScreen->Width - TTClockAdjustWarningPanel->Width) / 2);
                TTClockAdjustWarningLabel->Caption =
                    "Changes have been made to the timetable clock - you may wish to save a session before resuming operation.\n\nTo cancel all changes re-click the 'Adjust the timetable clock' button then click the reset button BEFORE resuming operation.";
                TTClockAdjustWarningPanel->Visible = true;
            }
        }
// Utilities->Clock2Stopped = false; // as above
        LastNonCtrlOrShiftKeyDown = -1;
// to restore the ability to reselect T after adj panel hidden (FormKeyUp doesn't work because the Interface form doesn't have focus)
        Utilities->CallLogPop(1876);
    }
    catch(const Exception &e)
    {
        ErrorLog(182, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockx2ButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockx2ButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockx2ButtonClick");
        TTClockSpeed = 2;
        TTClockSpeedLabel->Caption = "x2";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1878);
    }
    catch(const Exception &e)
    {
        ErrorLog(184, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockx4ButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockx4ButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockx4ButtonClick");
        TTClockSpeed = 4;
        TTClockSpeedLabel->Caption = "x4";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1883);
    }
    catch(const Exception &e)
    {
        ErrorLog(189, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockx8ButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockx8ButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockx8ButtonClick");
        TTClockSpeed = 8;
        TTClockSpeedLabel->Caption = "x8";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1884);
    }
    catch(const Exception &e)
    {
        ErrorLog(190, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockx16ButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockx16ButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockx16ButtonClick");
        TTClockSpeed = 16;
        TTClockSpeedLabel->Caption = "x16";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1885);
    }
    catch(const Exception &e)
    {
        ErrorLog(191, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockx1ButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockx1ButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockx1ButtonClick");
        TTClockSpeed = 1;
        TTClockSpeedLabel->Caption = "x1";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1886);
    }
    catch(const Exception &e)
    {
        ErrorLog(192, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockxHalfButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockxHalfButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockxHalfButtonClick");
        TTClockSpeed = 0.5;
        TTClockSpeedLabel->Caption = "x1/2";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1887);
    }
    catch(const Exception &e)
    {
        ErrorLog(193, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockxQuarterButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockxQuarterButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockxQuarterButtonClick");
        TTClockSpeed = 0.25;
        TTClockSpeedLabel->Caption = "x1/4";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(1888);
    }
    catch(const Exception &e)
    {
        ErrorLog(194, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockxEighthButtonClick(TObject *Sender)
{
    // added for v2.3.0 for very big railways
    try
    {
        TrainController->LogEvent("TTClockxEighthButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockxEighthButtonClick");
        TTClockSpeed = 0.125;
        TTClockSpeedLabel->Caption = "x1/8";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(2099);
    }
    catch(const Exception &e)
    {
        ErrorLog(203, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockxSixteenthButtonClick(TObject *Sender)
{
    // added for v2.3.0 for very big railways
    try
    {
        TrainController->LogEvent("TTClockxSixteenthButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockxSixteenthButtonClick");
        TTClockSpeed = 0.0625;
        TTClockSpeedLabel->Caption = "x1/16";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        Utilities->CallLogPop(2100);
    }
    catch(const Exception &e)
    {
        ErrorLog(204, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockAdd1hButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockAdd1hButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockAdd1hButtonClick");
        double TTClockIncrement = 1.0 / 24;
        TrainController->RestartTime += TDateTime(TTClockIncrement);
        TrainController->TTClockTime = TrainController->RestartTime;
        ClockLabel->Caption = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        Utilities->CallLogPop(1879);
    }
    catch(const Exception &e)
    {
        ErrorLog(185, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockAdd10mButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockAdd10mButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockAdd10mButtonClick");
        double TTClockIncrement = 1.0 / 144;
        TrainController->RestartTime += TDateTime(TTClockIncrement);
        TrainController->TTClockTime = TrainController->RestartTime;
        ClockLabel->Caption = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        Utilities->CallLogPop(1881);
    }
    catch(const Exception &e)
    {
        ErrorLog(187, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockAdd1mButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockAdd1mButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockAdd1mButtonClick");
        double TTClockIncrement = 1.0 / 1440;
        TrainController->RestartTime += TDateTime(TTClockIncrement);
        TrainController->TTClockTime = TrainController->RestartTime;
        ClockLabel->Caption = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        Utilities->CallLogPop(1882);
    }
    catch(const Exception &e)
    {
        ErrorLog(188, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockResetButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockResetButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockResetButtonClick");
        TrainController->RestartTime = TDateTime(PauseEntryRestartTime);
        TrainController->TTClockTime = TrainController->RestartTime;
        ClockLabel->Caption = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        TTClockSpeed = PauseEntryTTClockSpeed;
        if(TTClockSpeed == 2)
        {
            TTClockSpeedLabel->Caption = "x2";
        }
        else if(TTClockSpeed == 4)
        {
            TTClockSpeedLabel->Caption = "x4";
        }
        else if(TTClockSpeed == 8)
        {
            TTClockSpeedLabel->Caption = "x8";
        }
        else if(TTClockSpeed == 16)
        {
            TTClockSpeedLabel->Caption = "x16";
        }
        else if(TTClockSpeed == 0.5)
        {
            TTClockSpeedLabel->Caption = "x1/2";
        }
        else if(TTClockSpeed == 0.25)
        {
            TTClockSpeedLabel->Caption = "x1/4";
        }
        else if(TTClockSpeed == 0.125)
        {
            TTClockSpeedLabel->Caption = "x1/8";
        }
        else if(TTClockSpeed == 0.0625)
        {
            TTClockSpeedLabel->Caption = "x1/16";
        }
        else
        {
            TTClockSpeed = 1;
            TTClockSpeedLabel->Caption = "x1";
        }
        Utilities->CallLogPop(1880);
    }
    catch(const Exception &e)
    {
        ErrorLog(186, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::PresetAutoSigRoutesButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("PresetAutoSigRoutesButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PresetAutoSigRoutesButtonClick");
        InfoPanel->Caption = "PRE-START:  Presetting automatic signal routes";
        OperatingPanelLabel->Caption = "Disabled";
        OperatingPanel->Enabled = false; // becomes re-enabled during the call to ClockTimer2
        ZoomButton->Enabled = false;
        HomeButton->Enabled = false;
        NewHomeButton->Enabled = false;
        ScreenLeftButton->Enabled = false;
        ScreenRightButton->Enabled = false;
        ScreenUpButton->Enabled = false;
        ScreenDownButton->Enabled = false;

        Screen->Cursor = TCursor(-11); // Hourglass
        TPrefDirElement StartElement, EndElement;
        bool PointsChanged, AtLeastOneSet = false;
        int LastIteratorValue = 0;
        while(true)
        {
            if(!EveryPrefDir->GetStartAndEndPrefDirElements(0, StartElement, EndElement, LastIteratorValue))
            {
                break;
            }
            // rest of routine here - i.e. build the routes
            ConstructRoute->ClearRoute(); // in case not empty though should be
            AtLeastOneSet = true;
            if(ConstructRoute->GetPreferredRouteStartElement(1, StartElement.HLoc, StartElement.VLoc, EveryPrefDir, true)) // true for AutoSigsFlag
            {
            }
            if(ConstructRoute->GetNextPreferredRouteElement(1, EndElement.HLoc, EndElement.VLoc, EveryPrefDir, true, true, ConstructRoute->ReqPosRouteID,
                                                            PointsChanged))
            {
            }
            ConstructRoute->ConvertAndAddPreferredRouteSearchVector(3, ConstructRoute->ReqPosRouteID, true); // true for AutoSigsFlag
        }
        if(AtLeastOneSet)
        {
            RevertToOriginalRouteSelector(15);
            ClearandRebuildRailway(68);
        }
        else
        {
            ShowMessage("No presettable automatic signal routes are available");
        }
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1994);
    }
    catch(const Exception &e)
    {
        ErrorLog(195, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::FormResize(TObject *Sender) // new at v2.1.0
{
    try
    {
        if(!SkipFormResizeEvent) // to avoid calling during startup and especially during shutdown
        {
            // else fails on shutdown because HiddenScreen & other things no longer exist
            int DispW = (Interface->Width - 64 - 16) / 16;
// will truncate down to a multiple of 16  (64 = side panels and 16 compensates for excess width of Interface)
            int DispH = (Interface->Height - 192) / 16;
            MainScreen->Width = DispW * 16;
            MainScreen->Height = DispH * 16;
            Utilities->ScreenElementWidth = DispW;
            Utilities->ScreenElementHeight = DispH;
            HiddenScreen->Width = MainScreen->Width;
            HiddenScreen->Height = MainScreen->Height;
//            PerfLogForm->Top = Screen->Height - PerfLogForm->Height - 32; //-32 to avoid overlapping taskbar  dropped these after Beta5a so keep last positions
//            PerfLogForm->Left = 0;
//            ActionsDueForm->Top = Screen->Height -ActionsDueForm->Height - 32; //-32 to avoid overlapping taskbar;;
//            ActionsDueForm->Left = Screen->Width - ActionsDueForm->Width;
            SigImagePanel->Left = (Interface->Width - SigImagePanel->Width) / 2; // added for v2.3.0
            DevelopmentPanel->Top = MainScreen->Top + MainScreen->Height - DevelopmentPanel->Height; // new v2.2.0
            DevelopmentPanel->Left = MainScreen->Left + MainScreen->Width - DevelopmentPanel->Width; // new v2.2.0
            MTBFEditBox->Left = MainScreen->Left + MainScreen->Width - MTBFEditBox->Width + 32; // new v2.4.0 32 is to place it above the positional panel
            MTBFLabel->Left = MainScreen->Left + MainScreen->Width - MTBFEditBox->Width + 30 - 55; // new v2.4.0 placed above and to the left of MTBFEditBox
            PositionalPanel->Left = MainScreen->Left + MainScreen->Width; // changed at v2.4.0
            PositionalPanel->Top = MainScreen->Top; // changed at v2.4.0
            PositionalPanel->Height = MainScreen->Height; // changed at v2.4.0

            if(!Display->ZoomOutFlag)
            {
                ClearandRebuildRailway(70);
            }
            else
            {
                Display->ClearDisplay(11);
                Track->PlotSmallRailway(9, Display);
            }
            Display->Update();
        }
    }
    catch(const Exception &e)
    {
        ErrorLog(197, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ConvertToOtherHandSignalsMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ConvertToOtherHandSignalsMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ConvertToOtherHandSignalsMenuItemClick");
        RailGraphics->ConvertSignalsToOppositeHand(0);
        if(Utilities->RHSignalFlag) // RH sigs after conversion
        {
            ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Left Hand Signals";
            if(Track->SignalAspectBuildMode == TTrack::GroundSignalBuild)
            {
                LoadGroundSignalGlyphs(4);
            }
            else
            {
                LoadNormalSignalGlyphs(2);
            }
            SigImagePanel->Caption = "Signals will be on the right hand side of the track";
            SigsOnLeftImage1->Visible = false;
            SigsOnLeftImage2->Visible = false;
            SigsOnRightImage1->Visible = true;
            SigsOnRightImage2->Visible = true;
        }
        else // LH sigs after conversion
        {
            ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Right Hand Signals";
            if(Track->SignalAspectBuildMode == TTrack::GroundSignalBuild)
            {
                LoadGroundSignalGlyphs(3);
            }
            else
            {
                LoadNormalSignalGlyphs(3);
            }
            SigImagePanel->Caption = "Signals will be on the left hand side of the track";
            SigsOnRightImage1->Visible = false;
            SigsOnRightImage2->Visible = false;
            SigsOnLeftImage1->Visible = true;
            SigsOnLeftImage2->Visible = true;
        }
        Utilities->CallLogPop(2097);
    }
    catch(const Exception &e)
    {
        ErrorLog(202, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::MTBFEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)

{
    try
    {
        TrainController->LogEvent("MTBFEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MTBFEditBoxKeyUp," + AnsiString(Key));
        if((Level1Mode != OperMode) || (Level2OperMode != PreStart))
        {
            Utilities->CallLogPop(2160);
            return;
        }
        bool TooBigFlag = false, BadCharsFlag = false;
        TrainController->AvHoursIntValue = 0;
        TrainController->MTBFHours = 0;
        if(MTBFEditBox->Text.Length() > 0)
        {
            for(int x = 1; x <= MTBFEditBox->Text.Length(); x++)
            {
                if((MTBFEditBox->Text[x] < '0') || (MTBFEditBox->Text[x] > '9'))
                {
                    BadCharsFlag = true;
                    break;
                }
            }
            if(!BadCharsFlag)
            {
                if(StrToInt(MTBFEditBox->Text) > 10000)
                {
                    TooBigFlag = true;
                }
            }
            if(TooBigFlag)
            {
                ShowMessage("Maximum value allowed is 9999"); //changed from 10,000 at v 2.10.0 but length limited to 4 anyway so 'to big' shouldn't arise
                MTBFEditBox->Text = "";
                TrainController->AvHoursIntValue = 0;
                TrainController->MTBFHours = 0;
                Utilities->CallLogPop(2161);
                return;
            }
            if(BadCharsFlag)
            {
                ShowMessage("Value must be a whole number with no special characters");
                MTBFEditBox->Text = "";
                TrainController->AvHoursIntValue = 0;
                TrainController->MTBFHours = 0;
                Utilities->CallLogPop(2162);
                return;
            }
            TrainController->AvHoursIntValue = StrToInt(MTBFEditBox->Text); // ok if user enters 0 as that means no failures
            TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        }
        if(TrainController->AvHoursIntValue == 0)
        {
            MTBFEditBox->Text = "";
            TrainController->MTBFHours = 0;
        }
        Utilities->CallLogPop(2163);
    }
    catch(const Exception &e)
    {
        ErrorLog(209, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::MTBFEditBoxClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MTBFEditBoxClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MTBFEditBoxClick");
        if((Level1Mode != OperMode) || (Level2OperMode != PreStart))
        {
            MTBFEditBox->ReadOnly = true; // it should be anyway but include here for safety
            TrainController->StopTTClockMessage(92,
                                                "Values can only be entered or changed in Pre-Start mode\ni.e. after selecting 'Operate railway' but before clicking 'Run'");
        }
        Utilities->CallLogPop(2164);
    }
    catch(const Exception &e)
    {
        ErrorLog(210, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::UserGraphicButtonClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MTBFEditBoxClick");
        LengthConversionPanel->Visible = false;
        SpeedConversionPanel->Visible = false;
        DistanceKey->Visible = false;
        TrackElementPanel->Visible = false;
        SigAspectButton->Enabled = false;
        Level2TrackMode = SelectGraphic;
        SetLevel2TrackMode(63);
        Display->Update();
        if((SelectedGraphicFileName != "") && (!Track->UserGraphicVector.empty()))
        // latter condition added at v2.6.0 because showed after ClearAll & reselect failed
        {
            UserGraphicReselectPanel->Visible = true;
        }
        else
        {
            UserGraphicReselectPanel->Visible = false;
            LoadUserGraphic(0);
        }
        Utilities->CallLogPop(2183);
    }
    catch(const Exception &e)
    {
        ErrorLog(212, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ReselectUserGraphicClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ReselectUserGraphicClick");
        TrainController->LogEvent("ReselectUserGraphicClick " + SelectedGraphicFileName);
        UserGraphicReselectPanel->Visible = false;
        TTrack::TUserGraphicMap::iterator UGMIt = Track->UserGraphicMap.find(SelectedGraphicFileName);
        if(UGMIt == Track->UserGraphicMap.end())
        {
            ShowMessage("Unable to find graphic file " + SelectedGraphicFileName + ". Check it still exists.");
            Utilities->CallLogPop(2196);
            return;
        }
        Level2TrackMode = AddGraphic;
        SetLevel2TrackMode(64);
        Utilities->CallLogPop(2184);
    }
    catch(const Exception &e)
    {
        ErrorLog(213, e.Message);
    }
}
// ---------------------------------------------------------------------------

void __fastcall TInterface::SelectNewGraphicClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SelectNewGraphicClick");
        UserGraphicReselectPanel->Visible = false;
        LoadUserGraphic(1);
        Utilities->CallLogPop(2185);
    }
    catch(const Exception &e)
    {
        ErrorLog(214, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TTClockAdjustOKButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TTClockAdjustOKButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TTClockAdjustOKButtonClick");
        TTClockAdjustWarningPanel->Visible = false;
        if(TTClockAdjustCheckBox->Checked)
        {
            TTClockAdjustWarningHide = true;
        }
        Utilities->CallLogPop(2219);
    }
    catch(const Exception &e)
    {
        ErrorLog(216, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::TwoLocationNameButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("TwoLocationNameButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TwoLocationNameButtonClick");
        TwoLocationNamePanel->Visible = false;
        ShowHideTTButton->Enabled = true;
        ExitTTModeButton->Enabled = true;
        TimetableEditPanel->Enabled = true;
        if(TwoLocationNameCheckBox->Checked)
        {
            TwoLocationNamePanelHide = true;
        }
        Utilities->CallLogPop(2316);
    }
    catch(const Exception &e)
    {
        ErrorLog(224, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::ConflictAnalysisButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("ConflictAnalysisButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ConflictAnalysisButtonClick");
        ConflictPanel->Visible = true;
        Utilities->CallLogPop(2220);
    }
    catch(const Exception &e)
    {
        ErrorLog(217, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CPCancelButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CPCancelButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CPCancelButtonClick");
        ConflictPanel->Visible = false;
        Utilities->CallLogPop(2221);
    }
    catch(const Exception &e)
    {
        ErrorLog(218, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::CPGenFileButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("CPGenFileButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",CPGenFileButtonClick");
        if(!CPArrivalsCheckBox->Checked && !CPDeparturesCheckBox->Checked && !CPAtLocCheckBox->Checked && !CPDirectionsCheckBox->Checked)
        {
            ShowMessage("No boxes ticked!");
        }
        else // keep ticks & range values from last time, only reset on startup
        {
            Screen->Cursor = TCursor(-11); // hourglass
            AnsiString TTTitle;
            if(RlyFile && TimetableValidFlag && (CreateEditTTFileName != ""))
            {
                for(int x = CreateEditTTFileName.Length(); x > 0; x--) // first need to strip out the timetable title from the full name
                {
                    if(CreateEditTTFileName[x] == '\\')
                    {
                        TTTitle = CreateEditTTFileName.SubString(x + 1, CreateEditTTFileName.Length() - x - 4);
                        break;
                    }
                }
                if(TrainController->CreateTTAnalysisFile(0, RailwayTitle, TTTitle, CurDir, CPArrivalsCheckBox->Checked, CPDeparturesCheckBox->Checked,
                                                         CPAtLocCheckBox->Checked, CPDirectionsCheckBox->Checked, CPEditArrRange->Text.ToInt(), CPEditDepRange->Text.ToInt()))
                {
                    ShowMessage("Analysis complete and file created");
                }
                ConflictPanel->Visible = false;
            }
        }
        Screen->Cursor = TCursor(-2); // arrow
        Utilities->CallLogPop(2222);
    }
    catch(const Exception &e)
    {
        ErrorLog(219, e.Message);
    }
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::ReloadConfigMenuItemClick(TObject *Sender) //new for v2.11.0
{
    try
    {
        TrainController->LogEvent("ReloadConfigMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ReloadConfigMenuItemClick");
        bool NoConfig; //not used
        LoadConfigFile(1, false, NoConfig); //false as it's not the first load
        Utilities->CallLogPop(2401);
    }
    catch(const Exception &e)
    {
        ErrorLog(238, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::LoadConfigFile(int Caller, bool FirstLoad, bool &NoConfigFile)
{
    try
    {
        //throw Exception(""); to test error message
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadConfigFile," + AnsiString((unsigned char)FirstLoad));
        int LengthInt, SpeedInt;
        NoConfigFile = false;
        std::ifstream ConfigFile((CurDir + "\\Config.txt").c_str()); // added at v2.6.0 to set save & load directories for railways, timetables & session & to
        if(ConfigFile.fail()) // no Config file                           //replace Signal.hnd, Background.col and GNU
        {
            NoConfigFile = true;
            if(FirstLoad) //added atv2.11.0 - may have changed to RH sigs so don't want it resetting to left when load a railway or session
            {
                ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Right Hand Signals";
                SigImagePanel->Caption = "Signals will be on the left hand side of the track";
                SigsOnLeftImage1->Visible = true;
                SigsOnLeftImage2->Visible = true;
                SigsOnRightImage1->Visible = false;
                SigsOnRightImage2->Visible = false;
                ShowMessage(
                    "This program is free software released under the terms of the GNU General Public License Version 3, as published by the Free Software Foundation. "
                    " It may be used or redistributed in accordance with that license and is released in the hope that it will be useful, but WITHOUT ANY WARRANTY; "
                    "without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details - "
                    "you should have received a copy along with this program but if not see <http://www.gnu.org/licenses/>.");
            }
        }
        else
        {
            AnsiString ConfigStr = "";
            bool ContinueFlag = false;
            do
            {
                if(Utilities->CheckAndReadOneLineFromConfigFile(ConfigFile, ConfigStr))
                {
                    if(ConfigFile.eof())
                    {
                        break;
                    }
    //changes at v2.11.0 to add default track lengths and speeds (for user editing) and to add comments
    //                AnsiString ConfigValue = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                    if(ConfigStr == "")
                    {
                        continue; //ignore blank lines
                    }
                    if(ConfigStr[1] == '#')
                    {
                        continue; //ignore lines thet begin with ''#'
                    }
                    for(int x = 1; x <= ConfigStr.Length(); x++)
                    {
                        if(ConfigStr[x] == '#')
                        {
                            ConfigStr = ConfigStr.SubString(1, x - 1); //strip the '#' and all after it
                            //get rid of all spaces & tabs at end of text (Trim() doesn't remove tabs)
                            while((ConfigStr.SubString(ConfigStr.Length(), 1) == AnsiString(' ')) || (ConfigStr.SubString(ConfigStr.Length(), 1) == AnsiString('\t')))
                            {
                                ConfigStr = ConfigStr.SubString(1, ConfigStr.Length() - 1);
                            }
                            break;
                        }
                    }
                    AnsiString ConfigValue = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                    if((ConfigStr.SubString(1, 8) == "Signals=") && FirstLoad)
                    {
                        //get rid of all spaces & tabs at beginning of text
                        while((ConfigValue.SubString(1, 1) == AnsiString(' ')) || (ConfigValue.SubString(1, 1) == AnsiString('\t')))
                        {
                            ConfigValue = ConfigValue.SubString(2, ConfigValue.Length() - 1);
                        }
                        if((ConfigValue == "right") && !Utilities->RHSignalFlag)
                        {
                            RailGraphics->ConvertSignalsToOppositeHand(1); // toggles Utilities->RHSignalFlag in function (sigs always left hand on startup)
                            ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Left Hand Signals";
                            if(Track->SignalAspectBuildMode == TTrack::GroundSignalBuild)
                            {
                                LoadGroundSignalGlyphs(1);
                            }
                            else
                            {
                                LoadNormalSignalGlyphs(1);
                            }
                            SigImagePanel->Caption = "Signals will be on the right hand side of the track";
                            SigsOnLeftImage1->Visible = false;
                            SigsOnLeftImage2->Visible = false;
                            SigsOnRightImage1->Visible = true;
                            SigsOnRightImage2->Visible = true;
                        }
                        else if((ConfigValue == "left") && Utilities->RHSignalFlag)
                        {
                            RailGraphics->ConvertSignalsToOppositeHand(2); // toggles Utilities->RHSignalFlag in function
                            ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Right Hand Signals";
                            if(Track->SignalAspectBuildMode == TTrack::GroundSignalBuild)
                            {
                                LoadGroundSignalGlyphs(2);
                            }
                            else
                            {
                                LoadNormalSignalGlyphs(5);
                            }
                            SigImagePanel->Caption = "Signals will be on the left hand side of the track";
                            SigsOnLeftImage1->Visible = true;
                            SigsOnLeftImage2->Visible = true;
                            SigsOnRightImage1->Visible = false;
                            SigsOnRightImage2->Visible = false;
                        }  //if not either of these then sigs already set as should be
                    }
                    if((ConfigStr.SubString(1, 8) == "BgndCol=") && FirstLoad)
                    {
                        // pick up transparent colour from file if there is one & set it to the stored value if it's valid else set to black
                        Utilities->clTransparent = clB0G0R0; // default black background;
                        if(ConfigValue == "white")
                        {
                            Utilities->clTransparent = TColor(0xFFFFFF);
                        }
                        else if(ConfigValue == "blue")
                        {
                            Utilities->clTransparent = TColor(0x330000);
                        }
                    }
                    if((ConfigStr.SubString(1, 8) == "RLYLocn=") && FirstLoad)
                    {
                        if(DirectoryExists(ConfigValue)) // else stays as original directory
                        {
                            SaveRailwayDialog->InitialDir = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                            LoadRailwayDialog->InitialDir = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                        }
                    }
                    else if((ConfigStr.SubString(1, 8) == "TTBLocn=") && FirstLoad)
                    {
                        if(DirectoryExists(ConfigValue)) // else stays as original directory
                        {
                            TimetableDialog->InitialDir = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                            SaveTTDialog->InitialDir = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                        }
                    }
                    else if((ConfigStr.SubString(1, 8) == "SSNLocn=") && FirstLoad)
                    {
                        if(DirectoryExists(ConfigValue)) // else stays as original directory
                        {
                            LoadSessionDialog->InitialDir = ConfigStr.SubString(9, ConfigStr.Length() - 8);
                        }
                    }
                    else if(ConfigStr.SubString(1, 8) == "Length =")
                    {
                        for(int x = 1; x <= ConfigValue.Length(); x++)
                        {
                            if((ConfigValue[x] < '0') || (ConfigValue[x] > '9'))
                            {
                                ContinueFlag = true; //ignore it if invalid
                                break;
                            }
                        }
                        if(ContinueFlag)
                        {
                            ContinueFlag = false;
                            continue;
                        }
                        LengthInt = ConfigStr.SubString(9, ConfigStr.Length() - 8).ToInt();
                        if(LengthInt < 10)
                        {
                            Utilities->DefaultTrackLength = 10;
                        }
                        if(LengthInt > 99999)
                        {
                            Utilities->DefaultTrackLength = 100;
                        }
                        else
                        {
                            Utilities->DefaultTrackLength = LengthInt;
                        }
                    }
                    else if(ConfigStr.SubString(1, 8) == "Speed  =")
                    {
                        for(int x = 1; x <= ConfigValue.Length(); x++)
                        {
                            if((ConfigValue[x] < '0') || (ConfigValue[x] > '9'))
                            {
                                ContinueFlag = true; //ignore it if invalid
                                break;
                            }
                        }
                        if(ContinueFlag)
                        {
                            ContinueFlag = false;
                            continue;
                        }
                        SpeedInt = ConfigStr.SubString(9, ConfigStr.Length() - 8).ToInt();
                        if(SpeedInt < 10)
                        {
                            Utilities->DefaultTrackSpeedLimit = 10;
                        }
                        else if(SpeedInt > 400)
                        {
                            Utilities->DefaultTrackSpeedLimit = 400;
                        }
                        else
                        {
                            Utilities->DefaultTrackSpeedLimit = SpeedInt;
                        }
                    }
                }
                else
                {
                    break;
                }
            }
            while(!ConfigFile.eof());
            ConfigFile.close();
        }
        Utilities->CallLogPop(2402);  //moved here from inside 'else' at v2.13.1
    }
    catch(const Exception &e)
    {
        ShowMessage("Unable to load the configuration file, it appears to be corrupt.  It will be re-written correctly when the program closes.\n\n"
                    "Default values will be used for the current session.");
        Utilities->RHSignalFlag = false;
        ConvertToOtherHandSignalsMenuItem->Caption = "Convert to Right Hand Signals";
        SigImagePanel->Caption = "Signals will be on the left hand side of the track";
        SigsOnLeftImage1->Visible = true;
        SigsOnLeftImage2->Visible = true;
        SigsOnRightImage1->Visible = false;
        SigsOnRightImage2->Visible = false;
        Utilities->clTransparent = clB0G0R0; // default black background;
        SaveRailwayDialog->InitialDir = CurDir + "\\" + RAILWAY_DIR_NAME;
        LoadRailwayDialog->InitialDir = CurDir + "\\" + RAILWAY_DIR_NAME;
        TimetableDialog->InitialDir = CurDir + "\\" + TIMETABLE_DIR_NAME;
        SaveTTDialog->InitialDir = CurDir + "\\" + TIMETABLE_DIR_NAME;
        LoadSessionDialog->InitialDir = CurDir + "\\" + SESSION_DIR_NAME;
        Utilities->DefaultTrackLength = 100;
        Utilities->DefaultTrackSpeedLimit = 200;
    }
}

//---------------------------------------------------------------------------

void TInterface::SaveConfigFile(int Caller)
{
    try
    {
        TrainController->LogEvent("SaveConfigFile");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",SaveConfigFile");
        // rewrite ConfigFile with signal handedness, background colour & InitialDir values (may be same but no matter)
        AnsiString ColourStr = "", SignalStr = "", LengthStr = "", SpeedStr = "";
        remove((CurDir + "\\Config.txt").c_str());
        std::ofstream ConfigFile((CurDir + "\\Config.txt").c_str());
        ColourStr = "black";
        SignalStr = "left";
        if((Utilities->DefaultTrackLength < 10) || (Utilities->DefaultTrackLength > 99999))
        {
            Utilities->DefaultTrackLength = 100;
        }
        if((Utilities->DefaultTrackSpeedLimit < 10) || (Utilities->DefaultTrackSpeedLimit > 400))
        {
            Utilities->DefaultTrackSpeedLimit = 200;
        }
        LengthStr = AnsiString(Utilities->DefaultTrackLength);
        SpeedStr = AnsiString(Utilities->DefaultTrackSpeedLimit);
        if(Utilities->clTransparent == TColor(0xFFFFFF))
        {
            ColourStr = "white";
        }
        else if(Utilities->clTransparent == TColor(0x330000))
        {
            ColourStr = "blue";
        }
        if(Utilities->RHSignalFlag)
        {
            SignalStr = "right";
        }
        ConfigFile << AnsiString("#This file contains a list of parameters that are saved after each use of the program and reloaded for the "
                                 "next use.  Track element length and speed limit values after the = sign may be changed and the configuration file reloaded "
                                 "during play, but please do not change anything else.  Comments begin with '#' and are ignored by the program.\n\n");
        ConfigFile << AnsiString("Signals=") << SignalStr << '\n';
        ConfigFile << AnsiString("BgndCol=") << ColourStr << '\n';
        ConfigFile << AnsiString("RLYLocn=") << AnsiString(LoadRailwayDialog->InitialDir) << '\n';
        ConfigFile << AnsiString("TTBLocn=") << AnsiString(TimetableDialog->InitialDir) << '\n';
        ConfigFile << AnsiString("SSNLocn=") << AnsiString(LoadSessionDialog->InitialDir) << '\n';
        ConfigFile << AnsiString("Length =") << LengthStr << "    #default track element length in metres (not less than 10)\n";
        ConfigFile << AnsiString("Speed  =") << SpeedStr << "    #default track element speed limit in km/h (not less than 10 and not greater than 400)\n";
        ConfigFile.close();
        Utilities->CallLogPop(2439);
    }
    catch(const Exception &e)
    {
        ShowMessage("Unable to save configuration file, file won't be updated");
    }
}

// ---------------------------------------------------------------------------

void TInterface::SetTopIndex(int Caller)
{
// Set TopIndex to the proper value & also Selected so don't have a different selection to the highlighted entry
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetTopIndex");
    if((TTCurrentEntryPtr == TimetableEditVector.end()) || TimetableEditVector.empty()) //added at v2.13.0 as a fix for mathstrains19 (discord name) error reported 13/04/22
    {                                                           //without this it crashes at line before last with "List index out of bounds"
        Utilities->CallLogPop(2485);
        return;
    }
    if((TTCurrentEntryPtr - TimetableEditVector.begin()) < AllEntriesTTListBox->TopIndex)
    {
        AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin();
    }
    else if((TTCurrentEntryPtr - TimetableEditVector.begin()) > (AllEntriesTTListBox->TopIndex + 45))
    {
        AllEntriesTTListBox->TopIndex = TTCurrentEntryPtr - TimetableEditVector.begin() - 45;
    }
    else //leave AllEntriesTTListBox->TopIndex as it is
    {
//        AllEntriesTTListBox->TopIndex = AllEntriesTTListBox->TopIndex; //removed at v2.13.0 as serves no purpose
    }
    AllEntriesTTListBox->Selected[TTCurrentEntryPtr - TimetableEditVector.begin()] = true;
    Utilities->CallLogPop(2207);
}

// ---------------------------------------------------------------------------

void TInterface::ClearandRebuildRailway(int Caller) // now uses HiddenScreen to help avoid flicker
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ClearandRebuildRailway");
    bool ClockState = Utilities->Clock2Stopped;

    Utilities->Clock2Stopped = true;
    HiddenDisplay->ClearDisplay(6);
    AllRoutes->RebuildRailwayFlag = false; //moved here at v2.14.0 from ClockTimer2 so this function not called twice when called before ClockTimer2 triggered
    Track->RebuildUserGraphics(0, HiddenDisplay); // new at v2.4.0, plot first so all else overwrites, including the grid if selected
    if(ScreenGridFlag && (Level1Mode == TrackMode))
    {
        int WidthNum = int(MainScreen->Width / 160) + 1;
        int HeightNum = int(MainScreen->Height / 144) + 1;
        for(int x = 0; x < WidthNum; x++)
        {
            for(int y = 0; y < HeightNum; y++)
            {
                HiddenDisplay->PlotAbsolute(0, x * 160, y * 144, RailGraphics->GridBitmap);
            }
        }
    }
// TextHandler->RebuildFromTextVector(1, HiddenDisplay); //This now incorporated in RebuildTrackAndText so that text is plotted after inactive
// elements but before active elements.  This is so text can overwite stations and non-station named locations.

    Track->RebuildTrackAndText(4, HiddenDisplay, (Level1Mode != OperMode));

// Display->Output->Invalidate();  experiment, needs TDisplay Output to be public.  Trying to invoke the white flashes that
// used to occur frequently without Disp->Update() in PlotOriginal

    // OperMode LCs plotted below
    if(Level2TrackMode == GapSetting)
    {
        Track->ShowSelectedGap(1, HiddenDisplay);
    }
    if(Level1Mode == PrefDirMode)
    {
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            EveryPrefDir->EveryPrefDirMarker(0, HiddenDisplay);
        }
        if((Level2PrefDirMode == PrefDirContinuing) && (ConstructPrefDir->PrefDirSize() > 0))
        {
            ConstructPrefDir->PrefDirMarker(5, PrefDirCall, true, HiddenDisplay);
        }
    }
    if(Level1Mode == TrackMode)
    {
        if(Track->NonFootCrossingNamedLocationExists(0))
        {
            LocationNameButton->Enabled = true;
        }
        else
        {
            LocationNameButton->Enabled = false;
        }
    }
    if(Level2TrackMode == DistanceStart)
    {
        Track->LengthMarker(0, HiddenDisplay);
        DistanceKey->Visible = true;
        DistancesMarked = true;
        LengthConversionPanel->Visible = true;
        SpeedConversionPanel->Visible = true;
    }
    if(Level2TrackMode == DistanceContinuing) // for extended distances
    {
        if(ConstructPrefDir->PrefDirSize() > 0)
        {
            Track->LengthMarker(2, HiddenDisplay);
// this line was after the next line until v2.5.1, changed so magenta not overrridden after PrefDirMarker called
            ConstructPrefDir->PrefDirMarker(11, PrefDirCall, true, HiddenDisplay);
            DistanceKey->Visible = true;
            DistancesMarked = true;
            LengthConversionPanel->Visible = true;
            SpeedConversionPanel->Visible = true;
        }
    }
    if((Level2TrackMode == TrackSelecting) && DistancesMarked)
    // this is to keep the distance markers if they are already present when Select is chosen, in case user wishes to choose SelectLengths,
    // don't need to display ConstructPrefDir marker as that only needed in DistanceContinuing mode
    {
        Track->LengthMarker(1, HiddenDisplay);
        DistanceKey->Visible = true;
    }
    if((Level2TrackMode != TrackSelecting) && (Level2TrackMode != DistanceContinuing) && (Level2TrackMode != DistanceStart))
    // cancel DistancesMarked if exit from any of these modes
    {
        DistancesMarked = false;
        DistanceKey->Visible = false;
        LengthConversionPanel->Visible = false; // added at v1.3.1 to remove when distance/speed setting exited
        SpeedConversionPanel->Visible = false; // added at v1.3.1 to remove when distance/speed setting exited
    }
    if(mbLeftDown && SelectPickedUp && ((Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving)))
    // in process of moving so use NewSelectBitmapHLoc & VLoc
    {
        HiddenDisplay->PlotOutput(8, NewSelectBitmapHLoc * 16, NewSelectBitmapVLoc * 16, SelectBitmap);
    }

    else if((!mbLeftDown || !SelectPickedUp) && ((Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving)))
    // not in process of moving or failed to click mouse within selection so use SelectBitmapHLoc & VLoc
    {
        HiddenDisplay->PlotOutput(9, SelectBitmapHLoc * 16, SelectBitmapVLoc * 16, SelectBitmap);
    }

    if(Level1Mode == OperMode)
    {
        AllRoutes->MarkAllRoutes(0, HiddenDisplay);
        if(!AllRoutes->LockedRouteVector.empty())
        {
            for(TAllRoutes::TLockedRouteVectorIterator LRVIT = AllRoutes->LockedRouteVector.end() - 1; LRVIT >= AllRoutes->LockedRouteVector.begin(); LRVIT--)
            {
                if(!(AllRoutes->TrackIsInARoute(7, LRVIT->LastTrackVectorPosition, LRVIT->LastXLinkPos)))
                {
                    AllRoutes->LockedRouteVector.erase(LRVIT);
                    // if end element not in route then a train must have entered it from the wrong end and erased the whole route,
                    // hence no longer needed so get rid of it (end of route can't be points, crossover or bridge so danger of
                    // route being on the other track of a 2-track element doesn't arise)
                    continue;
                }
                TOneRoute Route = AllRoutes->GetFixedRouteAt(0, LRVIT->RouteNumber);
//                int x = Route.PrefDirSize() - 1;
//here need to find the PrefDirVector position for Route that corresponds to LRVIT->LastTrackVectorPosition
                int FrontPDPos = -1;  //added at v2.15.0 for front truncation
                for(int x = (Route.PrefDirSize() - 1); x >= 0; x--)
                {
                    if(Route.GetFixedPrefDirElementAt(262, x).GetTrackVectorPosition() == LRVIT->LastTrackVectorPosition)
                    {
                        FrontPDPos = x;
                    }
                }
                if(FrontPDPos == -1)
                {
                    throw Exception("Failed to find LastTrackVectorPosition in Clearand... for a locked route");
                }
                bool BreakFlag = false;
                TPrefDirElement PrefDirElement = Route.GetFixedPrefDirElementAt(1, FrontPDPos);
                while(PrefDirElement.GetTrackVectorPosition() != LRVIT->RearTrackVectorPosition)
                {
                    HiddenDisplay->PlotOutput(10, (PrefDirElement.HLoc) * 16, (PrefDirElement.VLoc) * 16,
                                              RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                    if(!(AllRoutes->TrackIsInARoute(8, PrefDirElement.Conn[PrefDirElement.GetELinkPos()],
                                                    PrefDirElement.ConnLinkPos[PrefDirElement.GetELinkPos()])))
                    {
                        BreakFlag = true;
                        break; // train removed earlier element from route so stop here
                    }
                    FrontPDPos--;
                    if(FrontPDPos < 0) // added after Albie Vowles reported error on 14/08/20 by email
                    {
                        // it means that part of the route (including that at the truncate point) has been cancelled, in this case by a train running past the signal
                        BreakFlag = true;
// at danger and cancelling the route elements in front of it.  The locked route is now too short and this 'while' loop won't find
                        break; // it, so x keeps decrementing and when it becomes -1 an error is thrown.  This addition prevents the error.
                    }
                    PrefDirElement = Route.GetFixedPrefDirElementAt(2, FrontPDPos);
                }
                if(!BreakFlag)
                {
                    if(PrefDirElement.GetTrackVectorPosition() == LRVIT->RearTrackVectorPosition)
                    {
                        HiddenDisplay->PlotOutput(11, (PrefDirElement.HLoc) * 16, (PrefDirElement.VLoc) * 16,
                                                  RailGraphics->LockedRouteCancelPtr[PrefDirElement.GetELink()]);
                    }
                }
            }
        }
        if(RouteMode == RouteContinuing)
        {
            AutoRouteStartMarker->PlotOriginal(23, HiddenDisplay);
// system thinks overlay is already plotted, so plot original to reset the OverlayPlotted flag
            SigRouteStartMarker->PlotOriginal(24, HiddenDisplay);
            NonSigRouteStartMarker->PlotOriginal(25, HiddenDisplay);
            if(AutoSigsFlag)
            {
                AutoRouteStartMarker->PlotOverlay(7, HiddenDisplay);
            }
            else if(PreferredRoute) // added at v2.7.0, was ConsecSignalsRoute
            {
                SigRouteStartMarker->PlotOverlay(8, HiddenDisplay);
            }
            else
            {
                NonSigRouteStartMarker->PlotOverlay(9, HiddenDisplay);
            }
        }
        if(Track->PointFlashFlag)
        {
            // need to reset the screen location for picking up the original graphic
            int Left, Top; // Embarcadero change - these missing in error from Borland file
            Track->GetScreenPositionsFromTruePos(1, Left, Top, PointFlash->GetHPos(), PointFlash->GetVPos());
            // note that the above Pos values are wrt layout, not the screen, but the Left & Top values are wrt screen
            PointFlash->SetSourceRect(Left, Top);
            PointFlash->LoadOriginalScreenGraphic(4); // reload from new position
            // doesn't matter whether Flash was on or off when this function called as will sort itself out later (may miss a flash but won't be noticeable)
        }
        // now plot level crossings (must be after routes). These don't need any base elements to be plotted as they are already plotted.
        // In order to avoid plotting the whole LC for every element of a LC a bool value - LCPlotted - is used to save time
        for(unsigned int x = 0; x < Track->LCVector.size(); x++)
        {
            (Track->InactiveTrackVector.begin() + (*(Track->LCVector.begin() + x)))->LCPlotted = false;
        }
        for(unsigned int x = 0; x < Track->LCVector.size(); x++)
        {
            int BaseSpeedTag;
            TTrackElement ATE;
            TTrackElement ITE = *(Track->InactiveTrackVector.begin() + (*(Track->LCVector.begin() + x)));
            {
                BaseSpeedTag = Track->GetTrackElementFromTrackMap(0, ITE.HLoc, ITE.VLoc).SpeedTag;
                if(ITE.LCPlotted == false)
                {
                    if(ITE.Attribute == 0)
                    {
                        Track->PlotPlainRaisedLinkedLevelCrossingBarriersAndSetMarkers(0, BaseSpeedTag, ITE.HLoc, ITE.VLoc, HiddenDisplay);
                    }
                    else if(ITE.Attribute == 1)
                    {
                        // need to determine if should plot green (manual) or red (auto), but all linked LCs have ConsecSignals set to 2 in BarriersDownVector if manual
                        // so just need to test this for the HLoc & VLoc position match
                        for(unsigned int x = 0; x < Track->BarriersDownVector.size(); x++)
                        {
                            if((Track->BarriersDownVector.at(x).HLoc == ITE.HLoc) && (Track->BarriersDownVector.at(x).VLoc == ITE.VLoc))
                            {
                                if(Track->BarriersDownVector.at(x).TypeOfRoute == 2)
                                {
                                    Track->PlotPlainLoweredLinkedLevelCrossingBarriersAndSetMarkers(0, BaseSpeedTag, ITE.HLoc, ITE.VLoc, HiddenDisplay,
                                                                                                    true); // true for manual = green
                                }
                                else
                                {
                                    Track->PlotPlainLoweredLinkedLevelCrossingBarriersAndSetMarkers(1, BaseSpeedTag, ITE.HLoc, ITE.VLoc, HiddenDisplay,
                                                                                                    false); // false for auto = red
                                }
                            }
                        }
                    }
                    // if ITE->Attribute == 2 then LC is changing, FlashingGraphics will take care of flashing & final plotting,
                    // it won't set LCPlotted but no real time lost in this case
                }
            }
        }
        TrainController->ReplotTrains(0, HiddenDisplay);
    }
    Display->ZoomOutFlag = false;
    ZoomButton->Glyph->LoadFromResourceName(0, "ZoomOut");
    MainScreen->Picture->Bitmap->Assign(HiddenScreen->Picture->Bitmap);
    Display->Update(); // resurrected when Update() dropped from PlotOutput etc
    Utilities->Clock2Stopped = ClockState;
    Utilities->CallLogPop(91);
}

// ---------------------------------------------------------------------------

bool TInterface::HighLightOneGap(int Caller, int &HLoc, int &VLoc)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",HighLightOneGap");
    if(Track->FindAndHighlightAnUnsetGap(1)) // true if find one
    {
        if(!PreventGapOffsetResetting) // don't reset display position if returning from zoomout mode
        {
            while((Display->DisplayOffsetH - Track->GetGapHLoc()) > 0)
            {
                Display->DisplayOffsetH -= (Utilities->ScreenElementWidth / 2); // use 30 instead of 60 so less likely to appear behind the message box
            }
            while((Track->GetGapHLoc() - Display->DisplayOffsetH) > (Utilities->ScreenElementWidth - 1))
            {
                Display->DisplayOffsetH += (Utilities->ScreenElementWidth / 2);
            }
            while((Display->DisplayOffsetV - Track->GetGapVLoc()) > 0)
            {
                Display->DisplayOffsetV -= (Utilities->ScreenElementHeight / 2); // use 18 instead of 36 so less likely to appear behind the message box
            }
            while((Track->GetGapVLoc() - Display->DisplayOffsetV) > (Utilities->ScreenElementHeight - 1))
            {
                Display->DisplayOffsetV += (Utilities->ScreenElementHeight / 2);
            }
        }
        InfoPanel->Visible = true;
        InfoPanel->Caption = "CONNECTING GAPS:  Click on connecting element";
        ClearandRebuildRailway(31); // get rid of earlier gap selection
        Utilities->CallLogPop(92);
        return(true); // return as one now identified & over to MainScreenMouseDown with Level2TrackMode = GapSetting
    }
    Utilities->CallLogPop(93);
    return(false); // no unset ones left to find
}

// ---------------------------------------------------------------------------

bool TInterface::ClearEverything(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ClearEverything");
    if(FileChangedFlag)
    {
        UnicodeString MessageStr = "The railway has changed, close it without saving?";
        int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
        if(button == IDNO)
        {
            Utilities->CallLogPop(1140);
            return(false);
        }
    }
    Display->ClearDisplay(7);
    HiddenDisplay->ClearDisplay(8);

    Display->DisplayOffsetH = 0;
    Display->DisplayOffsetV = 0;
    Display->DisplayOffsetHHome = 0;
    Display->DisplayOffsetVHome = 0;
    Display->DisplayZoomOutOffsetH = 0;
    Display->DisplayZoomOutOffsetV = 0;

// these ensure that all persistent vectors, maps & multimaps etc are cleared
    delete TrainController;
    delete EveryPrefDir;
    delete SelectPrefDir;
    delete ConstructRoute;
    delete ConstructPrefDir;
    delete AllRoutes;
    delete Track;
    delete TextHandler;
// NB can't delete & recreate Utilities or will lose the CallLog file & have errors due to log being empty when try to
// pop earlier pushed values
// OK though as no containers in Utilities that need to clear & PerformanceFile recreated when begin to operate a later
// railway
    TextHandler = new TTextHandler;
    Track = new TTrack;
    AllRoutes = new TAllRoutes;
    ConstructPrefDir = new TOnePrefDir;
    ConstructRoute = new TOneRoute;
    EveryPrefDir = new TOnePrefDir;
    SelectPrefDir = new TOnePrefDir;
    TrainController = new TTrainController;
    PerfLogForm->PerformanceLogBox->Lines->Clear();
    ResetAll(1);
    bool NoConfig; //not used
    LoadConfigFile(2, false, NoConfig); //reset default track element length &  speed limit (uninitialised when Track recreated), false as it's not the first load

    Utilities->CallLogPop(94);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::FileIntegrityCheck(int Caller, char *FileName) const // true for success
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",FileIntegrityCheck," + AnsiString(FileName));
    std::ifstream VecFile(FileName);

    if(VecFile.is_open())
    {
        if(!Utilities->CheckFileStringZeroDelimiter(VecFile)) // Program version
        {
            VecFile.close();
            Utilities->CallLogPop(1805);
            return(false);
        }
        if(!Utilities->CheckFileInt(VecFile, -1000000, 1000000)) // DisplayOffsetHHome
        {
            VecFile.close();
            Utilities->CallLogPop(1440);
            return(false);
        }
        if(!Utilities->CheckFileInt(VecFile, -1000000, 1000000)) // DisplayOffsetVHome
        {
            VecFile.close();
            Utilities->CallLogPop(1441);
            return(false);
        }
        bool GraphicsFollow = false;
        int NumberOfActiveElements;
        if(!(Track->CheckTrackElementsInFile(1, NumberOfActiveElements, GraphicsFollow, VecFile))) // for new loads
        {
            VecFile.close();
            Utilities->CallLogPop(95);
            return(false);
        }
        if(!(TextHandler->CheckTextElementsInFile(0, VecFile)))
        {
            VecFile.close();
            Utilities->CallLogPop(96);
            return(false);
        }
        if(!(EveryPrefDir->CheckOnePrefDir(0, NumberOfActiveElements, VecFile)))
        {
            VecFile.close();
            Utilities->CallLogPop(97);
            return(false);
        }
        if(GraphicsFollow)
        {
            if(!Track->CheckUserGraphics(0, VecFile, CurDir + "\\" + USERGRAPHICS_DIR_NAME)) // include path to Graphics folder
            {
                VecFile.close();
                Utilities->CallLogPop(2186);
                return(false);
            }
        }
        VecFile.close();
    }
    else
    {
        Utilities->CallLogPop(1153);
        return(false);
    }
    Utilities->CallLogPop(98);
    return(true);
}

// ---------------------------------------------------------------------------

void TInterface::Delay(int Caller, double Msec)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",Delay," + AnsiString(Msec));
    TDateTime First, Second;
    bool Finished = false;

    First = TDateTime::CurrentDateTime();
    double TimeVal1 = 86400000 * double(First); // no of msec in a day

    while(!Finished)
    {
        Second = TDateTime::CurrentDateTime();
        double TimeVal2 = 86400000 * double(Second);
        if((TimeVal2 - TimeVal1) > Msec)
        {
            Finished = true;
        }
    }
    Utilities->CallLogPop(1203);
}

// ---------------------------------------------------------------------------

void TInterface::ResetCurrentSpeedButton(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ResetCurrentSpeedButton");
    if(CurrentSpeedButton)
    {
        CurrentSpeedButton->Down = false;
    }
    CurrentSpeedButton = 0;
    Utilities->CallLogPop(1204);
}

// ---------------------------------------------------------------------------

bool TInterface::MovingTrainPresentOnFlashingRoute(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",MovingTrainPresentOnFlashingRoute");
    int TrainID;

    if(ConstructRoute->SearchVectorSize() == 0)
    {
        Utilities->CallLogPop(99);
        return(false);
    }
    for(unsigned int x = 0; x < ConstructRoute->SearchVectorSize(); x++)
    {
        TPrefDirElement PrefDirElement = ConstructRoute->GetFixedSearchElementAt(14, x);
        if(PrefDirElement.TrackType == Bridge)
        {
            if(PrefDirElement.GetXLinkPos() < 2)
            {
                TrainID = Track->TrackElementAt(486, PrefDirElement.GetTrackVectorPosition()).TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
            }
            else
            {
                TrainID = Track->TrackElementAt(487, PrefDirElement.GetTrackVectorPosition()).TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
            }
        }
        else
        {
            TrainID = Track->TrackElementAt(488, PrefDirElement.GetTrackVectorPosition()).TrainIDOnElement;
        }
        if((TrainID > -1) && !(TrainController->TrainVectorAtIdent(4, TrainID).Stopped()))
        {
            Utilities->CallLogPop(100);
            return(true);
        }
        // check for crossed diagonal fouling by train added at v1.2.0
        int TrainID; // not used
        int LinkNumber1 = PrefDirElement.Link[PrefDirElement.GetELinkPos()];
        int LinkNumber2 = PrefDirElement.Link[PrefDirElement.GetXLinkPos()];
        if((LinkNumber1 == 1) || (LinkNumber1 == 3) || (LinkNumber1 == 7) || (LinkNumber1 == 9))
        {
            if(Track->DiagonalFouledByTrain(1, PrefDirElement.HLoc, PrefDirElement.VLoc, LinkNumber1, TrainID))
            {
                Utilities->CallLogPop(2037);
                return(true);
            }
        }
        if((LinkNumber2 == 1) || (LinkNumber2 == 3) || (LinkNumber2 == 7) || (LinkNumber2 == 9))
        {
            if(Track->DiagonalFouledByTrain(2, PrefDirElement.HLoc, PrefDirElement.VLoc, LinkNumber2, TrainID))
            {
                Utilities->CallLogPop(2038);
                return(true);
            }
        }
    }
    Utilities->CallLogPop(101);
    return(false);
}

// ---------------------------------------------------------------------------

void TInterface::RevertToOriginalRouteSelector(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RevertToOriginalRouteSelector");
    AutoRouteStartMarker->PlotOriginal(26, Display); // if overlay not plotted will ignore
    SigRouteStartMarker->PlotOriginal(27, Display); // if overlay not plotted will ignore
    NonSigRouteStartMarker->PlotOriginal(28, Display); // if overlay not plotted will ignore
    RouteCancelFlag = false;
    if(AllRoutes->AllRoutesVector.size() > AllRoutes->LockedRouteVector.size())
    {
        RouteCancelButton->Enabled = true;
    }
    else
    {
        RouteCancelButton->Enabled = false;
    }
    RouteMode = RouteNotStarted;
    ConstructRoute->StartSelectionRouteID = IDInt(-1);
// reset here so that a n element that has been selected and then not doesn't remain set as a single element
    InfoPanel->Visible = true;
    if(Level2OperMode != Paused)
    {
        InfoPanel->Caption = InfoCaptionStore;
    }
    Utilities->CallLogPop(102);
}

// ---------------------------------------------------------------------------

// usermode functions below
void TInterface::SetLevel1Mode(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetLevel1Mode");
    if(!Display->ZoomOutFlag)
    {
        Track->GapFlashGreen->PlotOriginal(39, Display);
        Track->GapFlashRed->PlotOriginal(40, Display);
        Track->GapFlashFlag = false;
    }
// GapFlash resets when any mode selected unless zoomed out
// note that if selecting zoom back in then this will be called before ZoomOutFlag is reset so won't
// reset GapFlashFlag
    switch(Level1Mode) // use the data member
    {
    case BaseMode:
        CopyMenuItem->ShortCut = TextToShortCut(""); // added these for v2.1.0 to set default values after use of the 'Edit' menu during track building
        CutMenuItem->ShortCut = TextToShortCut(""); // to allow normal cutting/copying/pasting, especially in timetable construction or editing
        PasteMenuItem->ShortCut = TextToShortCut("");
        Track->ActiveTrackElementNameMapCompiledFlag = false;
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Level2OperMode = NoOperMode;
        LengthConversionPanel->Visible = false;
        SpeedConversionPanel->Visible = false;
        TimetableEditPanel->Visible = false;
        TrainController->TTEditPanelVisible = false; // added at v2.6.0 for two location message
        TrackBuildPanel->Visible = false;
        TrackElementPanel->Visible = false;
        LocationNameTextBox->Visible = false;
        TextBox->Visible = false;
        TrackLengthPanel->Visible = false;
        InfoPanel->Visible = false;
        PrefDirPanel->Visible = false;
        TimetablePanel->Visible = false;
        OperatingPanel->Visible = false;
        PrefDirKey->Visible = false;
        TrackLinkedImage->Visible = false;
        TrackNotLinkedImage->Visible = false;
        GapsSetImage->Visible = false;
        GapsNotSetImage->Visible = false;
        LocationNamesSetImage->Visible = false;
        LocationNamesNotSetImage->Visible = false;
        ModeMenu->Enabled = true;
        FileMenu->Enabled = true;
        EditMenu->Enabled = false;
        BuildTrackMenuItem->Enabled = true;
        MultiplayerMenu->Enabled = false;
        CouplingFileLoadedFlag = false;
        PlayerMakingInitialContactFlag = false;
        PlayerReadyToBeginFlag = false;
        PlayerCancelJoinFlag = false;
        PlayerAwaitingHostStartFlag = false;
        HostInSessionFlag = false;
        PlayerInSessionFlag = false;
        SigAspectButton->Enabled = false;
        Track->ChangingLCVector.clear();
        Track->BarriersDownVector.clear();
        Track->ResetLevelCrossings(0);
        ConvertToOtherHandSignalsMenuItem->Enabled = false; // new at v2.3.0
        SigImagePanel->Visible = false; // new at v2.3.0
        MTBFEditBox->Visible = false; // new at v2.4.0
        MTBFLabel->Visible = false;
        TTClockAdjustWarningPanel->Visible = false;
        HideTTActionsListBox(1);
        DelayMenu->Visible = false;  //added at v2.13.0
        DelayMenu->Enabled = false;
        FailureMenu->Visible = false;  //added at v2.14.0
        FailureMenu->Enabled = false;
        if(Track->IsTrackFinished())
        {
            PlanPrefDirsMenuItem->Enabled = true;
            if(TimetableTitle != "")
            {
                OperateRailwayMenuItem->Enabled = true;
            }
            else
            {
                OperateRailwayMenuItem->Enabled = false;
            }
        }
        else
        {
            PlanPrefDirsMenuItem->Enabled = false;
            OperateRailwayMenuItem->Enabled = false;
        }
        if(RlyFile)
        {
            LoadTimetableMenuItem->Enabled = true;
        }
        else
        {
            LoadTimetableMenuItem->Enabled = false;
        }
        LoadRailwayMenuItem->Enabled = true;
        if(NoRailway())
        {
            SaveAsMenuItem->Enabled = false;
            ImageMenu->Enabled = false;
            SaveImageAndGridMenuItem->Enabled = false;
            SaveImageNoGridMenuItem->Enabled = false;
            SaveImageAndPrefDirsMenuItem->Enabled = false;
            SaveOperatingImageMenuItem->Enabled = false;
            BlackBgndMenuItem->Enabled = false;
            WhiteBgndMenuItem->Enabled = false;
            BlueBgndMenuItem->Enabled = false;
            ConvertToOtherHandSignalsMenuItem->Enabled = true; // new at v2.3.0
            SigImagePanel->Visible = true; // new at v2.3.0
            if(Utilities->clTransparent != TColor(0))
            {
                BlackBgndMenuItem->Enabled = true;
            }
            if(Utilities->clTransparent != TColor(0xFFFFFF))
            {
                WhiteBgndMenuItem->Enabled = true;
            }
            if(Utilities->clTransparent != TColor(0x330000))
            {
                BlueBgndMenuItem->Enabled = true;
            }
            ClearAllMenuItem->Enabled = false;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "Select an option from the File, Mode or Help menus";
        }
        else
        {
            InfoPanel->Visible = false;
            SaveAsMenuItem->Enabled = true;
            ImageMenu->Enabled = true;
            SaveImageAndGridMenuItem->Enabled = true;
            SaveImageNoGridMenuItem->Enabled = true;
            if(EveryPrefDir->PrefDirSize() > 0)
            {
                SaveImageAndPrefDirsMenuItem->Enabled = true;
            }
            else
            {
                SaveImageAndPrefDirsMenuItem->Enabled = false;
            }
            BlackBgndMenuItem->Enabled = false;
            WhiteBgndMenuItem->Enabled = false;
            BlueBgndMenuItem->Enabled = false;
            SaveOperatingImageMenuItem->Enabled = false;
            ClearAllMenuItem->Enabled = true;
        }
        if(SavedFileName == "")
        {
            SaveMenuItem->Enabled = false;
        }
        else if(!FileChangedFlag)
        {
            SaveMenuItem->Enabled = false;
        }
        else if((SavedFileName[SavedFileName.Length()] == 'y') || (SavedFileName[SavedFileName.Length()] == 'Y')) // 'rly' file
        {
            if(!(Track->IsReadyForOperation(false)))
            {
                SaveMenuItem->Enabled = false; // can't save under its old name as not now a .rly file
            }
            else
            {
                SaveMenuItem->Enabled = true; // must have changed some of the PrefDirs (because FileChangedFlag is true)
            }
        }
        else
        {
            SaveMenuItem->Enabled = true;
        }
        LoadSessionMenuItem->Enabled = true;
        ExitMenuItem->Enabled = true;
        ScreenGridFlag = false;
        TrainController->CrashWarning = false;
        TrainController->DerailWarning = false;
        TrainController->SPADWarning = false;
        TrainController->TrainFailedWarning = false;
        TrainController->CallOnWarning = false;
        TrainController->SignalStopWarning = false;
        TrainController->BufferAttentionWarning = false;
        UserGraphicReselectPanel->Visible = false;
        ClearandRebuildRailway(32); // to get rid of unwanted displays (eg distance markers)
        SetTrackBuildImages(13);
        ClipboardChecked = false;
        Utilities->CumulativeDelayedRandMinsAllTrains = 0; //added at v2.13.0
//        Utilities->LastTSRCheckTime = TDateTime(0); //added at v2.13.0 //removed at v2.14.0, now value set to TTClockTime when start operation or load session
        Utilities->LastDelayTTClockTime = 0;
//        Utilities->LastTSRCheckTime = TDateTime(0); removed at v2.13.2 as redundant (covered above)
        Track->FailedPointsVector.clear();
        Track->FailedSignalsVector.clear();
        Track->TSRVector.clear();
        Track->SimpleVector.clear();
        break;

    case TimetableMode:
        if(TwoLocationNamePanel->Visible) //added at v2.9.1 so panel persists until button clicked
        {
            break;
        }
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Level2OperMode = NoOperMode;
        ModeMenu->Enabled = false;
        SigImagePanel->Visible = false; // new at v2.3.0
        FileMenu->Enabled = false;
        EditMenu->Enabled = false;
        FloatingInfoMenu->Enabled = false;
        ImageMenu->Enabled = false;
        TimetableEditPanel->BringToFront();
        TimetableHandler();
        break;

    case TrackMode:
    {
        if(Level2TrackMode == CutMoving)
        {
            Level2TrackMode = Pasting;     // paste the selection
            SetLevel2TrackMode(52);     // CancelSelectionFlag used in Case Pasting
        }
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Level2OperMode = NoOperMode;
        ResetCurrentSpeedButton(0);
        TrackBuildPanel->Visible = true;
        TrackBuildPanelLabel->Caption = "Build/modify";
        TrackElementPanel->Visible = false;
        TrackLengthPanel->Visible = false;
        PrefDirPanel->Visible = false;
        TimetablePanel->Visible = false;
        OperatingPanel->Visible = false;
        InfoPanel->Visible = false;
        InfoPanel->Caption = "";
        LocationNameTextBox->Visible = false;
        TextBox->Visible = false;
        ModeMenu->Enabled = false;
        SigImagePanel->Visible = false;     // new at v2.3.0
        FileMenu->Enabled = false;
        // set edit menu items
        SetTrackModeEditMenu(4);
        // display track buttons
        AddTrackButton->Enabled = true;
        if(Track->NonFootCrossingNamedLocationExists(1))
        {
            LocationNameButton->Enabled = true;
        }
        else
        {
            LocationNameButton->Enabled = false;
        }
        ScreenGridButton->Enabled = true;
        ExitTrackButton->Enabled = true;
        SetGapsButton->Enabled = false;
        TrackOKButton->Enabled = false;
        if(Track->GapsUnset(5))
        {
            SetGapsButton->Enabled = true;
        }
        // only enable if there are gaps still to be set (returns false for no track)
        else
        {
            if(!(Track->NoActiveTrack(2)) && !(Track->IsTrackFinished()))
            {
                TrackOKButton->Enabled = true;
            }
            // TrackOK only enabled if track exists, there are no unset gaps, and track not finished
        }
        SetLengthsButton->Enabled = false;
        if(Track->IsTrackFinished())     // can only set lengths for several elements together if TrackFinished
        {
            SetLengthsButton->Enabled = true;
        }
        // text buttons
        AddTextButton->Enabled = true;
        TextOrUserGraphicGridButton->Enabled = true;
        FontButton->Enabled = true;
        MoveTextOrGraphicButton->Enabled = false;
        if(TextHandler->TextVectorSize(9) > 0)
        {
            MoveTextOrGraphicButton->Enabled = true;
        }
        if(!Track->UserGraphicVector.empty())
        {
            MoveTextOrGraphicButton->Enabled = true;
        }
        SelectionValid = false;
        SetTrackBuildImages(1);
        TimetableTitle = "";
        SetCaption(0);
    } break;

    case PrefDirMode:
        Screen->Cursor = TCursor(-11); //Hourglass in case many pref dirs
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Level2OperMode = NoOperMode;
        PrefDirPanel->Visible = true;
        PrefDirPanelLabel->Caption = "Preferred direction selection";

        InfoPanel->Visible = true;
        InfoPanel->Caption = "PREFERRED DIRECTION SETTING:  Select preferred direction start location (right click to erase)";
        PrefDirKey->Visible = true;
        ModeMenu->Enabled = false;
        SigImagePanel->Visible = false; // new at v2.3.0
        FileMenu->Enabled = false;
        if(!PrefDirConflictAdviceMessageSent)
        {
            ShowMessage("Preferred direction correctness can be difficult to check by eye\n"
                        "alone, especially for large railways, so an automated conflict\n"
                        "check is available in the 'Edit' menu when in preferred\n"
                        "direction mode.\n\n"
                        "This message will not be shown again.");
            PrefDirConflictAdviceMessageSent = true;
        }
// set edit menu items
        SetInitialPrefDirModeEditMenu();
        AddPrefDirButton->Enabled = false;
        DeleteOnePrefDirButton->Enabled = false;
        ConstructPrefDir->ExternalClearPrefDirAnd4MultiMap();
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            DeleteAllPrefDirButton->Visible = true;
            DeleteAllPrefDirButton->Enabled = true;
            SaveImageAndPrefDirsMenuItem->Enabled = true;
        }
        else
        {
            DeleteAllPrefDirButton->Enabled = false;
            SaveImageAndPrefDirsMenuItem->Enabled = false;
        }
        ExitPrefDirButton->Enabled = true;
        ClearandRebuildRailway(33); // to mark PrefDirs & clear earlier PrefDir markers
// TimetableTitle = ""; no need to unload timetable if only PrefDirs being changed
// SetCaption();
        Screen->Cursor = TCursor(-2); //Arrow
        break;

    case OperMode: // if there are any PrefDirs, set to SigPref, else to NoSigNonPref; start in Paused mode
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Level2OperMode = PreStart;
        Track->PopulateSimpleVector(0);
        OperatingPanel->Visible = true;
        OperatingPanelLabel->Caption = "Operation";

        CallingOnButton->Visible = false;
        PresetAutoSigRoutesButton->Visible = true;
        if(!EveryPrefDir->PrefDirVector.empty())//condition added at v2.10.0
        {
            PresetAutoSigRoutesButton->Enabled = true;
        }
        else
        {
            PresetAutoSigRoutesButton->Enabled = false;
        }
        InfoPanel->Visible = true;
        SigImagePanel->Visible = false; // new at v2.3.0
        ModeMenu->Enabled = false;
        FileMenu->Enabled = false;
        EditMenu->Enabled = false;
        ImageMenu->Enabled = true;
        SaveImageAndGridMenuItem->Enabled = true;
        SaveImageNoGridMenuItem->Enabled = true;
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            SaveImageAndPrefDirsMenuItem->Enabled = true;
        }
        else
        {
            SaveImageAndPrefDirsMenuItem->Enabled = false;
        }
        SaveOperatingImageMenuItem->Enabled = true;
        AutoSigsFlag = false;
        MTBFEditBox->Visible = true; // visible at pre-start whether any value set or not, so can set a value if required
        if(TrainController->AvHoursIntValue > 0)
        {
            MTBFEditBox->Text = AnsiString(TrainController->AvHoursIntValue);
        }
        else
        {
            MTBFEditBox->Text = "";
        }
        MTBFEditBox->ReadOnly = false; // because this is prestart mode
        MTBFLabel->Visible = true;
        MTBFLabel->Caption = "Mean time between\ntrain failures in\ntimetable hours";
        TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            ConsecSignalsRoute = true; // default starting conditions
            PreferredRoute = true; // default starting conditions
        }
        else // no PrefDirs
        {
            ConsecSignalsRoute = false;
            PreferredRoute = false;
        }
        OperateButton->Enabled = true;
        OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
        ExitOperationButton->Enabled = true;
        TTClockAdjButton->Enabled = true;
        ShowPerfLogForm = false;
        PerformanceLogButton->Glyph->LoadFromResourceName(0, "ShowLog");
        ShowActionsDueForm = false; // new at v2.2.0
        OperatorActionButton->Glyph->LoadFromResourceName(0, "ShowOpActionPanel"); // new v2.2.0

        SetRouteButtonsInfoCaptionAndRouteNotStarted(2);

        Utilities->Clock2Stopped = false;
        TrainController->RestartTime = TrainController->TimetableStartTime;
        PauseEntryRestartTime = double(TrainController->RestartTime);
        PauseEntryTTClockSpeed = 1;
        TTClockSpeed = 1;
        TTClockSpeedLabel->Caption = "x1";
        TrainController->TTClockTime = TrainController->TimetableStartTime;
        TrainController->LastSessionSaveTTClockTime = TrainController->TimetableStartTime; // added at v2.5.0
        Utilities->LastTSRCheckTime = TrainController->TTClockTime; //added at v2.14.0 so don't have any TSRs until 1 min after start

        PerformanceFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // format "16/06/2009 20:55:17"
        // avoid characters in filename:=   / \ : * ? " < > |
        PerformanceFileName = CurDir + "\\" + PERFLOG_DIR_NAME + "\\Log " + PerformanceFileName + "; " + RailwayTitle + "; " + TimetableTitle + ".txt";

        Utilities->PerformanceFile.open(PerformanceFileName.c_str(), std::ios_base::out);
        if(Utilities->PerformanceFile.fail())
        {
            ShowMessage("Performance logfile failed to open, logs won't be saved. Ensure that there is a folder named " + PERFLOG_DIR_NAME +
                        " in the folder where the 'Railway.exe' program file resides");
        }
        PerfLogForm->PerformanceLog(16, "Performance Log:");  //these statements separated at v2.13.0 as didn't separate in on-screen log
        PerfLogForm->PerformanceLog(21, "Railway: " + RailwayTitle);
        PerfLogForm->PerformanceLog(22, "Timetable: " + TimetableTitle);
        PerfLogForm->PerformanceLog(23, "Start Time: " + TrainController->TimetableStartTime.FormatString("hh:nn"));
        if(Utilities->DelayMode == Nil) //this section added at v2.13.0 for random delays
        {
            PerfLogForm->PerformanceLog(24, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": No random delays selected");
        }
        else if(Utilities->DelayMode == Minor)
        {
            PerfLogForm->PerformanceLog(25, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Minor random delays selected");
        }
        else if(Utilities->DelayMode == Moderate)
        {
            PerfLogForm->PerformanceLog(26, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Moderate random delays selected");
        }
        else if(Utilities->DelayMode == Major)
        {
            PerfLogForm->PerformanceLog(27, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Major random delays selected");
        }
        if(Utilities->FailureMode == FNil) //this section added at v2.14.0 for random failure
        {
            PerfLogForm->PerformanceLog(47, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": No random failures selected");
        }
        else if(Utilities->FailureMode == FMinor)
        {
            PerfLogForm->PerformanceLog(48, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Minor random failures selected");
        }
        else if(Utilities->FailureMode == FModerate)
        {
            PerfLogForm->PerformanceLog(49, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Moderate random failures selected");
        }
        else if(Utilities->FailureMode == FMajor)
        {
            PerfLogForm->PerformanceLog(50, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Major random failures selected");
        }
        SetPausedOrZoomedInfoCaption(3);
// DisableRouteButtons(2); enable route setting or pre-start
// DisablePanelsStoreMainMenuStates();
        TrainController->ContinuationAutoSigVector.clear(); // for restarting after earlier run
        AllRoutes->LockedRouteVector.clear(); // for restarting after earlier run
// TrainController->Operate(1);//plot trains that are present at TT start time, ready for running - no, allow route plotting prior to train entries

// reset all performance indicators
        TrainController->OnTimeArrivals = 0;
        TrainController->LateArrivals = 0;
        TrainController->EarlyArrivals = 0;
        TrainController->OnTimePasses = 0;
        TrainController->LatePasses = 0;
        TrainController->EarlyPasses = 0;
        TrainController->OnTimeDeps = 0;
        TrainController->LateDeps = 0;
        TrainController->OnTimeExits = 0; //these 3 exits added at v2.9.2 - missed in error earlier
        TrainController->LateExits = 0;
        TrainController->EarlyExits = 0;
        TrainController->MissedStops = 0;
        TrainController->OtherMissedEvents = 0;
        TrainController->UnexpectedExits = 0;
        TrainController->IncorrectExits = 0;
        TrainController->SPADEvents = 0;
        TrainController->SPADRisks = 0;
        TrainController->CrashedTrains = 0;
        TrainController->Derailments = 0;
        TrainController->TotArrDepPass = 0;
        TrainController->TotLateArrMins = 0;
        TrainController->TotEarlyArrMins = 0;
        TrainController->TotLatePassMins = 0;
        TrainController->TotEarlyPassMins = 0;
        TrainController->TotLateDepMins = 0;
        TrainController->TotEarlyExitMins = 0;
        TrainController->TotLateExitMins = 0;
        TrainController->ExcessLCDownMins = 0;
        TrainController->SkippedTTEvents = 0;

        TrainController->OpActionPanelHintDelayCounter = 0; // new at v2.2.0 to reset hint delay
        ActionsDueForm->ActionsDueListBox->Clear();
        ActionsDueForm->ActionsDueListBox->Items->Add(L""); // hints for OpActionPanel
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Left click");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"headcode to");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"locate train");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Right click");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"headcode for");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"information");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Left click and");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"hold \"Actions");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Due\" label");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"to move panel");
        DelayMenu->Visible = true; //the following added at v2.13.0
        DelayMenu->Enabled = true;
        FailureMenu->Visible = true; //the following added at v2.14.0
        FailureMenu->Enabled = true;
        ClearandRebuildRailway(55); // so points display with one fillet
        break;

    case RestartSessionOperMode: // restart in Paused mode after a session load, sets both Level1Mode & Level2OperMode
        Level1Mode = OperMode;
// Level2OperMode = Paused; this is now loaded during LoadInterface & could be PreStart of Paused
        Level2TrackMode = NoTrackMode;
        Level2PrefDirMode = NoPrefDirMode;
        Track->PopulateSimpleVector(1);
        OperatingPanel->Visible = true;
        OperatingPanelLabel->Caption = "Operation";
        DelayMenu->Visible = true;  //added at v2.13.0
        DelayMenu->Enabled = true;
        FailureMenu->Visible = true;  //added at v2.14.0
        FailureMenu->Enabled = true;

        CallingOnButton->Visible = true;
        PresetAutoSigRoutesButton->Visible = false;
        InfoPanel->Visible = true;
        ModeMenu->Enabled = false;
        SigImagePanel->Visible = false; // new at v2.3.0
        FileMenu->Enabled = false;
        EditMenu->Enabled = false;
        ImageMenu->Enabled = true;
        SaveImageAndGridMenuItem->Enabled = true;
        SaveImageNoGridMenuItem->Enabled = true;
        if(EveryPrefDir->PrefDirSize() > 0)
        {
            SaveImageAndPrefDirsMenuItem->Enabled = true;
        }
        else
        {
            SaveImageAndPrefDirsMenuItem->Enabled = false;
        }
        SaveOperatingImageMenuItem->Enabled = true;

        OperateButton->Enabled = true;
        OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
        ExitOperationButton->Enabled = true;
        TTClockAdjButton->Enabled = true;
        SetRouteButtonsInfoCaptionAndRouteNotStarted(3);
        SetPausedOrZoomedInfoCaption(4);
        if(Level2OperMode == Paused)
        {
            DisableRouteButtons(3); // could be PreStart or Paused
        }
        TrainController->TTClockTime = TrainController->RestartTime;
        PauseEntryRestartTime = double(TrainController->RestartTime);
        TrainController->LastSessionSaveTTClockTime = TrainController->TTClockTime; // added at v2.5.0
        Utilities->LastTSRCheckTime = TrainController->TTClockTime; //added at v2.14.0 so don't have any TSRs until 1 min after start
        PauseEntryTTClockSpeed = 1;
        TTClockSpeed = 1;
        TTClockSpeedLabel->Caption = "x1";
        TrainController->SetWarningFlags(0);
        ShowPerfLogForm = false; // original (ShowPerformancePanel) added at v2.2.0, changed at v2.13.0
        ShowActionsDueForm = false; // new at v2.2.0
        TrainController->OpActionPanelHintDelayCounter = 0; // new at v2.2.0 to reset hint delay
        ActionsDueForm->ActionsDueListBox->Clear();
        ActionsDueForm->ActionsDueListBox->Items->Add(L""); // hints for OpActionPanel
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Left click");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"headcode to");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"locate train");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Right click");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"headcode for");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"information");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Left click and");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"hold \"Actions");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"Due\" label");
        ActionsDueForm->ActionsDueListBox->Items->Add(L"to move panel");
        if((TrainController->AvHoursIntValue > 0) || (Level2OperMode == PreStart)) // only visible if already set or if still in prestart mode
        {
            MTBFEditBox->Visible = true;
            if(TrainController->AvHoursIntValue > 0)
            {
                MTBFEditBox->Text = AnsiString(TrainController->AvHoursIntValue);
            }
            else
            {
                MTBFEditBox->Text = "";
            }
            MTBFEditBox->ReadOnly = false; // because this is still prestart mode
            MTBFLabel->Visible = true;
            MTBFLabel->Caption = "Mean time between\ntrain failures in\ntimetable hours";
            TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        }
        else
        {
            MTBFEditBox->Visible = false;
            MTBFEditBox->Text = "";
            MTBFEditBox->ReadOnly = true; // because this is not prestart mode
            MTBFLabel->Visible = false;
            MTBFLabel->Caption = "Mean time between\ntrain failures in\ntimetable hours";
            TrainController->MTBFHours = 0;
        }
        break;

    default:
        // No further recursion in BaseMode so OK
        Level1Mode = BaseMode;
        SetLevel1Mode(29);
        break;
    }
    api_main_mode_ = int(Level1Mode);   //added at v2.10.0
    session_api_->dump();   // update session INI file
    Utilities->CallLogPop(103);
}

// ---------------------------------------------------------------------------

void TInterface::SetLevel2TrackMode(int Caller)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetLevel2TrackMode");
        if(Level1Mode != TrackMode)
        {
            // No further recursion in BaseMode so OK
            Level1Mode = BaseMode;
            SetLevel1Mode(20);
            Utilities->CallLogPop(1115);
            return;
        }
        if(Level2TrackMode == NoTrackMode)
        {
            Utilities->CallLogPop(104);
            return;
        }
        switch(Level2TrackMode) // use the data member
        {
        case AddTrack:
            ResetCurrentSpeedButton(1);
            InfoPanel->Visible = true;
            InfoPanel->Caption = "ADDING TRACK:  Select element then left click to add it.  Right click an element to remove it.";
            LengthConversionPanel->Visible = false; // in case had been in distance setting mode
            SpeedConversionPanel->Visible = false; // in case had been in distance setting mode
            TrackElementPanel->Visible = true;
            TrackElementPanel->Enabled = true;
            SigAspectButton->Visible = true;
            SigAspectButton->Enabled = true;
            ClearandRebuildRailway(34); // to replot grid if required & clear any other unwanted items
            SetTrackBuildImages(4);
            SetLengthsButton->Enabled = false;
    // section added at v2.8.0 so buttons show correctly after a paste
            SetGapsButton->Enabled = false;
            TrackOKButton->Enabled = false;
            if(Track->GapsUnset(9))
            {
                SetGapsButton->Enabled = true;
            }
            // only enable if there are gaps still to be set (returns false for no track)
            else
            {
                if(!(Track->NoActiveTrack(3)) && !(Track->IsTrackFinished()))
                {
                    TrackOKButton->Enabled = true;
                }
                // TrackOK only enabled if track exists, there are no unset gaps, and track not finished
            }
    // end of 2.8.0 addition
            if(Track->IsTrackFinished()) // can only set lengths for several elements together if TrackFinished
            {
                SetLengthsButton->Enabled = true;
            }
            UserGraphicReselectPanel->Visible = false;
            SelectLengthsFlag = false; // in case still set though probably won't be
            EditMenu->Enabled = true; // added at v2.6.0 to allow edits for an empty screen so track elements can fill a selected area
            SetTrackModeEditMenu(6); //added at v2.10.0 to set menu items
            break;

        case AddGraphic:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "ADDING GRAPHIC:  Left click layout to add SELECTED graphic, right click to remove ANY graphic.";
            break;

        case SelectGraphic:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "SELECTING USER GRAPHIC:  Select the graphic file then add as many as necessary to the layout.";
            break;

        case GapSetting:
            int HLoc, VLoc, Count;
            Count = Track->NumberOfGaps(0);
            if(div(Count, 2).rem == 1) // condition OK
            {
                ShowMessage("Can't connect, there are an odd number of gaps");
                Level1Mode = TrackMode;
                SetLevel1Mode(77);
                Level2TrackMode = AddTrack;
                // No further recursion in AddTrack so OK
                SetLevel2TrackMode(40);
                Utilities->CallLogPop(105);
                return;
            }
            if(!HighLightOneGap(2, HLoc, VLoc)) // condition OK
            // need to call this here to start gap setting process off,
            // called in MainScreenMouseDown hereafter.  Function returns false for either a LocError (links not yet
            // complete) or no more gaps to be highlighted
            {
                // shouldn't reach here as later gaps covered in MainScreenMouseDown but leave & give error message
                ShowMessage("Error - Even number of gaps but all set after first call to HighLightOneGap");
                Level1Mode = TrackMode;
                SetLevel1Mode(78);
                Level2TrackMode = AddTrack;
                // No further recursion in AddTrack so OK
                SetLevel2TrackMode(41);
                Utilities->CallLogPop(106);
                return; // all gaps set
            }
            InfoPanel->Visible = true;
            InfoPanel->Caption = "CONNECTING GAPS:  Click on connecting gap";
            UserGraphicReselectPanel->Visible = false;
            SetTrackBuildImages(5);
            break;

        case AddText:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "ADDING/EDITING TEXT: Left click to add, right click first letter to erase, or left click first letter to edit";
            if(TextHandler->TextVectorSize(13) > 0)
            {
                MoveTextOrGraphicButton->Enabled = true;
            }
            else
            {
                MoveTextOrGraphicButton->Enabled = false;
            }
            UserGraphicReselectPanel->Visible = false;
            ClearandRebuildRailway(58); // to drop DistanceKey if was displayed
            break;

        case MoveTextOrGraphic:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "MOVING TEXT OR GRAPHIC: If text left click first letter, if graphic left click anywhere, then drag";
            UserGraphicReselectPanel->Visible = false;
            ClearandRebuildRailway(59); // to drop DistanceKey if was displayed
            break;

        case AddLocationName:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "NAMING LOCATIONS:  Click on location element to add or change name";
            ClearandRebuildRailway(35); // to get rid of earlier red rectangle
            UserGraphicReselectPanel->Visible = false;
            SetTrackBuildImages(12);
            break;

        case DistanceStart:
            InfoPanel->Visible = true;
            InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Select first location (only non-default elements marked)";
            DistanceKey->Visible = true;
            LengthConversionPanel->Visible = true;
            SpeedConversionPanel->Visible = true;
            UserGraphicReselectPanel->Visible = false;
            ClearandRebuildRailway(36); // to get rid of earlier unwanted markings
            break;

        case DistanceContinuing:
            InfoPanel->Visible = true;
            if(ConstructPrefDir->PrefDirSize() == 1)
            {
                InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Select next location";
            }
            else
            {
                InfoPanel->Caption = "DISTANCE/SPEED SETTING:  Continue or set values (overall length), or right click to cancel/truncate";
            }
            UserGraphicReselectPanel->Visible = false;
            ClearandRebuildRailway(54); // to remove earlier end marker if present
            break;

        case TrackSelecting:
            Track->CopyFlag = false;
            if(!SelectionValid)
            {
                ResetSelectRect(); // so a viewpoint change before a new SelectRect chosen doesn't redisplay
            }
            // the old SelectRect (only called when entered from SelectMenuItemClick, & not from
            // ReselectMenuItemClick)
            InfoPanel->Visible = true;
            InfoPanel->Caption = "SELECTING:  Select area - click left mouse && drag";
            SelectMenuItem->Enabled = false;
            ReselectMenuItem->Enabled = false;
            CancelSelectionMenuItem->Enabled = true;
            UserGraphicReselectPanel->Visible = false;
            break;

        case CopyMoving:
            Track->CopyFlag = true;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "COPYING:  Left click in selection && drag";
            CutMenuItem->Enabled = false;
            CopyMenuItem->Enabled = false;
            FlipMenuItem->Enabled = false;
            MirrorMenuItem->Enabled = false;
            RotRightMenuItem->Enabled = false;
            RotLeftMenuItem->Enabled = false;
            RotateMenuItem->Enabled = false;
            PasteMenuItem->Enabled = true;
    // PasteWithAttributesMenuItem->Enabled = false;  //new at v2.2.0 - don't allow the option if copying (dropped at 2.4.0 as all pastes are with attributes)
            DeleteMenuItem->Enabled = false;
            SelectLengthsMenuItem->Enabled = false;
            SelectBiDirPrefDirsMenuItem->Visible = false;
            CheckPrefDirConflictsMenuItem->Visible = false;
            CancelSelectionMenuItem->Enabled = true;
            SelectBitmapHLoc = SelectRect.left;
            SelectBitmapVLoc = SelectRect.top;
            SetTrackBuildImages(6);
            UserGraphicReselectPanel->Visible = false;
            break;

        case CutMoving:
        {
            // have to use braces as otherwise the default case bypasses the initialisation of these local variables
            // erase track elements within selected region
            Track->CopyFlag = false;
            bool EraseSuccessfulFlag, NeedToLink = false, TextChangesMade = false, GraphicChangesMade = false;
            int ErasedTrackVectorPosition;
            Screen->Cursor = TCursor(-11);     // Hourglass;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "CUT PROCESSING: Please do not click the mouse";
            InfoPanel->Update();
            for(int H = SelectRect.left; H < SelectRect.right; H++)
            {
                for(int V = SelectRect.top; V < SelectRect.bottom; V++)
                {
                    Track->EraseTrackElement(2, H, V, ErasedTrackVectorPosition, EraseSuccessfulFlag, false);
                    if(EraseSuccessfulFlag)
                    {
                        if(ErasedTrackVectorPosition > -1) //may be an inactive element that was erased
                        {
                            EveryPrefDir->RealignAfterTrackErase(1, ErasedTrackVectorPosition);
                        }
                        NeedToLink = true;
                    }
                }
            }

            // erase text elements within selected region
            int LowSelectHPos = SelectRect.left * 16;
            int HighSelectHPos = SelectRect.right * 16;
            int LowSelectVPos = SelectRect.top * 16;
            int HighSelectVPos = SelectRect.bottom * 16;
            if(!TextHandler->TextVector.empty())     // skip iteration if empty else have an error
            {
                for(TTextHandler::TTextVectorIterator TextPtr = (TextHandler->TextVector.end() - 1); TextPtr >= TextHandler->TextVector.begin();
                    TextPtr--)     // reverse to prevent skipping during erase
                {
                    if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos <
                                                                                                                                    HighSelectVPos))
                    {
                        if(TextHandler->TextErase(1, TextPtr->HPos, TextPtr->VPos, AnsiString("")))
                        {
                            ;
                        }     // unused condition

                        TextChangesMade = true;
                    }
                }
            }
            // erase graphic elements that fall wholly within region to be overwritten
            if(!Track->UserGraphicVector.empty())     // skip iteration if empty else have an error
            {
                for(TTrack::TUserGraphicVector::iterator GraphicPtr = (Track->UserGraphicVector.end() - 1); GraphicPtr >= Track->UserGraphicVector.begin();
                    GraphicPtr--)     // reverse to prevent skipping during erase
                {
                    if((GraphicPtr->HPos >= LowSelectHPos) && ((GraphicPtr->HPos + GraphicPtr->Width) < HighSelectHPos) && (GraphicPtr->VPos >= LowSelectVPos)
                       && ((GraphicPtr->VPos + GraphicPtr->Height) < HighSelectVPos))
                    {
                        Track->UserGraphicVector.erase(GraphicPtr);
                        GraphicChangesMade = true;
                    }
                }
            }
            Track->CheckMapAndTrack(11);     // test
            Track->CheckMapAndInactiveTrack(10);     // test
            Track->CheckLocationNameMultiMap(19);     // test
            Screen->Cursor = TCursor(-2);     // Arrow;
            // Track->SetTrackFinished(!NeedToLink);  This is an error (see Sam Wainwright email of 24/08/17 & devhistory.txt
            // if track not linked to begin with then becomes linked if NeedToLink false
            if(NeedToLink)
            {
                Track->SetTrackFinished(false);     // corrected for v2.1.0
            }
            InfoPanel->Caption = "CUTTING:  Left click in selection && drag";
            CutMenuItem->Enabled = false;
            CopyMenuItem->Enabled = false;
            FlipMenuItem->Enabled = false;
            MirrorMenuItem->Enabled = false;
            RotRightMenuItem->Enabled = false;
            RotLeftMenuItem->Enabled = false;
            RotateMenuItem->Enabled = false;
            PasteMenuItem->Enabled = true;
    // PasteWithAttributesMenuItem->Enabled = true;  //new at v2.2.0 - option enabled if cutting   (dropped at 2.4.0 as all pastes are with attributes)
            DeleteMenuItem->Enabled = false;
            SelectLengthsMenuItem->Enabled = false;
            SelectBiDirPrefDirsMenuItem->Visible = false;
            CheckPrefDirConflictsMenuItem->Visible = false;
            CancelSelectionMenuItem->Enabled = true;
            SelectBitmapHLoc = SelectRect.left;
            SelectBitmapVLoc = SelectRect.top;
            if(NeedToLink || TextChangesMade || GraphicChangesMade)
            {
                ResetChangedFileDataAndCaption(20, true);     // true for NonPrefDirChangesMade
            }
            ClearandRebuildRailway(37);     // to overplot the erased elements with SelectBitmap
            UserGraphicReselectPanel->Visible = false;
            SetTrackBuildImages(7);
        } break;

        case Pasting:
        {
            // have to use braces as otherwise the default case bypasses the initialisation of these local variables
            int HDiff = SelectBitmapHLoc - SelectRect.left;     // SelectBitmapHLoc/VLoc is the paste position & SelectRect.left/top is the original position
            int VDiff = SelectBitmapVLoc - SelectRect.top;
            if(!SelectionValid && !CancelSelectionFlag)     // may be pasting into a new application so use clipboard, new at v2.8.0
            {
                bool ValidResult;
                RecoverClipboard(0, ValidResult);     // new at v2.8.0
                if(ValidResult)
                {
                    HDiff = Display->DisplayOffsetH - SelectRect.left;     // SelectRect.left & top recovered in clipboard
                    VDiff = Display->DisplayOffsetV - SelectRect.top;
                    SelectBitmapHLoc = Display->DisplayOffsetH;     // so the area to erase corresponds to the paste area (TLHC of screen = DisplayOffsetH & V)
                    SelectBitmapVLoc = Display->DisplayOffsetV;
                    SelectionValid = false;     // don't want reselect in new app after paste
                    Track->SetTrackFinished(false);     // would be set to false in other app but not in this so set it to false here
                    if(!RecoverClipboardMessageSent)
                    {
                        UnicodeString MessageStr =
                            "Please be aware of the relevant conditions when pasting a railway segment from a different application.\n"
                            "These are set out in section 3.5 of the manual and " "on-screen help under the heading 'Pasting in an application "
                            "after cutting or copying from a different application'.\n\n" "This warning will not be shown again.\n\n" "Proceed?";
                        int button = Application->MessageBox(MessageStr.c_str(), L"Warning", MB_YESNO | MB_ICONWARNING);
                        RecoverClipboardMessageSent = true;
                        if(button == IDNO)
                        {
                            CancelSelectionMenuItem->Click();     // reset clipboard etc
                            Utilities->CallLogPop(2271);
                            return;
                        }
                    }
                }
                else
                {
                    Application->MessageBoxW(L"Unable to paste (clipboard is invalid) - possibly because another application has changed it)", L"Warning", MB_OK | MB_ICONWARNING);
                    CancelSelectionMenuItem->Click();     // reset clipboard etc
                    TrainController->LogEvent("ValidResult false in case Pasting - probably due to error in RecoverClipboard - see earlier log");
                    Utilities->CallLogPop(2272); //EClipboardException (here as search term only)
                    return;
                }
            }
            if(CancelSelectionFlag)     // plot cut area in original position in case moved
            {
                SelectBitmapHLoc = SelectRect.left;
                SelectBitmapVLoc = SelectRect.top;
                HDiff = 0;
                VDiff = 0;
            }
            Clipboard()->Clear();     // already cleared & closed if recovered clipboard but not otherwise so clear & close here
            Clipboard()->Close();
            Track->SkipLocationNameMultiMapCheck = true;
            ResetChangedFileDataAndCaption(17, true);
            bool NeedToLink = false;
            bool TrackLinkingRequiredFlag;
            Screen->Cursor = TCursor(-11);     // Hourglass;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "PASTING: Please wait";
            InfoPanel->Update();
    // erase track elements
            int LowSelectHLoc = SelectBitmapHLoc;
            int HighSelectHLoc = SelectBitmapHLoc + (SelectBitmap->Width / 16);
            int LowSelectVLoc = SelectBitmapVLoc;
            int HighSelectVLoc = SelectBitmapVLoc + (SelectBitmap->Height / 16);
            bool TrackEraseSuccessfulFlag;     // needed but not used here
            int ErasedTrackVectorPosition;
    // new quick method of erasing, only need H & V values
            for(int x = LowSelectHLoc; x < HighSelectHLoc; x++)
            {
                for(int y = LowSelectVLoc; y < HighSelectVLoc; y++)
                {
                    Track->EraseTrackElement(5, x, y, ErasedTrackVectorPosition, TrackEraseSuccessfulFlag, false);
                    if(ErasedTrackVectorPosition > -1)
                    {
                        EveryPrefDir->RealignAfterTrackErase(2, ErasedTrackVectorPosition);
                    }
                }
            }

    // erase text elements that fall within region to be overwritten
            int LowSelectHPos = SelectBitmapHLoc * 16;
            int HighSelectHPos = (SelectBitmapHLoc * 16) + SelectBitmap->Width;
            int LowSelectVPos = SelectBitmapVLoc * 16;
            int HighSelectVPos = (SelectBitmapVLoc * 16) + SelectBitmap->Height;
            if(!TextHandler->TextVector.empty())     // skip iteration if empty else have an error
            {
                for(TTextHandler::TTextVectorIterator TextPtr = (TextHandler->TextVector.end() - 1); TextPtr >= TextHandler->TextVector.begin();
                    TextPtr--)     // reverse to prevent skipping during erase
                {
                    if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos <
                                                                                                                                    HighSelectVPos))
                    {
                        if(TextHandler->TextErase(2, TextPtr->HPos, TextPtr->VPos, AnsiString("")))
                        {
                            ;
                        }     // unused condition

                    }
                }
            }
    // erase graphic elements that fall wholly within region to be overwritten
            if(!Track->UserGraphicVector.empty())     // skip iteration if empty else have an error
            {
                for(TTrack::TUserGraphicVector::iterator GraphicPtr = (Track->UserGraphicVector.end() - 1); GraphicPtr >= Track->UserGraphicVector.begin();
                    GraphicPtr--)     // reverse to prevent skipping during erase
                {
                    if((GraphicPtr->HPos >= LowSelectHPos) && ((GraphicPtr->HPos + GraphicPtr->Width) < HighSelectHPos) && (GraphicPtr->VPos >= LowSelectVPos)
                       && ((GraphicPtr->VPos + GraphicPtr->Height) < HighSelectVPos))
                    {
                        Track->UserGraphicVector.erase(GraphicPtr);
                    }
                }
            }
            // change the H & V values in SelectVector to the new positions in case Reselect chosen
            for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
            {
                Track->SelectVectorAt(35, x).HLoc += HDiff;
                Track->SelectVectorAt(1, x).VLoc += VDiff;
            }

            // add the new track elements
            AnsiString LocName;
            for(unsigned int x = 0; x < Track->SelectVectorSize(); x++)
            {
                if(Track->CopyFlag)     // blank all names if copying, lengths & speedlimits stay
                {
                    Track->SelectVectorAt(80, x).LocationName = "";
                    Track->SelectVectorAt(81, x).ActiveTrackElementName = "";
                }
                else //cut, check if element has a name and if so remove same existing name from name map and track vector
                {
                    LocName = Track->SelectVectorAt(82, x).LocationName;
                    if(LocName == "")
                    {
                        LocName = Track->SelectVectorAt(83, x).ActiveTrackElementName;
                    }
                    if(LocName != "")
                    {
                        Track->EraseLocationAndActiveTrackElementNames(6, LocName); //this will keep erasing adjacent element names but the last one will be pasted and not erased
                                                                                    //and that will name all linked elements so should work ok
                        int HPos = 0, VPos = 0;
                        if(TextHandler->FindText(5, LocName, HPos, VPos))
                        {
                            ;
                        }
                        {
                            if(EraseLocationNameText(4, LocName, HPos, VPos))
                            {
                                ;
                            } // condition not used
                        }
                    }
                }
                bool InternalChecks = false;
    // if(Track->PastingWithAttributes) //new at v2.2.0 to select the new funtion & skip multimap checks //drop in v2.4.0
    // {
                Track->PlotPastedTrackElementWithAttributes(0, Track->SelectVectorAt(2, x), Track->SelectVectorAt(3, x).HLoc, Track->SelectVectorAt(4, x).VLoc,
                                                            TrackLinkingRequiredFlag, InternalChecks);
                // new at v2.2.0 & used in place of PlotAndAddTrackElement to keep length & speed values
    // }
    /* drop this in v2.4.0 as all pastes are with attributes
                else //'Aspect' parameter added to PlotAndAdd... at v2.2.0 so can plot signals correctly (always four-aspect before)
                {
                    int Aspect;
                    if(Track->SelectVectorAt(15, x).TrackType != SignalPost) Aspect = 0;  //if an '0' value appears with a SignalPost then must be adding track
                    //this combination allows the funtion to distinguish between adding track and plotting with attributes
                    else if(Track->SelectVectorAt(16, x).SigAspect == TTrackElement::GroundSignal) Aspect = 1;
                    else if(Track->SelectVectorAt(17, x).SigAspect == TTrackElement::TwoAspect) Aspect = 2;
                    else if(Track->SelectVectorAt(18, x).SigAspect == TTrackElement::ThreeAspect) Aspect = 3;
                    else Aspect = 4;
                    Track->PlotAndAddTrackElement(2, Track->SelectVectorAt(19, x).SpeedTag, Aspect, Track->SelectVectorAt(20, x).HLoc, Track->SelectVectorAt(21, x).VLoc, TrackLinkingRequiredFlag, InternalChecks);
                }
    */
                if(TrackLinkingRequiredFlag)
                {
                    NeedToLink = true;
                }
            }

            //add the pref dir elements, added at v2.9.0
            int ATVecPos;
            bool FoundFlag;
            if(SelectPrefDir->PrefDirSize() > 0)     // skip iteration if empty
            {
                // keep contents valid in case reselect
                for(TOnePrefDir::TPrefDirVectorIterator PDVIt = SelectPrefDir->PrefDirVector.begin(); PDVIt < SelectPrefDir->PrefDirVector.end();
                    PDVIt++)
                {
                    PDVIt->HLoc += HDiff;     // for reselect
                    PDVIt->VLoc += VDiff;     // for reselect
                    //need to reset TrackVectorPosition in case any elements erased before linking, as if so EveryPrefDir can only be erased too if it has the correct TrackVectorPosition
                    ATVecPos = Track->GetVectorPositionFromTrackMap(60, PDVIt->HLoc, PDVIt->VLoc, FoundFlag);
                    if(!FoundFlag)
                    {
                        throw Exception("Failed to find TrackVectorPosition in PrefDir setting for Paste");
                    }
                    PDVIt->SetTrackVectorPosition(ATVecPos);

                    //reset all Conns & ConnLinkPos values so won't be erased during a later cut, they will be set in RebuildPrefDirVector which is called when track linked
                    for(int x = 0; x < 4; x++)
                    {
                        PDVIt->Conn[x] = -1;
                        PDVIt->ConnLinkPos[x] = -1;
                    }
                    EveryPrefDir->ExternalStorePrefDirElement(10, *PDVIt);
                }
                EveryPrefDir->CheckPrefDirAgainstTrackVector(1);
            }

            // add the new text items
            if(!TextHandler->SelectTextVector.empty())     // skip iteration if empty else have an error
            {
                for(TTextHandler::TTextVectorIterator TextPtr = TextHandler->SelectTextVector.begin(); TextPtr < TextHandler->SelectTextVector.end(); TextPtr++)
                {
                    TextPtr->HPos += HDiff * 16;
                    TextPtr->VPos += VDiff * 16;
                    AnsiString TempString = TextPtr->TextString;
                    // have to create a new TextItem in order to create a new Font object
    /* drop in v2.4.0 as all pastes are paste with attributes
                    if(!Track->PastingWithAttributes) //new at v2.2.0 to deal with the new location prefix '##**'  //drop in v2.4.0
                    {
                        if(TextPtr->TextString.SubString(1,4) != "##**") //added for named locations so can delete in a simple paste but
                                                                         //use in PastingWithAttributes
                        {
                            TTextItem TextItem(TextPtr->HPos, TextPtr->VPos, TextPtr->TextString, TextPtr->Font);
                            TextHandler->TextVectorPush(0, TextItem); //if a normal paste include normal text but not location text
                        }
                        else TextPtr->TextString = "";  //delete the name for a simple paste
                    }
    */
    // else //if pasting with attributes paste all text but strip the '##**' prefix if present
    // {
                    if(TextPtr->TextString.SubString(1, 4) == "##**")
                    {
                        TempString = TextPtr->TextString.SubString(5, TextPtr->TextString.Length());     // don't change SelectTextVector value
                        if(Track->CopyFlag)
                        {
                            TextPtr->TextString = "";     // change SelectTextVector value as reselect shouldn't have locations if copied
                            TempString = "";
                        }
                    }
                    TTextItem TextItem(TextPtr->HPos, TextPtr->VPos, TempString, TextPtr->Font);
                    TextHandler->TextVectorPush(4, TextItem);
    // }
                }
            }
            // add new graphic items
            if(!Track->SelectGraphicVector.empty())     // skip iteration if empty else have an error
            {
                // keep contents of SelectVector valid in case reselect
                for(TTrack::TUserGraphicVector::iterator GraphicPtr = Track->SelectGraphicVector.begin(); GraphicPtr < Track->SelectGraphicVector.end();
                    GraphicPtr++)
                {
                    GraphicPtr->HPos += HDiff * 16;     // for reselect
                    GraphicPtr->VPos += VDiff * 16;     // for reselect
                    Track->UserGraphicVector.push_back(*GraphicPtr);
                }
            }
            Track->SkipLocationNameMultiMapCheck = false;     // renamed in v2.4.0 - reset the flag after pasting complete, otherwise multimap checks always skipped
            Track->CopyFlag = false;
            Track->CheckMapAndTrack(7);     // test
            Track->CheckMapAndInactiveTrack(7);     // test
            Track->CheckLocationNameMultiMap(7);     // test
            // Track->SetTrackFinished(!NeedToLink);  This is an error (see Sam Wainwright email of 24/08/17 & devhistory.txt
            // if track not linked to begin with then becomes linked if NeedToLink false
            if(NeedToLink)
            {
                Track->SetTrackFinished(false);     // corrected for v2.1.0
            }
            Screen->Cursor = TCursor(-2);     // Arrow;
            SetTrackBuildImages(14);
            ClearandRebuildRailway(38);
            // Level1Mode = TrackMode; //dropped as prevents AddTrack being called to display track elements
            // SetLevel1Mode(79);
            SetTrackModeEditMenu(5);     // this is called from the above but is still needed to enable Select (& Reselect if pasted in same app) menu items
            PasteMenuItem->Enabled = false;
            UserGraphicReselectPanel->Visible = false;
            if(Level2TrackMode != AddTrack)     // no need to set if already set in an earlier call
            {
                Level2TrackMode = AddTrack;
                // No further recursion in AddTrack so OK
                SetLevel2TrackMode(42);
            }
        } break;

        case Deleting:
        {
            // have to use braces as otherwise the default case bypasses the initialisation of these local variables
            Track->CopyFlag = false;
            UnicodeString MessageStr = "Selected area will be deleted - proceed?";
            int button = Application->MessageBox(MessageStr.c_str(), L"Please confirm", MB_YESNO);
            if(button == IDNO)
            {
                break;
            }
            bool EraseSuccessfulFlag, NeedToLink = false, TextChangesMade = false, GraphicChangesMade = false;
            int ErasedTrackVectorPosition;
            Screen->Cursor = TCursor(-11);     // Hourglass;
            InfoPanel->Visible = true;
            InfoPanel->Caption = "DELETING: Please wait";
            InfoPanel->Update();
            for(int H = SelectRect.left; H < SelectRect.right; H++)
            {
                for(int V = SelectRect.top; V < SelectRect.bottom; V++)
                {
                    Track->EraseTrackElement(3, H, V, ErasedTrackVectorPosition, EraseSuccessfulFlag, false);
                    if(EraseSuccessfulFlag)
                    {
                        if(ErasedTrackVectorPosition > -1)
                        {
                            EveryPrefDir->RealignAfterTrackErase(3, ErasedTrackVectorPosition);
                        }
                        NeedToLink = true;
                    }
                }
            }
            // erase text elements that fall within selected region
            int LowSelectHPos = SelectRect.left * 16;
            int HighSelectHPos = SelectRect.right * 16;
            int LowSelectVPos = SelectRect.top * 16;
            int HighSelectVPos = SelectRect.bottom * 16;
            if(!TextHandler->TextVector.empty())     // skip iteration if empty else have an error
            {
                for(TTextHandler::TTextVectorIterator TextPtr = (TextHandler->TextVector.end() - 1); TextPtr >= TextHandler->TextVector.begin();
                    TextPtr--)     // reverse to prevent skipping during erase
                {
                    AnsiString Check = TextPtr->TextString;
                    if((TextPtr->HPos >= LowSelectHPos) && (TextPtr->HPos < HighSelectHPos) && (TextPtr->VPos >= LowSelectVPos) && (TextPtr->VPos <
                                                                                                                                    HighSelectVPos))
                    {
                        if(TextHandler->TextErase(3, TextPtr->HPos, TextPtr->VPos, AnsiString("")))
                        {
                            ;
                        }     // unused condition

                        TextChangesMade = true;
                    }
                }
            }
            // erase graphic elements that fall within selected region
            if(!Track->UserGraphicVector.empty())     // skip iteration if empty else have an error
            {

    // Isglassen05 (vilhelmgg@gmail.com) reported an error via email and attached an error file on 31/07/20.  The error was in the following line which was:

    // for(TTrack::TUserGraphicVector::iterator GraphicPtr = (Track->SelectGraphicVector.end() - 1); GraphicPtr >= Track->SelectGraphicVector.begin();
    // GraphicPtr--) // reverse to prevent skipping during erase

    // i.e if the railway included one or more user graphics but the SelectGraphicVector didn't include any, then GraphicPtr wouldn't point to anything and the program would fail
    // corrected 01/08/20 by using UserGraphicVector (as it should have been) for SelectGraphicVector.  New version v2.4.3.

                for(TTrack::TUserGraphicVector::iterator GraphicPtr = (Track->UserGraphicVector.end() - 1); GraphicPtr >= Track->UserGraphicVector.begin();
                    GraphicPtr--)     // reverse to prevent skipping during erase
                {
                    if((GraphicPtr->HPos >= LowSelectHPos) && ((GraphicPtr->HPos + GraphicPtr->Width) < HighSelectHPos) && (GraphicPtr->VPos >= LowSelectVPos)
                       && ((GraphicPtr->VPos + GraphicPtr->Height) < HighSelectVPos))
                    {
                        for(TTrack::TUserGraphicVector::iterator UserGraphicPtr = (Track->UserGraphicVector.end() - 1);
                            UserGraphicPtr >= Track->UserGraphicVector.begin(); UserGraphicPtr--)     // reverse to prevent skipping during erase
                        {
                            if((UserGraphicPtr->HPos == GraphicPtr->HPos) && (UserGraphicPtr->VPos == GraphicPtr->VPos) &&
                               (UserGraphicPtr->Width == GraphicPtr->Width) && (UserGraphicPtr->Height == GraphicPtr->Height) &&
                               (UserGraphicPtr->FileName == GraphicPtr->FileName))
                            {
                                Track->UserGraphicVector.erase(UserGraphicPtr);
                                GraphicChangesMade = true;
                            }
                        }
                    }
                }
            }
            // clear the selectvectors
            Track->SelectVectorClear();
            TextHandler->SelectTextVector.clear();
            Track->SelectGraphicVector.clear();
            SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
            Track->CheckMapAndTrack(10);     // test
            Track->CheckMapAndInactiveTrack(9);     // test
            Track->CheckLocationNameMultiMap(15);     // test
            // Track->SetTrackFinished(!NeedToLink);  This is an error (see Sam Wainwright email of 24/08/17 & devhistory.txt
            // if track not linked to begin with then becomes linked if NeedToLink false
            if(NeedToLink)
            {
                Track->SetTrackFinished(false);     // corrected for v2.1.0
            }
            if(NeedToLink || TextChangesMade || GraphicChangesMade)
            {
                ResetChangedFileDataAndCaption(21, true);     // true for NonPrefDirChangesMade
            }
            Screen->Cursor = TCursor(-2);     // Arrow;
            ClearandRebuildRailway(39);
            Level1Mode = TrackMode;
            SetLevel1Mode(80);
            Level2TrackMode = AddTrack;
            // No further recursion in AddTrack so OK
            UserGraphicReselectPanel->Visible = false;
            SetLevel2TrackMode(43);
        } break;

        default:
            // No further recursion in TrackMode so OK
            Track->CopyFlag = false;
            Level1Mode = TrackMode;
            SetLevel1Mode(21);
            UserGraphicReselectPanel->Visible = false;
            break;
        }
        Utilities->CallLogPop(107);
    }
    catch (const EClipboardException &e) //non-error catch
    {
        TrainController->LogEvent("Clipboard error in SetLevel2TrackMode");
        Utilities->CallLogPop(2404);
    }
}

// ---------------------------------------------------------------------------

void TInterface::SetLevel2PrefDirMode(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetLevel2PrefDirMode");
    if(Level1Mode != PrefDirMode)
    {
        // No further recursion in BaseMode so OK
        Level1Mode = BaseMode;
        SetLevel1Mode(22);
        Utilities->CallLogPop(108);
        return;
    }
    if(Level2PrefDirMode == NoPrefDirMode)
    {
        Utilities->CallLogPop(109);
        return;
    }
    switch(Level2PrefDirMode) // use the data member
    {
    case PrefDirContinuing:
    {
        // have to use braces as otherwise the default case bypasses the initialisation of these local variables
        InfoPanel->Visible = true;
        if(!Display->ZoomOutFlag)     // can't set focus if zoomed out, get an error - added this condition for v0.4d
        {
            AddPrefDirButton->Enabled = true;     // this and the line below are to remove focus from any other button that might have it, prior to
            AddPrefDirButton->SetFocus();     // disabling the AddPrefDir button, so pressing enter does nothing, it is reset to the AddPrefDir
        }
        AddPrefDirButton->Enabled = false;     // button later if it becomes enabled
        DeleteOnePrefDirButton->Enabled = false;
        bool LeadingPointsAtLastElement = false;
        if(!ConstructPrefDir->EndPossible(0, LeadingPointsAtLastElement))
        {
            if(LeadingPointsAtLastElement)     // size must be > 1
            {
                InfoPanel->Caption = "PREFERRED DIRECTION SETTING:  Can't end on leading points, select next location or truncate";
                DeleteOnePrefDirButton->Enabled = true;
            }
            else     // size == 1, DeleteOnePrefDirButton->Enabled remains false
            {
                InfoPanel->Caption = "PREFERRED DIRECTION SETTING:  Select next preferred direction location (right click to truncate)";
            }
        }
        else     // size > 1 & EndPossible
        {
            InfoPanel->Caption = "PREFERRED DIRECTION SETTING:  Add selection or select next location (right click to truncate)";
            if(!Display->ZoomOutFlag)     // can't set focus if zoomed out, get an error - added this condition for v0.4d
            {
                AddPrefDirButton->Enabled = true;
                AddPrefDirButton->SetFocus();     // so can just press 'Enter' key
            }
            DeleteOnePrefDirButton->Enabled = true;
        }
        ExitPrefDirButton->Enabled = true;
        ClearandRebuildRailway(40);     // to show truncated PrefDirs
    } break;

    case PrefDirSelecting:
        ResetSelectRect(); // so a viewpoint change before a new SelectRect chosen doesn't redisplay the old SelectRect
        InfoPanel->Visible = true;
        InfoPanel->Caption = "SELECTING:  Select area - click left mouse && drag";
        SelectMenuItem->Enabled = false;
        ReselectMenuItem->Enabled = false;
        CancelSelectionMenuItem->Enabled = true;
        break;

    default:
        // No further recursion in PrefDirMode so OK
        Level1Mode = PrefDirMode;
        SetLevel1Mode(23);
        break;
    }
    Utilities->CallLogPop(110);
}

// ---------------------------------------------------------------------------

void TInterface::SetLevel2OperMode(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetLevel2OperMode");
    if(Level1Mode != OperMode)
    {
        // No further recursion in BaseMode so OK
        Level1Mode = BaseMode;
        SetLevel1Mode(24);
        Utilities->CallLogPop(111);
        return;
    }
    if(Level2OperMode == NoOperMode)
    {
        Utilities->CallLogPop(112);
        return;
    }
    DelayMenu->Visible = true; //these added at v2.13.0
    DelayMenu->Enabled = true;
    FailureMenu->Visible = true; //these added at v2.14.0
    FailureMenu->Enabled = true;
    CallingOnButton->Visible = true;
    PresetAutoSigRoutesButton->Visible = false;
    switch(Level2OperMode) // use the data member
    {
    case Operating:
    {
        // have to use braces as otherwise the default case bypasses the initialisation of local variables
        OperateButton->Enabled = true;
        OperateButton->Glyph->LoadFromResourceName(0, "PauseGraphic");
        ExitOperationButton->Enabled = true;
        TTClockAdjButton->Enabled = false;
        if(TTClockSpeed == 2)
        {
            TTClockSpeedLabel->Caption = "x2";
        }
        else if(TTClockSpeed == 4)
        {
            TTClockSpeedLabel->Caption = "x4";
        }
        else if(TTClockSpeed == 8)
        {
            TTClockSpeedLabel->Caption = "x8";
        }
        else if(TTClockSpeed == 16)
        {
            TTClockSpeedLabel->Caption = "x16";
        }
        else if(TTClockSpeed == 0.5)
        {
            TTClockSpeedLabel->Caption = "x1/2";
        }
        else if(TTClockSpeed == 0.25)
        {
            TTClockSpeedLabel->Caption = "x1/4";
        }
        else if(TTClockSpeed == 0.125)
        {
            TTClockSpeedLabel->Caption = "x1/8";
        }
        else if(TTClockSpeed == 0.0625)
        {
            TTClockSpeedLabel->Caption = "x1/16";
        }
        else
        {
            TTClockSpeed = 1;
            TTClockSpeedLabel->Caption = "x1";
        }
        AnsiString TimeMessage = Utilities->Format96HHMMSS(TDateTime(PauseEntryRestartTime)) + ": ";
        if(TTClockSpeed != PauseEntryTTClockSpeed)
        {
            // send message to performance log
            if(TTClockSpeed == 2)
            {
                PerfLogForm->PerformanceLog(6, TimeMessage + "Timetable clock speed changed to twice normal");
            }
            else if(TTClockSpeed == 4)
            {
                PerfLogForm->PerformanceLog(7, TimeMessage + "Timetable clock speed changed to four times normal");
            }
            else if(TTClockSpeed == 8)
            {
                PerfLogForm->PerformanceLog(8, TimeMessage + "Timetable clock speed changed to eight times normal");
            }
            else if(TTClockSpeed == 16)
            {
                PerfLogForm->PerformanceLog(9, TimeMessage + "Timetable clock speed changed to sixteen times normal");
            }
            else if(TTClockSpeed == 0.5)
            {
                PerfLogForm->PerformanceLog(10, TimeMessage + "Timetable clock speed changed to half normal");
            }
            else if(TTClockSpeed == 0.25)
            {
                PerfLogForm->PerformanceLog(11, TimeMessage + "Timetable clock speed changed to quarter normal");
            }
            else if(TTClockSpeed == 0.125)
            {
                PerfLogForm->PerformanceLog(14, TimeMessage + "Timetable clock speed changed to one eighth normal");
            }
            else if(TTClockSpeed == 0.0625)
            {
                PerfLogForm->PerformanceLog(15, TimeMessage + "Timetable clock speed changed to one sixteenth normal");
            }
            else
            {
                PerfLogForm->PerformanceLog(12, TimeMessage + "Timetable clock speed changed to normal");
            }
        }
        double TTClockTimeChange = double(TrainController->RestartTime) - PauseEntryRestartTime;
        if(TTClockTimeChange > 0.000347)     // 30 seconds, min increase is 1 minute & don't trust doubles to stay exactly equal
        {
            // send message to performance log
            int MinsIncrease = ((TTClockTimeChange * 1440) + 0.5);     // add 30 secs to ensure truncates correctly
            int HoursIncrease = 0;
            while(MinsIncrease >= 60)
            {
                HoursIncrease++;
                MinsIncrease -= 60;
            }
            if(HoursIncrease == 0)
            {
                TimeMessage += "Timetable clock incremented by " + AnsiString(MinsIncrease) + "m";
            }
            else if(MinsIncrease == 0)
            {
                TimeMessage += "Timetable clock incremented by " + AnsiString(HoursIncrease) + "h";
            }
            else
            {
                TimeMessage += "Timetable clock incremented by " + AnsiString(HoursIncrease) + "h " + AnsiString(MinsIncrease) + "m";
            }
            PerfLogForm->PerformanceLog(13, TimeMessage);
        }
        WarningHover = false;
        SetRouteButtonsInfoCaptionAndRouteNotStarted(4);
        if(TrainController->AvHoursIntValue > 0)
        {
            MTBFEditBox->Visible = true;
            MTBFEditBox->Text = AnsiString(TrainController->AvHoursIntValue);
            MTBFEditBox->ReadOnly = true;     // because this is not prestart mode
            MTBFLabel->Visible = true;
            MTBFLabel->Caption = "Mean time between\ntrain failures in\ntimetable hours";
            TrainController->MTBFHours = double(TrainController->AvHoursIntValue) / TTClockSpeed;
        }
        else
        {
            MTBFEditBox->Visible = false;
            MTBFEditBox->Text = "";
            MTBFLabel->Visible = false;
            MTBFLabel->Caption = "Mean time between\ntrain failures in\ntimetable hours";
            TrainController->MTBFHours = 0;
        }
        TrainController->BaseTime = TDateTime::CurrentDateTime();
// StopTTClockFlag already false because TTClock stopped by condition "if(!TrainController->StopTTClockFlag && (Level2OperMode == Operating))" in MasterClockTimer function
    } break;

    case Paused:
        OperateButton->Enabled = true;
        OperateButton->Glyph->LoadFromResourceName(0, "RunGraphic");
        ExitOperationButton->Enabled = true;
        TTClockAdjButton->Enabled = true;
        SetRouteButtonsInfoCaptionAndRouteNotStarted(7);
        DisableRouteButtons(4);
        SetPausedOrZoomedInfoCaption(5);
        TrainController->RestartTime = TrainController->TTClockTime;
// StopTTClockFlag stays false because TTClock stopped by condition "if(!TrainController->StopTTClockFlag && (Level2OperMode == Operating))" in MasterClockTimer function
        PauseEntryRestartTime = double(TrainController->RestartTime);
        PauseEntryTTClockSpeed = TTClockSpeed;
        break;

    // don't need a separate case for PreStart

    default:
        // No further recursion in OperMode so OK
        Level1Mode = OperMode;
        SetLevel1Mode(25);
        break;
    }
    api_oper_mode_ = int(Level2OperMode);   //added at v2.10.0
    session_api_->dump();   // update session INI file
    Utilities->CallLogPop(113);
}

// ---------------------------------------------------------------------------

void TInterface::ApproachLocking(int Caller, TDateTime TTClockTime)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ApproachLocking");
    float LockDelay = 120.0;

    if(!AllRoutes->LockedRouteVector.empty())
    {
        for(TAllRoutes::TLockedRouteVectorIterator LRVIT = AllRoutes->LockedRouteVector.end() - 1; LRVIT >= AllRoutes->LockedRouteVector.begin(); LRVIT--)
        {
            bool BreakFlag = false;
            if(AllRoutes->TrackIsInARoute(5, LRVIT->LastTrackVectorPosition, LRVIT->LastXLinkPos))
            {
                TOneRoute &Route = AllRoutes->GetModifiableRouteAt(0, LRVIT->RouteNumber);
                //below added at v2.15.0
                TPrefDirElement LastPDElement = Route.GetFixedPrefDirElementAt(265, Route.PrefDirSize() - 1); //these will persist after the actual PDElements have been removed
                TPrefDirElement FirstPDElement = Route.GetFixedPrefDirElementAt(266, 0);
                //end of section added at v2.15.0
                if((TTClockTime - LRVIT->LockStartTime) > TDateTime(LockDelay / 86400))
                {
                    TrainController->LogEvent("LockedRouteRemoved," + AnsiString(LRVIT->RearTrackVectorPosition) + "," +
                                              AnsiString(LRVIT->LastTrackVectorPosition));
                    while(Route.LastElementPtr(9)->GetTrackVectorPosition() != LRVIT->RearTrackVectorPosition)
                    {
                        // examine the element one earlier in the route than the last
                        if(!(AllRoutes->TrackIsInARoute(6, Route.LastElementPtr(10)->Conn[Route.LastElementPtr(11)->GetELinkPos()],
                                                        Route.LastElementPtr(12)->ConnLinkPos[Route.LastElementPtr(13)->GetELinkPos()])))
                        {
                            BreakFlag = true;
                        }
                        AllRoutes->RemoveRouteElement(1, Route.LastElementPtr(14)->HLoc, Route.LastElementPtr(15)->VLoc, Route.LastElementPtr(16)->GetELink());
                        if(BreakFlag)
                        {
                            break; // train removed earlier element from route so stop here
                        }
                    }
                    if(!BreakFlag)
                    {
                        // still need to remove the element at the RearTrackVectorPosition
                        if(Route.LastElementPtr(17)->GetTrackVectorPosition() == LRVIT->RearTrackVectorPosition)
                        {
                            AllRoutes->RemoveRouteElement(2, Route.LastElementPtr(18)->HLoc, Route.LastElementPtr(19)->VLoc,
                                                          Route.LastElementPtr(20)->GetELink());
                        }
                    }
                    if(LastPDElement.AutoSignals) //only reclaim sigs for blue routes - added at v2.15.0
                    {
                        Route.ReclaimSignalsForNonAutoSigRoutes(2, LastPDElement, FirstPDElement);
                    }
                    AllRoutes->CheckMapAndRoutes(10); // test
                    AllRoutes->LockedRouteVector.erase(LRVIT);
                    if(!Display->ZoomOutFlag)
                    {
                        ClearandRebuildRailway(17); // to get rid of route graphics
                    }
                    RevertToOriginalRouteSelector(13);
                }
            }
            else
            {
                AllRoutes->LockedRouteVector.erase(LRVIT);
                // if end element not in route then a train must have entered it from the wrong end and erased the whole route,
                // hence no longer needed so get rid of it
            }
        }
    }
    Utilities->CallLogPop(743);
}

// ---------------------------------------------------------------------------

void TInterface::ContinuationAutoSignals(int Caller, TDateTime TTClockTime)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ContinuationAutoSignals");
    if(!TrainController->ContinuationAutoSigVector.empty())
    {
        TTrainController::TContinuationAutoSigVectorIterator AutoSigVectorIT;
        for(AutoSigVectorIT = TrainController->ContinuationAutoSigVector.end() - 1; AutoSigVectorIT >= TrainController->ContinuationAutoSigVector.begin();
            AutoSigVectorIT--)
        {
            // Below added at v2.1.0 to prevent locked autosig continuation routes from clearing signals
            // need to identify the Continuation element in the route & check if it's in a locked route.  If it is then don't call
            // SetTrailingSignalsOnContinuationRoute as all signals must stay red.
            TPrefDirElement TempPrefDirElement;
            int TempLockedVectorNumber;
            int LastRouteElement = AllRoutes->GetFixedRouteAt(220, AutoSigVectorIT->RouteNumber).PrefDirSize() - 1;
            int TVNum = AllRoutes->GetFixedRouteAt(221, AutoSigVectorIT->RouteNumber).GetFixedPrefDirElementAt(246, LastRouteElement).GetTrackVectorPosition();
            // this will be a continuation (error thrown in SetTrailingSignalsOnContinuationRoute if not) & XLinkPos is always 0 for
            // route exiting at a continuation
            if(AllRoutes->IsElementInLockedRouteGetPrefDirElementGetLockedVectorNumber(14, TVNum, 0, TempPrefDirElement, TempLockedVectorNumber))
            {
                continue;
            }
            // end of additions
            if(((TTClockTime - AutoSigVectorIT->PassoutTime) > TDateTime(AutoSigVectorIT->FirstDelay / 86400)) && (AutoSigVectorIT->AccessNumber == 0))
            {
                AllRoutes->SetTrailingSignalsOnContinuationRoute(1, AutoSigVectorIT->RouteNumber, 0);
                AutoSigVectorIT->AccessNumber++;
                continue;
            }
            if(((TTClockTime - AutoSigVectorIT->PassoutTime) > TDateTime(AutoSigVectorIT->SecondDelay / 86400)) && (AutoSigVectorIT->AccessNumber == 1))
            {
                AllRoutes->SetTrailingSignalsOnContinuationRoute(2, AutoSigVectorIT->RouteNumber, 1);
                AutoSigVectorIT->AccessNumber++;
                continue;
            }
            if(((TTClockTime - AutoSigVectorIT->PassoutTime) > TDateTime(AutoSigVectorIT->ThirdDelay / 86400)) && (AutoSigVectorIT->AccessNumber == 2))
            {
                AllRoutes->SetTrailingSignalsOnContinuationRoute(3, AutoSigVectorIT->RouteNumber, 2);
                AutoSigVectorIT->AccessNumber++;
                continue;
            }
        }
        // examine all vector for any expired values & erase
        for(AutoSigVectorIT = TrainController->ContinuationAutoSigVector.end() - 1; AutoSigVectorIT >= TrainController->ContinuationAutoSigVector.begin();
            AutoSigVectorIT--)
        {
            if(AutoSigVectorIT->AccessNumber > 2)
            {
                TrainController->ContinuationAutoSigVector.erase(AutoSigVectorIT); // erase expired entries - reverse interation so OK to erase
            }
        }
    }
    Utilities->CallLogPop(744);
}

// ---------------------------------------------------------------------------

void TInterface::TrackTrainFloat(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",TrackTrainFloat");
    TPoint MousePoint = Mouse->CursorPos;
    int ScreenX = MousePoint.x - MainScreen->ClientOrigin.x; //mouse position wrt MainScreen
    int ScreenY = MousePoint.y - MainScreen->ClientOrigin.y;

    if(SkipTTActionsListBox->Visible ||
        (!ActionsDueForm->ActionsDueListBoxRightMouseButtonDown &&
            ((ScreenX > (MainScreen->Width - 1)) || (ScreenY > (MainScreen->Height - 1)) || (ScreenX < 0) || (ScreenY < 0)))) //button up & mouse outside mainscreen
    {
        // added !ActionsDueListBoxRightMouseButtonDown at v2.7.0 so can still obtain info & move to trains from ActionsDueListBox even if they are out of the main screen area
        // added SkipTTActionsListBox->Visible at v2.11.0 so no floating window when this is displayed
        FloatingPanel->Visible = false;
        Utilities->CallLogPop(1432);
        return;
    }

// mouse in ActionsDueForm if absolute mouseposX >= adfleft && mouseposX <= adfleft + adfwidth && mouseposY >= adftop && mouseposY <= adftop + adfheight
    if(ActionsDueForm->Visible && (MousePoint.x >= ActionsDueForm->Left) && (MousePoint.x <= (ActionsDueForm->Left + ActionsDueForm->Width)) &&
        (MousePoint.y >= ActionsDueForm->Top) && (MousePoint.y <= (ActionsDueForm->Top + ActionsDueForm->Height)) &&
        !ActionsDueForm->ActionsDueListBoxRightMouseButtonDown)
    {   //added at v2.13.0 so floating window not shown if mouse inside ActionsDue Form & right button not down in listbox
        FloatingPanel->Visible = false;
        Utilities->CallLogPop(2240);
        return;
    }
// mouse in PerfLogForm if absolute mouseposX >= plfleft && mouseposX <= plfleft + plfwidth && mouseposY >= plftop && mouseposY <= plftop + plfheight
    if(PerfLogForm->Visible && (MousePoint.x >= PerfLogForm->Left) && (MousePoint.x <= (PerfLogForm->Left + PerfLogForm->Width)) &&
        (MousePoint.y >= PerfLogForm->Top) && (MousePoint.y <= (PerfLogForm->Top + PerfLogForm->Height)) &&
        !ActionsDueForm->ActionsDueListBoxRightMouseButtonDown)
//    if(PerfLogForm->MouseInClient || PerfLogForm->PerformanceLogBox->MouseInClient)
    {   //added at v2.13.0 so floating window not shown if mouse inside PerfLogForm & right button not down in ADForm listbox
        //(MouseInClient was ok but changed to match ActionsDueForm)
        FloatingPanel->Visible = false;
        Utilities->CallLogPop(2538);
        return;
    }
    if(TimetableEditPanel->Visible) // added at v2.5.1 as showed track info behind panel
    {
        if((MousePoint.x >= TimetableEditPanel->Left) && (MousePoint.x <= (TimetableEditPanel->Left + TimetableEditPanel->Width)) &&
           ((MousePoint.y - ClientOrigin.y) >= TimetableEditPanel->Top) && ((MousePoint.y - ClientOrigin.y) <=
                                                                            (TimetableEditPanel->Top + TimetableEditPanel->Height)))
        {
            // dont show floating window if mouse over TimetableEditPanel
            FloatingPanel->Visible = false;
            Utilities->CallLogPop(2541);
            return;
        }
    }
    AnsiString TrackFloat = "", TrainStatusFloat = "", TrainTTFloat = "";
    bool ShowTrackFloatFlag = false, ShowTrainStatusFloatFlag = false, ShowTrainTTFloatFlag = false;
    int HLoc, VLoc;

    Track->GetTrackLocsFromScreenPos(4, HLoc, VLoc, ScreenX, ScreenY);

    if(Display->ZoomOutFlag)
    {
        Utilities->CallLogPop(1123);
        return;
    }
    bool MouseOverOAPanel = false;
// this flag added at v2.7.0 in place of prohibition of all floating windows (which was added at v2.3.0 when Xeon notified me in email of 15/10/19 that they were showing)
//so track info not shown when mouse over OA panel (as now can right click panel to show train info)
    if(ActionsDueForm->Visible)  //changed to ..Form instead of ..Panel at v2.13.0
    {
        if((MousePoint.x >= ActionsDueForm->Left) && (MousePoint.x <= (ActionsDueForm->Left + ActionsDueForm->Width)) &&
           ((MousePoint.y - ClientOrigin.y) >= ActionsDueForm->Top) && ((MousePoint.y - ClientOrigin.y) <=
           (ActionsDueForm->Top + ActionsDueForm->Height)))
        {
            MouseOverOAPanel = true;
        }
    }
    if((TrackInfoOnOffMenuItem->Caption == "Hide") && !MouseOverOAPanel)
    // MouseOverOAPanel condit added at v2.7.0 in place of prohibition of all floating windows (which was added at v2.3.0 when Xeon notified me in email of 15/10/19 that they were showing)
    {
        bool ActiveTrackFoundFlag = false, InactiveTrackFoundFlag = false, TwoTrack = false;
        AnsiString Length01Str = "", Length23Str = "", SpeedLimit01Str = "", SpeedLimit23Str = "";
        AnsiString StationEntryStopLinkPos1Str = "", StationEntryStopLinkPos2Str = "";
        AnsiString ATrackSN = "", ATrackTN = "", IATrackSN = "", LengthAndSpeedCaption = "";
        AnsiString SigAspectString = ""; // new at version 0.6
        int ActiveVecPos = Track->GetVectorPositionFromTrackMap(5, HLoc, VLoc, ActiveTrackFoundFlag);
        TTrack::TIMPair InactiveVecPositions = Track->GetVectorPositionsFromInactiveTrackMap(3, HLoc, VLoc, InactiveTrackFoundFlag);
        TTrackElement ActiveTrackElement, InactiveTrackElement;
        if(InactiveTrackFoundFlag)
        {
            InactiveTrackElement = Track->InactiveTrackElementAt(32, InactiveVecPositions.first); // only need one for the name
            IATrackSN = InactiveTrackElement.LocationName;
        }
        if(ActiveTrackFoundFlag)
        {
            ActiveTrackElement = Track->TrackElementAt(449, ActiveVecPos);
            ATrackSN = ActiveTrackElement.LocationName;
            StationEntryStopLinkPos1Str = AnsiString(ActiveTrackElement.StationEntryStopLinkPos1);
            StationEntryStopLinkPos2Str = AnsiString(ActiveTrackElement.StationEntryStopLinkPos2);
            ATrackTN = ActiveTrackElement.ActiveTrackElementName;
            if((ATrackTN != "") && (!InactiveTrackFoundFlag || ((InactiveTrackElement.TrackType != Platform) &&
                                                                (InactiveTrackElement.TrackType != NamedNonStationLocation)) ||
                                    (InactiveTrackElement.LocationName != ActiveTrackElement.ActiveTrackElementName)))
            {
                ShowMessage("Error - Track has timetable name without corresponding plat/named loc");
            }
            if(InactiveTrackFoundFlag && ((InactiveTrackElement.TrackType == Platform) || (InactiveTrackElement.TrackType == NamedNonStationLocation)) &&
               (InactiveTrackElement.LocationName != ActiveTrackElement.ActiveTrackElementName))
            {
                ShowMessage("Error - plat/named loc and track have different names, or plat/named loc named but not track");
            }
            if((ActiveTrackElement.TrackType == Points) || (ActiveTrackElement.TrackType == Bridge) || (ActiveTrackElement.TrackType == Crossover))
            {
                TwoTrack = true;
            }
            Length01Str = AnsiString(ActiveTrackElement.Length01);
            if(Length01Str == "-1")
            {
                Length01Str = "Not Set";
            }
            SpeedLimit01Str = AnsiString(ActiveTrackElement.SpeedLimit01);
            if(SpeedLimit01Str == "-1")
            {
                SpeedLimit01Str = "Not Set";
            }
            if(TwoTrack)
            {
                Length23Str = AnsiString(ActiveTrackElement.Length23);
                if(Length23Str == "-1")
                {
                    Length23Str = "Not Set"; // shouldn't be -1 but leave in
                }
                SpeedLimit23Str = AnsiString(ActiveTrackElement.SpeedLimit23);
                if(SpeedLimit23Str == "-1")
                {
                    SpeedLimit23Str = "Not Set"; // shouldn't be -1 but leave in
                }
                if((ActiveTrackElement.TrackType == Points) && (ActiveTrackElement.SpeedTag < 132))
                {
                    LengthAndSpeedCaption = "Straight track length = " + Length01Str + " m" + '\n' + "Diverging track length = " + Length23Str + " m" + '\n' +
                        "Straight track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Diverging track speed limit = " + SpeedLimit23Str + " km/h";
                }
                else if(ActiveTrackElement.TrackType == Points)
                {
                    LengthAndSpeedCaption = "Left diverging track length = " + Length01Str + " m" + '\n' + "Right diverging track length = " + Length23Str +
                        " m" + '\n' + "Left diverging track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Right diverging track Speed Limit = " +
                        SpeedLimit23Str + " km/h";
                }
                else if(ActiveTrackElement.TrackType == Crossover)
                // crossover links 0 & 1 = diagonal top left to Bottom right, then horizontal, then vertical
                {
                    if((ActiveTrackElement.SpeedTag == 15) || (ActiveTrackElement.SpeedTag == 46))
                    {
                        LengthAndSpeedCaption = "Horizontal track length = " + Length01Str + " m" + '\n' + "Other track length = " + Length23Str + " m" + '\n' +
                            "Horizontal track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Other track speed limit = " + SpeedLimit23Str + " km/h";
                    }
                    else if(ActiveTrackElement.SpeedTag == 47)
                    {
                        LengthAndSpeedCaption = "Horizontal track length = " + Length23Str + " m" + '\n' + "Other track length = " + Length01Str + " m" + '\n' +
                            "Horizontal track speed limit = " + SpeedLimit23Str + " km/h" + '\n' + "Other track speed limit = " + SpeedLimit01Str + " km/h";
                    }
                    else if(ActiveTrackElement.SpeedTag == 45)
                    {
                        LengthAndSpeedCaption = "Vertical track length = " + Length01Str + " m" + '\n' + "Other track length = " + Length23Str + " m" + '\n' +
                            "Vertical track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Other track speed limit = " + SpeedLimit23Str + " km/h";
                    }
                    else if(ActiveTrackElement.SpeedTag == 44)
                    {
                        LengthAndSpeedCaption = "Vertical track length = " + Length23Str + " m" + '\n' + "Other track length = " + Length01Str + " m" + '\n' +
                            "Vertical track speed limit = " + SpeedLimit23Str + " km/h" + '\n' + "Other track speed limit = " + SpeedLimit01Str + " km/h";
                    }
                    else if(ActiveTrackElement.SpeedTag == 16)
                    {
                        LengthAndSpeedCaption = "Top left to bottom right track length = " + Length01Str + " m" + '\n' + "Other track length = " + Length23Str +
                            " m" + '\n' + "Top left to bottom right track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Other track speed limit = " +
                            SpeedLimit23Str + " km/h";
                    }
                }
                else // bridge
                {
                    LengthAndSpeedCaption = "Top track length = " + Length01Str + " m" + '\n' + "Bottom track length = " + Length23Str + " m" + '\n' +
                        "Top track speed limit = " + SpeedLimit01Str + " km/h" + '\n' + "Bottom track speed limit = " + SpeedLimit23Str + " km/h";
                }
            }
            else
            {
                LengthAndSpeedCaption = "Track length = " + Length01Str + " m" + '\n' + "Track speed limit = " + SpeedLimit01Str + " km/h";
            }
        }
        if(ActiveTrackFoundFlag)
        {
            // note that now the "In timetable..." line removed much of the below could be simplified, but leave as is
            // in case wish to resurrect this line for any reason
            ShowTrackFloatFlag = true;
            if(ATrackTN != "") // has a timetable name & therefore has a valid platform or non-station name
            {
                TrackFloat = "Location = " + ATrackTN + '\n' + LengthAndSpeedCaption + '\n' + "ID = " + AnsiString(ActiveTrackElement.ElementID);
            }
            else if(ATrackSN != "") // no timetable name but location name, i.e. a footcrossing
            {
                TrackFloat = "Location = " + ATrackSN + '\n' + LengthAndSpeedCaption + '\n' + "ID = " + AnsiString(ActiveTrackElement.ElementID);
            }
            else if(InactiveTrackFoundFlag) // no timetable name yet but unnamed inactive element at same location (can't be a parapet if active element there)
            {
                TrackFloat = "Location unnamed\n" + LengthAndSpeedCaption + '\n' + "ID = " + AnsiString(ActiveTrackElement.ElementID);
            }
            else // no timetable or location name, just track
            {
                TrackFloat = LengthAndSpeedCaption + '\n' + "Track Element ID = " + AnsiString(ActiveTrackElement.ElementID);
            }
            if(ActiveTrackElement.TrackType == SignalPost) // new for version 0.6
            {
                if(ActiveTrackElement.SigAspect == TTrackElement::ThreeAspect)
                {
                    SigAspectString = "\nThree-aspect signal";
                }
                else if(ActiveTrackElement.SigAspect == TTrackElement::TwoAspect)
                {
                    SigAspectString = "\nTwo-aspect signal";
                }
                else if(ActiveTrackElement.SigAspect == TTrackElement::GroundSignal)
                {
                    SigAspectString = "\nGround signal";
                }
                else
                {
                    SigAspectString = "\nFour-aspect signal";
                }
                TrackFloat += SigAspectString;
            }
//failed points info added at v2.13.0
            if((ActiveTrackElement.TrackType == Points) && ActiveTrackElement.Failed) //failed points
            {
                AnsiString RepairTimeStr;
                TDateTime Now = TrainController->TTClockTime;
                for(TTrack::TFailedElementVector::iterator FPVIt = Track->FailedPointsVector.begin(); FPVIt != Track->FailedPointsVector.end(); FPVIt++)
                {
                    if(ActiveVecPos == FPVIt->TVPos) //found the failed point
                    {
                        if((Now - FPVIt->FailureTime) <= TDateTime(Utilities->RepairDiagnosisTime/1440)) //less than 5 minutes since failed - type of failure not yet identified
                        {
                            RepairTimeStr = "not yet known.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(10.0/1440))
                        {
                            RepairTimeStr = "only a few minutes.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(30.0/1440))
                        {
                            RepairTimeStr = "30 minutes or less.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(60.0/1440))
                        {
                            RepairTimeStr = "30 minutes to an hour.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "1 to 2 hours.";
                        }
                        else if((FPVIt->RepairTime - Now) > TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "over 2 hours.";
                        }
                        break; //no point looking further
                    }
                }
                TrackFloat += "\nPoints failed. Repair time " + RepairTimeStr;
            }
//failed signals info added at v2.13.0
            if((ActiveTrackElement.TrackType == SignalPost) && ActiveTrackElement.Failed) //failed signals
            {
                AnsiString RepairTimeStr;
                TDateTime Now = TrainController->TTClockTime;
                for(TTrack::TFailedElementVector::iterator FPVIt = Track->FailedSignalsVector.begin(); FPVIt != Track->FailedSignalsVector.end(); FPVIt++)
                {
                    if(ActiveVecPos == FPVIt->TVPos) //found the failed signal
                    {
                        if((Now - FPVIt->FailureTime) <= TDateTime(Utilities->RepairDiagnosisTime/1440)) //less than 5 minutes since failed - type of failure not yet identified
                        {
                            RepairTimeStr = "not yet known.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(10.0/1440))
                        {
                            RepairTimeStr = "only a few minutes.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(30.0/1440))
                        {
                            RepairTimeStr = "30 minutes or less.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(60.0/1440))
                        {
                            RepairTimeStr = "30 minutes to an hour.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "1 to 2 hours.";
                        }
                        else if((FPVIt->RepairTime - Now) > TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "over 2 hours.";
                        }
                        break; //no point looking further
                    }
                }
                TrackFloat += "\nSignal failed. Repair time " + RepairTimeStr;
            }
//TSR info added at v2.13.0
            if((ActiveTrackElement.TrackType == Simple) && ActiveTrackElement.Failed) //TSR
            {
                AnsiString RepairTimeStr;
                TDateTime Now = TrainController->TTClockTime;
                for(TTrack::TFailedElementVector::iterator FPVIt = Track->TSRVector.begin(); FPVIt != Track->TSRVector.end(); FPVIt++)
                {
                    if(ActiveVecPos == FPVIt->TVPos) //found the TSR
                    {
                        if((Now - FPVIt->FailureTime) <= TDateTime(Utilities->RepairDiagnosisTime/1440)) //less than 5 minutes since failed - type of failure not yet identified
                        {
                            RepairTimeStr = "not yet known.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(10.0/1440))
                        {
                            RepairTimeStr = "only a few minutes.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(30.0/1440))
                        {
                            RepairTimeStr = "30 minutes or less.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(60.0/1440))
                        {
                            RepairTimeStr = "30 minutes to an hour.";
                        }
                        else if((FPVIt->RepairTime - Now) <= TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "1 to 2 hours.";
                        }
                        else if((FPVIt->RepairTime - Now) > TDateTime(120.0/1440))
                        {
                            RepairTimeStr = "over 2 hours.";
                        }
                        break; //no point looking further
                    }
                }
                TrackFloat += "\nTemporary Speed Restriction in place. Restoration time " + RepairTimeStr;
            }
        } // if(ActiveFoundFlag)
        else if(InactiveTrackFoundFlag) // inactive element but no active element,
                                        // i.e. concourse or non-station name at a blank element
        {
            ShowTrackFloatFlag = true;
            if(InactiveTrackElement.TrackType != Parapet)
            {
                if(IATrackSN == "")
                {
                    TrackFloat = "Location unnamed\nID = " + AnsiString(InactiveTrackElement.ElementID);
                }
                else
                {
                    TrackFloat = "Location = " + IATrackSN + '\n' + "ID = " + AnsiString(InactiveTrackElement.ElementID);
                }
            }
            else // it is a parapet, just show the ID
            {
                TrackFloat = "ID = " + AnsiString(InactiveTrackElement.ElementID);
            }
        }
    }
// end of TrackFloat section

    bool ActionsDueListBoxFloatRequired = false; // identifies which window needs the float
    if(Level1Mode == OperMode && ((TrainStatusInfoOnOffMenuItem->Caption == "Hide Status") || (TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable")))
    // if caption is 'Hide' label is required
    {
        bool FoundFlag;
        AnsiString FormatOneDPStr = "####0.0";
        AnsiString FormatNoDPStr = "#######0";
        AnsiString MaxBrakeStr = "";
        AnsiString SpecialStr = "";
        if(ActionsDueForm->Visible) // added at v2.6.2 to show floating window for trains in actions due list
        {
            if(ActionsDueForm->ActionsDueListBox->MouseInClient && !ActionsDueForm->ActionsDuePanel->MouseInClient && ActionsDueForm->ActionsDueListBoxRightMouseButtonDown)
            {
                int X = ActionsDueForm->ActionsDueListBox->ScreenToClient(MousePoint).x;
                int Y = ActionsDueForm->ActionsDueListBox->ScreenToClient(MousePoint).y;
                int TrainID = -1, ContinuationPos = -1;
                if(GetTrainIDOrContinuationPosition(1, X, Y, TrainID, ContinuationPos))
                {
                    ActionsDueListBoxFloatRequired = true;
                    if(TrainStatusInfoOnOffMenuItem->Caption == "Hide Status")
                    {
                        ShowTrainStatusFloatFlag = true;
                    }
                    if(TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable")
                    {
                        ShowTrainTTFloatFlag = true;
                    }
                    if((TrainID > -1) && (ShowTrainStatusFloatFlag || ShowTrainTTFloatFlag))
                    {
                        TTrain Train = TrainController->TrainVectorAtIdent(53, TrainID);
                        TrainStatusFloat = GetTrainStatusFloat(0, TrainID, FormatNoDPStr, SpecialStr);
                        TrainTTFloat = Train.FloatingTimetableString(1, Train.ActionVectorEntryPtr);
                    }
                    else if(ContinuationPos > -1)
                    {
                        GetTrainFloatingInfoFromContinuation(0, ContinuationPos, FormatNoDPStr, SpecialStr, TrainStatusFloat, TrainTTFloat);
                    }
                }
            }
        }
        if(!ActionsDueListBoxFloatRequired) // condition added at v2.6.2 so only one floating window can show
        {
            int VecPos = Track->GetVectorPositionFromTrackMap(6, HLoc, VLoc, FoundFlag);
            if(FoundFlag && !MouseOverOAPanel) // MouseOverOAPanel added at v2.7.0 to prevent trains showimng behind OA  panel
            {
                if(Track->TrackElementAt(450, VecPos).TrainIDOnElement > -1)
                // if a bridge & 2 trains at that position will select the train with TrainIDOnElement set
                {
                    int TrainID = Track->TrackElementAt(452, VecPos).TrainIDOnElement;
                    if(TrainStatusInfoOnOffMenuItem->Caption == "Hide Status")
                    {
                        ShowTrainStatusFloatFlag = true;
                        TrainStatusFloat = GetTrainStatusFloat(1, TrainID, FormatNoDPStr, SpecialStr);
                    }
                    if(TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable")
                    {
                        ShowTrainTTFloatFlag = true;
                        TTrain Train = TrainController->TrainVectorAtIdent(54, TrainID);
                        TrainTTFloat = Train.FloatingTimetableString(0, Train.ActionVectorEntryPtr);
                    }
                }

                else if(Track->TrackElementAt(666, VecPos).TrackType == Continuation)
                // always give train information if a train present, but if not & either of train status or timetable info
                // selected then give next expected train to enter, or 'No trains expected'
                {
                    TrainStatusFloat = "No trains expected";
                    TrainTTFloat = "No timetable";
                    if(TrainStatusInfoOnOffMenuItem->Caption == "Hide Status")
                    {
                        ShowTrainStatusFloatFlag = true;
                    }
                    if(TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable")
                    {
                        ShowTrainTTFloatFlag = true;
                    }
                    if(!TrainController->ContinuationTrainExpectationMultiMap.empty())
                    {
                        GetTrainFloatingInfoFromContinuation(1, VecPos, FormatNoDPStr, SpecialStr, TrainStatusFloat, TrainTTFloat);
                    }
                }
            }
        }
    }
// end of TrainFloat section
    AnsiString Caption;

    if(!ShowTrackFloatFlag && !ShowTrainStatusFloatFlag && !ShowTrainTTFloatFlag)
    {
        FloatingPanel->Visible = false;
        Utilities->CallLogPop(1485);
        return; // return with label invisible
    }
    else if(ShowTrackFloatFlag && !ShowTrainStatusFloatFlag && !ShowTrainTTFloatFlag)
    {
        Caption = TrackFloat;
    }
    else if(!ShowTrackFloatFlag && ShowTrainStatusFloatFlag && !ShowTrainTTFloatFlag)
    {
        Caption = TrainStatusFloat;
    }
    else if(ShowTrackFloatFlag && ShowTrainStatusFloatFlag && !ShowTrainTTFloatFlag)
    {
        Caption = TrainStatusFloat + '\n' + '\n' + TrackFloat;
    }
    else if(!ShowTrackFloatFlag && !ShowTrainStatusFloatFlag && ShowTrainTTFloatFlag)
    {
        if(TrainStatusFloat == "No trains expected")
        {
            Caption = TrainStatusFloat;
        }
        else
        {
            Caption = TrainTTFloat;
        }
    }
    else if(ShowTrackFloatFlag && !ShowTrainStatusFloatFlag && ShowTrainTTFloatFlag)
    {
        if(TrainStatusFloat == "No trains expected")
        {
            Caption = TrainStatusFloat + '\n' + '\n' + TrackFloat;
        }
        else
        {
            Caption = TrainTTFloat + '\n' + '\n' + TrackFloat;
        }
    }
    else if(!ShowTrackFloatFlag && ShowTrainStatusFloatFlag && ShowTrainTTFloatFlag)
    {
        if(TrainStatusFloat == "No trains expected")
        {
            Caption = TrainStatusFloat;
        }
        else
        {
            Caption = TrainStatusFloat + '\n' + '\n' + TrainTTFloat;
        }
    }
    else if(ShowTrackFloatFlag && ShowTrainStatusFloatFlag && ShowTrainTTFloatFlag)
    {
        if(TrainStatusFloat == "No trains expected")
        {
            Caption = TrainStatusFloat + '\n' + '\n' + TrackFloat;
        }
        else
        {
            Caption = TrainStatusFloat + '\n' + '\n' + TrainTTFloat + '\n' + '\n' + TrackFloat;
        }
    }
    int WindowOffsetLeft = 16;
    int WindowOffsetRight = 16;
    if(ActionsDueListBoxFloatRequired)
    {
        if((ActionsDueForm->Left >= (Interface->Left + Interface->Width)) || ((ActionsDueForm->Left + ActionsDueForm->Width) <= Interface->Left) ||
            (ActionsDueForm->Top >= (Interface->Top + Interface->Height)) || ((ActionsDueForm->Top + ActionsDueForm->Height) <= Interface->Top))
            //AD form outside interface so floating window in TRH corner of mainscreen
        {
            FloatingLabel->Caption = Caption; //added here as return in this function, see below for information
            FloatingPanel->Visible = true;
            FloatingPanel->Left = MainScreen->Left + MainScreen->Width - FloatingPanel->Width;
            FloatingPanel->Top = MainScreen->Top;
            FloatingPanel->BringToFront();
            Utilities->CallLogPop(2544);
            return;
        }
        else
        {
            WindowOffsetLeft = 96; //was 32;
            WindowOffsetRight = 96; //was 64;
        }
    }
    FloatingLabel->Caption = Caption; // set this here so dimensions correct in calculations, moved from below at v2.7.0
    FloatingPanel->Visible = true; // need this or dimensions still not valid, moved from below at v2.7.0

    int Left = ScreenX + MainScreen->Left + WindowOffsetRight; // so lhs of window is WindowOffset to the right of the mouse pos
// this offset is because window position is relative to the interface form, whereas ScreenX & Y are relative to the MainScreen, which is
// offset 32 to the right and 95 down from the interface form
    if((Left + FloatingPanel->Width) > MainScreen->Left + MainScreen->Width)
    {
        Left = ScreenX - FloatingPanel->Width + 32 - WindowOffsetLeft;
    }
// so rhs of window is 32 - WindowOffset to the left of the mouse pos (+32 would be at mouse pos)
    int Top = ScreenY + MainScreen->Top + 16; // so top of window is one element below the mouse pos (ScreenY + MainScreen->Top would be at mouse pos)

    if((Top + FloatingPanel->Height) > MainScreen->Top + MainScreen->Height)
    {
        Top = ScreenY - FloatingPanel->Height + 79; // so bottom of window is one element above the mouse pos (95 would be at mouse pos)
        // but, top may now be off the top of the screen, if so position at the top of the screen, as always need to see the top, if have to
        // lose something then it's best to be from the bottom
        if(Top < 30) // use 30 instead of MainScreen->Top [95] as top can go off MainScreen providing it doesn't reach the information panel, as that would
                     // obscure the window
        {
            Top = 30;
        }
    }
/* if((Left != FloatingPanel->Left) || (Top != FloatingPanel->Top))    //dropped at v2.7.0 as causes more flicker than allowing window to move with mouse
    {
        FloatingPanel->Visible = false; // so doesn't flicker when reposition
        FloatingPanel->Left = Left;
        FloatingPanel->Top = Top;
        Utilities->CallLogPop(1917);
        return;
    }
*/

    FloatingPanel->Left = Left; // new at v2.7.0 in place of above
    FloatingPanel->Top = Top;

// FloatingLabel->Caption = Caption;  moved up at v2.7.0
// FloatingPanel->Visible = true; //  moved up at v2.7.0
    FloatingPanel->BringToFront();
    Utilities->CallLogPop(746);
}

// ---------------------------------------------------------------------------

void TInterface::GetTrainFloatingInfoFromContinuation(int Caller, int VecPos, AnsiString FormatNoDPStr, AnsiString SpecialStr, AnsiString &TrainStatusFloat,
                                                      AnsiString &TrainTTFloat)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetTrainFloatingInfoFromContinuation");
    TTrainController::TContinuationTrainExpectationMultiMapIterator CTEIt = TrainController->ContinuationTrainExpectationMultiMap.begin();
    int LineSpeedLimit = Track->TrackElementAt(906, VecPos).SpeedLimit01; // speed only in 01 as a continuation
    float EntrySpeed;
    if(CTEIt != TrainController->ContinuationTrainExpectationMultiMap.end())
    {
        while((CTEIt != TrainController->ContinuationTrainExpectationMultiMap.end()) && ((CTEIt->second.VectorPosition != VecPos) ||
                                                                                         (CTEIt->second.TrainDataEntryPtr->TrainOperatingDataVector.at(CTEIt->second.RepeatNumber).RunningEntry != NotStarted)))
        {
            CTEIt++;
        }
        if(CTEIt != TrainController->ContinuationTrainExpectationMultiMap.end())
        {
            TTrainDataEntry *TTDEPtr = CTEIt->second.TrainDataEntryPtr;
            AnsiString ServiceReferenceInfo = "";
            // Repeat information
            if(TTDEPtr->NumberOfTrains > 1) // Service reference information
            {
                if(CTEIt->second.RepeatNumber == 0)
                {
                    if(CTEIt->second.HeadCode != TTDEPtr->ServiceReference)
                    {
                        ServiceReferenceInfo = "\nFirst service of ref. " + TTDEPtr->ServiceReference;
                    }
                    else
                    {
                        ServiceReferenceInfo = "\nFirst service";
                    }
                }
                else if(CTEIt->second.HeadCode == TTDEPtr->ServiceReference)
                {
                    ServiceReferenceInfo = "\nRepeat service no. " + AnsiString(CTEIt->second.RepeatNumber);
                }
                else
                {
                    ServiceReferenceInfo = "\nRepeat service no. " + AnsiString(CTEIt->second.RepeatNumber) + " of ref. " + TTDEPtr->ServiceReference;
                }
            }
            else
            {
                if(CTEIt->second.HeadCode != TTDEPtr->ServiceReference)
                {
                    ServiceReferenceInfo = "\nService reference " + TTDEPtr->ServiceReference;
                }
            }
            if(TTDEPtr->ActionVector.at(0).SignallerControl) // entry at 0 is the start entry
            {
                SpecialStr = "\nTrain under signaller control";
                EntrySpeed = TTDEPtr->SignallerSpeed;
                if(EntrySpeed > LineSpeedLimit)
                {
                    EntrySpeed = LineSpeedLimit;
                }
            }
            else
            {
                EntrySpeed = TTDEPtr->StartSpeed;
                if(EntrySpeed > LineSpeedLimit)
                {
                    EntrySpeed = LineSpeedLimit;
                }
            }
            if((CTEIt->first + TDateTime(1.0 / 1440)) < TrainController->TTClockTime) // has to be at least 1 min late to show as late
            {
                TDateTime TempTime = CTEIt->first;
// need this because CTEIt points to a const object and shouldn't use FormatString on a const object
                TrainStatusFloat = CTEIt->second.HeadCode + ": " + CTEIt->second.Description + ServiceReferenceInfo + "\nEntry speed " +
                    AnsiString::FormatFloat(FormatNoDPStr, EntrySpeed) + "km/h" + SpecialStr + "\nDelayed, was due at " + Utilities->Format96HHMM(TempTime);
            }
            else
            {
                TDateTime TempTime = CTEIt->first;
// need this because CTEIt points to a const object and shouldn't use FormatString on a const object
                TrainStatusFloat = CTEIt->second.HeadCode + ": " + CTEIt->second.Description + ServiceReferenceInfo + "\nEntry speed " +
                    AnsiString::FormatFloat(FormatNoDPStr, EntrySpeed) + "km/h" + SpecialStr + "\nExpected at " + Utilities->Format96HHMM(TempTime);
            }
            if(TrainTTInfoOnOffMenuItem->Caption == "Hide Timetable")
            {
                if(!TTDEPtr->ActionVector.at(0).SignallerControl) // if signaller control there's no timetable & SpecialStr covers this
                {
                    TrainTTFloat = TrainController->ContinuationEntryFloatingTTString(0, TTDEPtr, CTEIt->second.RepeatNumber, CTEIt->second.IncrementalMinutes,
                                                                                      CTEIt->second.IncrementalDigits);
                }
            }
        }
    }
    Utilities->CallLogPop(2262);
}

// ---------------------------------------------------------------------------

AnsiString TInterface::GetTrainStatusFloat(int Caller, int TrainID, AnsiString FormatNoDPStr, AnsiString SpecialStr)
// new at v2.6.2 to make it easier to show also from actions due panel
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",GetTrainStatusFloat");
    AnsiString HeadCode = "", ServiceReferenceInfo = "", Status = "", CurrSpeedStr = "", BrakePCStr = "", NextStopStr = "", TimeLeftStr = "",
               TimeToNextMovementStr = "", MassStr = "", PowerStr = "";
    AnsiString FormatOneDPStr = "####0.0", MaxBrakeStr = "", MaxSpeedStr = "", MaxMPHStr = "", TrainStatusFloat; //MaxMPHStr added at v2.15.0

    double CurrSpeed;
    TTrain Train = TrainController->TrainVectorAtIdent(1, TrainID);
    MassStr = AnsiString::FormatFloat(FormatNoDPStr, ((double)Train.Mass) / 1000); // Te
    PowerStr = AnsiString::FormatFloat(FormatNoDPStr, Train.PowerAtRail / 1000 / 0.8); // kW
    if(Train.BeingCalledOn)
    {
        MaxSpeedStr = "30";
        MaxMPHStr = "19mph";
    }
    else
    {
        MaxSpeedStr = AnsiString::FormatFloat(FormatNoDPStr, Train.MaxRunningSpeed);
        MaxMPHStr = AnsiString::FormatFloat(FormatNoDPStr, (Train.MaxRunningSpeed * 5 / 8)) + "mph";
    }
    TDateTime ElapsedDeltaT = TrainController->TTClockTime - Train.EntryTime;
    TDateTime FirstHalfTimeDeltaT = Train.ExitTimeHalf - Train.EntryTime;
    TDateTime SecondHalfTimeDeltaT = Train.ExitTimeFull - Train.EntryTime - FirstHalfTimeDeltaT;
    TDateTime TimeLeft;
    double BrakePCRate = Train.BrakeRate * 100.0 / Train.MaxBrakeRate;
    MaxBrakeStr = AnsiString::FormatFloat(FormatNoDPStr, (Train.MaxBrakeRate * Train.Mass / 9810));
    HeadCode = Train.HeadCode;
    if(Train.TrainDataEntryPtr->NumberOfTrains > 1) // Service reference information added at v0.6b
    {
        if(Train.RepeatNumber == 0)
        {
            if(HeadCode != Train.TrainDataEntryPtr->ServiceReference)
            {
                ServiceReferenceInfo = "\nFirst service of ref. " + Train.TrainDataEntryPtr->ServiceReference;
            }
            else
            {
                ServiceReferenceInfo = "\nFirst service";
            }
        }
        else if(HeadCode == Train.TrainDataEntryPtr->ServiceReference)
        {
            ServiceReferenceInfo = "\nRepeat service no. " + AnsiString(Train.RepeatNumber);
        }
        else
        {
            ServiceReferenceInfo = "\nRepeat service no. " + AnsiString(Train.RepeatNumber) + " of ref. " + Train.TrainDataEntryPtr->ServiceReference;
        }
    }
    else
    {
        if(HeadCode != Train.TrainDataEntryPtr->ServiceReference)
        {
            ServiceReferenceInfo = "\nService reference " + Train.TrainDataEntryPtr->ServiceReference;
        }
    }
    if(Train.Stopped())
    {
        if(Train.SignallerStopped)
        {
            Status = "Stopped on signaller's instruction"; // if stopped for any other reason that will diplay
        }
        if(Train.NotInService)
        {
            Status = "Not in service"; // not used so far but leave it in
        }
        if(Train.StoppedAtBuffers)
        {
            Status = "Stopped at buffers";
        }
        if(Train.StoppedAtSignal)
        {
            Status = "Stopped at signal";
        }
        if(Train.StoppedForTrainInFront)
        {
            Status = "Stopped - forward track occupied"; // before station stop as want to display station stop if that set
        }
        if(Train.RevisedStoppedAtLoc())
        {
            Status = "Stopped at " + Train.ActionVectorEntryPtr->LocationName;
        }
        if((Train.RevisedStoppedAtLoc()) && (Train.StoppedForTrainInFront))
        {
            Status = "Stopped at " + Train.ActionVectorEntryPtr->LocationName + " + forward track occupied";
        }
        if(Train.StoppedWithoutPower)
        {
            if(Train.TrainFailed)
            {
                Status = "Stopped without power - train failed";
            }
            else
            {
                Status = "Stopped without power";
            }
        }
        if(Train.StoppedAfterSPAD)
        {
            Status = "Stopped - signal passed at danger";
        }
        if(Train.Derailed)
        {
            Status = "Derailed";
        }
        if(Train.Crashed)
        {
            Status = "Crashed";
        }
        CurrSpeed = 0;
    }
    else if(Train.OneLengthAccelDecel)
    {
        if(Train.FirstHalfMove)
        {
            Status = "Accelerating"; // just display a linear speed rise over half length
            BrakePCRate = 0; // reset to proper value during braking
            CurrSpeed = Train.EntrySpeed + ((Train.ExitSpeedHalf - Train.EntrySpeed) * (double(ElapsedDeltaT) / double(FirstHalfTimeDeltaT)));
        }
        else
        {
            BrakePCRate = Train.BrakeRate * 100.0 / Train.MaxBrakeRate;
            if(BrakePCRate < 55)
            {
                Status = "Light braking";
            }
            else if(BrakePCRate < 90)
            {
                Status = "Heavy braking";
            }
            else
            {
                Status = "Emergency braking";
            }
            CurrSpeed = Train.ExitSpeedHalf - 3.6 * (Train.BrakeRate * double(TrainController->TTClockTime - Train.ExitTimeHalf) * 86400.0);
        }
    }
    else if(Train.BrakeRate > 0.01)
    {
        if(BrakePCRate < 55)
        {
            Status = "Light braking";
        }
        else if(BrakePCRate < 90)
        {
            Status = "Heavy braking";
        }
        else
        {
            Status = "Emergency braking";
        }
        CurrSpeed = Train.EntrySpeed - 3.6 * (Train.BrakeRate * double(ElapsedDeltaT) * 86400.0);
    }

    else if((Train.BrakeRate <= 0.01) && (Train.ExitSpeedHalf > (Train.EntrySpeed + 0.01)) && Train.FirstHalfMove)
    {
        Status = "Accelerating"; // just display a linear speed rise over half length
        CurrSpeed = Train.EntrySpeed + ((Train.ExitSpeedHalf - Train.EntrySpeed) * (double(ElapsedDeltaT) / double(FirstHalfTimeDeltaT)));
    }

    else if((Train.BrakeRate <= 0.01) && (Train.ExitSpeedFull > (Train.ExitSpeedHalf + 0.01)) && !Train.FirstHalfMove)
    {
        Status = "Accelerating";
        CurrSpeed = Train.ExitSpeedHalf +
            ((Train.ExitSpeedFull - Train.ExitSpeedHalf) * (double(ElapsedDeltaT - FirstHalfTimeDeltaT) / double(SecondHalfTimeDeltaT)));
    }

    else if((Train.BrakeRate <= 0.01) && (Train.ExitSpeedFull <= Train.ExitSpeedHalf) && !Train.FirstHalfMove)
    {
        if(Train.PowerAtRail < 1)
        {
            if(Train.TrainFailed)
            {
                Status = "Coasting - train failed";
            }
            else
            {
                Status = "Coasting - no power";
            }
            CurrSpeed = Train.ExitSpeedFull;
        }
        else
        {
            Status = "Constant speed";
            CurrSpeed = Train.ExitSpeedFull;
        }
    }

    else // No braking, first half move, ExitSpeedHalf <= EntrySpeed
    {
        if(Train.PowerAtRail < 1) // as designed there is no way a vehicle can coast without having failed
        {
            if(Train.TrainFailed)
            {
                Status = "Coasting - train failed";
            }
            else
            {
                Status = "Coasting - no power";
            }
            CurrSpeed = Train.ExitSpeedHalf;
        }
        else
        {
            Status = "Constant speed";
            CurrSpeed = Train.ExitSpeedHalf;
        }
    }
    if(Train.TimetableFinished)
    {
        if(Train.TrainMode == Signaller)
        {
            NextStopStr = "At signaller's discretion";
        }
        else
        {
            NextStopStr = "None";
        }
    }
    else
    {
        NextStopStr = Train.FloatingLabelNextString(0, Train.ActionVectorEntryPtr);
    }
    if(Train.TrainMode == Signaller)
    {
        SpecialStr = "Train under signaller control" + AnsiString('\n');
    }
    else if(Train.BeingCalledOn && !Train.RevisedStoppedAtLoc())
    {
        SpecialStr = "Restricted speed - being called on" + AnsiString('\n');
    }
    double RemTimeHalf = 86400.0 * double(Train.ExitTimeHalf - TrainController->TTClockTime);
    if(RemTimeHalf < 0)
    {
        RemTimeHalf = 0;
    }
    double RemTimeFull = 86400.0 * double(Train.ExitTimeFull - TrainController->TTClockTime);
    if(RemTimeFull < 0)
    {
        RemTimeFull = 0;
    }
    if(RemTimeHalf > 0)
    {
        TimeLeft = RemTimeHalf;
    }
    else
    {
        TimeLeft = RemTimeFull;
    }
    TimeToNextMovementStr = "Time to next movement (sec) = " + TimeLeftStr.FormatFloat(FormatOneDPStr, double(TimeLeft));
    //addition at v2.13.0
    AnsiString OverallDelayString = AnsiString('\n');
    if(int(Train.DelayedRandMins) > 0)
    {
        if(int(Train.DelayedRandMins) > 1)
        {
            OverallDelayString = AnsiString("\nTotal random delay ") + AnsiString(int(Train.DelayedRandMins)) + AnsiString(" minutes\n");
        }
        else
        {
            OverallDelayString = AnsiString("\nTotal random delay 1 minute\n");
        }
    }
    if(Train.Stopped())
    {
        TimeToNextMovementStr = "";
    }

    if(Train.StoppedAtLocation && (Train.ActionVectorEntryPtr->DepartureTime > TDateTime(-1)))  //if departure not next action then ignore NewDelay
    {                                                                                          //added at v2.13.0
        if(int(Train.NewDelay) == 1)
        {
            TrainStatusFloat = HeadCode + ": " + Train.TrainDataEntryPtr->Description + ServiceReferenceInfo + '\n' + "Maximum train speed " + MaxSpeedStr +
                "km/h (" + MaxMPHStr + "); Power " + PowerStr + "kW" + '\n' + "Mass " + MassStr + "Te; Brakes " + MaxBrakeStr + "Te" + '\n' + SpecialStr + Status + '\n' +
                "New random delay here of 1 minute" + OverallDelayString + AnsiString("\nNext: ") + NextStopStr;
        }
        else if(int(Train.NewDelay) > 1)
        {
            TrainStatusFloat = HeadCode + ": " + Train.TrainDataEntryPtr->Description + ServiceReferenceInfo + '\n' + "Maximum train speed " + MaxSpeedStr +
                "km/h (" + MaxMPHStr + "); Power " + PowerStr + "kW" + '\n' + "Mass " + MassStr + "Te; Brakes " + MaxBrakeStr + "Te" + '\n' + SpecialStr + Status + '\n' +
                "New random delay here of " + AnsiString(int(Train.NewDelay)) + " minutes" + OverallDelayString + AnsiString("\nNext: ") + NextStopStr;
        }
        else //int(NewDelay) == 0
        {
            TrainStatusFloat = HeadCode + ": " + Train.TrainDataEntryPtr->Description + ServiceReferenceInfo + '\n' + "Maximum train speed " + MaxSpeedStr +
                "km/h (" + MaxMPHStr + "); Power " + PowerStr + "kW" + '\n' + "Mass " + MassStr + "Te; Brakes " + MaxBrakeStr + "Te" + '\n' + SpecialStr + Status +
                OverallDelayString + AnsiString("\nNext: ") + NextStopStr;
        }
    }
    else if(Train.Stopped()) //stopped anywhere else or not a departure next
    {
        TrainStatusFloat = HeadCode + ": " + Train.TrainDataEntryPtr->Description + ServiceReferenceInfo + '\n' + "Maximum train speed " + MaxSpeedStr +
            "km/h (" + MaxMPHStr + "); Power " + PowerStr + "kW" + '\n' + "Mass " + MassStr + "Te; Brakes " + MaxBrakeStr + "Te" + '\n' + SpecialStr + Status +
            OverallDelayString + AnsiString("\nNext: ") + NextStopStr;
            //changed to 'Next timetabled action:' at v2.13.0 instead of 'Next:' to make clear it doesn't include delays
    }
    else //added mph at v2.15.0
    {
        TrainStatusFloat = HeadCode + ": " + Train.TrainDataEntryPtr->Description + ServiceReferenceInfo + '\n' + "Maximum train speed " + MaxSpeedStr +
            "km/h (" + MaxMPHStr + "); Power " + PowerStr + "kW" + '\n' + "Mass " + MassStr + "Te; Brakes " + MaxBrakeStr + "Te" + '\n' + SpecialStr + Status + ": " +
            CurrSpeedStr.FormatFloat(FormatNoDPStr, CurrSpeed) + "km/h (" + CurrSpeedStr.FormatFloat(FormatNoDPStr, (CurrSpeed * 5 / 8)) + "mph)" +
            OverallDelayString + AnsiString("\nNext: ") + NextStopStr;
    }                          //changed to 'Next timetabled action:' at v2.13.0 instead of 'Next:' to make clear it doesn't include delays
    Utilities->CallLogPop(2263);
    return(TrainStatusFloat);
}

// ---------------------------------------------------------------------------

void TInterface::FlashingGraphics(int Caller, TDateTime Now)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",FlashingGraphics");
//deal with any failed track elements - flash in zoom-out mode - added at v2.13.0
    if(Display->ZoomOutFlag)
    {
        if(!Track->FailedPointsVector.empty())
        {
            for(unsigned int x = 0; x < Track->FailedPointsVector.size(); x++)
            {
                if(WarningFlash)
                {
                    Display->PlotSmallOutput(26, Track->TrackElementAt(1536, Track->FailedPointsVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1542, Track->FailedPointsVector.at(x).TVPos).VLoc * 4, RailGraphics->smBlack);
                }
                else
                {
                    Display->PlotSmallOutput(27, Track->TrackElementAt(1537, Track->FailedPointsVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1543, Track->FailedPointsVector.at(x).TVPos).VLoc * 4, RailGraphics->smSolidBgnd);
                }
            }
        }
        if(!Track->FailedSignalsVector.empty())
        {
            for(unsigned int x = 0; x < Track->FailedSignalsVector.size(); x++)
            {
                if(WarningFlash)
                {
                    Display->PlotSmallOutput(28, Track->TrackElementAt(1538, Track->FailedSignalsVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1544, Track->FailedSignalsVector.at(x).TVPos).VLoc * 4, RailGraphics->smBlack);
                }
                else
                {
                    Display->PlotSmallOutput(29, Track->TrackElementAt(1539, Track->FailedSignalsVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1545, Track->FailedSignalsVector.at(x).TVPos).VLoc * 4, RailGraphics->smSolidBgnd);
                }
            }
        }
        if(!Track->TSRVector.empty())
        {
            for(unsigned int x = 0; x < Track->TSRVector.size(); x++)
            {
                if(WarningFlash)
                {
                    Display->PlotSmallOutput(30, Track->TrackElementAt(1540, Track->TSRVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1546, Track->TSRVector.at(x).TVPos).VLoc * 4, RailGraphics->smBlack);
                }
                else
                {
                    Display->PlotSmallOutput(31, Track->TrackElementAt(1541, Track->TSRVector.at(x).TVPos).HLoc * 4,
                        Track->TrackElementAt(1547, Track->TSRVector.at(x).TVPos).VLoc * 4, RailGraphics->smSolidBgnd);
                }
            }
        }
    }

// following section checks to see if GapFlashFlag set & flashes the Gap graphics if so
// Gap flashing is cancelled on any mousedown event
// deal with flashing GapFlash graphics (only in basic mode so no need to check for trains)
    if(Track->GapFlashFlag && !Display->ZoomOutFlag)
    {
        if(WarningFlash)
        {
            Track->GapFlashGreen->PlotOverlay(4, Display); // only plotted if PlotOverlay reset
            Track->GapFlashRed->PlotOverlay(5, Display);
        }
        else
        {
            Track->GapFlashGreen->PlotOriginal(17, Display); // only plotted if PlotOverlay set
            Track->GapFlashRed->PlotOriginal(18, Display);
        }
    }
    if(Track->GapFlashFlag && Display->ZoomOutFlag)
    {
        if(WarningFlash)
        {
            Display->PlotSmallOutput(0, Track->TrackElementAt(454, Track->GapFlashGreenPosition).HLoc * 4,
                                     Track->TrackElementAt(455, Track->GapFlashGreenPosition).VLoc * 4, RailGraphics->smBrightGreen);
            Display->PlotSmallOutput(1, Track->TrackElementAt(456, Track->GapFlashRedPosition).HLoc * 4,
                                     Track->TrackElementAt(457, Track->GapFlashRedPosition).VLoc * 4, RailGraphics->smRed);
            Display->Update();
        }
        else
        {
            Display->PlotSmallOutput(2, Track->TrackElementAt(458, Track->GapFlashGreenPosition).HLoc * 4,
                                     Track->TrackElementAt(459, Track->GapFlashGreenPosition).VLoc * 4, RailGraphics->smSolidBgnd);
            Display->PlotSmallOutput(3, Track->TrackElementAt(460, Track->GapFlashRedPosition).HLoc * 4,
                                     Track->TrackElementAt(461, Track->GapFlashRedPosition).VLoc * 4, RailGraphics->smSolidBgnd);
            Display->Update();
        }
    }
// deal with gap setting - added at v2.6.1 to make location easier
    if((WarningFlash && Level2TrackMode == GapSetting) && Display->ZoomOutFlag)
    {
        Display->PlotSmallOutput(22, Track->GetGapHLoc() * 4, Track->GetGapVLoc() * 4, RailGraphics->smRed);
    }
    if((WarningFlash && Level2TrackMode == GapSetting) && !Display->ZoomOutFlag)
    {
        Display->Ellipse(2, Track->GetGapHLoc() * 16, Track->GetGapVLoc() * 16, clB0G0R5);
    }
    if((!WarningFlash && Level2TrackMode == GapSetting) && Display->ZoomOutFlag)
    {
        Display->PlotSmallOutput(23, Track->GetGapHLoc() * 4, Track->GetGapVLoc() * 4, RailGraphics->smYellow);
    }
    if((!WarningFlash && Level2TrackMode == GapSetting) && !Display->ZoomOutFlag)
    {
        Display->Ellipse(3, Track->GetGapHLoc() * 16, Track->GetGapVLoc() * 16, clB5G5R5);
    }
// deal with other flashing graphics
    if(Track->RouteFlashFlag && !Display->ZoomOutFlag)
    {
        if((Now - RouteFlashStartTime) < TDateTime(RouteFlashDuration / 86400))
        {
            // cancel if train is moving & arrives on any part of flashing route
            if(MovingTrainPresentOnFlashingRoute(0))
            {
                Track->RouteFlashFlag = false;
                RevertToOriginalRouteSelector(7);
                ClearandRebuildRailway(18); // because using ConstructRoute->RouteFlash.PlotOriginal() can plot wrong point fillet as well as
                                            // original (if proposed route would change point). With this can dispense with ConstructRoute->RouteFlash.PlotOriginal()
                Utilities->CallLogPop(75);
                return;
            }
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Route setting in progress";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Route setting in progress";
            }
            if(WarningFlash)
            {
                ConstructRoute->RouteFlash.PlotRouteOverlay(0);
            }
            else
            {
                ConstructRoute->RouteFlash.PlotRouteOriginal(0);
            }
        }
        else
        {
// ConstructRoute->RouteFlash.PlotOriginal(); don't need with clearand....
// stop clock while converting route as can take several seconds
            TrainController->StopTTClockFlag = true; // so TTClock stopped during MasterClockTimer function
            TrainController->RestartTime = TrainController->TTClockTime;
            if(PreferredRouteFlag)
            {
                ConstructRoute->ConvertAndAddPreferredRouteSearchVector(1, ConstructRoute->ReqPosRouteID, AutoSigsFlag);
            }
            else
            {
                ConstructRoute->ConvertAndAddNonPreferredRouteSearchVector(1, ConstructRoute->ReqPosRouteID);
            }
            ConstructRoute->ClearRoute(); // clear it immediately after use so as not to clutter the errorlog
            TrainController->BaseTime = TDateTime::CurrentDateTime();
            TrainController->StopTTClockFlag = false;
            Track->RouteFlashFlag = false;
            RevertToOriginalRouteSelector(8);
            ClearandRebuildRailway(19); // if drop this ensure replot trains after replot routes else route will overwrite a train
        }
    }
    if(Track->RouteFlashFlag && Display->ZoomOutFlag) // must have entered RouteFlash from normal screen so button states stored
    // dropped ZoomOutButton when route or point flashing, but leave this section in in case need to reinstate
    // no need to call Clearand... as that is called when revert to normal mode
    {
        if((Now - RouteFlashStartTime) >= TDateTime(RouteFlashDuration / 86400))
        {
            Track->RouteFlashFlag = false;
            if(PreferredRouteFlag)
            {
                ConstructRoute->ConvertAndAddPreferredRouteSearchVector(2, ConstructRoute->ReqPosRouteID, AutoSigsFlag);
            }
            else
            {
                ConstructRoute->ConvertAndAddNonPreferredRouteSearchVector(2, ConstructRoute->ReqPosRouteID);
            }
            ConstructRoute->ClearRoute(); // clear it immediately after use so as not to clutter the errorlog
        }
    }
    if(Track->PointFlashFlag && !Display->ZoomOutFlag)
    {
        if((Now - PointFlashStartTime) < TDateTime((PointsFlashDuration) / 86400))
        {
            // cancel if train is present on or enters a flashing point, either selected or diverging
            if((PointFlashVectorPosition > -1) && (Track->TrackElementAt(463, PointFlashVectorPosition).TrainIDOnElement > -1))
            {
                PointFlash->PlotOriginal(19, Display);
                Track->PointFlashFlag = false;
                DivergingPointVectorPosition = -1;
                Utilities->CallLogPop(76);
                return;
            }
            if((DivergingPointVectorPosition > -1) && (Track->TrackElementAt(464, DivergingPointVectorPosition).TrainIDOnElement > -1))
            {
                PointFlash->PlotOriginal(20, Display);
                Track->PointFlashFlag = false;
                DivergingPointVectorPosition = -1;
                Utilities->CallLogPop(77);
                return;
            }
            if(WarningFlash)
            {
                PointFlash->LoadOriginalScreenGraphic(3);
                PointFlash->PlotOverlay(6, Display);
            }
            else
            {
                PointFlash->PlotOriginal(21, Display);
            }
        }
        else
        {
            PointFlash->PlotOriginal(22, Display);
            int Att = Track->TrackElementAt(465, PointFlashVectorPosition).Attribute;
            Track->TrackElementAt(466, PointFlashVectorPosition).Attribute = 1 - Att;
            if(DivergingPointVectorPosition > -1)
            {
                Att = Track->TrackElementAt(467, DivergingPointVectorPosition).Attribute;
                Track->TrackElementAt(468, DivergingPointVectorPosition).Attribute = 1 - Att;
                Track->PlotPoints(1, Track->TrackElementAt(471, DivergingPointVectorPosition), Display, false);
            }
            Track->PlotPoints(2, Track->TrackElementAt(474, PointFlashVectorPosition), Display, false);
            Display->Update(); // resurrected when Update() dropped from PlotOutput etc
            Track->PointFlashFlag = false;
            DivergingPointVectorPosition = -1;
        }
    }
    if(Track->PointFlashFlag && Display->ZoomOutFlag)
    // dropped ZoomOutButton when point flashing but leave this section in in case need to reinstate
    {
        if((Now - PointFlashStartTime) < TDateTime((PointsFlashDuration) / 86400))
        {
            int Att = Track->TrackElementAt(475, PointFlashVectorPosition).Attribute;
            Track->TrackElementAt(476, PointFlashVectorPosition).Attribute = 1 - Att;
            if(DivergingPointVectorPosition > -1)
            {
                Att = Track->TrackElementAt(477, DivergingPointVectorPosition).Attribute;
                Track->TrackElementAt(478, DivergingPointVectorPosition).Attribute = 1 - Att;
            }
            Track->PointFlashFlag = false;
            DivergingPointVectorPosition = -1;
        }
    }
// deal with changing level crossings
    if(!Track->ChangingLCVector.empty() && (Level2OperMode != Paused))
    {
        int H;
        int V;

        for(unsigned int x = 0; x < Track->ChangingLCVector.size(); x++)
        {
            bool Manual = false;
            if(Track->ChangingLCVector.at(x).TypeOfRoute == 2) // manual
            {
                Manual = true;
            }
            H = Track->ChangingLCVector.at(x).HLoc;
            V = Track->ChangingLCVector.at(x).VLoc;
            if((Now - Track->ChangingLCVector.at(x).StartTime) < TDateTime((Track->ChangingLCVector.at(x).ChangeDuration) / 86400))
            // still flashing
            {
                if(WarningFlash)
                {
                    if(Track->ChangingLCVector.at(x).BarrierState == TTrack::Raising) // closing to trains
                    {
                        Track->PlotRaisedLinkedLevelCrossingBarriers(1, Track->ChangingLCVector.at(x).BaseElementSpeedTag, H, V, Display);
// always plots red when raising
                    }
                    else
                    {
                        Track->PlotLoweredLinkedLevelCrossingBarriers(0, Track->ChangingLCVector.at(x).BaseElementSpeedTag, H, V,
                                                                      Track->ChangingLCVector.at(x).TypeOfRoute, Display, Manual);
                    }
                }
                else
                {
                    Track->PlotLCBaseElementsOnly(2, Track->ChangingLCVector.at(x).BarrierState, Track->ChangingLCVector.at(x).BaseElementSpeedTag, H, V,
                                                  Track->ChangingLCVector.at(x).TypeOfRoute, Display);
                }
            }
            else
            // flashing period finished
            {
                if(Track->ChangingLCVector.at(x).BarrierState == TTrack::Raising)
                {
                    Track->PlotRaisedLinkedLevelCrossingBarriers(2, Track->ChangingLCVector.at(x).BaseElementSpeedTag, H, V, Display);
// always plot red when fully raised
                    Track->SetLinkedLevelCrossingBarrierAttributes(4, H, V, 0); // only set attr to 0 when fully raised
                    // attributes set to 2 when changing state, now reset to 0, no other actions needed
                }
                else
                // barriers lowering
                {
                    Track->PlotLoweredLinkedLevelCrossingBarriers(1, Track->ChangingLCVector.at(x).BaseElementSpeedTag, H, V,
                                                                  Track->ChangingLCVector.at(x).TypeOfRoute, Display, Manual);
                    Track->SetLinkedLevelCrossingBarrierAttributes(5, H, V, 1); // only set attr to 1 when fully lowered
                    bool FoundFlag;
                    int TVPos = Track->GetVectorPositionFromTrackMap(46, H, V, FoundFlag);
                    if(!FoundFlag)
                    {
                        throw Exception("Failed to find a route at LC position HLoc = " + (AnsiString)H + " VLoc = " + (AnsiString)V);
                    }
                    int RouteNumber;
                    AllRoutes->GetRouteTypeAndNumber(24, TVPos, 0, RouteNumber); // use 0 for LinkPos, could be 1 or 0 as only a single track element
                                                                                 // don't need returned value of RouteType
                    if(RouteNumber > -1) // if train crashed then there won't be a routenumber
                    {
                        AllRoutes->GetFixedRouteAt(196, RouteNumber).SetRouteSignals(8);
                    }
                }
            }
        }
        for(int x = Track->ChangingLCVector.size() - 1; x >= 0; x--)
        {
            // now transfer lowering barrier object from the ChangingLCVector to the BarriersDownVector if lowering, reset the start timer (to time the barrier down period)
            // and for either raising or lowering erase the object from the ChangingLCVector
            if(!Track->IsLCBarrierFlashingAtHV(0, Track->ChangingLCVector.at(x).HLoc, Track->ChangingLCVector.at(x).VLoc))
            {
                if(Track->ChangingLCVector.at(x).BarrierState == TTrack::Lowering)
                {
                    Track->ChangingLCVector.at(x).StartTime = TrainController->TTClockTime;
                    Track->ChangingLCVector.at(x).BarrierState = TTrack::Down;
                    Track->BarriersDownVector.push_back(Track->ChangingLCVector.at(x));
                }
                Track->ChangingLCVector.erase(Track->ChangingLCVector.begin() + x);
            }
        }
    }
    Utilities->CallLogPop(747);
}

// ---------------------------------------------------------------------------

void TInterface::SetSaveMenuAndButtons(int Caller)
// set boundary, Home, NewHome, ZoomOut, CallingOn buttons & menu items as appropriate
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetSaveMenuAndButtons");

// set save railway buttons
    bool SaveRailwayButtonsFlag = true;

    SaveRailwayTBPButton->Visible = true;
    SaveRailwayPDPButton->Visible = true;
    SaveSessionButton->Visible = true;
    if(Level1Mode == OperMode)
    {
        if(Display->ZoomOutFlag || Track->RouteFlashFlag || Track->PointFlashFlag || Track->LCChangeFlag)
        {
            SaveRailwayButtonsFlag = false;
        }
        // set PresetAutoSigRoutesButton enabled or not
        // enable if PreStart & no routes set
        if((Level2OperMode == PreStart) && (AllRoutes->AllRoutesVector.empty()) && !EveryPrefDir->PrefDirVector.empty())//last condition added at v2.10.0
        {
            PresetAutoSigRoutesButton->Enabled = true;
        }
        else
        {
            PresetAutoSigRoutesButton->Enabled = false;
        }
    }
    else
    {
        if(!FileChangedFlag || Display->ZoomOutFlag || (Track->NoActiveOrInactiveTrack(11) && (TextHandler->TextVectorSize(14) == 0)
                                                        && Track->UserGraphicVector.empty()))
        {
            SaveRailwayButtonsFlag = false;
        }
        else if(SavedFileName != "")
        {
            if((SavedFileName[SavedFileName.Length()] == 'y') || (SavedFileName[SavedFileName.Length()] == 'Y')) // 'rly' file
            {
                if(!(Track->IsReadyForOperation(false)))
                {
                    SaveRailwayButtonsFlag = false; // can't save under its old name as not now a .rly file
                }
            }
        }
    }
    if(SaveRailwayButtonsFlag && (Level1Mode == BaseMode))
    {
        SaveRailwayBaseModeButton->Visible = true;
    }
    else
    {
        SaveRailwayBaseModeButton->Visible = false;
    }
    SaveRailwayTBPButton->Enabled = SaveRailwayButtonsFlag;
    SaveRailwayPDPButton->Enabled = SaveRailwayButtonsFlag;
    SaveRailwayBaseModeButton->Enabled = SaveRailwayButtonsFlag;
    SaveSessionButton->Enabled = SaveRailwayButtonsFlag;

// set formatted timetable menu item
    if(TimetableTitle == "")
    {
        ExportTTMenuItem->Enabled = false;
    }
    else
    {
        ExportTTMenuItem->Enabled = true;
    }
// set info menu items
    if((Track->NoActiveOrInactiveTrack(8)) || Display->ZoomOutFlag || ((Level1Mode == TimetableMode) && (TimetableEditPanel->Visible)))
    {
        FloatingInfoMenu->Enabled = false;
        TrackInfoMenuItem->Enabled = false;
        TrainInfoMenuItem->Enabled = false;
    }
    else
    {
        FloatingInfoMenu->Enabled = true;
        TrackInfoMenuItem->Enabled = true;
        if(Level1Mode == OperMode)
        {
            TrainInfoMenuItem->Enabled = true;
        }
        else
        {
            TrainInfoMenuItem->Enabled = false;
        }
    }
// set all bar CallingOnButton operational to begin with - no, causes flickering of button graphics,
// work on internal flags & then set buttons according to final flag values, then graphic won't change unless
// there has been a legitimate change of state since the last access

    bool ZoomFlag = true, HomeFlag = true, NewHomeFlag = true, ScreenLeftFlag = true, ScreenRightFlag = true, ScreenUpFlag = true, ScreenDownFlag = true,
         TrackBuildPanelEnabledFlag = true, PrefDirPanelEnabledFlag = true, OperatingPanelEnabledFlag = true, TimetablePanelEnabledFlag = true;

    AnsiString TrackBuildPanelLabelCaptionStr = "Build/modify";
    AnsiString PrefDirPanelLabelCaptionStr = "Preferred direction selection";
    AnsiString OperatingPanelLabelCaptionStr = "Operation";
    AnsiString TimetablePanelLabelCaptionStr = "Timetable editor";

    if(!Display->ZoomOutFlag)
    {
        // prevent if half a screen or less visible (width = 60, height = 36) [Note HLocMin & Max 1 greater than extreme element]
        if((Track->GetHLocMin() - Display->DisplayOffsetH + 1 >= (Utilities->ScreenElementWidth / 2)))
        {
            ScreenLeftFlag = false; // 60 - 30
        }
        if((Track->GetHLocMax() - Display->DisplayOffsetH - 1 < (Utilities->ScreenElementWidth / 2)))
        {
            ScreenRightFlag = false; // 60 - (60 - 30)
        }
        if((Track->GetVLocMin() - Display->DisplayOffsetV + 1 >= (Utilities->ScreenElementHeight / 2)))
        {
            ScreenUpFlag = false; // 36 - 18
        }
        if((Track->GetVLocMax() - Display->DisplayOffsetV - 1 < (Utilities->ScreenElementHeight / 2)))
        {
            ScreenDownFlag = false; // 36 - (36 - 18)
        }
    }
    else
    {
        // prevent if less than a quarter of a screen visible (width = 240, height = 144)
        if((Track->GetHLocMin() - Display->DisplayZoomOutOffsetH + 1 >= (3 * Utilities->ScreenElementWidth)))
        {
            ScreenLeftFlag = false; // 240 - 60
        }
        if((Track->GetHLocMax() - Display->DisplayZoomOutOffsetH - 1 < Utilities->ScreenElementWidth))
        {
            ScreenRightFlag = false; // 240 - (240 - 60)
        }
        if((Track->GetVLocMin() - Display->DisplayZoomOutOffsetV + 1 >= (3 * Utilities->ScreenElementHeight)))
        {
            ScreenUpFlag = false; // 144 - 36
        }
        if((Track->GetVLocMax() - Display->DisplayZoomOutOffsetV - 1 < Utilities->ScreenElementHeight))
        {
            ScreenDownFlag = false; // 144 - (144 - 36)
        }
    }
    if(Track->NoActiveOrInactiveTrack(6) && TextHandler->TextVector.empty() && Track->UserGraphicVector.empty())
    {
        ZoomFlag = false;
        HomeFlag = false;
        NewHomeFlag = false;
        ScreenLeftFlag = false;
        ScreenRightFlag = false;
        ScreenUpFlag = false;
        ScreenDownFlag = false;
    }
    if(Display->ZoomOutFlag)
    {
// NewHomeFlag = false;
        TrackBuildPanelEnabledFlag = false;
        TrackBuildPanelLabelCaptionStr = "Disabled";
        PrefDirPanelEnabledFlag = false;
        PrefDirPanelLabelCaptionStr = "Disabled";
        OperatingPanelEnabledFlag = false;
        OperatingPanelLabelCaptionStr = "Disabled";
        TimetablePanelEnabledFlag = false;
        TimetablePanelLabelCaptionStr = "Disabled";
    }
    if(Level1Mode == OperMode)
    {
        if(Track->RouteFlashFlag || Track->PointFlashFlag || TTClockAdjPanel->Visible == true || TTClockAdjustWarningPanel->Visible == true ||
                MultiplayerHostPanel->Visible == true || MultiplayerPlayerPanel->Visible == true || SkipTTActionsListBox->Visible)
        // TTClockAdjPanel added for v2.4.2 to keep it disabled after Clock2Stopped dropped
        // host & player panels added for multiplayer
        {
            MTBFEditBox->Enabled = false;
            OperatingPanelEnabledFlag = false;
            OperatingPanelLabelCaptionStr = "Disabled";
            ZoomFlag = false;
            HomeFlag = false;
            NewHomeFlag = false;
            ScreenLeftFlag = false;
            ScreenRightFlag = false;
            ScreenUpFlag = false;
            ScreenDownFlag = false;
            SaveOperatingImageMenuItem->Enabled = false;
        }
        else
        {
            MTBFEditBox->Enabled = true;
            SaveOperatingImageMenuItem->Enabled = true;
        }
    }
    if(LocationNameTextBox->Visible)
    {
        ZoomFlag = false;
        HomeFlag = false;
        NewHomeFlag = false;
        ScreenLeftFlag = false;
        ScreenRightFlag = false;
        ScreenUpFlag = false;
        ScreenDownFlag = false;
    }
    if(TextBox->Visible) // added at v1.3.0 to prevent screen moving when movement keys pressed during text entry
    {
        ZoomFlag = false;
        HomeFlag = false;
        NewHomeFlag = false;
        ScreenLeftFlag = false;
        ScreenRightFlag = false;
        ScreenUpFlag = false;
        ScreenDownFlag = false;
    }
    if((Level1Mode == TimetableMode) && (TimetableEditPanel->Visible))
    // added at v1.3.0 to prevent screen moving when movement keys pressed during timetable compilation (allowed if TT hidden)
    {
        ZoomFlag = false;
        HomeFlag = false;
        NewHomeFlag = false;
        ScreenLeftFlag = false;
        ScreenRightFlag = false;
        ScreenUpFlag = false;
        ScreenDownFlag = false;
    }
    if((Level2TrackMode == TrackSelecting) || (Level2TrackMode == CopyMoving) || (Level2TrackMode == CutMoving) || (Level2TrackMode == DistanceStart) ||
       (Level2TrackMode == DistanceContinuing) || (Level2PrefDirMode == PrefDirSelecting))
    {
        ZoomFlag = false;
    }
    if(ZoomFlag)
    {
        ZoomButton->Enabled = true;
    }
    else
    {
        ZoomButton->Enabled = false;
    }
    if(HomeFlag)
    {
        HomeButton->Enabled = true;
    }
    else
    {
        HomeButton->Enabled = false;
    }
    if(NewHomeFlag)
    {
        NewHomeButton->Enabled = true;
    }
    else
    {
        NewHomeButton->Enabled = false;
    }
    if(ScreenLeftFlag)
    {
        ScreenLeftButton->Enabled = true;
    }
    else
    {
        ScreenLeftButton->Enabled = false;
    }
    if(ScreenRightFlag)
    {
        ScreenRightButton->Enabled = true;
    }
    else
    {
        ScreenRightButton->Enabled = false;
    }
    if(ScreenUpFlag)
    {
        ScreenUpButton->Enabled = true;
    }
    else
    {
        ScreenUpButton->Enabled = false;
    }
    if(ScreenDownFlag)
    {
        ScreenDownButton->Enabled = true;
    }
    else
    {
        ScreenDownButton->Enabled = false;
    }
    if(OperatingPanelEnabledFlag)
    {
        OperatingPanel->Enabled = true;
    }
    else
    {
        OperatingPanel->Enabled = false;
    }
    if(TrackBuildPanelEnabledFlag)
    {
        TrackBuildPanel->Enabled = true;
    }
    else
    {
        TrackBuildPanel->Enabled = false;
    }
    if(PrefDirPanelEnabledFlag)
    {
        PrefDirPanel->Enabled = true;
    }
    else
    {
        PrefDirPanel->Enabled = false;
    }
    if(TimetablePanelEnabledFlag)
    {
        TimetablePanel->Enabled = true;
    }
    else
    {
        TimetablePanel->Enabled = false;
    }
    TrackBuildPanelLabel->Caption = TrackBuildPanelLabelCaptionStr;
    PrefDirPanelLabel->Caption = PrefDirPanelLabelCaptionStr;
    OperatingPanelLabel->Caption = OperatingPanelLabelCaptionStr;
    TimetablePanelLabel->Caption = TimetablePanelLabelCaptionStr;

// check if any CallingOnFlags set & set button accordingly
    if(Display->ZoomOutFlag)
    {
        CallingOnButton->Enabled = false;
        CallingOnButton->Down = false;
    }
    else
    {
        if(Level2OperMode == Operating)
        {
            bool CallOnValid = false;
            for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
            {
                if(TrainController->TrainVectorAt(30, x).CallingOnFlag)
                {
                    CallingOnButton->Enabled = true;
                    CallOnValid = true;
                }
            }
            if(!CallOnValid)
            {
                CallingOnButton->Enabled = false;
                CallingOnButton->Down = false;
            }
        }
        else
        {
            CallingOnButton->Enabled = false;
            CallingOnButton->Down = false;
        }
    }
    Utilities->CallLogPop(970);
}

// ---------------------------------------------------------------------------

void TInterface::ErrorLog(int Caller, AnsiString Message)
{
// create an error file for diagnostic purposes called on detection of a runtime error

// Note: For faults in ClockTimer2, after the catch block in ClockTimer2 which calls this function, execution continues from where
// ClockTimer2 was called, so the Utilities->Clock2Stopped flag is cleared and the whole sequence repeats itself, including the fault, until
// the user presses the Exit button.  Note also that Utilities->CallLogPop, called when ClockTimer (not ClockTimer2) returns, pops the error
// message off the back of the Utilities->CallLog, not the ClockTimer call.  Hence entries keep stacking up, including the push_front entry
// but not the push_back error entry, and when finally printed there is a whole series of entries for the one fault, the number
// depending on the time taken to press Exit.
// Hence introduce an ErrorLogCalledFlag, set to true on first call, and preventing further calls thereafter.

    if(ErrorLogCalledFlag)
    {
        return;
    }
    ErrorLogCalledFlag = true;
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + "," + Message);
    Utilities->CallLog.push_front("Version: " + ProgramVersion + "; Time and date: " + Utilities->DateTimeStamp());
    SaveErrorFile();
    if((TempTTFileName != "") && FileExists(TempTTFileName))
    {
        DeleteFile(TempTTFileName);
    }
    Display->GetImage()->Visible = false;
    PerfLogForm->Visible = false;
    ActionsDueForm->Visible = false; // new v2.2.0
    TrackBuildPanel->Visible = false;
    TrackElementPanel->Visible = false;
    LocationNameTextBox->Visible = false;
    TextBox->Visible = false;
    TrackLengthPanel->Visible = false;
    InfoPanel->Visible = false;
    PrefDirPanel->Visible = false;
    TimetablePanel->Visible = false;
    TimetableEditPanel->Visible = false;
    TrainController->TTEditPanelVisible = false; // added at v2.6.0 for two location message
    OperatingPanel->Visible = false;
    FloatingPanel->Visible = false;
    ModeMenu->Enabled = false;
    SigImagePanel->Visible = false; // new at v2.3.0
    FileMenu->Enabled = false;
    EditMenu->Enabled = false;
    FloatingInfoMenu->Enabled = false;
    HelpMenu->Enabled = false;
// SaveHeaderMenu1->Enabled = false;
    ScreenLeftButton->Visible = false;
    ScreenRightButton->Visible = false;
    ScreenUpButton->Visible = false;
    ScreenDownButton->Visible = false;
    HomeButton->Visible = false;
    NewHomeButton->Visible = false;
    ZoomButton->Visible = false;
    PrefDirKey->Visible = false;
    DistanceKey->Visible = false;
    RecoverClipboardMessageSent = true; // to stop paste message being given if recover clipboard error
    OutputLog1->Caption = "";
    OutputLog2->Caption = "";
    OutputLog3->Caption = "";
    OutputLog4->Caption = "";
    OutputLog5->Caption = "";
    OutputLog6->Caption = "";
    OutputLog7->Caption = "";
    OutputLog8->Caption = "";
    OutputLog9->Caption = "";
    OutputLog10->Caption = "";
    ErrorMessage->Visible = true;
    ErrorButton->Visible = true;
    Screen->Cursor = TCursor(-2); // Arrow; - in case was an hourglass
// No need for Utilities->CallLogPop as the call log deque has already been written to file & the next action
// is to close the program when the exit button is pressed
}

// ---------------------------------------------------------------------------

bool TInterface::IsPerfLogFormObscuringFloatingLabel(int Caller)
// reinstated at v2.13.0 with new form for PerfLogForm //not used from v2.2.0 as now allow floating panel & label to overlie performance panel
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsPerfLogFormObscuringFloatingLabel");
    if(FloatingPanel->Visible == false)
    {
        Utilities->CallLogPop(1205);
        return(false);
    }
// ok if pftop >= flbot, pfbot <= fltop, pfleft >= flright, pfright <= flleft
    if((PerfLogForm->Top >= (FloatingPanel->ClientOrigin.y + FloatingPanel->Height)) || ((PerfLogForm->Top + PerfLogForm->Height) <= (FloatingPanel->ClientOrigin.y)) ||
       (PerfLogForm->Left >= (FloatingPanel->ClientOrigin.x + FloatingPanel->Width)) || ((PerfLogForm->Left + PerfLogForm->Width) <= (FloatingPanel->ClientOrigin.x)))
    {
        Utilities->CallLogPop(1206);
        return(false);
    }
    else
    {
        Utilities->CallLogPop(1207);
        return(true);
    }
}

// ---------------------------------------------------------------------------

bool TInterface::IsActionsDueFormObscuringFloatingLabel(int Caller)
// new at v2.13.0
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",IsActionsDueFormObscuringFloatingLabel");
    if(FloatingPanel->Visible == false)
    {
        Utilities->CallLogPop(2539);
        return(false);
    }
// ok if adftop >= flbot, adfbot <= fltop, adfleft >= flright, adfright <= flleft
    if((ActionsDueForm->Top >= (FloatingPanel->ClientOrigin.y + FloatingPanel->Height)) || ((ActionsDueForm->Top + ActionsDueForm->Height) <= (FloatingPanel->ClientOrigin.y)) ||
       (ActionsDueForm->Left >= (FloatingPanel->ClientOrigin.x + FloatingPanel->Width)) || ((ActionsDueForm->Left + ActionsDueForm->Width) <= (FloatingPanel->ClientOrigin.x)))
    {
        Utilities->CallLogPop(2542);
        return(false);
    }
    else
    {
        Utilities->CallLogPop(2543);
        return(true);
    }
}

// ---------------------------------------------------------------------------

void TInterface::SetCaption(int Caller)
{
/*
   NamedRailway; RlyFile; NamedTimetable
     n           x          x  "New railway under development";
     y           n          x  RailwayTitle + ": under development";
     y           y          n  RailwayTitle + ": no timetable loaded";
     y           y          y  RailwayTitle + ", " + TimetableTitle;
*/

    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetCaption");
    if(RailwayTitle == "")
    {
        Caption = "Railway: New railway under development";
    }
    else if(!RlyFile)
    {
        Caption = "Railway: " + RailwayTitle + " under development";
    }
// else if(TimetableTitle == "") Caption = "Railway: " + RailwayTitle + "; Timetable: none loaded";
    else if(TimetableTitle == "")
    {
        Caption = "Railway: " + RailwayTitle; // changed at v2.1.0, no need to mention TT if none loaded
    }
    else
    {
        Caption = "Railway: " + RailwayTitle + "; Timetable: " + TimetableTitle;
    }
    session_api_->dump();   // update session INI file  //added at v2.10.0
    Utilities->CallLogPop(1208);
}

// ---------------------------------------------------------------------------

void TInterface::ResetAll(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ResetAll");
    LastNonCtrlOrShiftKeyDown = -1; // added at v2.4.2 to no key down
    Track->GapFlashGreenPosition = -1;
    Track->GapFlashRedPosition = -1;
    Track->GapFlashFlag = false;
    Track->RouteFlashFlag = false;
    Track->PointFlashFlag = false;
    DivergingPointVectorPosition = -1;
    AutoSigsFlag = false;
    PreventGapOffsetResetting = false;

    Utilities->Clock2Stopped = false;
    TTClockSpeed = 1;
    TTClockSpeedLabel->Caption = "x1";
    Track->SetTrackFinished(false);
    Track->ActiveTrackElementNameMapCompiledFlag = false;
    CurrentSpeedButton = 0; // not assigned yet
    Display->ResetZoomInOffsets();
    StartX = 0;
    StartY = 0;
    mbLeftDown = false;
    TextOrUserGraphicGridVal = 1;
    TextOrUserGraphicGridButton->Glyph->LoadFromResourceName(0, "PixelPrecision1");
    Track->SignalAspectBuildMode = TTrack::FourAspectBuild;
    SigAspectButton->Glyph->LoadFromResourceName(0, "FourAspect");
    LoadNormalSignalGlyphs(4);
    WarningFlashCount = 0;

    Level1Mode = BaseMode;
    SetLevel1Mode(26);
    RouteMode = None;
    PreferredRoute = true; // default starting conditions
    ConsecSignalsRoute = true; // default starting conditions
    DevelopmentPanel->Visible = false;

    MainScreen->Canvas->CopyMode = cmSrcCopy;
    FloatingPanel->Visible = false;
    OverallDistance = 0;
    OverallSpeedLimit = -1;
    AllRoutes->RouteBackTruncateFlag = false;
    CallingOnButton->Down = false;
    Display->ZoomOutFlag = false;
    ScreenGridFlag = false;
    InfoCaptionStore = "";
    ErrorLogCalledFlag = false;
    ErrorMessage->Visible = false;
    ErrorMessageStoreImage->Visible = false;
    TempCursorSet = false;
    TempCursor = TCursor(-2); // Arrow
    WholeRailwayMoving = false; // new at v2.1.0

    TrainController->TTClockTime = TDateTime(0); // default setting
    TTClockAdjPanel->Visible = false;
    TrainController->StopTTClockFlag = false;
    ConflictPanel->Visible = false;
    SelectedTrainID = -1;
    SetTrackBuildImages(11);
// TrackInfoOnOffMenuItem->Caption = "Show";  dropped these here at v1.2.0 so don't reset when load a session file
// TrainStatusInfoOnOffMenuItem->Caption = "Show Status";
// TrainTTInfoOnOffMenuItem->Caption = "Show Timetable";
    Track->CalcHLocMinEtc(8);
    FileChangedFlag = false;
    RlyFile = false;
    SaveSessionFlag = false;
    LoadSessionFlag = false;
    SelectionValid = false;
    TimetableChangedFlag = false;
    SavedFileName = "";
    RailwayTitle = "";
    TimetableTitle = "";
    SetCaption(1);
    CreateEditTTFileName = ""; // set to null to allow a check during error file saving, if not null save the tt being edited to the file
                               // added for Beta v0.2b
    CreateEditTTTitle = ""; // as above
    AllRoutes->NextRouteID = 0;
    TTrain::NextTrainID = 0; // reset to 0 whenever enter operating mode
    TFont *TempFont = new TFont; // if try to alter MainScreen->Canvas->Font directly it won't change the style for some reason

    TempFont->Style.Clear();
    TempFont->Name = "MS Sans Serif"; // reset font, else stays set to last displayed text font
    TempFont->Size = 10;
    TempFont->Color = clB0G0R0;
    TempFont->Charset = (TFontCharset)(0);
    MainScreen->Canvas->Font->Assign(TempFont);
    ;                                                                                                // new v2.2.0
    // ScreenRightButton->Left = MainScreen->Width + MainScreen->Left;  //Button values changed at v2.1.0 to allow for screen resizing
    // ScreenLeftButton->Left = ScreenRightButton->Left;
    // ScreenUpButton->Left = ScreenRightButton->Left;
    // ScreenDownButton->Left = ScreenRightButton->Left;
    // HomeButton->Left = ScreenRightButton->Left;
    // NewHomeButton->Left = ScreenRightButton->Left;
    // ZoomButton->Left = ScreenRightButton->Left;
    DevelopmentPanel->Top = MainScreen->Top + MainScreen->Height - DevelopmentPanel->Height;
    DevelopmentPanel->Left = MainScreen->Left + MainScreen->Width - DevelopmentPanel->Width;
    ;                                                                                          // new v2.2.0

    delete TempFont;
    CtrlKey = false;
    ShiftKey = false;
    ClipboardChecked = false;
    session_api_->dump();   // update session INI file  //added at v2.10.0
    Utilities->CallLogPop(1209);
}

// ---------------------------------------------------------------------------

void TInterface::SetTrackBuildImages(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetTrackBuildImages,");
    if((Level1Mode == OperMode) || RlyFile)
    {
        TrackLinkedImage->Visible = false;
        TrackNotLinkedImage->Visible = false;
        GapsSetImage->Visible = false;
        GapsNotSetImage->Visible = false;
        LocationNamesSetImage->Visible = false;
        LocationNamesNotSetImage->Visible = false;
        Utilities->CallLogPop(1114);
        return;
    }
    else
    {
        if(!Track->NoActiveTrack(9))
        {
            if(Track->IsTrackFinished())
            {
                TrackLinkedImage->Visible = true;
                TrackNotLinkedImage->Visible = false;
            }
            else
            {
                TrackNotLinkedImage->Visible = true;
                TrackLinkedImage->Visible = false;
            }
        }
        else
        {
            TrackLinkedImage->Visible = false;
            TrackNotLinkedImage->Visible = false;
        }
        if(!Track->NoGaps(1))
        {
            if(Track->GapsUnset(6))
            {
                GapsNotSetImage->Visible = true;
                GapsSetImage->Visible = false;
            }
            else
            {
                GapsNotSetImage->Visible = false;
                GapsSetImage->Visible = true;
            }
        }
        else
        {
            GapsNotSetImage->Visible = false;
            GapsSetImage->Visible = false;
        }
        if(!Track->NoNamedLocationElements(1))
        {
            if(Track->LocationsNotNamed(0))
            {
                LocationNamesSetImage->Visible = false;
                LocationNamesNotSetImage->Visible = true;
            }
            else
            {
                LocationNamesSetImage->Visible = true;
                LocationNamesNotSetImage->Visible = false;
            }
        }
        else
        {
            LocationNamesSetImage->Visible = false;
            LocationNamesNotSetImage->Visible = false;
        }
    }
    Utilities->CallLogPop(1113);
}

// ---------------------------------------------------------------------------

void TInterface::ResetChangedFileDataAndCaption(int Caller, bool NonPrefDirChangesMade)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",ResetChangedFileDataAndCaption");
    FileChangedFlag = true;
    if(NonPrefDirChangesMade)
    {
        if(RlyFile) // i.e. was a Railway file but major changes made so class as a new railway
        {
            RailwayTitle = "";
            TimetableTitle = "";
            SavedFileName = "";
            RlyFile = false;
        }
        TimetableTitle = ""; // should have been reset already during user mode change but include here also
        SetTrackBuildImages(15);
    }
    session_api_->dump();   // update session INI file   //added at v2.10.0
    SetCaption(2);
    Utilities->CallLogPop(1210);
}

// ---------------------------------------------------------------------------

void TInterface::SaveSession(int Caller)
{
    // ExcessLCDownMins saved as string after ***Interface*** see below
    try
    {
        TrainController->LogEvent("SaveSession");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveSession");
        AnsiString CurrentDateTimeStr = "", TimetableTimeStr = "", SessionFileStr = "";
        Screen->Cursor = TCursor(-11); // Hourglass;
        CurrentDateTimeStr = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
        // avoid characters in filename:=   / \ : * ? " < > |
        TimetableTimeStr = Utilities->Format96HHMMSS(TrainController->TTClockTime);
        TimetableTimeStr = TimetableTimeStr.SubString(1, 2) + '.' + TimetableTimeStr.SubString(4, 2) + '.' + TimetableTimeStr.SubString(7, 2);
// SessionFileStr = CurDir + "\\" + SESSION_DIR_NAME + "\\Session " + CurrentDateTimeStr + "; Timetable time " + TimetableTimeStr + "; " + RailwayTitle +
// "; " + TimetableTitle + ".ssn";
        SessionFileStr = LoadSessionDialog->InitialDir + "\\Session " + CurrentDateTimeStr + "; Timetable time " + TimetableTimeStr + "; " + RailwayTitle +
            "; " + TimetableTitle + ".ssn";
        std::ofstream SessionFile(SessionFileStr.c_str());
        if(!(SessionFile.fail()))
        {
            Utilities->SaveFileString(SessionFile, ProgramVersion + ": ***Interface***" + FloatToStr(TrainController->ExcessLCDownMins));
// added ExcessLC... at v2.2.0 as omitted earlier
            SaveInterface(0, SessionFile);
            // save track elements
            Utilities->SaveFileString(SessionFile, "***Track***");
            if(Track->UserGraphicVector.empty())
            {
                Track->SaveTrack(4, SessionFile, false); // false for no graphics (**Active elements** saved as marker)
            }
            else
            {
                Track->SaveTrack(11, SessionFile, true); // true for graphics to be saved (**Active elements**1 saved as marker)
            }
            // save text elements
            Utilities->SaveFileString(SessionFile, "***Text***");
            TextHandler->SaveText(2, SessionFile);
            // save PrefDir elements
            Utilities->SaveFileString(SessionFile, "***PrefDirs***");
            EveryPrefDir->SavePrefDirVector(2, SessionFile);
            if(!Track->UserGraphicVector.empty())
            {
                // save user graphics
                Track->SaveUserGraphics(2, SessionFile);
            }
            // save routes
            Utilities->SaveFileString(SessionFile, "***Routes***");
            AllRoutes->SaveRoutes(0, SessionFile);
            // save LockedRoutes
            Utilities->SaveFileString(SessionFile, "***Locked routes***");
            TrainController->SaveSessionLockedRoutes(0, SessionFile);
            // save ContinuationAutoSigEntries
            Utilities->SaveFileString(SessionFile, "***ContinuationAutoSigEntries***");
            TrainController->SaveSessionContinuationAutoSigEntries(0, SessionFile);
            // save BarriersDownVector
            Utilities->SaveFileString(SessionFile, "***BarriersDownVector***");
            Track->SaveSessionBarriersDownVector(0, SessionFile);
            // save timetable
            Utilities->SaveFileString(SessionFile, "***Timetable***");
            if(!(SaveTimetableToSessionFile(0, SessionFile, SessionFileStr))) //includes the timetable itself + TrainOperatingData
            {
                SessionFile.close();
                DeleteFile(SessionFileStr);
                Screen->Cursor = TCursor(-2); // Arrow;
                TrainController->StopTTClockMessage(3, "Error saving file, unable to save session");
                Utilities->CallLogPop(1150);
                return;
            }
            // save TimetableClock
            Utilities->SaveFileString(SessionFile, "***TimetableClock***");
            Utilities->SaveFileDouble(SessionFile, double(TrainController->TTClockTime));

            // save trains
            Utilities->SaveFileString(SessionFile, "***Trains***");
            TrainController->SaveSessionTrains(0, SessionFile);
            // save performance file
            Utilities->SaveFileString(SessionFile, "***Performance file***");
            SavePerformanceFile(0, SessionFile);
            Utilities->SaveFileString(SessionFile, "***End of performance file***");

/* The following additions are for later program versions where new features need to be saved in sessions.
In each case need to ensure that the following points are considered and dealt with:

    1) New program works ok with old session files
    2) Old programs work ok with extended session file
    3) Check what happens to changed railway/track/trains/timetable etc when an old prog loads a new session file
    4) Ensure that the last character saved for a record change can't be 'E' as that used to identify the end of the additions
*/
            Utilities->SaveFileString(SessionFile, "***Additions after v2.3.1***");

// additions at v2.4.0 to save TrainController->AvHoursIntValue
            Utilities->SaveFileInt(SessionFile, TrainController->AvHoursIntValue);
            Utilities->SaveFileInt(SessionFile, TrainController->NumFailures);
            Utilities->SaveFileString(SessionFile, "***Failed Trains***");
            for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
            {
                if(TrainController->TrainVectorAt(66, x).TrainFailed)
                {
                    Utilities->SaveFileInt(SessionFile, TrainController->TrainVectorAt(67, x).TrainID);
                    Utilities->SaveFileDouble(SessionFile, TrainController->TrainVectorAt(68, x).OriginalPowerAtRail);
                }
            }
            Utilities->SaveFileInt(SessionFile, -1); // marker for end of failed trains
            Utilities->SaveFileString(SessionFile, "End of file at v2.4.0");
// end of v2.4.0 additions

// addition at v2.7.0
            Utilities->SaveFileBool(SessionFile, ConsecSignalsRoute);
            Utilities->SaveFileString(SessionFile, "End of file at v2.7.0");
// end of v2.7.0 addition

// additions at v2.9.1
            Utilities->SaveFileInt(SessionFile, TrainController->EarlyExits);
            Utilities->SaveFileInt(SessionFile, TrainController->OnTimeExits);
            Utilities->SaveFileInt(SessionFile, TrainController->LateExits);
            Utilities->SaveFileDouble(SessionFile, double(TrainController->TotEarlyExitMins));
            Utilities->SaveFileDouble(SessionFile, double(TrainController->TotLateExitMins));
            Utilities->SaveFileString(SessionFile, "End of file at v2.9.1");  //changed from '2.9.0' at v2.9.2
// end of v2.9.1 additions

//additions at v2.11.0 - SkippedTTEvents
            Utilities->SaveFileInt(SessionFile, TrainController->SkippedTTEvents);
            // add data for trains in process of skipping timetable events (i.e. those with events after a future departure)
            if(!TrainController->TrainVector.empty())
            {
                for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
                {
                    TTrain Train = TrainController->TrainVectorAt(82, x);
                    if(Train.SkippedDeparture)
                    {
                        Utilities->SaveFileInt(SessionFile, Train.TrainID);
                        Utilities->SaveFileBool(SessionFile, Train.SkippedDeparture);
                        Utilities->SaveFileBool(SessionFile, Train.ActionsSkippedFlag);
                        Utilities->SaveFileInt(SessionFile, Train.SkipPtrValue);
                        Utilities->SaveFileInt(SessionFile, Train.TrainSkippedEvents);
                    }
                }
            }
            Utilities->SaveFileString(SessionFile, "End of file at v2.11.0");
//end of v2.11.0 additions

//additions at v2.12.0 - become new service early & treat pass as departure
            if(!TrainController->TrainVector.empty())
            {
                for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
                {
                    TTrain Train = TrainController->TrainVectorAt(85, x);
                    if(Train.TreatPassAsTimeLocDeparture) //this can only apply once for a single train (service repeats are separate trains)
                    {
                        Utilities->SaveFileInt(SessionFile, Train.TrainID);
                    }
                }
            }
            Utilities->SaveFileString(SessionFile, "End of file at v2.12.0");
//end of v2.12.0 additions

//additions at v2.13.0 - random delays & failures
//No need to save Utilities->LastDelayTTClockTime - makes little difference and would cause corruption in any v2.13.0 Beta sessions
            Utilities->SaveFileInt(SessionFile, Utilities->CumulativeDelayedRandMinsAllTrains); //to allow for exited and removed trains
            for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
            { //if empty will skip
                TTrain Train = TrainController->TrainVectorAt(87, x);
                Utilities->SaveFileDouble(SessionFile, Train.NewDelay);
                Utilities->SaveFileDouble(SessionFile, Train.DelayedRandMins);
                Utilities->SaveFileDouble(SessionFile, Train.CumulativeDelayedRandMinsOneTrain);
                Utilities->SaveFileDouble(SessionFile, double(Train.ActualArrivalTime));
                //ReleaseTime already loaded
            }
            //save failed point info
            Utilities->SaveFileInt(SessionFile, Track->FailedPointsVector.size()); //number of failed points
            for(unsigned int x = 0; x < Track->FailedPointsVector.size(); x++)
            { //if empty will skip, when reload set Failed to true & SpeedLimits to 10km/h
                TTrackElement &TE = Track->TrackElementAt(1512, Track->FailedPointsVector.at(x).TVPos);
                Utilities->SaveFileInt(SessionFile, Track->FailedPointsVector.at(x).TVPos);
                Utilities->SaveFileInt(SessionFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01);
                Utilities->SaveFileInt(SessionFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23);
                Utilities->SaveFileDouble(SessionFile, double(Track->FailedPointsVector.at(x).FailureTime));
                Utilities->SaveFileDouble(SessionFile, double(Track->FailedPointsVector.at(x).RepairTime));
            }
            //save failed signal info
            Utilities->SaveFileInt(SessionFile, Track->FailedSignalsVector.size()); //number of failed signals
            for(unsigned int x = 0; x < Track->FailedSignalsVector.size(); x++)
            { //if empty will skip, when reload set Failed to true
                Utilities->SaveFileInt(SessionFile, Track->FailedSignalsVector.at(x).TVPos);
                Utilities->SaveFileDouble(SessionFile, double(Track->FailedSignalsVector.at(x).FailureTime));
                Utilities->SaveFileDouble(SessionFile, double(Track->FailedSignalsVector.at(x).RepairTime));
            }
            //save TSR info
            Utilities->SaveFileInt(SessionFile, Track->TSRVector.size()); //number of TSRs
            for(unsigned int x = 0; x < Track->TSRVector.size(); x++)
            { //if empty will skip, when reload set Failed to true & SpeedLimit to 10km/h
                TTrackElement &TE = Track->TrackElementAt(1532, Track->TSRVector.at(x).TVPos);
                Utilities->SaveFileInt(SessionFile, Track->TSRVector.at(x).TVPos);
                Utilities->SaveFileInt(SessionFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01);
                Utilities->SaveFileDouble(SessionFile, double(Track->TSRVector.at(x).FailureTime));
                Utilities->SaveFileDouble(SessionFile, double(Track->TSRVector.at(x).RepairTime));
            }
            Utilities->SaveFileString(SessionFile, "End of file at v2.13.0");
//end of v2.13.0 additions

//additions at v2.14.0 - delays and failures separated & now saved with session
            if(Utilities->DelayMode == Minor)
            {
                Utilities->SaveFileInt(SessionFile, 1);
            }
            else if(Utilities->DelayMode == Moderate)
            {
                Utilities->SaveFileInt(SessionFile, 2);
            }
            else if(Utilities->DelayMode == Major)
            {
                Utilities->SaveFileInt(SessionFile, 3);
            }
            else
            {
                Utilities->SaveFileInt(SessionFile, 0);
            }
            if(Utilities->FailureMode == FMinor)
            {
                Utilities->SaveFileInt(SessionFile, 1);
            }
            else if(Utilities->FailureMode == FModerate)
            {
                Utilities->SaveFileInt(SessionFile, 2);
            }
            else if(Utilities->FailureMode == FMajor)
            {
                Utilities->SaveFileInt(SessionFile, 3);
            }
            else
            {
                Utilities->SaveFileInt(SessionFile, 0);
            }
            Utilities->SaveFileString(SessionFile, "End of file at v2.14.0");
//end of v2.14.0 additions
//IF ADD MORE PARAMETERS REMEMBER TO ADD TO ERROR FILE TOO, BUT CHANGE 'SessionFile' to 'ErrorFile'

            SessionFile.close();
            TrainController->StopTTClockMessage(4, "Session saved: Session " + CurrentDateTimeStr + "; Timetable time " + TimetableTimeStr + "; " +
                                                RailwayTitle + "; " + TimetableTitle + ".ssn");
            LastNonCtrlOrShiftKeyDown = -1;
// to restore the ability to reselect Ctrl S after a save (FormKeyUp doesn't work because the Interface form doesn't have focus)
        }
        else
        {
            TrainController->StopTTClockMessage(5, "Session file failed to open - reason not known, unable to save.");
        }
        TrainController->LastSessionSaveTTClockTime = TrainController->TTClockTime; // added at v2.5.0
        Screen->Cursor = TCursor(-2); // Arrow
        Utilities->CallLogPop(1141);
    }
    catch(const Exception &e) //non-error catch at v2.14.0
    {
        TrainController->StopTTClockMessage(138, "Session file failed to save\nError message: " + e.Message);
        Screen->Cursor = TCursor(-2); // Arrow;
        Utilities->CallLogPop(2554);
    }
}

// ---------------------------------------------------------------------------

void TInterface::LoadSession(int Caller)
// always loads in 'Paused' or 'PreStart' mode
{
// remember to load the timetable clock
// no routes in build
// prob need to set 'OperMode' then 'Paused', ensure have all info needed for these
// set buttons enabled to correspond to flags on reloading. If no PrefDirs then disable all route buttons
// set RlyFile true
    try
    {
        TrainController->LogEvent("LoadSession");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadSession");
        if(!ClearEverything(4))
        {
            Utilities->CallLogPop(1145);
            return;
        }
        LoadSessionDialog->Filter = "Session file (*.ssn)|*.ssn";
        if(LoadSessionDialog->Execute())
        {
            if(LoadSessionDialog->InitialDir != TPath::GetDirectoryName(LoadSessionDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                LoadSessionDialog->InitialDir = TPath::GetDirectoryName(LoadSessionDialog->FileName);
            }
            TrainController->LogEvent("LoadSession " + LoadSessionDialog->FileName);
            Screen->Cursor = TCursor(-11); // Hourglass;
            if(SessionFileIntegrityCheck(0, AnsiString(LoadSessionDialog->FileName).c_str()))
            // if(true)
            {
                std::ifstream SessionFile(AnsiString(LoadSessionDialog->FileName).c_str());
                if(!(SessionFile.fail()))
                {
                    TrainController->AvHoursIntValue = 0; // initial value set at v2.4.0 in case not changed later
                    TrainController->MTBFHours = 0; // initial value set at v2.4.0 in case not changed later
                    AnsiString TempString = Utilities->LoadFileString(SessionFile);
// "version + : ***Interface***" + at v2.2.0 ExcessLCDownMins (omitted earlier)

                    int LastCharBeforeFloat = TempString.LastDelimiter('*'); // added at v2.2.0
                    if((LastCharBeforeFloat == 0) || (LastCharBeforeFloat == TempString.Length()))
                    // can't find it or no value for Excess LCDownMins, either way count as zero
                    {
                        TrainController->ExcessLCDownMins = 0;
                    }
                    else
                    {
                        AnsiString FloatStr = TempString.SubString(LastCharBeforeFloat + 1, TempString.Length() - LastCharBeforeFloat);
                        if(!Utilities->CheckStringDouble(FloatStr)) // returns false for empty string or invalid double
                        {
                            TrainController->ExcessLCDownMins = 0;
                        }
                        else
                        {
                            TrainController->ExcessLCDownMins = FloatStr.ToDouble();
                        }
                    } // end of v2.2.0 * v2.4.0 additions

                    LoadInterface(0, SessionFile);
                    int TempDisplayOffsetH = Display->DisplayOffsetH; // stored as they are zeroed when track loaded
                    int TempDisplayOffsetV = Display->DisplayOffsetV;
                    int TempDisplayOffsetHHome = Display->DisplayOffsetHHome;
                    int TempDisplayOffsetVHome = Display->DisplayOffsetVHome;
                    bool GraphicsFollow = false;
                    // load track elements
                    TempString = Utilities->LoadFileString(SessionFile); // ***Track***"
                    Track->LoadTrack(4, SessionFile, GraphicsFollow);
                    if(!Track->IsTrackFinished()) //added at v2.13.0, should have been included earlier
                    {
                        SessionFile.close();
                        Screen->Cursor = TCursor(-2); // Arrow;
                        ShowMessage("Track not linked, session can't be loaded");
                        Utilities->CallLogPop(2532);
                        return;
                    }
                    // load text elements
                    TempString = Utilities->LoadFileString(SessionFile); // ***Text***"
                    TextHandler->LoadText(1, SessionFile);
                    // load PrefDir elements
                    TempString = Utilities->LoadFileString(SessionFile); // "***PrefDirs***"
                    EveryPrefDir->LoadPrefDir(1, SessionFile);
                    if(GraphicsFollow)
                    {
                        Track->LoadGraphics(1, SessionFile, CurDir + "\\" + USERGRAPHICS_DIR_NAME); // include path to Graphics folder);
                    }
                    if(!EveryPrefDir->CheckPrefDirAgainstTrackVectorNoMessage(0))
                    {
                        SessionFile.close();
                        Screen->Cursor = TCursor(-2); // Arrow;
                        ShowMessage("Corruption in preferred direction section of the session file, session can't be loaded");
                        Utilities->CallLogPop(1438);
                        return;
                    }
                    // load routes
                    TempString = Utilities->LoadFileString(SessionFile); // "***Routes***"
                    if(!AllRoutes->LoadRoutes(0, SessionFile))
                    {
                        SessionFile.close();
                        Screen->Cursor = TCursor(-2); // Arrow;
                        ShowMessage("Corruption in route section of the session file, session can't be loaded");
                        Utilities->CallLogPop(1439);
                        return;
                    }
                    // load LockedRoutes
                    TempString = Utilities->LoadFileString(SessionFile); // "***Locked routes***"
                    TrainController->LoadSessionLockedRoutes(0, SessionFile);
                    // load ContinuationAutoSigEntries
                    TempString = Utilities->LoadFileString(SessionFile); // "***ContinuationAutoSigEntries***"
                    TrainController->LoadSessionContinuationAutoSigEntries(0, SessionFile);
                    // load BarriersDownVector if present, but ensure backwards compatibility with earlier files
                    TempString = Utilities->LoadFileString(SessionFile); // "***BarriersDownVector***" or "***Timetable***"
                    if(TempString == "***BarriersDownVector***")
                    {
                        Track->LoadBarriersDownVector(0, SessionFile);
                        TempString = Utilities->LoadFileString(SessionFile); // "***Timetable***"
                    }
                    // load timetable (marker "***Timetable***" already loaded)
                    if(!(LoadTimetableFromSessionFile(0, SessionFile)))
                    {
                        SessionFile.close();
                        Screen->Cursor = TCursor(-2); // Arrow;
                        ShowMessage("Unable to load timetable section of the session file, session can't be loaded");
                        Utilities->CallLogPop(1151);
                        return;
                    }
                    // TimetableTitle should be loaded at this stage - check
                    if(TimetableTitle == "")
                    {
                        SessionFile.close();
                        Screen->Cursor = TCursor(-2); // Arrow;
                        throw Exception("TimetableTitle null in LoadSession");
                    }
                    // load timetable clock
                    TempString = Utilities->LoadFileString(SessionFile); // ***TimetableClock***
                    TrainController->RestartTime = TDateTime(Utilities->LoadFileDouble(SessionFile)); // ClockTime set in RestartSessionOperMode;
                    // load trains
                    TempString = Utilities->LoadFileString(SessionFile); // ***Trains***
                    TrainController->LoadSessionTrains(0, SessionFile);
                    // load performance file + populate the performance log
                    TempString = Utilities->LoadFileString(SessionFile); // ***Performance file***
                    // first reset the performance file name and open it before reloading it
                    PerformanceFileName = TDateTime::CurrentDateTime().FormatString("dd-mm-yyyy hh.nn.ss");
                    // avoid characters in filename:=   / \ : * ? " < > |
                    PerformanceFileName = CurDir + "\\" + PERFLOG_DIR_NAME + "\\Log " + PerformanceFileName + "; " + RailwayTitle + "; " +
                        TimetableTitle + ".txt";
                    Utilities->PerformanceFile.open(PerformanceFileName.c_str(), std::ios_base::out);
                    if(Utilities->PerformanceFile.fail())
                    {
                        ShowMessage("Performance logfile failed to open, logs won't be saved. Ensure that there is a folder named " + PERFLOG_DIR_NAME +
                                    " in the folder where the 'Railway.exe' program file resides");
                    }
                    // now reload the performance file (also populates PerformanceLogBox)
                    LoadPerformanceFile(0, SessionFile);
// addition at v2.4.0 (train failures)
                    char TempChar;
                    SessionFile.get(TempChar);
                    while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0'))) // get rid of all end of lines & emerge with eof or '*'
                    {
                        SessionFile.get(TempChar);
                    }
                    if(SessionFile.eof()) // old session file
                    {
                        TrainController->AvHoursIntValue = 0;  //initialise these for new prog
                        TrainController->MTBFHours = 0;
                        SessionFile.close(); // no TrainController->AvHoursIntValue & no failed trains
                        goto FINISHEDLOADING; //don't like goto's normally but necessary here to avoid multiple else's
                    }
                    {   //remainder enclosed in a block so goto doesn't bypass initialisation of a local variable (DummyStr, ID etc.)
                        AnsiString DummyStr = Utilities->LoadFileString(SessionFile); // "**Additions after v2.3.1***"  discarded (first '*' loaded earlier)
                        TrainController->AvHoursIntValue = Utilities->LoadFileInt(SessionFile); // TrainController->AvHoursIntValue added at v2.4.0
                        TrainController->NumFailures = Utilities->LoadFileInt(SessionFile); // number of train failures
                        TrainController->MTBFHours = TrainController->AvHoursIntValue; // TTClockSpeed set to 1 in RestartSessionMode so no need to include here
                        // now load any failed trains along with their OriginalPowerAtRail values
                        DummyStr = Utilities->LoadFileString(SessionFile); // discard "***Failed Trains***"
                        int ID = Utilities->LoadFileInt(SessionFile); // train ID or -1 for no more failed trains
                        double PowerDouble;
                        while(ID != -1)
                        {
                            PowerDouble = Utilities->LoadFileDouble(SessionFile); // ok TrainVector loaded at this stage (loaded in LoadSessionTrains)
                            TrainController->TrainVectorAtIdent(47, ID).TrainFailed = true;
                            TrainController->TrainVectorAtIdent(48, ID).OriginalPowerAtRail = PowerDouble;
                            ID = Utilities->LoadFileInt(SessionFile);
                        }
//end of 2.4.0 addition
// addition at v2.7.0 - need value for ConsecSignalsRoute but might have eof here with older sessions so first test for that
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.4.0"  discarded

                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0'))) // get rid of all end of lines & emerge with eof or '0' or '1'
                        {
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file
                        {
                            SessionFile.close(); //ConsecSignalsRoute set to PrefDirRoute
                            goto FINISHEDLOADING;
                        }
                        if((TempChar != '0') && (TempChar != '1'))
                        {
                            throw Exception("TempChar value = " + AnsiString(TempChar) + ", should be 0 or 1");
                        }
                        ConsecSignalsRoute = true;
                        if(TempChar == '0')
                        {
                            ConsecSignalsRoute = false;
                            // at v2.7.0 if find eof then don't need a value for ConsecSignalsRoute as that loaded during LoadInterface
                        }
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.7.0"  discarded
//end of 2.7.0 additions
//additions at v2.9.1 - added exit information for performance log (should have been included earlier)
                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0'))) // get rid of all end of lines & emerge with 1st digit of EarlyExits as character
                        {
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file
                        {
                            TrainController->EarlyExits = 0;    //initialise for new prog - added at v2.13.0, should heve been here before
                            TrainController->OnTimeExits = 0;
                            TrainController->LateExits = 0;
                            TrainController->TotEarlyExitMins = 0;
                            TrainController->TotLateExitMins = 0;
                            SessionFile.close();
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the first digit of EarlyExits as an ASCII character, so get the rest up to CRLF
                        TempString = TempChar;
                        SessionFile.get(TempChar);
                        while((TempChar != '\n') && (TempChar != '\0'))
                        {
                            TempString = TempString + TempChar;
                            SessionFile.get(TempChar);
                        }
                        TrainController->EarlyExits = TempString.ToInt();
                        TrainController->OnTimeExits = Utilities->LoadFileInt(SessionFile);
                        TrainController->LateExits = Utilities->LoadFileInt(SessionFile);
                        TrainController->TotEarlyExitMins = float(Utilities->LoadFileDouble(SessionFile));
                        TrainController->TotLateExitMins = float(Utilities->LoadFileDouble(SessionFile));
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.9.1"  discarded
//end of 2.9.1 additions

//2.11.0 additions - skip timetabled events
                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0')))
                        {// get rid of all end of lines & emerge with eof or 1st digit of TrainController->SkippedTTEvents
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file
                        {
                            TrainController->SkippedTTEvents = 0; //initialise for new prog, added at v2.13.0, should have been here earlier
                            SessionFile.close();                  //no need to initialise train data as initialised during creation of a new train
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the first digit of SkippedTTEvents as a character, so get the rest up to CRLF
                        TempString = TempChar;
                        SessionFile.get(TempChar);
                        while((TempChar != '\n') && (TempChar != '\0'))
                        {
                            TempString = TempString + TempChar;
                            SessionFile.get(TempChar);
                        }
                        //here have SkippedTTEvents as AnsiString in TempString
                        TrainController->SkippedTTEvents = TempString.ToInt();
                        //now get the skip data for each train (may or may not be any)
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0')))
                        {// get rid of all end of lines & emerge with eof or 1st digit of TrainID
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //no train skip data
                        {
                            SessionFile.close();
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the 1st digit of TrainID as a character or 'E'
                        TempString = TempChar;
                        while(TempString != 'E') //'E' is 1st character of 'End of file at v2.11.0'
                        {
                            SessionFile.get(TempChar);
                            while((TempChar != '\n') && (TempChar != '\0'))
                            {
                                TempString = TempString + TempChar;
                                SessionFile.get(TempChar);
                            }
                            //here have TrainID as AnsiString in TempString
                            TTrain &Train = TrainController->TrainVectorAtIdent(57, TempString.ToInt());
                            Train.SkippedDeparture = Utilities->LoadFileBool(SessionFile);
                            Train.ActionsSkippedFlag = Utilities->LoadFileBool(SessionFile);
                            Train.SkipPtrValue = Utilities->LoadFileInt(SessionFile);
                            Train.TrainSkippedEvents = Utilities->LoadFileInt(SessionFile);
                            SessionFile.get(TempChar); //will be '\n' as LoadFileInt doesn't extract newlines from the stream
                            TempString = TempChar; //added at v2.12.0 as a safeguard in case not '\n' in which case it would retain its old value
                            while((TempChar == '\n') || (TempChar == '\0'))  //get rid of any excess non-significant chars
                            {
                                SessionFile.get(TempChar); //get the next one
                                TempString = TempChar;     //when emerge this will be 'E' or 1st digit of TrainID
                            }
                        }
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.11.0"  discarded ('E' already loaded)
//end of 2.11.0 additions

//additions at v2.12.0 - change to new service early
                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0')))
                        {// get rid of all end of lines & emerge with eof or 1st digit of a TrainID or 'E'
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file
                        {
                            SessionFile.close(); //no need to initialise train data as initialised during creation of a new train
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the first digit of the first train ID which requires TreatPassAsTimeLocDeparture to be set, or 'E' if none
                        TempString = TempChar;
                        while(TempString != 'E') //'E' is 1st character of 'End of file at v2.12.0'
                        {
                            SessionFile.get(TempChar);
                            while((TempChar != '\n') && (TempChar != '\0'))
                            {
                                TempString = TempString + TempChar;
                                SessionFile.get(TempChar);
                            }
                            //here have TrainID as AnsiString in TempString & '\n' in TempChar
                            TTrain &Train = TrainController->TrainVectorAtIdent(62, TempString.ToInt());
                            Train.TreatPassAsTimeLocDeparture = true;
                            SessionFile.get(TempChar); //will be 'E' or 1st digit of next TrainID as character if more than one, or \n if more than one \n character
                            TempString = TempChar;
                            while((TempChar == '\n') || (TempChar == '\0'))  //get rid of any excess non-significant chars, unlikely to be any
                            {
                                SessionFile.get(TempChar); //get the next one
                                TempString = TempChar;
                            }
                        }
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.12.0"  discarded ('E' already loaded)
//end of additions at v2.12.0

//additions at v2.13.0 - random delays - location delays, failed points & signals  (DelayMode not saved here, but saved later with FailureMode)
                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0')))
                        {// get rid of all end of lines & emerge with eof or 1st digit of CumulativeDelayedRandMinsAllTrains
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file
                        {
                            Utilities->CumulativeDelayedRandMinsAllTrains = 0; //initialised for new prog
                            SessionFile.close(); //no need to initialise train data or Track.Failed as initialised during LoadSessionTrains and LoadTrack
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the first digit of CumulativeDelayedRandMinsAllTrains
                        TempString = "";
                        while((TempChar != '\n') && (TempChar != '\0'))
                        {
                            TempString = TempString + TempChar;
                            SessionFile.get(TempChar);
                        }
                        //here have CumulativeDelayedRandMinsAllTrains as AnsiString in TempString & '\n' in TempChar
                        Utilities->CumulativeDelayedRandMinsAllTrains = TempString.ToDouble(); //if invalid will fail with a non-error catch
                        for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++) //trains already loaded, if no trains then load DummyStr
                        { //if empty will skip
                            double TempDouble;
                            TTrain &Train = TrainController->TrainVectorAt(88, x);
                            Train.NewDelay = Utilities->LoadFileDouble(SessionFile);
                            Train.DelayedRandMins = Utilities->LoadFileDouble(SessionFile);
                            Train.CumulativeDelayedRandMinsOneTrain = Utilities->LoadFileDouble(SessionFile);
                            TempDouble = Utilities->LoadFileDouble(SessionFile);
                            Train.ActualArrivalTime = TDateTime(TempDouble); //ReleaseTime already loaded
                        }
                        //load failed point info
                        int TempInt, VecSize;
                        double TempDouble;
                        VecSize = Utilities->LoadFileInt(SessionFile); //number of failed points
                        TTrack::TInfrastructureFailureEntry FPVE;
                        for(int x = 0; x < VecSize; x++)
                        {
                            TempInt = Utilities->LoadFileInt(SessionFile); //TVPos
                            TTrackElement &TE = Track->TrackElementAt(1513, TempInt);
                            TE.Failed = true;
                            FPVE.TVPos = TempInt;
                            TempInt = Utilities->LoadFileInt(SessionFile); //TrainIDOnBridgeOrFailedPointOrigSpeedLimit01
                            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TempInt;
                            TempInt = Utilities->LoadFileInt(SessionFile); //TrainIDOnBridgeOrFailedPointOrigSpeedLimit23
                            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = TempInt;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //FailureTime
                            FPVE.FailureTime = TempDouble;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //RepairTime
                            FPVE.RepairTime = TempDouble;
                            Track->FailedPointsVector.push_back(FPVE);
                        }
                        //load failed signal info
                        VecSize = Utilities->LoadFileInt(SessionFile); //number of failed points
                        for(int x = 0; x < VecSize; x++)
                        {
                            TempInt = Utilities->LoadFileInt(SessionFile); //TVPos
                            TTrackElement &TE = Track->TrackElementAt(1533, TempInt);
                            TE.Failed = true;
                            FPVE.TVPos = TempInt;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //FailureTime
                            FPVE.FailureTime = TempDouble;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //RepairTime
                            FPVE.RepairTime = TempDouble;
                            Track->FailedSignalsVector.push_back(FPVE);
                        }
                        //load TSR info
                        VecSize = Utilities->LoadFileInt(SessionFile); //number of TSRs
                        for(int x = 0; x < VecSize; x++)
                        {
                            TempInt = Utilities->LoadFileInt(SessionFile); //TVPos
                            TTrackElement &TE = Track->TrackElementAt(1534, TempInt);
                            TE.Failed = true;
                            FPVE.TVPos = TempInt;
                            TempInt = Utilities->LoadFileInt(SessionFile); //TrainIDOnBridgeOrFailedPointOrigSpeedLimit01
                            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = TempInt;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //FailureTime
                            FPVE.FailureTime = TempDouble;
                            TempDouble = Utilities->LoadFileDouble(SessionFile); //RepairTime
                            FPVE.RepairTime = TempDouble;
                            Track->TSRVector.push_back(FPVE);
                        }
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.13.0"  discarded
//end of additions at v2.13.0

//additions at v2.14.0 - delays and failures
                        SessionFile.get(TempChar);
                        while(!SessionFile.eof() && ((TempChar == '\n') || (TempChar == '\0')))
                        {// get rid of all end of lines & emerge with eof or digit that represents DelayMode (0, 1, 2 or 3)
                            SessionFile.get(TempChar);
                        }
                        if(SessionFile.eof()) //old session file, initialise delays & failures to none
                        {
                            NoDelaysMenuItem->Enabled = false;
                            MinorDelaysMenuItem->Enabled = true;
                            ModerateDelaysMenuItem->Enabled = true;
                            MajorDelaysMenuItem->Enabled = true;
                            DelayMenu->Caption = "No delays";
                            PerfLogForm->PerformanceLog(51, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": No random delays selected on loading session");
                            Utilities->DelayMode = Nil;

                            NoFailuresMenuItem->Enabled = false;
                            MinorFailuresMenuItem->Enabled = true;
                            ModerateFailuresMenuItem->Enabled = true;
                            MajorFailuresMenuItem->Enabled = true;
                            Utilities->PointChangeEventsPerFailure = Utilities->NilPointChangeEventsPerFailure;
                            Utilities->SignalChangeEventsPerFailure = Utilities->NilSignalChangeEventsPerFailure;
                            Utilities->MTBTSRs = Utilities->NilMTBTSRs;
                            FailureMenu->Caption = "No failures";
                            PerfLogForm->PerformanceLog(52, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": No random failures selected on loading session");
                            Utilities->FailureMode = FNil;
                            SessionFile.close();
                            goto FINISHEDLOADING;
                        }
                        //TempChar now contains the digit that represents DelayMode (0, 1, 2 or 3)
                        if(TempChar == '0')
                        {
                            NoDelaysMenuItem->Enabled = false;
                            MinorDelaysMenuItem->Enabled = true;
                            ModerateDelaysMenuItem->Enabled = true;
                            MajorDelaysMenuItem->Enabled = true;
                            DelayMenu->Caption = "No delays";
                            PerfLogForm->PerformanceLog(53, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": No random delays selected on loading session");
                            Utilities->DelayMode = Nil;
                        }
                        else if(TempChar == '1')
                        {
                            NoDelaysMenuItem->Enabled = true;
                            MinorDelaysMenuItem->Enabled = false;
                            ModerateDelaysMenuItem->Enabled = true;
                            MajorDelaysMenuItem->Enabled = true;
                            DelayMenu->Caption = "Minor delays";
                            PerfLogForm->PerformanceLog(54, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Minor random delays selected on loading session");
                            Utilities->DelayMode = Minor;
                        }
                        else if(TempChar == '2')
                        {
                            NoDelaysMenuItem->Enabled = true;
                            MinorDelaysMenuItem->Enabled = true;
                            ModerateDelaysMenuItem->Enabled = false;
                            MajorDelaysMenuItem->Enabled = true;
                            DelayMenu->Caption = "Moderate delays";
                            PerfLogForm->PerformanceLog(55, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Moderate random delays selected on loading session");
                            Utilities->DelayMode = Moderate;
                        }
                        else if(TempChar == '3')
                        {
                            NoDelaysMenuItem->Enabled = true;
                            MinorDelaysMenuItem->Enabled = true;
                            ModerateDelaysMenuItem->Enabled = true;
                            MajorDelaysMenuItem->Enabled = false;
                            DelayMenu->Caption = "Major delays";
                            PerfLogForm->PerformanceLog(56, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Major random delays selected on loading session");
                            Utilities->DelayMode = Major;
                        }
                        else
                        {
                            throw Exception("Session file DelayMode not in range");   //non-error catch later
                        }
                        SessionFile.get(TempChar); //should be '\n'
                        SessionFile.get(TempChar); //FailureMode
                        if(TempChar == '0')
                        {
                            NoFailuresMenuItem->Enabled = false;
                            MinorFailuresMenuItem->Enabled = true;
                            ModerateFailuresMenuItem->Enabled = true;
                            MajorFailuresMenuItem->Enabled = true;
                            Utilities->PointChangeEventsPerFailure = Utilities->NilPointChangeEventsPerFailure;
                            Utilities->SignalChangeEventsPerFailure = Utilities->NilSignalChangeEventsPerFailure;
                            Utilities->MTBTSRs = Utilities->NilMTBTSRs;
                            FailureMenu->Caption = "No failures";
                            PerfLogForm->PerformanceLog(57, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": No random failures selected on loading session");
                            Utilities->FailureMode = FNil;
                        }
                        else if(TempChar == '1')
                        {
                            NoFailuresMenuItem->Enabled = true;
                            MinorFailuresMenuItem->Enabled = false;
                            ModerateFailuresMenuItem->Enabled = true;
                            MajorFailuresMenuItem->Enabled = true;
                            Utilities->PointChangeEventsPerFailure = Utilities->MinorPointChangeEventsPerFailure;
                            Utilities->SignalChangeEventsPerFailure = Utilities->MinorSignalChangeEventsPerFailure;
                            Utilities->MTBTSRs = Utilities->MinorMTBTSRs;
                            FailureMenu->Caption = "Minor failures";
                            PerfLogForm->PerformanceLog(58, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Minor random failures selected on loading session");
                            Utilities->FailureMode = FMinor;
                        }
                        else if(TempChar == '2')
                        {
                            NoFailuresMenuItem->Enabled = true;
                            MinorFailuresMenuItem->Enabled = true;
                            ModerateFailuresMenuItem->Enabled = false;
                            MajorFailuresMenuItem->Enabled = true;
                            Utilities->PointChangeEventsPerFailure = Utilities->ModeratePointChangeEventsPerFailure;
                            Utilities->SignalChangeEventsPerFailure = Utilities->ModerateSignalChangeEventsPerFailure;
                            Utilities->MTBTSRs = Utilities->ModerateMTBTSRs;
                            FailureMenu->Caption = "Moderate failures";
                            PerfLogForm->PerformanceLog(59, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Moderate random failures selected on loading session");
                            Utilities->FailureMode = FModerate;
                        }
                        else if(TempChar == '3')
                        {
                            NoFailuresMenuItem->Enabled = true;
                            MinorFailuresMenuItem->Enabled = true;
                            ModerateFailuresMenuItem->Enabled = true;
                            MajorFailuresMenuItem->Enabled = false;
                            Utilities->PointChangeEventsPerFailure = Utilities->MajorPointChangeEventsPerFailure;
                            Utilities->SignalChangeEventsPerFailure = Utilities->MajorSignalChangeEventsPerFailure;
                            Utilities->MTBTSRs = Utilities->MajorMTBTSRs;
                            FailureMenu->Caption = "Major failures";
                            PerfLogForm->PerformanceLog(60, Utilities->Format96HHMMSS(TrainController->RestartTime) + ": Major random failures selected on loading session");
                            Utilities->FailureMode = FMajor;
                        }
                        else
                        {
                            throw Exception("Session file FailureMode not in range"); //non-error catch later
                        }
                        SessionFile.get(TempChar); //should be '\n'
                        DummyStr = Utilities->LoadFileString(SessionFile); // "End of file at v2.14.0"  discarded
//end of v2.14.0 additions
                        SessionFile.close();
                    }

FINISHEDLOADING:
                    if(SessionFile.is_open())
                    {
                        SessionFile.close();
                    }
                    // deal with other settings
                    Display->DisplayOffsetH = TempDisplayOffsetH; // reset to saved values
                    Display->DisplayOffsetV = TempDisplayOffsetV;
                    Display->DisplayOffsetHHome = TempDisplayOffsetHHome;
                    Display->DisplayOffsetVHome = TempDisplayOffsetVHome;
                    // now set attributes to 1 for all LCs with barriers down
                    for(unsigned int x = 0; x < Track->BarriersDownVector.size(); x++)
                    {
                        Track->SetLinkedLevelCrossingBarrierAttributes(2, Track->BarriersDownVector.at(x).HLoc, Track->BarriersDownVector.at(x).VLoc, 1);
                    }
                    Track->ChangingLCVector.clear();
                    Track->CalcHLocMinEtc(10);
                    Level1Mode = RestartSessionOperMode;
                    SetLevel1Mode(27);
                    if(Level2OperMode == PreStart)
                    // this section added at v1.3.2 as otherwise only in MainScreenMouseDown2, and if load a session without clicking mouse on screen
                    {
                        // then delay unspecified though seems to be 0
                        PointsFlashDuration = 0.0;
                        Track->LevelCrossingBarrierUpFlashDuration = 0.0;
                        Track->LevelCrossingBarrierDownFlashDuration = 0.0;
                    }
                    else
                    {
                        PointsFlashDuration = AllRoutes->PointsDelay;
                        Track->LevelCrossingBarrierUpFlashDuration = AllRoutes->LevelCrossingBarrierUpDelay;
                        Track->LevelCrossingBarrierDownFlashDuration = AllRoutes->LevelCrossingBarrierDownDelay;
                    }
                    RlyFile = true;
                    SetCaption(3);
                    TrainController->ReplotTrains(2, Display); //to set track elements with train IDs
                   //now routes and trains loaded and TrainIDs set (in ReplotTrains) set all the signals as a session file saved before v2.14.0 will have incorrect
                   //aspects if there are facing ground signals on a route new at v2.14.0
                    if(AllRoutes->AllRoutesVector.size() > 0)
                    {
                        for(TAllRoutes::TAllRoutesVectorIterator ARVIt = AllRoutes->AllRoutesVector.begin(); ARVIt < AllRoutes->AllRoutesVector.end(); ARVIt++)
                        {
                            ARVIt->SetRouteSignals(13);
                        }
                    }
                    ClearandRebuildRailway(42);
                }
            }
            else
            {
                ShowMessage("Session file integrity check failed, unable to load " + LoadSessionDialog->FileName);
            }
            Screen->Cursor = TCursor(-2); // Arrow;
        }
        Utilities->CallLogPop(1146);
    }
    catch(const Exception &e)
    {
        if((e.Message.Pos("esource") > 0) || (e.Message.Pos("arameter") > 0)) // 'Resource or Parameter, avoid capitals as may be OS dependent
        {
            Screen->Cursor = TCursor(-2); // Arrow;
            OutputLog1->Caption = "";
            OutputLog2->Caption = "";
            OutputLog3->Caption = "";
            OutputLog4->Caption = "";
            OutputLog5->Caption = "";
            OutputLog6->Caption = "";
            OutputLog7->Caption = "";
            OutputLog8->Caption = "";
            OutputLog9->Caption = "";
            OutputLog10->Caption = "";
            UnicodeString MessageStr =
                "Insufficient memory available to load the file, and partial load likely to be corrupt. Application will terminate. Try loading the session as the first action after reloading the program.";
// UnicodeString MessageStr = "Last train loaded = " + UnicodeString(TrainController->LastTrainLoaded); //for debugging session train loading for many trains
            Application->MessageBox(MessageStr.c_str(), L"Out of memory", MB_OK | MB_ICONERROR);
            Application->Terminate();
        }
        else  //non-error catch at v2.14.0
        {
            TrainController->StopTTClockMessage(96, "Session file failed to load - may be corrupt.\nError message: " + e.Message);
            Screen->Cursor = TCursor(-2); // Arrow;
            Utilities->CallLogPop(2441);
        }
    }
}

// ---------------------------------------------------------------------------

void TInterface::SaveInterface(int Caller, std::ofstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveInterface");
    if(Level2OperMode == PreStart)
    {
        Utilities->SaveFileString(SessionFile, AnsiString("PreStart"));
    }
    else
    {
        Utilities->SaveFileString(SessionFile, AnsiString("NotPreStart")); // covers both Paused & Operating
    }
    Utilities->SaveFileString(SessionFile, RailwayTitle);
    Utilities->SaveFileString(SessionFile, TimetableTitle);
    Utilities->SaveFileBool(SessionFile, PreferredRoute);
    Utilities->SaveFileBool(SessionFile, PreferredRoute);
// changed at v2.7.0, was ConsecSignalsRoute here but if different to PreferredRoute (as can be from v2.7.0) then have
    Utilities->SaveFileBool(SessionFile, AutoSigsFlag);
// error if try to load with an earlier prog version.  ConsecSignalsRoute now moved to end of session file
    Utilities->SaveFileInt(SessionFile, Display->DisplayOffsetH);
    Utilities->SaveFileInt(SessionFile, Display->DisplayOffsetV);
    Utilities->SaveFileInt(SessionFile, Display->DisplayOffsetHHome);
    Utilities->SaveFileInt(SessionFile, Display->DisplayOffsetVHome);
    Utilities->SaveFileInt(SessionFile, Display->DisplayZoomOutOffsetH);
    Utilities->SaveFileInt(SessionFile, Display->DisplayZoomOutOffsetV);
    Utilities->SaveFileString(SessionFile, OutputLog1->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog2->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog3->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog4->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog5->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog6->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog7->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog8->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog9->Caption);
    Utilities->SaveFileString(SessionFile, OutputLog10->Caption);

    Utilities->SaveFileInt(SessionFile, TrainController->OnTimeArrivals);
    Utilities->SaveFileInt(SessionFile, TrainController->LateArrivals);
    Utilities->SaveFileInt(SessionFile, TrainController->EarlyArrivals);
    Utilities->SaveFileInt(SessionFile, TrainController->OnTimePasses);
    Utilities->SaveFileInt(SessionFile, TrainController->LatePasses);
    Utilities->SaveFileInt(SessionFile, TrainController->EarlyPasses);
    Utilities->SaveFileInt(SessionFile, TrainController->OnTimeDeps);
    Utilities->SaveFileInt(SessionFile, TrainController->LateDeps);
    Utilities->SaveFileInt(SessionFile, TrainController->MissedStops);
    Utilities->SaveFileInt(SessionFile, TrainController->OtherMissedEvents);
    Utilities->SaveFileInt(SessionFile, TrainController->UnexpectedExits);
    Utilities->SaveFileInt(SessionFile, TrainController->IncorrectExits);
    Utilities->SaveFileInt(SessionFile, TrainController->SPADEvents);
    Utilities->SaveFileInt(SessionFile, TrainController->SPADRisks);
    Utilities->SaveFileInt(SessionFile, TrainController->CrashedTrains);
    Utilities->SaveFileInt(SessionFile, TrainController->Derailments);
    Utilities->SaveFileDouble(SessionFile, TrainController->TotLateArrMins);
    Utilities->SaveFileDouble(SessionFile, TrainController->TotEarlyArrMins);
    Utilities->SaveFileDouble(SessionFile, TrainController->TotLatePassMins);
    Utilities->SaveFileDouble(SessionFile, TrainController->TotEarlyPassMins);
    Utilities->SaveFileDouble(SessionFile, TrainController->TotLateDepMins);
    // ExcessLCDownMins saved after ***Interface*** at v2.2.0 (omitted in error earlier)
    Utilities->CallLogPop(1211);
}

// ---------------------------------------------------------------------------
void TInterface::LoadInterface(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadInterface");
    AnsiString OpMode = Utilities->LoadFileString(SessionFile);

    if(OpMode == "PreStart")
    {
        Level2OperMode = PreStart;
    }
    else
    {
        Level2OperMode = Paused;
    }
    RailwayTitle = Utilities->LoadFileString(SessionFile);
    SavedFileName = CurDir + "\\" + RAILWAY_DIR_NAME + "\\" + RailwayTitle + ".rly";

    TimetableTitle = Utilities->LoadFileString(SessionFile);
    PreferredRoute = Utilities->LoadFileBool(SessionFile);
    ConsecSignalsRoute = Utilities->LoadFileBool(SessionFile);
    AutoSigsFlag = Utilities->LoadFileBool(SessionFile);
    Display->DisplayOffsetH = Utilities->LoadFileInt(SessionFile);
    Display->DisplayOffsetV = Utilities->LoadFileInt(SessionFile);
    Display->DisplayOffsetHHome = Utilities->LoadFileInt(SessionFile);
    Display->DisplayOffsetVHome = Utilities->LoadFileInt(SessionFile);
    Display->DisplayZoomOutOffsetH = Utilities->LoadFileInt(SessionFile);
    Display->DisplayZoomOutOffsetV = Utilities->LoadFileInt(SessionFile);
    OutputLog1->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog2->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog3->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog4->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog5->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog6->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog7->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog8->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog9->Caption = Utilities->LoadFileString(SessionFile);
    OutputLog10->Caption = Utilities->LoadFileString(SessionFile);

    TrainController->OnTimeArrivals = Utilities->LoadFileInt(SessionFile);
    TrainController->LateArrivals = Utilities->LoadFileInt(SessionFile);
    TrainController->EarlyArrivals = Utilities->LoadFileInt(SessionFile);
    TrainController->OnTimePasses = Utilities->LoadFileInt(SessionFile);
    TrainController->LatePasses = Utilities->LoadFileInt(SessionFile);
    TrainController->EarlyPasses = Utilities->LoadFileInt(SessionFile);
    TrainController->OnTimeDeps = Utilities->LoadFileInt(SessionFile);
    TrainController->LateDeps = Utilities->LoadFileInt(SessionFile);
    TrainController->MissedStops = Utilities->LoadFileInt(SessionFile);
    TrainController->OtherMissedEvents = Utilities->LoadFileInt(SessionFile);
    TrainController->UnexpectedExits = Utilities->LoadFileInt(SessionFile);
    TrainController->IncorrectExits = Utilities->LoadFileInt(SessionFile);
    TrainController->SPADEvents = Utilities->LoadFileInt(SessionFile);
    TrainController->SPADRisks = Utilities->LoadFileInt(SessionFile);
    TrainController->CrashedTrains = Utilities->LoadFileInt(SessionFile);
    TrainController->Derailments = Utilities->LoadFileInt(SessionFile);
    TrainController->TotLateArrMins = Utilities->LoadFileDouble(SessionFile);
    TrainController->TotEarlyArrMins = Utilities->LoadFileDouble(SessionFile);
    TrainController->TotLatePassMins = Utilities->LoadFileDouble(SessionFile);
    TrainController->TotEarlyPassMins = Utilities->LoadFileDouble(SessionFile);
    TrainController->TotLateDepMins = Utilities->LoadFileDouble(SessionFile);
    session_api_->dump();   // update session INI file  //added at v2.10.0
    Utilities->CallLogPop(1212);
}

// ---------------------------------------------------------------------------

bool TInterface::CheckInterface(int Caller, std::ifstream &SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckInterface");

    AnsiString OpMode = "";

    if(!Utilities->CheckAndReadFileString(SessionFile, OpMode))
    {
        Utilities->CallLogPop(1767);
        return(false);
    }
    else if((OpMode != "PreStart") && (OpMode != "NotPreStart"))
    {
        Utilities->CallLogPop(1768);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile)) // RailwayTitle
    {
        Utilities->CallLogPop(1213);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile)) // TimetableTitle
    {
        Utilities->CallLogPop(1214);
        return(false);
    }
    if(!Utilities->CheckFileBool(SessionFile))
    {
        Utilities->CallLogPop(1216);
        return(false);
    }
    if(!Utilities->CheckFileBool(SessionFile))
    {
        Utilities->CallLogPop(1217);
        return(false);
    }
    if(!Utilities->CheckFileBool(SessionFile))
    {
        Utilities->CallLogPop(1218);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1409);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1486);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1487);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1488);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1489);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, -1000000, 1000000))
    {
        Utilities->CallLogPop(1528);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1725);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1726);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1727);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1728);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1730);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1731);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1732);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1733);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1734);
        return(false);
    }
    if(!Utilities->CheckFileStringZeroDelimiter(SessionFile))
    {
        Utilities->CallLogPop(1789);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1737);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1738);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1739);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1740);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1741);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1742);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1743);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1744);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1745);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1746);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1747);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1748);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1749);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1750);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1751);
        return(false);
    }
    if(!Utilities->CheckFileInt(SessionFile, 0, 1000000))
    {
        Utilities->CallLogPop(1752);
        return(false);
    }
    if(!Utilities->CheckFileDouble(SessionFile))
    {
        Utilities->CallLogPop(1753);
        return(false);
    }
    if(!Utilities->CheckFileDouble(SessionFile))
    {
        Utilities->CallLogPop(1754);
        return(false);
    }
    if(!Utilities->CheckFileDouble(SessionFile))
    {
        Utilities->CallLogPop(1755);
        return(false);
    }
    if(!Utilities->CheckFileDouble(SessionFile))
    {
        Utilities->CallLogPop(1756);
        return(false);
    }
    if(!Utilities->CheckFileDouble(SessionFile))
    {
        Utilities->CallLogPop(1757);
        return(false);
    }
    Utilities->CallLogPop(1219);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::SaveTimetableToSessionFile(int Caller, std::ofstream &SessionFile, AnsiString SessionFileStr)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveTimetableToSessionFile," + SessionFileStr);
    if(!FileExists(TempTTFileName))
    {
        Utilities->CallLogPop(1862);
        return(false);
    }
    SessionFile.close(); // close & re-open in append & binary mode so LF characters copy as LFs & not CRLFs
    SessionFile.open(SessionFileStr.c_str(), std::ios_base::app | std::ios_base::binary); // file pointer set to end

    int Handle = FileOpen(TempTTFileName, fmOpenRead);
    int Count = 0;

    while(Handle < 0) // this type of file use failed when used in SaveTempTimetableFile when used to resave timetable.tmp from
                      // temp .ttb file, but changed that to avoid so many rapid file actions in quick succession & been OK since
                      // then, but nevertheless have 10 retries before giving message to be on safe side
    {
        Handle = FileOpen(TempTTFileName, fmOpenRead);
        Count++;
        Delay(1, 50); // 50mSec delay between tries
        if(Count > 10)
        {
            ShowMessage("Failed to open temporary timetable file.  Unable to save the session");
            Utilities->CallLogPop(1221);
            return(false);
        }
    }

    char *Buffer = new char[10000];
    int BytesRead;

    while(true)
    {
        BytesRead = FileRead(Handle, Buffer, 10000);
        SessionFile.write(Buffer, BytesRead);
        if(BytesRead < 10000)
        {
            break;
        }
    }
    delete[]Buffer;
    FileClose(Handle);

    SessionFile.close(); // close & re-open in append & text out mode as before so can write text
    SessionFile.open(SessionFileStr.c_str(), std::ios_base::app | std::ios_base::out); // file pointer set to end

    Utilities->SaveFileString(SessionFile, "***End***"); // marker for end of timetable
// now need to save the TrainOperatingData so can be loaded back into the timetable as is
    Utilities->SaveFileInt(SessionFile, TrainController->TrainDataVector.size());
    for(unsigned int x = 0; x < TrainController->TrainDataVector.size(); x++)
    {
        Utilities->SaveFileInt(SessionFile, TrainController->TrainDataVector.at(x).TrainOperatingDataVector.size());
        for(unsigned int y = 0; y < TrainController->TrainDataVector.at(x).TrainOperatingDataVector.size(); y++)
        {
            Utilities->SaveFileInt(SessionFile, TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).TrainID);
            Utilities->SaveFileInt(SessionFile, (short)(TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).EventReported));
            Utilities->SaveFileInt(SessionFile, (short)(TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).RunningEntry));
        }
    }
    Utilities->CallLogPop(1220);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::SaveTimetableToErrorFile(int Caller, std::ofstream &ErrorFile, AnsiString ErrorFileStr, AnsiString TimetableFileName)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveTimetableToErrorFile," + ErrorFileStr + "," + TimetableFileName);
    if(!FileExists(TimetableFileName))
    {
        Utilities->CallLogPop(1863);
        return(false);
    }
    ErrorFile.close(); // close & re-open in append & binary mode so LF characters copy as LFs & not CRLFs
    ErrorFile.open(ErrorFileStr.c_str(), std::ios_base::app | std::ios_base::binary); // file pointer set to end

    int Handle = FileOpen(TimetableFileName, fmOpenRead);
    int Count = 0;

    while(Handle < 0) // this type of file use failed when used in SaveTempTimetableFile when used to resave timetable.tmp from
                      // temp .ttb file, but changed that to avoid so many rapid file actions in quick succession & been OK since
                      // then, but nevertheless have 10 retries before giving message to be on safe side
    {
        Handle = FileOpen(TimetableFileName, fmOpenRead);
        Count++;
        Delay(5, 50); // 50mSec delay between tries
        if(Count > 10)
        {
            Utilities->CallLogPop(1835);
            return(false);
        }
    }

    char *Buffer = new char[10000];
    int BytesRead;

    while(true)
    {
        BytesRead = FileRead(Handle, Buffer, 10000);
        ErrorFile.write(Buffer, BytesRead);
        if(BytesRead < 10000)
        {
            break;
        }
    }
    delete[]Buffer;
    FileClose(Handle);

    ErrorFile.close(); // close & re-open in append & text out mode as before so can write text
    ErrorFile.open(ErrorFileStr.c_str(), std::ios_base::app | std::ios_base::out); // file pointer set to end

    Utilities->SaveFileString(ErrorFile, "***End of timetable***"); // marker for end of timetable
    Utilities->CallLogPop(1836);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::LoadTimetableFromSessionFile(int Caller, std::ifstream &SessionFile)
// the .ttb section is delimited by "***End***"
// create the temporary timetable file in the working folder exactly like the original
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadTimetableFromSessionFile");
    // reset all message flags, stops them being given twice (shouldn't be needed here but add for safety) //new at v2.4.0
    TrainController->SSHigh = false;
    TrainController->MRSHigh = false;
    TrainController->MRSLow = false;
    TrainController->MassHigh = false;
    TrainController->BFHigh = false;
    TrainController->BFLow = false;
    TrainController->PwrHigh = false;
    TrainController->SigSHigh = false;
    TrainController->SigSLow = false;
    if((TempTTFileName != "") && FileExists(TempTTFileName))
    {
        DeleteFile(TempTTFileName);
    }
    int TempTTFileNumber = 0;

    while(FileExists(CurDir + "\\TmpTT" + AnsiString(TempTTFileNumber) + ".tmp"))
    {
        TempTTFileNumber++;
    }
    TempTTFileName = CurDir + "\\TmpTT" + AnsiString(TempTTFileNumber) + ".tmp";

    std::ofstream TTBFile(TempTTFileName.c_str()); // use text mode as SessionFile is in text mode, so CRLFs read as LFs, and LFs write as CRLFs.
    int Count;
    char Zero = '\0';

    if(!TTBFile.fail())
    {
        char *Buffer = new char[10000]; // can't use LoadFileString as that expects a '\0' delimiter
        char TempChar = (char)(SessionFile.peek()); // have a look at the next character, if it's '\n'
        if(TempChar == '\n')
        {
            SessionFile.get(TempChar); // then get rid of it, else leave it in as part of the first line
        }
        if(!SessionFile.getline(Buffer, 10000, '\0'))
        {
            TTBFile.close();
            DeleteFile(TempTTFileName);
            delete[]Buffer;
            Utilities->CallLogPop(1222);
            return(false);
        }
        Count = 0;
        for(int x = 0; x < 10000; x++)
        {
            if(Buffer[x] != '\0')
            {
                Count++;
            }
            else
            {
                break;
            }
        }
        while(AnsiString(Buffer) != "***End***")
        {
            TTBFile.write(Buffer, Count);
            TTBFile.write(&Zero, 1);
// TTBFile.write(&NewLine, 1);
            if(!SessionFile.getline(Buffer, 10000, '\0'))
            {
                TTBFile.close();
                DeleteFile(TempTTFileName);
                delete[]Buffer;
                Utilities->CallLogPop(1223);
                return(false);
            }
            Count = 0;
            for(int x = 0; x < 10000; x++)
            {
                if(Buffer[x] != '\0')
                {
                    Count++;
                }
                else
                {
                    break;
                }
            }
        }
        TTBFile.close();
        delete[]Buffer;
// SaveTempTimetableFile(1, TTBFileName); no need, already has required name
// now create the internal timetable from the .tmp file
        bool GiveMessagesFalse = false;
        bool CheckLocationsExistInRailwayTrue = true;
        if(TrainController->TimetableIntegrityCheck(1, TempTTFileName.c_str(), GiveMessagesFalse, CheckLocationsExistInRailwayTrue))
        {
            std::ifstream TTBLFile(TempTTFileName.c_str(), std::ios_base::binary);
            if(TTBLFile.is_open())
            {
                bool SessionFileTrue = true;
                if(!(BuildTrainDataVectorForLoadFile(1, TTBLFile, GiveMessagesFalse, CheckLocationsExistInRailwayTrue, SessionFileTrue)))
                {
                    TTBLFile.close();
                    DeleteFile(TempTTFileName);
                    Utilities->CallLogPop(1224);
                    return(false);
                }
            }
            else
            {
                DeleteFile(TempTTFileName);
                Utilities->CallLogPop(1225);
                return(false);
            }
        } // if(FileIntegrityCheck(TTBFileName.c_str()))
        else
        {
            DeleteFile(TempTTFileName);
            Utilities->CallLogPop(1226);
            return(false);
        }
// DeleteFile(TempTTFileName); no, need to save it for later session saves

        // now need to load the TrainOperatingData so can be loaded back into the timetable
        int NumberOfTrainEntries = Utilities->LoadFileInt(SessionFile);
        if(NumberOfTrainEntries != (int)(TrainController->TrainDataVector.size()))
        {
            Utilities->CallLogPop(1811);
            return(false);
        }
        for(int x = 0; x < NumberOfTrainEntries; x++)
        {
            int NumberOfTrains = Utilities->LoadFileInt(SessionFile);
            if(NumberOfTrains != (int)(TrainController->TrainDataVector.at(x).TrainOperatingDataVector.size()))
            {
                Utilities->CallLogPop(1812);
                return(false);
            }
            for(int y = 0; y < NumberOfTrains; y++)
            {
                TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).TrainID = Utilities->LoadFileInt(SessionFile);
                TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).EventReported = (TActionEventType)(Utilities->LoadFileInt(SessionFile));
                TrainController->TrainDataVector.at(x).TrainOperatingDataVector.at(y).RunningEntry = (TRunningEntry)(Utilities->LoadFileInt(SessionFile));
            }
        }
        Utilities->CallLogPop(1227);
        return(true);
    }
    else
    {
        Utilities->CallLogPop(1228);
        return(false);
    }
}

// ---------------------------------------------------------------------------

bool TInterface::CheckTimetableFromSessionFile(int Caller, std::ifstream &SessionFile)
// the .ttb section is delimited by '\0' followed by "***End***" & has been saved in binary mode, i.e. no '\0'
// string delimiters between entries, this check function just checks the (non-zero terminated) string entries in the file without
// trying to build a timetable - that's done during load
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckTimetableFromSessionFile");
    AnsiString OutString;

    if(!Utilities->CheckAndReadFileString(SessionFile, OutString))
    {
        Utilities->CallLogPop(1229);
        return(false);
    }
    while(OutString != "***End***")
    {
        if(!Utilities->CheckAndReadFileString(SessionFile, OutString))
        {
            Utilities->CallLogPop(1230);
            return(false);
        }
    }
// now need to check the TrainOperatingData, which was saved in text mode
    if(SessionFile.fail())
    {
        Utilities->CallLogPop(1231);
        return(false);
    }
    int NumberOfTrainEntries;

    if(!Utilities->CheckAndReadFileInt(SessionFile, 0, 10000, NumberOfTrainEntries))
    {
        Utilities->CallLogPop(1232);
        return(false);
    }
    for(int x = 0; x < NumberOfTrainEntries; x++)
    {
        int NumberOfTrains;
        if(!Utilities->CheckAndReadFileInt(SessionFile, 0, 10000, NumberOfTrains))
        {
            Utilities->CallLogPop(1233);
            return(false);
        }
        for(int y = 0; y < NumberOfTrains; y++)
        {
            if(!Utilities->CheckFileInt(SessionFile, -1, 1000000)) // TrainID
            {
                Utilities->CallLogPop(1234);
                return(false);
            }
            if(!Utilities->CheckFileInt(SessionFile, 0, 32)) // EventReported //increased to 32 at v2.11.1 due to Xeon error report 07/01/22 as there are 33
                                                                              //event reports now (increased at v2.9.1)
            {
                Utilities->CallLogPop(1235);
                return(false);
            }
            if(!Utilities->CheckFileInt(SessionFile, 0, 2)) // RunningEntry
            {
                Utilities->CallLogPop(1236);
                return(false);
            }
        }
    }
    Utilities->CallLogPop(1237);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::BuildTrainDataVectorForLoadFile(int Caller, std::ifstream &TTBLFile, bool GiveMessages, bool CheckLocationsExistInRailway, bool SessionFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",BuildTrainDataVectorForLoadFile," + AnsiString((short)GiveMessages));
    TrainController->TrainDataVector.clear(); // get rid of any earlier timetable
    bool EndOfFile = false;
    int Count = 0;
    char *TrainTimetableString = new char[10000]; // enough for ~ 200 stations at 50 chars/station, should be adequate!

    while(!EndOfFile)
    {
        TTBLFile.getline(TrainTimetableString, 10000, '\0');
        if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // stores a null in 1st position if doesn't load any characters
        {
            // may still have eof even if read a line (no CRLF at end), and
            // if so need to process it
            EndOfFile = true;
            break;
        }
        AnsiString OneLine(TrainTimetableString);
        bool FinalCallTrue = true;
        while((Count == 0) && !TrainController->ProcessOneTimetableLine(3, Count, OneLine, EndOfFile, FinalCallTrue, GiveMessages,
                                                                        CheckLocationsExistInRailway)) // get rid of lines before the start time
        {
            TTBLFile.getline(TrainTimetableString, 10000, '\0');
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // see above
            {
                TTBLFile.close();
                throw Exception("Timetable FinalCall error - no start time on own line, Count = 0");
            }
            OneLine = AnsiString(TrainTimetableString);
        }
        // here when have accepted the start time
        if(Count == 0)
        {
            Count++; // increment past the start time
            TTBLFile.getline(TrainTimetableString, 10000, '\0'); // get next line after start time
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // see above
            {
                EndOfFile = true;
                OneLine = "";
            }
            else
            {
                OneLine = AnsiString(TrainTimetableString);
            }
        }
        if(!TrainController->ProcessOneTimetableLine(4, Count, OneLine, EndOfFile, FinalCallTrue, GiveMessages, CheckLocationsExistInRailway))
        {
            TTBLFile.close();
            throw Exception("Timetable FinalCall error in processing one timetable line, Count = " + AnsiString(Count));
        }
        if(EndOfFile && (Count < 2)) // Timetable must contain at least two relevant lines, one for start time and at least one train
        {
            TTBLFile.close();
            throw Exception("Timetable FinalCall error - too few or no relevant entries, Count = " + AnsiString(Count));
        }
        Count++;
    }
    TTBLFile.close();
    delete[]TrainTimetableString;
    bool TwoLocationFlag; //not used in LoadFile
// here when first pass actions completed successfully
    if(!TrainController->SecondPassActions(0, GiveMessages, TwoLocationFlag)) // Check for matching join/split HeadCodes, check increasing times & matching split/join
    // times, complete arrival & departure times for each TT line, check & complete train info for each type of start,
    // messages given in function if errors & vector cleared
    {
        if(GiveMessages)
        {
            ShowMessage("Timetable secondary integrity check failed - unable to load");
        }
        Utilities->CallLogPop(1238);
        return(false);
    }
    else
    {
// TimetableLoaded = true;
        if(!SessionFile) // new timetable being loaded so need new TimetableTitle, if SessionFile true then already have it from LoadInterface
        {
            for(int x = TimetableDialog->FileName.Length(); x > 0; x--)
            {
                if(TimetableDialog->FileName[x] == '\\')
                {
                    TimetableTitle = TimetableDialog->FileName.SubString(x + 1, TimetableDialog->FileName.Length() - x - 4);
                    SetCaption(4);
                    break;
                }
            }
        }
// if(GiveMessages) //only set BaseMode if have manually loaded a timetable changed for the below in v2.4.0
        if(!SessionFile) // only set BaseMode if have manually loaded a timetable, i.e SessionFile is false
        {
            Level1Mode = BaseMode;
            SetLevel1Mode(28);
        }
    }
    Utilities->CallLogPop(1239);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::BuildTrainDataVectorForValidateFile(int Caller, std::ifstream &TTBLFile, bool GiveMessages, bool CheckLocationsExistInRailway)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",BuildTrainDataVectorForValidateFile," + AnsiString((short)GiveMessages));
    TrainController->TrainDataVector.clear(); // get rid of any earlier timetable
    bool EndOfFile = false;
    int Count = 0;
    char *TrainTimetableString = new char[10000]; // enough for ~ 200 stations at 50 chars/station, should be adequate!

    while(!EndOfFile)
    {
        TTBLFile.getline(TrainTimetableString, 10000, '\0');
        if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // stores a null in 1st position if doesn't load any characters
        {
            // may still have eof even if read a line (no CRLF at end), and
            // if so need to process it
            EndOfFile = true;
            break;
        }
        AnsiString OneLine(TrainTimetableString);
        bool FinalCallTrue = true;
        while((Count == 0) && !TrainController->ProcessOneTimetableLine(0, Count, OneLine, EndOfFile, FinalCallTrue, GiveMessages,
                                                                        CheckLocationsExistInRailway)) // get rid of lines before the start time
        {
            TTBLFile.getline(TrainTimetableString, 10000, '\0');
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // see above
            {
                TTBLFile.close();
                throw Exception("Timetable FinalCall error - no start time on own line, Count = 0");
            }
            OneLine = AnsiString(TrainTimetableString);
        }
        // here when have accepted the start time
        if(Count == 0)
        {
            Count++; // increment past the start time
            TTBLFile.getline(TrainTimetableString, 10000, '\0'); // get next line after start time
            if(TTBLFile.eof() && (TrainTimetableString[0] == '\0')) // see above
            {
                EndOfFile = true;
                OneLine = "";
            }
            else
            {
                OneLine = AnsiString(TrainTimetableString);
            }
        }
        if(!TrainController->ProcessOneTimetableLine(1, Count, OneLine, EndOfFile, FinalCallTrue, GiveMessages, CheckLocationsExistInRailway))
        {
            TTBLFile.close();
            throw Exception("Timetable FinalCall error in processing one timetable line, Count = " + AnsiString(Count));
        }
        if(EndOfFile && (Count < 2)) // Timetable must contain at least two relevant lines, one for start time and at least one train
        {
            TTBLFile.close();
            throw Exception("Timetable FinalCall error - too few or no relevant entries, Count = " + AnsiString(Count));
        }
        Count++;
    }
    TTBLFile.close();
    delete[]TrainTimetableString;
    bool TwoLocationFlag;
// here when first pass actions completed successfully
    if(!TrainController->SecondPassActions(1, GiveMessages, TwoLocationFlag)) // Check for matching join/split HeadCodes, check increasing times & matching split/join
    // times, complete arrival & departure times for each TT line, check & complete train info for each type of start,
    // messages given in function if errors & vector cleared
    {
// if(GiveMessages) ShowMessage("Timetable secondary integrity check failed");
// above dropped in v2.4.0 as all called functions give own messages
        Utilities->CallLogPop(1665);
        return(false);
    }
    else if(TwoLocationFlag) //i.e returns true but have services with two or more locations without a cdt between //added at v2.9.1
    {
        AnsiString AllServices = "", Suffix  = "";
        int Count = 1;
        if(!TwoLocationNamePanelHide)
        {
            TwoLocationNamePanel->Top = TimetableEditPanel->Top + ((TimetableEditPanel->Height - TwoLocationNamePanel->Height) / 2);
            TwoLocationNamePanel->Left = TimetableEditPanel->Left + ((TimetableEditPanel->Width - TwoLocationNamePanel->Width) / 2);
            for(TTrainController::TServiceCallingLocsList::iterator TLLIt = TrainController->TwoLocationList.begin(); TLLIt != TrainController->TwoLocationList.end(); TLLIt++)
            {
                if(Count <= 5)
                {
                    AllServices = AllServices + *TLLIt + ", ";
                }
                Count++;
            }
            if(Count > 6) //if exactly 5 entered then Count will be 6, Count always 1 more than entered
            {
                Suffix = "(more than 5, first 5 are) ";
            }
            if(Count > 2) //more than 1
            {
                TwoLocationNameLabel->Caption = "The following services have two or more locations with the same name without a change of\n"
                                                "direction between them.  If this isn't intended then please correct them.\n\n"
                                                "Before ticking the check box please be sure that all services are correct.\n\n"
                                                "Services: " + Suffix + " " + AllServices;
            }
            else
            {
                TwoLocationNameLabel->Caption = "The following service has two or more locations with the same name without a change of\n"
                                                "direction between them.  If this isn't intended then please correct it.\n\n"
                                                "Service: " + AllServices;
            }
            TwoLocationNamePanel->Visible = true;
            TwoLocationNamePanel->BringToFront();
            ShowHideTTButton->Enabled = false;
            ExitTTModeButton->Enabled = false;
            TimetableEditPanel->Enabled = false;
        }
    }
    Utilities->CallLogPop(1666);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::SessionFileIntegrityCheck(int Caller, AnsiString FileName)
/* Here need to check as far as timetable, then go back and load the track, because the timetable compilation check
relies on the track vector and map being in place.  Won't affect the later load because the vector and map are cleared
before loading.

Although this appears cumbersome, I initially used tellg() & seekg() to reposition the file pointer without having to do
all this backtracking.  However after many problems I eventually found that tellg() sometimes returns false values,
which cause problems when reloaded using seekg().  This must be a compiler problem, though I could find no mention of it
in the CBuilder4 issues list or on the web.  The full write-up is at the end of this unit.

Also, with hindsight, I wish I had just saved and reloaded the timetable vectors rather than the text of the timetable.  That
would probably have been easier.  To change it now though would cause compatibility problems with sessions created by earlier versions.
*/
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SessionFileIntegrityCheck," + FileName);
    std::ifstream InFile(FileName.c_str());
// first pass as far as timetable
    int NumberOfActiveElements;
    bool GraphicsFollow = false;

    if(InFile.is_open())
    {
        if(!Utilities->CheckFileStringZeroDelimiter(InFile))
        // expected to be "***Interface***" for original version or "Version + : ***Interface***" for later releases + ExcessLCDownMins added as float at v2.3.0
        {
            InFile.close();
            Utilities->CallLogPop(1240);
            return(false);
        }
        if(!CheckInterface(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1241);
            return(false);
        }
        // check track elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***Track***"))
        {
            InFile.close();
            Utilities->CallLogPop(1242);
            return(false);
        }
        if(!Track->CheckTrackElementsInFile(2, NumberOfActiveElements, GraphicsFollow, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1243);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1244);
            return(false);
        }
        // check text elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***Text***"))
        {
            InFile.close();
            Utilities->CallLogPop(1245);
            return(false);
        }
        if(!TextHandler->CheckTextElementsInFile(1, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1246);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1247);
            return(false);
        }
        // check PrefDir elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***PrefDirs***"))
        {
            InFile.close();
            Utilities->CallLogPop(1248);
            return(false);
        }
        if(!EveryPrefDir->CheckOnePrefDir(1, NumberOfActiveElements, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1249);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1250);
            return(false);
        }
        // check graphics
        if(GraphicsFollow)
        {
            if(!Track->CheckUserGraphics(1, InFile, CurDir + "\\" + USERGRAPHICS_DIR_NAME)) // include path to Graphics folder
            {
                InFile.close();
                Utilities->CallLogPop(2187);
                return(false);
            }
            if(InFile.fail())
            {
                InFile.close();
                Utilities->CallLogPop(2188);
                return(false);
            }
        }
        // check routes
        if(!Utilities->CheckAndCompareFileString(InFile, "***Routes***"))
        {
            InFile.close();
            Utilities->CallLogPop(1251);
            return(false);
        }
        if(!AllRoutes->CheckRoutes(0, NumberOfActiveElements, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1252);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1253);
            return(false);
        }
        // check LockedRoutes
        if(!Utilities->CheckAndCompareFileString(InFile, "***Locked routes***"))
        {
            InFile.close();
            Utilities->CallLogPop(1254);
            return(false);
        }
        if(!TrainController->CheckSessionLockedRoutes(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1255);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1256);
            return(false);
        }
        // check ContinuationAutoSigs
        if(!Utilities->CheckAndCompareFileString(InFile, "***ContinuationAutoSigEntries***"))
        {
            InFile.close();
            Utilities->CallLogPop(1257);
            return(false);
        }
        if(!TrainController->CheckSessionContinuationAutoSigEntries(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1258);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1259);
            return(false);
        }
        // check BarriersDownVector, but ensure backwards compatibility with earlier files which don't have this section
        AnsiString TempString = Utilities->LoadFileString(InFile);
        if((TempString != "***BarriersDownVector***") && (TempString != "***Timetable***"))
        {
            InFile.close();
            Utilities->CallLogPop(1964);
            return(false);
        }
        if(TempString == "***BarriersDownVector***")
        {
            if(!Track->CheckActiveLCVector(0, InFile))
            {
                InFile.close();
                Utilities->CallLogPop(1965);
                return(false);
            }
            if(InFile.fail())
            {
                InFile.close();
                Utilities->CallLogPop(1966);
                return(false);
            }
            if(!Utilities->CheckAndCompareFileString(InFile, "***Timetable***"))
            {
                InFile.close();
                Utilities->CallLogPop(1260);
                return(false);
            }
        }
        // check timetable (marker string already checked immediately above)
        if(!CheckTimetableFromSessionFile(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1261);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1262);
            return(false);
        }
    }
    else
    {
        InFile.close();
//        ShowMessage("Session file failed to open, reason not known, unable to load session."); message given in calling function if returns false
        Utilities->CallLogPop(1263);
        return(false);
    }
// now ready for the 2nd pass for timetable loading and checking
    InFile.close();
    InFile.open(FileName.c_str());
    if(InFile.is_open())
    {
        if(!Utilities->CheckFileStringZeroDelimiter(InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1264);
            return(false);
        }
        if(!CheckInterface(1, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1265);
            return(false);
        }
        // load track elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***Track***"))
        {
            InFile.close();
            Utilities->CallLogPop(1266);
            return(false);
        }
        bool GraphicsFollow = false;
        Track->LoadTrack(2, InFile, GraphicsFollow); // load the track this time
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1267);
            return(false);
        }
        // check text elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***Text***"))
        {
            InFile.close();
            Utilities->CallLogPop(1268);
            return(false);
        }
        if(!TextHandler->CheckTextElementsInFile(2, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1269);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1270);
            return(false);
        }
        // check PrefDir elements
        if(!Utilities->CheckAndCompareFileString(InFile, "***PrefDirs***"))
        {
            InFile.close();
            Utilities->CallLogPop(1271);
            return(false);
        }
        if(!EveryPrefDir->CheckOnePrefDir(2, NumberOfActiveElements, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1272);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1273);
            return(false);
        }
        // check graphics
        if(GraphicsFollow)
        {
            if(!Track->CheckUserGraphics(2, InFile, CurDir + "\\" + USERGRAPHICS_DIR_NAME)) // include path to Graphics folder
            {
                InFile.close();
                Utilities->CallLogPop(2189);
                return(false);
            }
            if(InFile.fail())
            {
                InFile.close();
                Utilities->CallLogPop(2190);
                return(false);
            }
        }
        // check routes
        if(!Utilities->CheckAndCompareFileString(InFile, "***Routes***"))
        {
            InFile.close();
            Utilities->CallLogPop(1274);
            return(false);
        }
        if(!AllRoutes->CheckRoutes(1, NumberOfActiveElements, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1275);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1276);
            return(false);
        }
        // check LockedRoutes
        if(!Utilities->CheckAndCompareFileString(InFile, "***Locked routes***"))
        {
            InFile.close();
            Utilities->CallLogPop(1277);
            return(false);
        }
        if(!TrainController->CheckSessionLockedRoutes(1, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1278);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1279);
            return(false);
        }
        // check ContinuationAutoSigs
        if(!Utilities->CheckAndCompareFileString(InFile, "***ContinuationAutoSigEntries***"))
        {
            InFile.close();
            Utilities->CallLogPop(1280);
            return(false);
        }
        if(!TrainController->CheckSessionContinuationAutoSigEntries(1, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1281);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1282);
            return(false);
        }
        // check BarriersDownVector, but ensure backwards compatibility with earlier files which don't have this section
        AnsiString TempString = Utilities->LoadFileString(InFile);
        if((TempString != "***BarriersDownVector***") && (TempString != "***Timetable***"))
        {
            InFile.close();
            Utilities->CallLogPop(1967);
            return(false);
        }
        if(TempString == "***BarriersDownVector***")
        {
            if(!Track->CheckActiveLCVector(0, InFile))
            {
                InFile.close();
                Utilities->CallLogPop(1968);
                return(false);
            }
            if(InFile.fail())
            {
                InFile.close();
                Utilities->CallLogPop(1969);
                return(false);
            }
            if(!Utilities->CheckAndCompareFileString(InFile, "***Timetable***"))
            {
                InFile.close();
                Utilities->CallLogPop(1283);
                return(false);
            }
        }
        // check timetable (marker string already checked)
        if(!LoadTimetableFromSessionFile(1, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1284);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1285);
            return(false);
        }
        // check timetable clock
        if(!Utilities->CheckAndCompareFileString(InFile, "***TimetableClock***"))
        {
            InFile.close();
            Utilities->CallLogPop(1286);
            return(false);
        }
        if(!Utilities->CheckFileDouble(InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1287);
            return(false);
        }
        // check trains
        if(!Utilities->CheckAndCompareFileString(InFile, "***Trains***"))
        {
            InFile.close();
            Utilities->CallLogPop(1288);
            return(false);
        }
        if(!TrainController->CheckSessionTrains(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1289);
            return(false);
        }
        if(InFile.fail())
        {
            InFile.close();
            Utilities->CallLogPop(1290);
            return(false);
        }
        if(!Utilities->CheckAndCompareFileString(InFile, "***Performance file***"))
        {
            InFile.close();
            Utilities->CallLogPop(1291);
            return(false);
        }
        if(!CheckPerformanceFile(0, InFile))
        {
            InFile.close();
            Utilities->CallLogPop(1292);
            return(false);
        }
        char TempChar;
        InFile.get(TempChar);
        while(!InFile.eof() && ((TempChar == '\n') || (TempChar == '\0'))) // when emerge from here either have eof or '*'
        {
            InFile.get(TempChar);
        }
        if(!InFile.eof()) // additional checks needed
        {
            if(!Utilities->CheckFileString(InFile))
            {
                InFile.close();
                Utilities->CallLogPop(2198);
                return(false);
            }
            if(!Utilities->CheckFileInt(InFile, 0, 1000000)) // TrainController->AvHoursIntValue
            {
                InFile.close();
                Utilities->CallLogPop(2199);
                return(false);
            }
            if(!Utilities->CheckFileInt(InFile, 0, 1000000)) // number of train failures
            {
                InFile.close();
                Utilities->CallLogPop(2200);
                return(false);
            }
            // now check any failed trains along with their OriginalPowerAtRail values
            Utilities->CheckFileString(InFile); // discard "***Failed Trains***"
            int IDVal;
            if(!Utilities->CheckAndReadFileInt(InFile, -1, 1000000, IDVal)) // train ID or -1 for no more failed trains,
            {
                InFile.close();
                Utilities->CallLogPop(2201);
                return(false);
            }
            double PowerDouble;
            while(IDVal != -1)
            {
                Utilities->CheckFileDouble(InFile); // original power
                if(!Utilities->CheckAndReadFileInt(InFile, -1, 1000000, IDVal))
                {
                    InFile.close();
                    Utilities->CallLogPop(2202);
                    return(false);
                }
            }
        }
        InFile.close();
    }
    else
    {
        InFile.close();
        Utilities->CallLogPop(1293);
        return(false);
    }
    Utilities->CallLogPop(1294);
    return(true);
}

// ---------------------------------------------------------------------------

void TInterface::LoadPerformanceFile(int Caller, std::ifstream &InFile)
// Note that the file integrity has already been checked using CheckPerformanceFile
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadPerformanceFile");
    AnsiString TempString = "", Line1 = "", Line2 = "", Line3 = "", Line4 = "", Line5 = "";
    char *Buffer = new char[1000];
    char TempChar;

    InFile.get(TempChar); // '\n'
    InFile.getline(Buffer, 1000);
    TempString = AnsiString(Buffer);
    if(TempString == "***End of performance file***") //added at v2.10.0
    {
        PerfLogForm->PerformanceLog(17, "Performance Log\nRailway: " + RailwayTitle + "\nTimetable: " + TimetableTitle + "\nStart Time: " +
                TrainController->TimetableStartTime.FormatString("hh:nn"));
    }
    else
    {
        while(TempString != "***End of performance file***")
        {
            PerfLogForm->PerformanceLogBox->Lines->Add(TempString);
            Utilities->PerformanceFile << TempString.c_str() << '\n';
            Utilities->PerformanceFile.flush(); //added at v2.13.0
            InFile.getline(Buffer, 1000);
            TempString = AnsiString(Buffer);
        }
    }
    delete[] Buffer;
    Utilities->CallLogPop(1295);
}

// ---------------------------------------------------------------------------

bool TInterface::CheckPerformanceFile(int Caller, std::ifstream &InFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",CheckPerformanceFile");
    AnsiString TempString = "";
    char TempChar;

    InFile.get(TempChar);
    if(TempChar != '\n')
    {
        Utilities->CallLogPop(1296);
        return(false);
    }
    if(!Utilities->CheckAndReadFileString(InFile, TempString))
    {
        Utilities->CallLogPop(1297);
        return(false);
    }
    while(TempString != "***End of performance file***")
    {
        if(!Utilities->CheckAndReadFileString(InFile, TempString))
        {
            Utilities->CallLogPop(1298);
            return(false);
        }
    }
    Utilities->CallLogPop(1299);
    return(true);
}

// ---------------------------------------------------------------------------

void TInterface::SavePerformanceFile(int Caller, std::ofstream &OutFile)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SavePerformanceFile");
    AnsiString Text = PerfLogForm->PerformanceLogBox->Text;

    while(Text != "")
    {
        AnsiString OneLine = Text.SubString(1, Text.Pos('\x0D'));
        while((OneLine.Length() > 0) && OneLine[OneLine.Length()] < ' ')
        {
            OneLine.SetLength(OneLine.Length() - 1); // get rid of trailing control characters
        }
        Text = Text.SubString(Text.Pos('\x0D'), Text.Length());
        while((Text.Length() > 0) && Text[1] < ' ')
        {
            Text = Text.SubString(2, (Text.Length() - 1)); // get rid of leading control characters
        }
        OutFile << OneLine.c_str() << '\n';
    }
    Utilities->CallLogPop(1300);
}

// ---------------------------------------------------------------------------

void TInterface::SetRouteButtonsInfoCaptionAndRouteNotStarted(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetRouteButtonsInfoCaptionAndRouteNotStarted");
    if(EveryPrefDir->PrefDirSize() > 0)
    {
        if(AutoSigsFlag && ConsecSignalsRoute)
        {
            AutoSigsButton->Enabled = false;
            SigAutoNonConsecButton->Enabled = true;
            SigPrefConsecButton->Enabled = true;
            SigPrefNonConsecButton->Enabled = true;
            UnrestrictedButton->Enabled = true;
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
            }
            InfoCaptionStore = InfoPanel->Caption;
        }
        else if(AutoSigsFlag && !ConsecSignalsRoute) //added at v2.14.0
        {
            AutoSigsButton->Enabled = true;
            SigAutoNonConsecButton->Enabled = false;
            SigPrefConsecButton->Enabled = true;
            SigPrefNonConsecButton->Enabled = true;
            UnrestrictedButton->Enabled = true;
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Select AUTOMATIC SIGNAL ROUTE start signal, or left click points to change manually";
            }
            InfoCaptionStore = InfoPanel->Caption;
        }
        else if(PreferredRoute && ConsecSignalsRoute) // added at v2.7.0, was just ConsecSignalsRoute
        {
            AutoSigsButton->Enabled = true;
            SigAutoNonConsecButton->Enabled = true;
            SigPrefConsecButton->Enabled = false;
            SigPrefNonConsecButton->Enabled = true;
            UnrestrictedButton->Enabled = true;
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Select PREFERRED ROUTE start signal, or left click points to change manually";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Select PREFERRED ROUTE start signal, or left click points to change manually";
            }
            InfoCaptionStore = InfoPanel->Caption;
        }
        else if(PreferredRoute && !ConsecSignalsRoute) // added at v2.7.0
        {
            AutoSigsButton->Enabled = true;
            SigAutoNonConsecButton->Enabled = true;
            SigPrefConsecButton->Enabled = true;
            SigPrefNonConsecButton->Enabled = false;
            UnrestrictedButton->Enabled = true;
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Select PREFERRED ROUTE start signal, or left click points to change manually";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Select PREFERRED ROUTE start signal, or left click points to change manually";
            }
            InfoCaptionStore = InfoPanel->Caption;
        }
        else  //unrestricted route
        {
            AutoSigsButton->Enabled = true;
            SigAutoNonConsecButton->Enabled = true;
            SigPrefConsecButton->Enabled = true;
            SigPrefNonConsecButton->Enabled = true;
            UnrestrictedButton->Enabled = false;
            InfoPanel->Visible = true;
            if(Level2OperMode == PreStart)
            {
                InfoPanel->Caption = "PRE-START:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
            }
            else
            {
                InfoPanel->Caption = "OPERATING:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
            }
            InfoCaptionStore = InfoPanel->Caption;
        }
    }
    else
    {
        AutoSigsButton->Enabled = false;
        SigAutoNonConsecButton->Enabled = false;
        SigPrefConsecButton->Enabled = false;
        SigPrefNonConsecButton->Enabled = false;
        UnrestrictedButton->Enabled = false;
        InfoPanel->Visible = true;
        if(Level2OperMode == PreStart)
        {
            InfoPanel->Caption = "PRE-START:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
        }
        else
        {
            InfoPanel->Caption = "OPERATING:  Select UNRESTRICTED ROUTE start location, or left click points to change manually";
        }
        InfoCaptionStore = InfoPanel->Caption;
    }
    if(AllRoutes->AllRoutesVector.size() > AllRoutes->LockedRouteVector.size())
    {
        RouteCancelButton->Enabled = true;
    }
    else
    {
        RouteCancelButton->Enabled = false;
    }
    RouteMode = RouteNotStarted;
    AutoRouteStartMarker->PlotOriginal(37, Display); // so start marker will replot if had selected start before pause & zoom
    SigRouteStartMarker->PlotOriginal(38, Display);
    NonSigRouteStartMarker->PlotOriginal(41, Display);
    Utilities->CallLogPop(1301);
}

// ---------------------------------------------------------------------------

void TInterface::SetPausedOrZoomedInfoCaption(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetPausedOrZoomedInfoCaption");
    if(Display->ZoomOutFlag)
    {
        InfoPanel->Visible = true;
        InfoPanel->Caption = "Left click screen to zoom in at that position";
    }
    else if(Level2OperMode == Paused)
    {
        InfoPanel->Visible = true;
        InfoPanel->Caption = "PAUSED:  Railway state changes disabled";
    }
// otherwise do nothing
    Utilities->CallLogPop(1302);
}

// ---------------------------------------------------------------------------

void TInterface::DisableRouteButtons(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",DisableRouteButtons");
    RouteCancelButton->Enabled = false;
    AutoSigsButton->Enabled = false;
    SigAutoNonConsecButton->Enabled = false;
    SigPrefConsecButton->Enabled = false;
    SigPrefNonConsecButton->Enabled = false;
    UnrestrictedButton->Enabled = false;
    Utilities->CallLogPop(1303);
}

// ---------------------------------------------------------------------------

void TInterface::SaveErrorFile()
// no need for call logging as already failed
{
/*
   In order to reload as a session file:

   NB:  Don't change it to a .txt file, as the '\0' characters [shown as a small square in wordpad] will be changed to spaces if it is subsequently saved

   strip out:-

   up to but excluding  ***Interface***
   from & including  ***ConstructPrefDir PrefDirVector***
   to but excluding ***PrefDirs***
   if there is a single line ***UserGraphics*** delete it (won't be present if no graphics)
   from & including  ***ConstructRoute PrefDirVector***
   to but excluding ***Routes***
   from & including ***ChangingLCVector*** to but excluding ***Timetable*** [if have ***No timetable loaded*** then can't use as a session file]
   from & including ***No editing timetable*** or ***Editing timetable - [title]***
   to but excluding ***TimetableClock***
   from but excluding  End of file at vx.x.x
   to end of file

   and save as a .ssn file.

   In order to load as a railway file: Note if error involves cut/copy etc with prefdirs then need to drop the check of CheckCount

   NB:  Don't change it to a .txt file, as the '\0' characters will be changed to spaces if it is subsequently saved

   note or copy the version information at the top of the file
   copy the two numbers on rows 7 & 8 below ***Interface*** (i.e ***Interface*** = row 0) on their own lines immediately after the ***Track*** line (these become DisplayOffsetH & V)
   strip out up to but excluding ***Track*** - this is needed to keep the \0 entry at end of ***Track*** [shown as a small square in wordpad]
   add the version number either before or instead of ***Track***, ensuring that the \0 is retained
   the next line after the two insertions should contain the number of active elements.
   strip out ***Text*** including the \0
   strip out from & including  ***ConstructPrefDir PrefDirVector*** to & including ***PrefDirs*** (and the \0's)
   strip out ***UserGraphics*** including the \0  <--this will be missing if none
   strip out from & including ***ConstructRoute PrefDirVector*** including the \0 to the end of the file
   the last entry should be '************NUL CR LF' (after all the pref dirs)
   rename as .dev or .rly file

   BUT - note that signals (and points, though they won't show) will be set as they were left.  To reset to red, load a suitable timetable & select
   'Operate' then 'Exit operation'.
*/

/*
   In order to extract a timetable:

   NB:  Don't change it to a .txt file, as the '\0' characters will be changed to spaces if it is subsequently saved

   set wordwrap to window on
   strip out all to and including ***Timetable*** or ***Editing timetable.... depending which is to be saved
   ensure any text before start time ends with \0, otherwise don't need the \0
   strip out all after the final \0 immediately before ***End*** or ***End of timetable***, but ensure leave the final \0
   save as a .ttb file
*/

    Screen->Cursor = TCursor(-11); // Hourglass;
    AnsiString ErrorFileStr = CurDir + "\\errorlog.err";
    std::ofstream ErrorFile(ErrorFileStr.c_str());

    if(!(ErrorFile.fail()))
    {
// save mouse position relative to mainscreen
        int ScreenX = Mouse->CursorPos.x - MainScreen->ClientOrigin.x;
        int ScreenY = Mouse->CursorPos.y - MainScreen->ClientOrigin.y;
        AnsiString MouseStr = "Posx: " + AnsiString(ScreenX) + "; Posy: " + AnsiString(ScreenY);
        Utilities->SaveFileString(ErrorFile, MouseStr);
// save call stack
        Utilities->SaveFileString(ErrorFile, "***Call stack***");
        for(unsigned int x = 0; x < Utilities->CallLog.size(); x++)
        {
            AnsiString Item = Utilities->CallLog.at(x);
            ErrorFile << Item.c_str() << '\n';
        }
// save event log
        Utilities->SaveFileString(ErrorFile, "***Event log***");
        for(unsigned int x = 0; x < Utilities->EventLog.size(); x++)
        {
            AnsiString Item = Utilities->EventLog.at(x);
            ErrorFile << Item.c_str() << '\n';
        }
// save interface
        Utilities->SaveFileString(ErrorFile, "***Interface***");
        SaveInterface(1, ErrorFile);
// save track elements
        Utilities->SaveFileString(ErrorFile, "***Track***");
        if(Track->UserGraphicVector.empty())
        {
            Track->SaveTrack(2, ErrorFile, false); // false for no graphics (**Active elements** saved as marker)
        }
        else
        {
            Track->SaveTrack(12, ErrorFile, true); // true for graphics to be saved (**Active elements**1 saved as marker)
        }
// save text elements
        Utilities->SaveFileString(ErrorFile, "***Text***");
        TextHandler->SaveText(3, ErrorFile);
// save ConstructPrefDir PrefDirVector elements
        Utilities->SaveFileString(ErrorFile, "***ConstructPrefDir PrefDirVector***");
        ConstructPrefDir->SavePrefDirVector(7, ErrorFile);
// save ConstructPrefDir SearchVector elements
        Utilities->SaveFileString(ErrorFile, "***ConstructPrefDir SearchVector***");
        ConstructPrefDir->SaveSearchVector(0, ErrorFile);
// save EveryPrefDir elements
        Utilities->SaveFileString(ErrorFile, "***PrefDirs***");
        EveryPrefDir->SavePrefDirVector(3, ErrorFile);
        if(!Track->UserGraphicVector.empty())
        {
            // save user graphics
            Utilities->SaveFileString(ErrorFile, "***UserGraphics***");
            Track->SaveUserGraphics(3, ErrorFile);
        }
// save ConstructRoute PrefDirVector
        Utilities->SaveFileString(ErrorFile, "***ConstructRoute PrefDirVector***");
        ConstructRoute->SavePrefDirVector(4, ErrorFile);
// save ConstructRoute SearchVector
        Utilities->SaveFileString(ErrorFile, "***ConstructRoute SearchVector***");
        ConstructRoute->SaveSearchVector(1, ErrorFile);
// save AllRoutes
        Utilities->SaveFileString(ErrorFile, "***Routes***");
        AllRoutes->SaveRoutes(1, ErrorFile);
// save LockedRoutes
        Utilities->SaveFileString(ErrorFile, "***Locked routes***");
        TrainController->SaveSessionLockedRoutes(1, ErrorFile);
// save ContinuationAutoSigEntries
        Utilities->SaveFileString(ErrorFile, "***ContinuationAutoSigEntries***");
        TrainController->SaveSessionContinuationAutoSigEntries(1, ErrorFile);
// save BarriersDownVector
        Utilities->SaveFileString(ErrorFile, "***BarriersDownVector***");
        Track->SaveSessionBarriersDownVector(1, ErrorFile);
// save ChangingLCVector
        Utilities->SaveFileString(ErrorFile, "***ChangingLCVector***");
        Track->SaveChangingLCVector(0, ErrorFile);
// save loaded timetable
        if(TimetableTitle == "")
        {
            Utilities->SaveFileString(ErrorFile, "***No timetable loaded***");
        }
        else
        {
            Utilities->SaveFileString(ErrorFile, "***Timetable***");
            if(!(SaveTimetableToSessionFile(1, ErrorFile, ErrorFileStr)))
            {
                Utilities->SaveFileString(ErrorFile, "***Loaded timetable failed to save***");
            }
        }
// save editing timetable
        if(CreateEditTTTitle == "")
        {
            Utilities->SaveFileString(ErrorFile, "***No editing timetable***");
        }
        else
        {
            Utilities->SaveFileString(ErrorFile, "***Editing timetable - " + CreateEditTTTitle + "***");
            if(!(SaveTimetableToErrorFile(1, ErrorFile, ErrorFileStr, CreateEditTTFileName)))
            {
                Utilities->SaveFileString(ErrorFile, "***Editing timetable failed to save***");
            }
        }
// save TimetableClock
        Utilities->SaveFileString(ErrorFile, "***TimetableClock***");
        Utilities->SaveFileDouble(ErrorFile, double(TrainController->TTClockTime));
// save trains
        Utilities->SaveFileString(ErrorFile, "***Trains***");
        TrainController->SaveSessionTrains(1, ErrorFile);
// save performance file
        Utilities->SaveFileString(ErrorFile, "***Performance file***");
        SavePerformanceFile(1, ErrorFile);
        Utilities->SaveFileString(ErrorFile, "***End of performance file***");
// addition at v2.4.1 to save TrainController->AvHoursIntValue + any future additions
        Utilities->SaveFileString(ErrorFile, "***Additions after v2.3.1***");
        Utilities->SaveFileInt(ErrorFile, TrainController->AvHoursIntValue);
        Utilities->SaveFileInt(ErrorFile, TrainController->NumFailures);
        Utilities->SaveFileString(ErrorFile, "***Failed Trains***");
        for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
        {
            if(TrainController->TrainVectorAt(70, x).TrainFailed)
            {
                Utilities->SaveFileInt(ErrorFile, TrainController->TrainVectorAt(71, x).TrainID);
                Utilities->SaveFileDouble(ErrorFile, TrainController->TrainVectorAt(72, x).OriginalPowerAtRail);
            }
        }
        Utilities->SaveFileInt(ErrorFile, -1); // marker for end of failed trains
        Utilities->SaveFileString(ErrorFile, "End of file at v2.4.1");
// end of v2.4.1 addition

// added at v2.7.0 - extras saved later in session file (added at v2.9.2)
        Utilities->SaveFileBool(ErrorFile, ConsecSignalsRoute);
        Utilities->SaveFileString(ErrorFile, "End of file at v2.7.0");
// end of v2.7.0 addition

// added at v2.9.1
        Utilities->SaveFileInt(ErrorFile, TrainController->EarlyExits);
        Utilities->SaveFileInt(ErrorFile, TrainController->OnTimeExits);
        Utilities->SaveFileInt(ErrorFile, TrainController->LateExits);
        Utilities->SaveFileDouble(ErrorFile, double(TrainController->TotEarlyExitMins));
        Utilities->SaveFileDouble(ErrorFile, double(TrainController->TotLateExitMins));
        Utilities->SaveFileString(ErrorFile, "End of v2.9.1 additions");  //changed from '2.9.0' at v2.9.2
// end of v2.9.1 additions

//added at v2.11.0
//add SkippedTTEvents
        Utilities->SaveFileInt(ErrorFile, TrainController->SkippedTTEvents);
// add data for trains in process of skipping timetable events (i.e. those with events after a future departure)
        if(!TrainController->TrainVector.empty())
        {
            for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
            {
                TTrain Train = TrainController->TrainVectorAt(83, x);
                if(Train.SkippedDeparture)
                {
                    Utilities->SaveFileInt(ErrorFile, Train.TrainID);
                    Utilities->SaveFileBool(ErrorFile, Train.SkippedDeparture);
                    Utilities->SaveFileBool(ErrorFile, Train.ActionsSkippedFlag);
                    Utilities->SaveFileInt(ErrorFile, Train.SkipPtrValue);
                    Utilities->SaveFileInt(ErrorFile, Train.TrainSkippedEvents);
                }
            }
        }
        Utilities->SaveFileString(ErrorFile, "End of file at v2.11.0");
//end of 2.11.0 additions

//additions at v2.12.0 - become new service early & treat pass as departure
        if(!TrainController->TrainVector.empty())
        {
            for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
            {
                TTrain Train = TrainController->TrainVectorAt(86, x);
                if(Train.TreatPassAsTimeLocDeparture) //this can only apply once for a single train (service repeats are separate trains)
                {
                    Utilities->SaveFileInt(ErrorFile, Train.TrainID);
                }
            }
        }
        Utilities->SaveFileString(ErrorFile, "End of file at v2.12.0");
//end of v2.12.0 additions

//additions at v2.13.0 - random delays
//No need to save Utilities->LastDelayTTClockTime - makes little difference and would cause corruption in any v2.13.0 Beta sessions
        Utilities->SaveFileInt(ErrorFile, Utilities->CumulativeDelayedRandMinsAllTrains); //to allow for exited and removed trains
        for(unsigned int x = 0; x < TrainController->TrainVector.size(); x++)
        { //if empty will skip
            TTrain Train = TrainController->TrainVectorAt(90, x);
            Utilities->SaveFileDouble(ErrorFile, Train.NewDelay);
            Utilities->SaveFileDouble(ErrorFile, Train.DelayedRandMins);
            Utilities->SaveFileDouble(ErrorFile, Train.CumulativeDelayedRandMinsOneTrain);
            Utilities->SaveFileDouble(ErrorFile, double(Train.ActualArrivalTime));
            //ReleaseTime already loaded
        }
        //save failed point info
        Utilities->SaveFileInt(ErrorFile, Track->FailedPointsVector.size()); //number of failed points
        for(unsigned int x = 0; x < Track->FailedPointsVector.size(); x++)
        { //if empty will skip, when reload set Failed to true & SpeedLimits to 10km/h
            TTrackElement &TE = Track->TrackElementAt(1551, Track->FailedPointsVector.at(x).TVPos);
            Utilities->SaveFileInt(ErrorFile, Track->FailedPointsVector.at(x).TVPos);
            Utilities->SaveFileInt(ErrorFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01);
            Utilities->SaveFileInt(ErrorFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23);
            Utilities->SaveFileDouble(ErrorFile, double(Track->FailedPointsVector.at(x).FailureTime));
            Utilities->SaveFileDouble(ErrorFile, double(Track->FailedPointsVector.at(x).RepairTime));
        }
        //save failed signal info
        Utilities->SaveFileInt(ErrorFile, Track->FailedSignalsVector.size()); //number of failed signals
        for(unsigned int x = 0; x < Track->FailedSignalsVector.size(); x++)
        { //if empty will skip, when reload set Failed to true
            Utilities->SaveFileInt(ErrorFile, Track->FailedSignalsVector.at(x).TVPos);
            Utilities->SaveFileDouble(ErrorFile, double(Track->FailedSignalsVector.at(x).FailureTime));
            Utilities->SaveFileDouble(ErrorFile, double(Track->FailedSignalsVector.at(x).RepairTime));
        }
        //save TSR info
        Utilities->SaveFileInt(ErrorFile, Track->TSRVector.size()); //number of TSRs
        for(unsigned int x = 0; x < Track->TSRVector.size(); x++)
        { //if empty will skip, when reload set Failed to true & SpeedLimit to 10km/h
            TTrackElement &TE = Track->TrackElementAt(1552, Track->TSRVector.at(x).TVPos);
            Utilities->SaveFileInt(ErrorFile, Track->TSRVector.at(x).TVPos);
            Utilities->SaveFileInt(ErrorFile, TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01);
            Utilities->SaveFileDouble(ErrorFile, double(Track->TSRVector.at(x).FailureTime));
            Utilities->SaveFileDouble(ErrorFile, double(Track->TSRVector.at(x).RepairTime));
        }
        Utilities->SaveFileString(ErrorFile, "End of file at v2.13.0");
//end of v2.13.0 additions
//additions at v2.14.0 - delays and failures
            if(Utilities->DelayMode == Minor)
            {
                Utilities->SaveFileInt(ErrorFile, 1);
            }
            else if(Utilities->DelayMode == Moderate)
            {
                Utilities->SaveFileInt(ErrorFile, 2);
            }
            else if(Utilities->DelayMode == Major)
            {
                Utilities->SaveFileInt(ErrorFile, 3);
            }
            else
            {
                Utilities->SaveFileInt(ErrorFile, 0);
            }
            if(Utilities->FailureMode == FMinor)
            {
                Utilities->SaveFileInt(ErrorFile, 1);
            }
            else if(Utilities->FailureMode == FModerate)
            {
                Utilities->SaveFileInt(ErrorFile, 2);
            }
            else if(Utilities->FailureMode == FMajor)
            {
                Utilities->SaveFileInt(ErrorFile, 3);
            }
            else
            {
                Utilities->SaveFileInt(ErrorFile, 0);
            }
            Utilities->SaveFileString(ErrorFile, "End of file at v2.14.0");
//end of v2.14.0 additions

//REMAINDER STAY AT END OF FILE
// addition at v2.8.0 in case of clipboard
// errors <-- keep at end of file as not wanted in a reconstructed session file
        Utilities->SaveFileInt(ErrorFile, SelectBitmap->Height); // extras for new clipboard functions
        Utilities->SaveFileInt(ErrorFile, SelectBitmap->Width);
        Utilities->SaveFileInt(ErrorFile, SelectBitmapHLoc); // paste location
        Utilities->SaveFileInt(ErrorFile, SelectBitmapVLoc);
        Utilities->SaveFileInt(ErrorFile, SelectRect.left); // original selection location
        Utilities->SaveFileInt(ErrorFile, SelectRect.top);
        Utilities->SaveFileInt(ErrorFile, SelectRect.right);
        Utilities->SaveFileInt(ErrorFile, SelectRect.bottom);
        Utilities->SaveFileString(ErrorFile, "End of clipboard additions");
// end of 2.8.0 addition
        ErrorFile.close();
    }
    else
    {
        TrainController->StopTTClockMessage(6, "Error file failed to open, error log won't be saved.");
    }
    Screen->Cursor = TCursor(-2); // Arrow
}

// ---------------------------------------------------------------------------

void TInterface::SaveTempTimetableFile(int Caller, AnsiString InFileName)
// the .ttb section is delimited by '\n' followed by "***End***"
// first create a .ttb file in the working folder exactly like the original

// Note: this type of file use failed when used to resave timetable.tmp from temp .ttb file, but changed that to avoid so many rapid
// file actions in quick succession & been OK since then, but nevertheless keep the 10 retries before giving message to be on safe side
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveTempTimetableFile");
    if((TempTTFileName != "") && FileExists(TempTTFileName))
    {
        DeleteFile(TempTTFileName);
    }
    int TempTTFileNumber = 0;

    while(FileExists(CurDir + "\\TmpTT" + AnsiString(TempTTFileNumber) + ".tmp"))
    {
        TempTTFileNumber++;
    }
    TempTTFileName = CurDir + "\\TmpTT" + AnsiString(TempTTFileNumber) + ".tmp";
    int InHandle = FileOpen(InFileName, fmOpenRead);
    int Count = 0;

    while(InHandle < 0) // sometimes fails, have 10 retries before giving message
    {
        InHandle = FileOpen(InFileName, fmOpenRead);
        Count++;
        Delay(2, 50); // 50mSec delay between tries
        if(Count > 10)
        {
            ShowMessage("Failed to open timetable file, make sure it's spelled correctly, it exists and isn't open in another application");
            Utilities->CallLogPop(1400);
            return;
        }
    }
    int OutHandle = FileCreate(TempTTFileName);

    Count = 0;
    while(OutHandle < 0) // sometimes fails, have 10 retries before giving message
    {
        OutHandle = FileCreate(TempTTFileName);
        Count++;
        Delay(3, 50); // 50mSec delay between tries
        if(Count > 10)
        {
            ShowMessage("Failed to save temporary timetable file, sessions can't be saved - try again, may only be a temporary problem");
            FileClose(InHandle);
            Utilities->CallLogPop(1401);
            return;
        }
    }
    int CountIn, CountOut;
    char *Buffer = new char[10000]; // can't use LoadFileString as that expects a '\0' delimiter

    while(true)
    {
        CountIn = FileRead(InHandle, Buffer, 10000);
        CountOut = FileWrite(OutHandle, Buffer, CountIn);
        if(CountOut != CountIn)
        {
            ShowMessage("Error in writing to the temporary timetable file, sessions can't be saved - try again, may only be a temporary problem");
            delete[]Buffer;
            FileClose(InHandle);
            FileClose(OutHandle);
            Utilities->CallLogPop(1402);
            return;
        }
        if(CountIn < 10000)
        {
            break;
        }
    }
    delete[]Buffer;
    FileClose(InHandle);
    FileClose(OutHandle);
    Utilities->CallLogPop(1403);
}

// ---------------------------------------------------------------------------

void TInterface::SetTrackLengths(int Caller, int Distance, int SpeedLimit) // Distance & SpeedLimit are -1 for no change to that parameter
/*
                  Rules: Platforms are fixed length elements of 100m and aren't changed - no, see note below. Variable length elements can't be less than 10m.
                  above changed in v2.4.0 to be variable as other track, but if <50m or >200m a warning is given

                  Enter with DistanceVector containing the PrefDir to be set, Distance containing the required sum of all element lengths,
                  and SpeedLimit containing the speed limit.  If either of these is -1 (can be -1 separately) then no change is to be made to it.
                  Return for an empty DistanceVector.  Deal first with a single element in the vector, giving a message if there is a platform there.
                  Now set exit link position (XLinkPos) value for the first element in DistanceVector by checking which link connects to the second
                  element in the vector, and give a warning message if fail to find it.  Now have to make two passes through the vector, firstly to
                  sum the fixed lengths, count the number of variable length elements and set the speed limit, and secondly to set the lengths.
                  Firstly store the first XLinkPos so don't have to recalculate it for the second pass.  On the first pass examine each element,
                  incrementing the variable element count or summing the fixed length count as go along, and setting the speed limits providing
                  SpeedLimit isn't -1.  If Distance was -1 then still go through but don't count anything, just set the speed limits.  Recalculate
                  the next XLinkPos for each succeeding element.
                  After the first pass return if Distance was -1 as in that case have now finished.  Otherwise check if the distance to be set is less than
                  the minimum possible within the rules, and if so give a message and return.  Also give a warning message if there aren't any variable length
                  elements.  Now enter the second pass.  In this the length of each variable element is set to int(RemainingDistance/RemainingVarElements) and
                  fixed length elements are ignored.  After each variable length element is set the RemainingDistance and RemainingVarElements are recalculated
                  ready for the next setting.  In this way there is never more than 1 difference between any two variable length elements and the total
                  distance sums exactly to the value required.  A check is made after every variable length element has been set to see whether RemainingDistance
                  and RemainingVarElements are zero, and if they don't reach zero together (which they should after the last variable length element has
                  been set), an error message is given.
*/

{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetLengths," + AnsiString(Distance) + "," + AnsiString(SpeedLimit));
    bool FoundFlag;

// ResetDistanceElements(4);
    if(ConstructPrefDir->PrefDirSize() == 0)
    {
        Utilities->CallLogPop(608);
        return;
    }
// must have PrefDir size of at least 2

// first pass to count number of variable length elements, sum fixed lengths & set speed limit
// for version in v2.4.0 have no fixed length elements but leave code as is as much as possible
    int VarElements = 0; // FixedLength = 0; drop this in v2.4.0
    bool NamedLocPresent = false;

    for(unsigned int x = 0; x < ConstructPrefDir->PrefDirSize(); x++)
    {
        TPrefDirElement PrefDirElement = ConstructPrefDir->GetFixedPrefDirElementAt(167, x);
        TTrackElement & TE = Track->TrackElementAt(34, Track->GetVectorPositionFromTrackMap(28, PrefDirElement.HLoc, PrefDirElement.VLoc, FoundFlag));
        if(!FoundFlag)
        {
            throw Exception("Error - failed to find track element at " + AnsiString(TE.HLoc) + " & " + AnsiString(TE.VLoc) + " in SetLengths");
        }
        if((Distance != -1) && (!Track->IsPlatformOrNamedNonStationLocationPresent(2, TE.HLoc, TE.VLoc)))
        {
            VarElements++;
        }
        else if((Distance != -1) && (Track->IsPlatformOrNamedNonStationLocationPresent(3, TE.HLoc, TE.VLoc)))
        {
            VarElements++; // added in v2.4.0 for no fixed elements
            NamedLocPresent = true;
// FixedLength+= DefaultTrackLength; dropped in v2.4.0 for no fixed elements
        }
        if((PrefDirElement.GetELinkPos() < 2) && (PrefDirElement.GetXLinkPos() < 2)) // could be points
        {
            if(SpeedLimit != -1)
            {
                TE.SpeedLimit01 = SpeedLimit;
            }
        }
        else
        {
            if(SpeedLimit != -1)
            {
                TE.SpeedLimit23 = SpeedLimit;
            }
        }
    }
    if(Distance == -1) // can't return before this as need to set speed limits
    {
        Utilities->CallLogPop(612);
        return;
    }
    if((NamedLocPresent) && (VarElements > 0) && ((Distance / VarElements) < 50)) // these two additions are for in v2.4.0
    {
        if(!TooShortMessageSentFlag)  //added at v2.9.1
        {
            ShowMessage("Note: Named location elements are quite short. If they are too short the simulation might be too unrealistic.\n\nThis message will not be shown again.");
            TooShortMessageSentFlag = true;   //added at v2.9.1
        }
    }
    if((NamedLocPresent) && (VarElements > 0) && ((Distance / VarElements) > 200))
    {
        if(!TooLongMessageSentFlag)   //added at v2.9.1
        {
            ShowMessage("Note: Named location elements are quite long. If they are too long the simulation might be too unrealistic.\n\nThis message will not be shown again.");
            TooLongMessageSentFlag = true;   //added at v2.9.1
        }
    }
    if((VarElements * 10) > Distance) // removed '+ FixedLength'
    {
        ShowMessage("Required distance is less than the minimum, will set each element to the minimum (10m)");
        Distance = (VarElements * 10); // removed '+ FixedLength'
    }
    if(VarElements == 0)
    {
// ShowMessage("Unable to set distance as all elements are of fixed length");  as was
        ShowMessage("No elements selected"); // probably don't need this but include for safety
        Utilities->CallLogPop(613);
        return;
    }
// second pass, set variable lengths
    int RemainingDistance = Distance, RemainingVarElements = VarElements, NextLength = RemainingDistance / VarElements; // removed ' - FixedLength'

    for(unsigned int x = 0; x < ConstructPrefDir->PrefDirSize(); x++)
    {
        TPrefDirElement PrefDirElement = ConstructPrefDir->GetFixedPrefDirElementAt(168, x);
        TTrackElement & TE = Track->TrackElementAt(35, Track->GetVectorPositionFromTrackMap(29, PrefDirElement.HLoc, PrefDirElement.VLoc, FoundFlag));
// if(!Track->IsPlatformOrNamedNonStationLocationPresent(4, TE.HLoc, TE.VLoc)) //variable lengths  dropped in v2.4.0
// {
        if(NextLength < 10)
        {
            NextLength = 10; // added for safety
        }
        if(TE.TrackType == Points)
        {
            if((PrefDirElement.GetELinkPos() == 1) || (PrefDirElement.GetXLinkPos() == 1))
            {
                TE.Length01 = NextLength;
            }
            else
            {
                TE.Length23 = NextLength;
            }
        }
        else
        {
            if(PrefDirElement.GetELinkPos() < 2)
            {
                TE.Length01 = NextLength;
            }
            else
            {
                TE.Length23 = NextLength;
            }
        }
        RemainingDistance -= NextLength;
        RemainingVarElements--;
        if(RemainingVarElements > 0)
        {
            NextLength = RemainingDistance / RemainingVarElements;
        }
        else
        {
            NextLength = 10;
        }
/* removed these as using integer division & that sometimes problematic.  None of these errors ever reported but be safe
                       if((RemainingDistance == 0) && (RemainingVarElements != 0))
                       {
                               throw Exception("Error RemainingDistance == 0 & RemainingVarElements != 0");
                       }
                       if((RemainingDistance != 0) && (RemainingVarElements == 0))
                       {
                               throw Exception("Error RemainingDistance != 0 & RemainingVarElements == 0");
                       }
*/
// }
    }
    Utilities->CallLogPop(614);
}

// ---------------------------------------------------------------------------

void TInterface::SaveAsSubroutine(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SaveAsSubroutine");
    if((Track->NoActiveOrInactiveTrack(4) && TextHandler->TextVectorSize(7) == 0) && Track->UserGraphicVector.empty())
    {
        ShowMessage("Nothing to save!");
    }
    else
    {
        if(Track->IsReadyForOperation(false))
        {
            SaveRailwayDialog->Filter = "Development file (*.dev)|*.dev|Railway file (*.rly)|*.rly";
        }
        else
        {
            SaveRailwayDialog->Filter = "Development file (*.dev)|*.dev";
        }
        if(SaveRailwayDialog->Execute())
        {
            if(SaveRailwayDialog->InitialDir != TPath::GetDirectoryName(SaveRailwayDialog->FileName)) // new at v2.6.0 to retain a new directory
            {
                SaveRailwayDialog->InitialDir = TPath::GetDirectoryName(SaveRailwayDialog->FileName);
                LoadRailwayDialog->InitialDir = TPath::GetDirectoryName(SaveRailwayDialog->FileName);
            }
            Screen->Cursor = TCursor(-11); // Hourglass;
            TrainController->LogEvent("Save " + SaveRailwayDialog->FileName);
            AnsiString Extension = "";
            if(SaveRailwayDialog->FileName.Length() > 2)
            {
                Extension = AnsiString(SaveRailwayDialog->FileName).SubString(AnsiString(SaveRailwayDialog->FileName).Length() - 2, 3).UpperCase();
            }
            if((Extension == "DEV") || (Track->IsReadyForOperation(true) && (Extension == "RLY"))) // give duplicated location name message if appropriate
            {
                std::ofstream VecFile(AnsiString(SaveRailwayDialog->FileName).c_str());
                if(!(VecFile.fail()))
                {
                    Utilities->SaveFileString(VecFile, ProgramVersion);
                    Utilities->SaveFileInt(VecFile, Display->DisplayOffsetHHome);
                    Utilities->SaveFileInt(VecFile, Display->DisplayOffsetVHome);
                    // save track elements
                    if(Track->UserGraphicVector.empty())
                    {
                        Track->SaveTrack(1, VecFile, false); // false for no graphics (**Active elements** saved as marker)
                    }
                    else
                    {
                        Track->SaveTrack(13, VecFile, true); // true for graphics to be saved (**Active elements**1 saved as marker)
                    }
                    // save text elements
                    TextHandler->SaveText(1, VecFile);
                    // save PrefDir elements
                    EveryPrefDir->SavePrefDirVector(1, VecFile);
                    if(!Track->UserGraphicVector.empty())
                    {
                        // save user graphics
                        Track->SaveUserGraphics(4, VecFile);
                    }
                    VecFile.close();
                    SavedFileName = SaveRailwayDialog->FileName; // includes the full PrefDir
                    if(SavedFileName != "") // shouldn't be "" at this stage but leave in as a safeguard
                    {
                        char LastChar = SavedFileName[SavedFileName.Length()];
                        if((LastChar == 'y') || (LastChar == 'Y'))
                        {
                            RlyFile = true;
                        }
                        else
                        {
                            RlyFile = false;
                        }
                    }
                    else
                    {
                        RlyFile = false;
                    }
                    FileChangedFlag = false;
                    for(int x = SaveRailwayDialog->FileName.Length(); x > 0; x--)
                    {
                        if(SaveRailwayDialog->FileName[x] == '\\')
                        {
                            RailwayTitle = SaveRailwayDialog->FileName.SubString(x + 1, SaveRailwayDialog->FileName.Length() - x - 4);
                            // TimetableTitle = ""; leave this as is, no need to unload a tt just because saved railway
                            SetCaption(7);
                            break;
                        }
                    }
                    Level1Mode = BaseMode;
                    SetLevel1Mode(13); // to disable the save option
                } // if(!(VecFile.fail()))
                else
                {
                    ShowMessage("File open failed prior to save");
                }
            } // else following  if(!Track->IsReadyForOperation() && (Extension != "DEV"))
            else
            {
                ShowMessage("Can't save: extension must be either '.dev', or '.rly' with railway ready for operation");
            }
            Screen->Cursor = TCursor(-2); // Arrow
        } // if(SaveRailwayDialog->Execute())

    }
    session_api_->dump();   // update session INI file   //added at v2.10.0
    Utilities->CallLogPop(1546);
}

// ---------------------------------------------------------------------------

void TInterface::SetTrackModeEditMenu(int Caller)
{
    try
    {
        // no need for log as only setting values
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",SetTrackModeEditMenu");
        CutMenuItem->Visible = true;
        CopyMenuItem->Visible = true;
        FlipMenuItem->Visible = true;
        MirrorMenuItem->Visible = true;
        RotRightMenuItem->Visible = true;
        RotLeftMenuItem->Visible = true;
        RotateMenuItem->Visible = true;
        PasteMenuItem->Visible = true;
        DeleteMenuItem->Visible = true;
        SelectLengthsMenuItem->Visible = true;
        ReselectMenuItem->Visible = true;
    // Application->MessageBox(L"Running SetTrackModeEditMenu", L"Message", MB_OK);     //debug check
        CutMenuItem->Enabled = false;
        CopyMenuItem->Enabled = false;
        FlipMenuItem->Enabled = false;
        MirrorMenuItem->Enabled = false;
        RotRightMenuItem->Enabled = false;
        RotLeftMenuItem->Enabled = false;
        RotateMenuItem->Enabled = false;
        PasteMenuItem->Enabled = false;
        EditMenu->Enabled = false;
        System::WideChar ValidityBuffer[14];
        Clipboard()->GetTextBuf(ValidityBuffer, 14);
        ClpBrdValid = AnsiString(ValidityBuffer);
        Clipboard()->Close();

    // new section for 2.8.0 in case have valid clipboard from another application
        if(!SelectionValid)
        {
            if(ClpBrdValid == "RlyClpBrdCopy")
            {
                PasteMenuItem->Enabled = true;
                if(Level1Mode == TrackMode)
                {
                    EditMenu->Enabled = true;
                }
                CopySelected = true;
                Track->CopyFlag = true;
    // Level1Mode = TrackMode;
            }
            else if(ClpBrdValid == "RlyClpBrd_Cut")
            {
                PasteMenuItem->Enabled = true;
                if(Level1Mode == TrackMode)
                {
                    EditMenu->Enabled = true;
                }
                CopySelected = false;
                Track->CopyFlag = false;
    // Level1Mode = TrackMode;
            }
        }
    // end of new section

    // PasteWithAttributesMenuItem->Enabled = false; //new at v2.2.0   (dropped at 2.4.0 as all pastes are with attributes)
        ClpBrdValid = "";
        DeleteMenuItem->Enabled = false;
        SelectLengthsMenuItem->Enabled = false;
        if(SelectionValid)
        {
            ReselectMenuItem->Enabled = true;
        }
        else
        {
            ReselectMenuItem->Enabled = false;
        }
        SelectBiDirPrefDirsMenuItem->Visible = false;
        CheckPrefDirConflictsMenuItem->Visible = false;
        CancelSelectionMenuItem->Enabled = true;
        SelectMenuItem->Enabled = true;

        if(NoRailway() && (TrackElementPanel->Visible == false)) //added latter condition at v2.10.0 so can use select to add track elements in bulk
        {
            SelectMenuItem->Enabled = false;
        }
        else if(Level1Mode == TrackMode)
        {
            EditMenu->Enabled = true;
        }
        Utilities->CallLogPop(2273);
    }
    catch(const EClipboardException &e) //non-error catch - added at v2.10.0 after SamWainwright access denial error (08/09/21)
                                        //also reported by Bengt on 03/10/21
    {
        TrainController->LogEvent("EClipboardException in SetTrackModeEditMenu - message = " + e.Message);
        Utilities->CallLogPop(2321);
    }
}

// ---------------------------------------------------------------------------

void TInterface::SetInitialPrefDirModeEditMenu()
{
    // no need for caller or log as only setting values
    EditMenu->Enabled = true;

    CutMenuItem->Visible = false;
    CopyMenuItem->Visible = false;
    FlipMenuItem->Visible = false;
    MirrorMenuItem->Visible = false;
    RotRightMenuItem->Visible = false;
    RotLeftMenuItem->Visible = false;
    RotateMenuItem->Visible = false;
    PasteMenuItem->Visible = false;
// PasteWithAttributesMenuItem->Visible = false;   //added at v2.2.0   (dropped at 2.4.0 as all pastes are with attributes)
    DeleteMenuItem->Visible = false;
    SelectLengthsMenuItem->Visible = false;
    ReselectMenuItem->Visible = false;

    SelectBiDirPrefDirsMenuItem->Visible = true;
    CheckPrefDirConflictsMenuItem->Visible = true;
    SelectBiDirPrefDirsMenuItem->Enabled = false;
    CheckPrefDirConflictsMenuItem->Enabled = true;
    CancelSelectionMenuItem->Enabled = true;
    SelectMenuItem->Enabled = true;
}

// ---------------------------------------------------------------------------

bool TInterface::NoRailway()
{
    return ((Track->NoActiveOrInactiveTrack(5)) && (TextHandler->TextVectorSize(8) == 0) && Track->UserGraphicVector.empty());
}

// ---------------------------------------------------------------------------

void TInterface::ResetSelectRect()
{
    SelectRect.left = 0;
    SelectRect.right = 0;
    SelectRect.top = 0;
    SelectRect.bottom = 0;
}

// ---------------------------------------------------------------------------

bool TInterface::EraseLocationNameText(int Caller, AnsiString Name, int &HPos, int &VPos)
{
    // return position of erased name in HPos & VPos, return true for found & erased
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",EraseLocationNameText," + Name);
    bool TextFound = false;

// if(Track->LocationNameMultiMap.find(Name) == Track->LocationNameMultiMap.end()) {} //name not in LocationNameMultiMap, so don't erase from TextVector  //condition dropped at v1.1.4 because of change in EnterLocationNames
/* else */ if(TextHandler->FindText(0, Name, HPos, VPos))
    {
        if(TextHandler->TextErase(4, HPos, VPos, Name))
        {
            ;
        } // condition not used

        TextFound = true;
    }
    Utilities->CallLogPop(1956);
    return(TextFound);
}

// ---------------------------------------------------------------------------

void TInterface::AddLocationNameText(int Caller, AnsiString Name, int HPos, int VPos, bool UseEnteredPosition)
{
    if(Name == "")
    {
        return;
    }
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",AddLocationNameText," + Name + "," + AnsiString(HPos) + "," +
                                 AnsiString(VPos) + "," + AnsiString((short)UseEnteredPosition));
    int VPosHi, VPosLo, TextPosHi, TextPosLo;
    TFont *Font = Display->GetFont();

    if(!UseEnteredPosition)
    {
        if(!Track->FindHighestLowestAndLeftmostNamedElements(0, Name, VPosHi, VPosLo, HPos))
        {
            Utilities->CallLogPop(1561);
            return;
        }
        int Depth = abs(Font->Height); // Height may be negative - see C++Builder Help file
        TextPosHi = VPosHi + 20; // add depth of track element + 4 pixels
        TextPosLo = VPosLo - Depth - 4; // reduce by depth of font + 4 pixels
        int ScreenPosHi = (Display->DisplayOffsetV * 16) + 576;
        int ScreenPosLo = Display->DisplayOffsetV * 16;
        if(TextPosLo >= ScreenPosLo)
        {
            VPos = TextPosLo; // if Lo value on screen then use that - displays above the location
        }
        else if(TextPosHi < ScreenPosHi)
        {
            VPos = TextPosHi;
        }
        else
        {
            VPos = ScreenPosLo + 288; // if location extends to or beyond height of screen the display in centre of screen
        }
    }
    TTextItem TI(HPos, VPos, Name, Font);

    TI.Font = Font; // may have been changed in constructor when returned as reference
    TextHandler->EnterAndDisplayNewText(1, TI, HPos, VPos);
    Utilities->CallLogPop(1558);
}

// ---------------------------------------------------------------------------

void TInterface::TestFunction()    //triggered by Ctrl Alt 4
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",TestFunction");
     //test code here
/*
        if(Level1Mode == TimetableMode)  //Invert timetable entry test
        {

            TTCurrentEntryPtr = TimetableEditVector.begin();
            InvertTTEntryButton->Click();
            while(TTCurrentEntryPtr < (TimetableEditVector.end() - 1))
            {
                TTCurrentEntryPtr++;
                InvertTTEntryButton->Click();
            }
        }
*/

     //throw Exception("Test error"); //for testing the error file
        Utilities->CallLogPop(2376);
    }
    catch(const Exception &e)
    {
        ErrorLog(114, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::LoadNormalSignalGlyphs(int Caller)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadNormalSignalGlyphs,");
    SpeedButton68->Glyph = RailGraphics->SpeedBut68NormBlackGlyph;
    SpeedButton69->Glyph = RailGraphics->SpeedBut69NormBlackGlyph;
    SpeedButton70->Glyph = RailGraphics->SpeedBut70NormBlackGlyph;
    SpeedButton71->Glyph = RailGraphics->SpeedBut71NormBlackGlyph;
    SpeedButton72->Glyph = RailGraphics->SpeedBut72NormBlackGlyph;
    SpeedButton73->Glyph = RailGraphics->SpeedBut73NormBlackGlyph;
    SpeedButton74->Glyph = RailGraphics->SpeedBut74NormBlackGlyph;
    SpeedButton75->Glyph = RailGraphics->SpeedBut75NormBlackGlyph;
    Utilities->CallLogPop(1871);
}

// ---------------------------------------------------------------------------

void TInterface::LoadGroundSignalGlyphs(int Caller) // changed from the above at v2.3.0 so the signal glyphs change hands
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadGroundSignalGlyphs,");
    SpeedButton68->Glyph = RailGraphics->SpeedBut68GrndBlackGlyph;
    SpeedButton69->Glyph = RailGraphics->SpeedBut69GrndBlackGlyph;
    SpeedButton70->Glyph = RailGraphics->SpeedBut70GrndBlackGlyph;
    SpeedButton71->Glyph = RailGraphics->SpeedBut71GrndBlackGlyph;
    SpeedButton72->Glyph = RailGraphics->SpeedBut72GrndBlackGlyph;
    SpeedButton73->Glyph = RailGraphics->SpeedBut73GrndBlackGlyph;
    SpeedButton74->Glyph = RailGraphics->SpeedBut74GrndBlackGlyph;
    SpeedButton75->Glyph = RailGraphics->SpeedBut75GrndBlackGlyph;
    Utilities->CallLogPop(1872);
}

// ---------------------------------------------------------------------------

void TInterface::UpdateActionsDuePanel(int Caller) // new at v2.2.0
// limit it to 20 entries max
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UpdateActionsDuePanel");
    if(TrainController->OpActionPanelHintDelayCounter >= 60)
    {
        ActionsDueForm->ActionsDueListBox->Clear();
    }
    if((!ActionsDueForm->Visible) || TrainController->OpTimeToActMultiMap.empty() || (TrainController->OpActionPanelHintDelayCounter < 60))
    // new at v2.2.0
    {
        Utilities->CallLogPop(2092);
        return;
    }
    AnsiString OpTimeToActDisplay;
    AnsiString OpTimeToActString;
    AnsiString HeadCode;
    float OpTimeToActFloat;
    TTrainController::THCandTrainPosParam HCandTrainPosParam;

    TrainController->OpTimeToActMultiMapIterator = TrainController->OpTimeToActMultiMap.begin();
    while(TrainController->OpTimeToActMultiMapIterator != TrainController->OpTimeToActMultiMap.end())
    {
        if(ActionsDueForm->ActionsDueListBox->Items->Count >= 20)
        {
            break;
        }
        OpTimeToActFloat = TrainController->OpTimeToActMultiMapIterator->first;
        HCandTrainPosParam = TrainController->OpTimeToActMultiMapIterator->second;
        HeadCode = HCandTrainPosParam.first;
        //additions at v2.13.0 to show delayed trains in actions due list
        if(HCandTrainPosParam.second >= 0)
            {
                TTrain Train = TrainController->TrainVectorAtIdent(63, HCandTrainPosParam.second); //doesn't need to be a reference here
                if(int(Train.DelayedRandMins) > 0)
                {
                    HeadCode += AnsiString('+'); //changed from 'd' to this on suggestion from Micke(Commuterpop) at v2.13.0
                }
            }
        //end of additions at v2.13.0
        if(OpTimeToActFloat < 0.25) // 15 secs estimated
        {
            OpTimeToActString = "NOW";
        }
        else if(OpTimeToActFloat < 1)
        {
            OpTimeToActString = "<1";
        }
        else
        {
            OpTimeToActString = AnsiString(floor(OpTimeToActFloat));
        }
        if(OpTimeToActFloat < 60)
        {
            OpTimeToActDisplay = HeadCode + AnsiString('\t') + OpTimeToActString;
            ActionsDueForm->ActionsDueListBox->Items->Add(OpTimeToActDisplay); // original
        }
        TrainController->OpTimeToActMultiMapIterator++;
    }
    Utilities->CallLogPop(2093);
}

// ---------------------------------------------------------------------------
//below used in debugging TimeToExitMultiMap: replaces times to act in OpTimeToAct panel with headcodes and exit times (or exit locs) so they are visible
//to use, uncomment this function and comment out the original above
/*
void TInterface::UpdateActionsDuePanel(int Caller) // new at v2.2.0
// limit it to 20 entries max
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",UpdateActionsDuePanel");
    if(TrainController->OpActionPanelHintDelayCounter >= 60)
    {
        ActionsDueListBox->Clear();
    }
    if((!ActionsDuePanel->Visible) || TrainController->TimeToExitMultiMap.empty() || (TrainController->OpActionPanelHintDelayCounter < 60))
    // new at v2.2.0
    {
        Utilities->CallLogPop(2386);
        return;
    }
    AnsiString OpTimeToActDisplay;
    AnsiString OpTimeToActString;
    AnsiString HeadCode;
    THVShortPair ExitPair;
    float OpTimeToActFloat;
//    TTrainController::THCandTrainPosParam HCandTrainPosParam;

    TTimeToExitMultiMap::iterator TTEMMIt = TrainController->TimeToExitMultiMap.begin();
    while(TTEMMIt != TrainController->TimeToExitMultiMap.end())
    {
        if(ActionsDueListBox->Items->Count >= 20)
        {
            break;
        }
        OpTimeToActFloat = float(TTEMMIt->second.TimeToExitSecs);
        HeadCode = TTEMMIt->second.ServiceReference.Trim();
        ExitPair = TTEMMIt->first;
        if((OpTimeToActFloat > 0) && (OpTimeToActFloat < 3600))  //no display if outside these limits
        {
            OpTimeToActString = AnsiString(int(OpTimeToActFloat));//seconds
            OpTimeToActDisplay = HeadCode + AnsiString(' ') + OpTimeToActString; //comment out one of these to display times or exits
            ActionsDueListBox->Items->Add(OpTimeToActDisplay);
        }
        TTEMMIt++;
    }
    Utilities->CallLogPop(2377;
}
*/
// ---------------------------------------------------------------------------

void TInterface::LoadUserGraphic(int Caller) // new at v2.4.0
{
    try
    {
        TrainController->LogEvent("LoadUserGraphic");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadUserGraphic");
        if(LoadUserGraphicDialog->Execute())
        {
            TrainController->LogEvent("LoadUserGraphic " + LoadUserGraphicDialog->FileName);
            SelectedGraphicFileName = AnsiString(LoadUserGraphicDialog->FileName); // SelectedGraphicFileName is a class member
            TTrack::TUserGraphicMapEntry UGME;
            TTrack::TUserGraphicMap::iterator UGMIt = Track->UserGraphicMap.find(SelectedGraphicFileName);
            if(UGMIt == Track->UserGraphicMap.end()) // i.e. there isn't an entry for that filename so insert one, else take no action
            {
                UGME.first = SelectedGraphicFileName;
                TPicture *PicPtr = new TPicture;
                PicPtr->LoadFromFile(SelectedGraphicFileName);
                UGME.second = PicPtr;
                if(!Track->UserGraphicMap.insert(UGME).second) // if no failure then the new entry is inserted
                {
                    throw Exception("Map Insertion Error 1 - UserGraphicMap insertion failure for " + SelectedGraphicFileName);
                }
            }
            Level2TrackMode = AddGraphic;
            SetLevel2TrackMode(65);
        }
        Utilities->CallLogPop(2191);
    }
    catch(const EInvalidGraphic &e) //non-error catch
    {
        ShowMessage(
            "Incorrect file format, the file can't be loaded.\nEnsure that the file you want is a valid graphic file with extension .bmp, .gif, .jpg, or .png");
        Utilities->CallLogPop(2311);
    }
    catch(const Exception &e)
    {
        ErrorLog(215, e.Message);
    }
}

// ---------------------------------------------------------------------------

void TInterface::LoadClipboard(int Caller) // new at v2.8.0
{
    try
    {
        TrainController->LogEvent("LoadClipboard");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",LoadClipboard");

        std::wstringstream wss; // used to hold all parameters prior to conversion to a string buffer
        if(CopySelected)
        {
            wss << "RlyClpBrdCopy\n";
        }
        else
        {
            wss << "RlyClpBrd_Cut\n";
        }
// Load the active & inactive track vectors
        for(TTrack::TTrackVectorIterator TTVIt = Track->SelectVector.begin(); TTVIt < Track->SelectVector.end(); TTVIt++)
        {
            wss << TTVIt->SpeedTag;
            wss << '\n'; // inherited int - all FixedTrackPiece parameters implicit in this
            for(int AnsLen = 0; AnsLen <= TTVIt->ActiveTrackElementName.Length(); AnsLen++)
            {
                if((TTVIt->ActiveTrackElementName).c_str()[AnsLen] != '\0')
                {
                    wss << (TTVIt->ActiveTrackElementName).c_str()[AnsLen];
                }
                else
                {
                    wss << '\n';
                }
            }
            for(int AnsLen = 0; AnsLen <= TTVIt->ElementID.Length(); AnsLen++)
            {
                if((TTVIt->ElementID).c_str()[AnsLen] != '\0')
                {
                    wss << (TTVIt->ElementID).c_str()[AnsLen];
                }
                else
                {
                    wss << '\n';
                }
            }
            for(int AnsLen = 0; AnsLen <= TTVIt->LocationName.Length(); AnsLen++)
            {
                if((TTVIt->LocationName).c_str()[AnsLen] != '\0')
                {
                    wss << (TTVIt->LocationName).c_str()[AnsLen];
                }
                else
                {
                    wss << '\n';
                }
            }
            wss << TTVIt->CallingOnSet;
            wss << '\n';
            wss << TTVIt->LCPlotted;
            wss << '\n';
/* dropped at v2.13.0, not used from 2.12.0
            wss << TTVIt->TempTrackMarker01;
            wss << '\n';
            wss << TTVIt->TempTrackMarker23;
            wss << '\n';
*/
            wss << TTVIt->Attribute;
            wss << '\n'; // all ints from here except last which is an enum
            wss << TTVIt->Conn[0];
            wss << '\n';
            wss << TTVIt->Conn[1];
            wss << '\n';
            wss << TTVIt->Conn[2];
            wss << '\n';
            wss << TTVIt->Conn[3];
            wss << '\n';
            wss << TTVIt->ConnLinkPos[0];
            wss << '\n';
            wss << TTVIt->ConnLinkPos[1];
            wss << '\n';
            wss << TTVIt->ConnLinkPos[2];
            wss << '\n';
            wss << TTVIt->ConnLinkPos[3];
            wss << '\n';
            wss << TTVIt->HLoc;
            wss << '\n';
            wss << TTVIt->VLoc;
            wss << '\n';
            wss << TTVIt->Length01;
            wss << '\n';
            wss << TTVIt->Length23;
            wss << '\n';
            wss << TTVIt->SpeedLimit01;
            wss << '\n';
            wss << TTVIt->SpeedLimit23;
            wss << '\n';
            wss << TTVIt->StationEntryStopLinkPos1;
            wss << '\n';
            wss << TTVIt->StationEntryStopLinkPos2;
            wss << '\n';
            wss << TTVIt->TrainIDOnElement;
            wss << '\n';
            wss << TTVIt->TrainIDOnBridgeOrFailedPointOrigSpeedLimit01;
            wss << '\n';
            wss << TTVIt->TrainIDOnBridgeOrFailedPointOrigSpeedLimit23;
            wss << '\n';
            wss << int(TTVIt->SigAspect);
            wss << '\n'; // enum
        }
        wss << "$$$" << '\n'; // send track element end marker

// Load the text vector

        for(TTextHandler::TTextVectorIterator TTVIt = TextHandler->SelectTextVector.begin(); TTVIt < TextHandler->SelectTextVector.end(); TTVIt++)
        {
            for(int AnsLen = 0; AnsLen <= TTVIt->TextString.Length(); AnsLen++)
            {
                if((TTVIt->TextString).c_str()[AnsLen] != '\0')
                {
                    wss << (TTVIt->TextString).c_str()[AnsLen];
                }
                else
                {
                    wss << '\n';
                }
            }
            wss << TTVIt->HPos;
            wss << '\n';
            wss << TTVIt->VPos;
            wss << '\n';
            for(int AnsLen = 0; AnsLen <= AnsiString(TTVIt->Font->Name).Length(); AnsLen++)
            {
                if(AnsiString(TTVIt->Font->Name).c_str()[AnsLen] != '\0')
                {
                    wss << AnsiString(TTVIt->Font->Name).c_str()[AnsLen];
                }
                else
                {
                    wss << '\n';
                }
            }
            wss << TTVIt->Font->Size;
            wss << '\n';
            if((TTVIt->Font->Color < 0) || (TTVIt->Font->Color > 0xFFFFFF)) // if set to any of the special 'windows' colours save it as black
            {
                wss << "0\n";
            }
            else
            {
                wss << int(TTVIt->Font->Color) << '\n';
            }
            wss << int(TTVIt->Font->Charset) << '\n'; // save as 'int' (would be unsigned char else) so 'n' can act as proper delimiter
            wss << TextHandler->GetFontStyleAsInt(1, TTVIt->Font) << '\n';
        }
        wss << "$$$" << '\n'; // send text item end marker

        //load select dimensions
        wss << SelectBitmap->Height;
        wss << '\n';
        wss << SelectBitmap->Width;
        wss << '\n';
        wss << SelectRect.left;
        wss << '\n';
        wss << SelectRect.top;
        wss << '\n';
        wss << "$$$" << '\n'; // send end of select dimension marker

        //load preferred directions //added at v2.9.0
        if(SelectPrefDir->PrefDirSize() > 0)     // skip load if empty
        {
            for(TOnePrefDir::TPrefDirVectorIterator PDVIt = SelectPrefDir->PrefDirVector.begin(); PDVIt < SelectPrefDir->PrefDirVector.end(); PDVIt++)
            {
                //Note that TrackVector Position won't be valid for a remote paste, it will be reset when pasted, also Conns & ConnLinkPosses set when
                //track linked
                wss << PDVIt->GetTrackVectorPosition(); //added at v2.9.2 so all 9 of CheckCount properties loaded (SpeedTag loaded from TrackElement at HLoc & VLoc)
                wss << '\n';
                wss << PDVIt->GetHLoc();
                wss << '\n';
                wss << PDVIt->GetVLoc();
                wss << '\n';
                wss << PDVIt->GetELink();
                wss << '\n';
                wss << PDVIt->GetELinkPos();
                wss << '\n';
                wss << PDVIt->GetXLink();
                wss << '\n';
                wss << PDVIt->GetXLinkPos();
                wss << '\n';
                wss << PDVIt->GetEXNumber();
                wss << '\n';
            }
        }
        wss << "$$$" << '\n'; // send pref dir end marker
        wss << '\0'; // has to end with NULL

        Clipboard()->Clear(); // clear the clipboard
        Clipboard()->SetTextBuf(&(wss.str()[0])); // populate the clipboard
        Clipboard()->Close();

        Utilities->CallLogPop(2267);
    }

    catch(const EClipboardException &e) //non-error catch - ignore access denials (but only seems to happen with recover), doesn't affect program
    {
// Application->MessageBox(L"A clipboard error occurred in loading the clipboard", L"Message", MB_OK);
        TrainController->LogEvent("EClipboardException in LoadClipboard - message = " + e.Message);
        Utilities->CallLogPop(2312);
    }

    catch(const Exception &e)
    {
        ErrorLog(222, e.Message);
    }

}

// ---------------------------------------------------------------------------

void TInterface::RecoverClipboard(int Caller, bool &ValidResult) // new at v2.8.0
{
    try
    {
        TrainController->LogEvent("RecoverClipboard");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + "," + AnsiString(Caller) + ",RecoverClipboard");
        ValidResult = false;
        System::WideChar *SelectVectorBuffer = new System::WideChar[4000000]; // scope for 130 chars per element & 4k resolution (240 x 135 elements)
        int StreamSize = 0;
        StreamSize = Clipboard()->GetTextBuf(SelectVectorBuffer, 4000000);
        Clipboard()->Clear(); // clear it so can't keep pasting same thing as don't permit this in single app
        Clipboard()->Close();
        if(StreamSize < 14)
        {
            Utilities->CallLogPop(2270); // ValidResult == false
            return;
        }
        std::wstringstream wss;
        wss << SelectVectorBuffer;
        ClpBrdValid = AnsiString(SelectVectorBuffer).SubString(1, 13);
        PasteMenuItem->Enabled = false;
        delete[]SelectVectorBuffer;

        if((ClpBrdValid != AnsiString("RlyClpBrdCopy")) && (ClpBrdValid != AnsiString("RlyClpBrd_Cut")))
        {
            Utilities->CallLogPop(2268); // ValidResult == false
            return;
        }
        int MarkerCounter = 0; //If ever get a MarkerCounter value well outside expected range it's probably because some text is too long - see comment below
        ClpBrdValid = "";
        wchar_t LineString[1000]; // should be big enough for any entry, (extended from 100 at v2.9.2) text can be long but hopefully not this long - won't
            //recover the clipboard if longer but won't crash.  It has to be at least as big as the biggest getline number or the excess will overwrite other variables,
            //this was discovered when MarkerCounter suddenly jumped from 1 to nearly 3000000 when Linesting loaded with text ~180 chars long with LineString limited
            //to 100 chars

        wss.getline(LineString, 100); // RlyClpBrdCopy or ...Cut - discard it
        Track->SelectVector.clear();
        TTrack::TTrackMap SelectTrackMap; //build map so can find TrackElement at required H  & V to build PrefDirElement from it //added at v2.9.0
        THVShortPair SelectTrackMapKeyPair; //for above
        TTrack::TTrackMapEntry SelectTrackMapEntry; //for above
        while(true) // recover active & inactive track (active first & top to bottom at leftmost position then again stepping right
        {
            wss.getline(LineString, 100);
            if(AnsiString(LineString) == "$$$") // end of track element marker
            {
                MarkerCounter++;
                break;
            }
            // if not $$$ then it's the SpeedTag number
            TTrackElement TE = Track->BuildBasicElementFromSpeedTag(5, AnsiString(LineString).ToInt());
            wss.getline(LineString, 100);
            TE.ActiveTrackElementName = AnsiString(LineString); // if not "$$$" must be the start of the next element
            wss.getline(LineString, 100);
            TE.ElementID = AnsiString(LineString);
            wss.getline(LineString, 100);
            TE.LocationName = AnsiString(LineString);

            wss.getline(LineString, 100);
            TE.CallingOnSet = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.LCPlotted = AnsiString(LineString).ToInt();
/* dropped at v2.13.0, not used from 2.12.0
            wss.getline(LineString, 100);
            TE.TempTrackMarker01 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.TempTrackMarker23 = AnsiString(LineString).ToInt();
*/
            wss.getline(LineString, 100);
            TE.Attribute = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Conn[0] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Conn[1] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Conn[2] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Conn[3] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.ConnLinkPos[0] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.ConnLinkPos[1] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.ConnLinkPos[2] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.ConnLinkPos[3] = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.HLoc = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.VLoc = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Length01 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.Length23 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.SpeedLimit01 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.SpeedLimit23 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.StationEntryStopLinkPos1 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.StationEntryStopLinkPos2 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.TrainIDOnElement = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit01 = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TE.TrainIDOnBridgeOrFailedPointOrigSpeedLimit23 = AnsiString(LineString).ToInt();

            wss.getline(LineString, 100);
            int temp = AnsiString(LineString).ToInt();
            if(temp == 0)
            {
                TE.SigAspect = TTrackElement::FourAspect;
            }
            else if(temp == 1)
            {
                TE.SigAspect = TTrackElement::ThreeAspect;
            }
            else if(temp == 2)
            {
                TE.SigAspect = TTrackElement::TwoAspect;
            }
            else if(temp == 3)
            {
                TE.SigAspect = TTrackElement::GroundSignal;
            }
            Track->SelectVector.push_back(TE);
            if((TE.TrackType != Concourse) && (TE.TrackType != Parapet) && (TE.TrackType != NamedNonStationLocation) && (TE.TrackType != Platform)
                && (TE.TrackType != LevelCrossing)) //aded at v2.9.2 so only active elements added to SelectTrackMap
            {
                SelectTrackMapKeyPair.first = TE.HLoc;
                SelectTrackMapKeyPair.second = TE.VLoc;
                SelectTrackMapEntry.first = SelectTrackMapKeyPair;
                SelectTrackMapEntry.second = Track->SelectVector.size() - 1;
                SelectTrackMap.insert(SelectTrackMapEntry);
            }
        }

        TextHandler->SelectTextVector.clear();
        AnsiString FontName;
        int FontSize, FontColour, FontCharset, FontStyle;
        while(true) // recover text
        {
            wss.getline(LineString, 1000);
            if(AnsiString(LineString) == "$$$") // end of text marker
            {
                MarkerCounter++;
                break;
            }
            // if not $$$ then it's the text string
            TTextItem TI;
            TI.TextString = AnsiString(LineString);
            wss.getline(LineString, 1000);   //extended to 1000 from 100 for text items at v2.9.2
            TI.HPos = AnsiString(LineString).ToInt();
            wss.getline(LineString, 1000);
            TI.VPos = AnsiString(LineString).ToInt();
            wss.getline(LineString, 1000);
            FontName = AnsiString(LineString).c_str();
            wss.getline(LineString, 1000);
            FontSize = AnsiString(LineString).ToInt();
            wss.getline(LineString, 1000);
            FontColour = AnsiString(LineString).ToInt();
            wss.getline(LineString, 1000);
            FontCharset = AnsiString(LineString).ToInt();
            wss.getline(LineString, 1000);
            FontStyle = AnsiString(LineString).ToInt();
            // create a new font
            TFont *NewFont = new TFont;
            NewFont->Name = FontName;
            NewFont->Size = FontSize;
            NewFont->Color = static_cast<TColor>(FontColour);
            NewFont->Charset = FontCharset;
            NewFont->Style = TextHandler->SetFontStyleFromInt(1, FontStyle);
            TI.Font = NewFont;
            TextHandler->SelectTextVector.push_back(TI);
        }

        // recover select dimensions
        wss.getline(LineString, 100);
        SelectBitmap->Height = AnsiString(LineString).ToInt();
        wss.getline(LineString, 100);
        SelectBitmap->Width = AnsiString(LineString).ToInt();
        wss.getline(LineString, 100);
        SelectRect.left = AnsiString(LineString).ToInt();
        wss.getline(LineString, 100);
        SelectRect.top = AnsiString(LineString).ToInt();
        wss.getline(LineString, 100);
        if(AnsiString(LineString) == "$$$")
        {
            MarkerCounter++;
        }

        // recover pref dirs - after dimensions so that a clipboard loaded with this app will paste into an earlier version app without pref dirs
        // if a clipboard loaded with an earlier app is pasted into this app then the marker will be wrong, an error message will be given but no crash
        int TempTVPos, TempHLoc, TempVLoc, TempELink, TempELinkPos, TempXLink, TempXLinkPos, TempEXNumber, ATVecPos;
        bool FoundFlag;
        SelectPrefDir->ExternalClearPrefDirAnd4MultiMap();
        while(true)
        {
            wss.getline(LineString, 100);
            if(AnsiString(LineString) == "$$$") // end of pref dir element marker
            {
                MarkerCounter++;
                break;
            }
            // if not $$$ then it's the TVPos value
            TempTVPos = AnsiString(LineString).ToInt(); //added at v2.9.2 so all 9 CheckCount properties valid (SpeedTag loaded from corresponding TrackElement)
            wss.getline(LineString, 100);
            TempHLoc = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempVLoc = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempELink = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempELinkPos = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempXLink = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempXLinkPos = AnsiString(LineString).ToInt();
            wss.getline(LineString, 100);
            TempEXNumber = AnsiString(LineString).ToInt();
            //build a pref dir element from these values and the corresponding TrackVectorPosition for HLoc & VLoc
            TTrackElement TempElement = Track->GetTrackElementFromAnyTrackMap(0, TempHLoc, TempVLoc, SelectTrackMap, Track->SelectVector);
            TPrefDirElement TempPrefDirElement(TempElement);
//            TempPrefDirElement.HLoc = TempHLoc;  //these and SpeedTag already set from TempElement
//            TempPrefDirElement.VLoc = TempVLoc;
            TempPrefDirElement.SetTrackVectorPosition(TempTVPos); //added at v2.9.2 so all 9 CheckCount properties have values (SpeedTag loaded from corresponding TrackElement)
                                                                  //TVPos only included for completeness & not valid yet, it will change to the correct value when pasted
                                                                  //and change again when the track is linked
            TempPrefDirElement.SetELink(TempELink);
            TempPrefDirElement.SetELinkPos(TempELinkPos);
            TempPrefDirElement.SetXLink(TempXLink);
            TempPrefDirElement.SetXLinkPos(TempXLinkPos);
            TempPrefDirElement.SetEXNumber(TempEXNumber);
            TempPrefDirElement.SetCheckCount(9); //added at v2.9.2
            SelectPrefDir->ExternalStorePrefDirElement(11, TempPrefDirElement);  //added 27/05 at v2.9.0
        }

        if(MarkerCounter == 4)
        {
            ValidResult = true;
        }
        Utilities->CallLogPop(2269);
    }

    catch(const EClipboardException &e) //non-error catch - don't stop for any error in this section, just give bad clipboard message
    {
        ValidResult = false;
        TrainController->LogEvent("EClipboardException in RecoverClipboard - message = " + e.Message);
        Utilities->CallLogPop(2313);
    }
    catch(const Exception &e) //non-error catch - non-clipboard exception
    {
        ValidResult = false;
        TrainController->LogEvent("non-clipboard exception in RecoverClipboard - message = " + e.Message);
        Utilities->CallLogPop(2322);
//        ErrorLog(223, e.Message);
    }

}
// ---------------------------------------------------------------------------

void __fastcall TInterface::NoDelaysMenuItemClick(TObject *Sender)  //these added at v2.13.0
{
    NoDelaysMenuItem->Enabled = false;
    MinorDelaysMenuItem->Enabled = true;
    ModerateDelaysMenuItem->Enabled = true;
    MajorDelaysMenuItem->Enabled = true;
    DelayMenu->Caption = "No delays";
    PerfLogForm->PerformanceLog(32, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": No random delays selected");
    Utilities->DelayMode = Nil;
}
//---------------------------------------------------------------------------

void __fastcall TInterface::MinorDelaysMenuItemClick(TObject *Sender)
{
    NoDelaysMenuItem->Enabled = true;
    MinorDelaysMenuItem->Enabled = false;
    ModerateDelaysMenuItem->Enabled = true;
    MajorDelaysMenuItem->Enabled = true;
    DelayMenu->Caption = "Minor delays";
    PerfLogForm->PerformanceLog(33, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Minor random delays selected");
    Utilities->DelayMode = Minor;
}
//---------------------------------------------------------------------------

void __fastcall TInterface::ModerateDelaysMenuItemClick(TObject *Sender)
{
    NoDelaysMenuItem->Enabled = true;
    MinorDelaysMenuItem->Enabled = true;
    ModerateDelaysMenuItem->Enabled = false;
    MajorDelaysMenuItem->Enabled = true;
    DelayMenu->Caption = "Moderate delays";
    PerfLogForm->PerformanceLog(34, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Moderate random delays selected");
    Utilities->DelayMode = Moderate;
}
//---------------------------------------------------------------------------

void __fastcall TInterface::MajorDelaysMenuItemClick(TObject *Sender)
{
    NoDelaysMenuItem->Enabled = true;
    MinorDelaysMenuItem->Enabled = true;
    ModerateDelaysMenuItem->Enabled = true;
    MajorDelaysMenuItem->Enabled = false;
    DelayMenu->Caption = "Major delays";
    PerfLogForm->PerformanceLog(35, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Major random delays selected");
    Utilities->DelayMode = Major;
}

// ---------------------------------------------------------------------------

void __fastcall TInterface::NoFailuresMenuItemClick(TObject *Sender)
{
    NoFailuresMenuItem->Enabled = false;
    MinorFailuresMenuItem->Enabled = true;
    ModerateFailuresMenuItem->Enabled = true;
    MajorFailuresMenuItem->Enabled = true;
    Utilities->PointChangeEventsPerFailure = Utilities->NilPointChangeEventsPerFailure;
    Utilities->SignalChangeEventsPerFailure = Utilities->NilSignalChangeEventsPerFailure;
    Utilities->MTBTSRs = Utilities->NilMTBTSRs;
    FailureMenu->Caption = "No failures";
    PerfLogForm->PerformanceLog(61, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": No random failures selected");
    Utilities->FailureMode = FNil;
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MinorFailuresMenuItemClick(TObject *Sender)
{
    NoFailuresMenuItem->Enabled = true;
    MinorFailuresMenuItem->Enabled = false;
    ModerateFailuresMenuItem->Enabled = true;
    MajorFailuresMenuItem->Enabled = true;
    Utilities->PointChangeEventsPerFailure = Utilities->MinorPointChangeEventsPerFailure;
    Utilities->SignalChangeEventsPerFailure = Utilities->MinorSignalChangeEventsPerFailure;
    Utilities->MTBTSRs = Utilities->MinorMTBTSRs;
    FailureMenu->Caption = "Minor failures";
    PerfLogForm->PerformanceLog(62, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Minor random failures selected");
    Utilities->FailureMode = FMinor;
}

//---------------------------------------------------------------------------

void __fastcall TInterface::ModerateFailuresMenuItemClick(TObject *Sender)
{
    NoFailuresMenuItem->Enabled = true;
    MinorFailuresMenuItem->Enabled = true;
    ModerateFailuresMenuItem->Enabled = false;
    MajorFailuresMenuItem->Enabled = true;
    Utilities->PointChangeEventsPerFailure = Utilities->ModeratePointChangeEventsPerFailure;
    Utilities->SignalChangeEventsPerFailure = Utilities->ModerateSignalChangeEventsPerFailure;
    Utilities->MTBTSRs = Utilities->ModerateMTBTSRs;
    FailureMenu->Caption = "Moderate failures";
    PerfLogForm->PerformanceLog(63, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Moderate random failures selected");
    Utilities->FailureMode = FModerate;
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MajorFailuresMenuItemClick(TObject *Sender)
{
    NoFailuresMenuItem->Enabled = true;
    MinorFailuresMenuItem->Enabled = true;
    ModerateFailuresMenuItem->Enabled = true;
    MajorFailuresMenuItem->Enabled = false;
    Utilities->PointChangeEventsPerFailure = Utilities->MajorPointChangeEventsPerFailure;
    Utilities->SignalChangeEventsPerFailure = Utilities->MajorSignalChangeEventsPerFailure;
    Utilities->MTBTSRs = Utilities->MajorMTBTSRs;
    FailureMenu->Caption = "Major failures";
    PerfLogForm->PerformanceLog(64, Utilities->Format96HHMMSS(TrainController->TTClockTime) + ": Major random failures selected");
    Utilities->FailureMode = FMajor;
}

//---------------------------------------------------------------------------

bool TInterface::GetTrainIDOrContinuationPosition(int Caller, int X, int Y, int &TrainID, int &TrackVectorPosition)
// returns true if value(s) valid
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",GetTrainIDOrContinuationPosition");
    TTrainController::TOpTimeToActMultiMapIterator OACurrentEntryPtr;
//    int TopPos = ActionsDueForm->ActionsDueListBox->TopIndex;

//substituted for the below
    int OAIndex = ActionsDueForm->ActionsDueListBox->ItemAtPos(TPoint(X,Y), true);
    if(OAIndex == -1)
    {
        Utilities->CallLogPop(2089);
        return(false);
    }
    else
    {
        OACurrentEntryPtr = TrainController->OpTimeToActMultiMap.begin();
        std::advance(OACurrentEntryPtr, OAIndex);
    }
//dropped at v2.13.0 as unreliable on high resolution monitors
/*    if((TopPos + (Y / 13)) >= ActionsDueForm->ActionsDueListBox->Items->Count) // if click beyond end of list ignore
    {
        Utilities->CallLogPop();
        return(false);
    }
    else
    {
        OACurrentEntryPtr = TrainController->OpTimeToActMultiMap.begin();
        std::advance(OACurrentEntryPtr, ((Y / 13) + TopPos));
    }
*/

    int TrainIDorTVPos = OACurrentEntryPtr->second.second;
    if(TrainIDorTVPos >= 0) // running train, so value is the TrainID
    {
        if(TrainController->TrainExistsAtIdent(0, TrainIDorTVPos)) // added at v2.4.0 in case train removed but still in OA list as not updated yet
        // see LiWinDom error report on Discord 23/04/20. Also needed for click ActionsDueListBox before any trains show,
        // as notified by Rokas Serys by email on 16/05/20
        {
            TrainID = TrainIDorTVPos;
            TrackVectorPosition = TrainController->TrainVectorAtIdent(43, TrainIDorTVPos).GetLeadElement();
        }
        else
        {
            Utilities->CallLogPop(2155); // if not there then ignore
            return(false);
        }
    }
    else // train to enter at a continuation, so value is -TVPos of continuation - 1
    {
        TrackVectorPosition = -(TrainIDorTVPos + 1);
    }
    Utilities->CallLogPop(2261);
    return(true);
}

// ---------------------------------------------------------------------------
//Multiplayer Code
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
//Host functions
// ---------------------------------------------------------------------------

void __fastcall TInterface::MultiplayerHostSessionMenuItemClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MultiplayerHostSessionMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MultiplayerHostSessionMenuItemClick");
        MultiplayerHostPanel->Visible = true;
        MultiplayerHostPanel->Left = MainScreen->Left + (MainScreen->Width / 2) - (MultiplayerHostPanel->Width / 2);
        MultiplayerHostPanel->Top = MainScreen->Top + 100;

        MultiplayerHostSessionMenuItem->Enabled = false;
        SaveMultiplayerSessionMenuItem->Enabled = false;
        EndSimulationMenuItem->Enabled = false;
        ShowHideStringGridMenuItem->Enabled = false;
        JoinMultiplayerSessionMenuItem->Enabled = false;
        ExitSimulationMenuItem->Enabled = false;
        HostInSessionFlag = false;
        CouplingFileLoadedFlag = false;
        PlayerMakingInitialContactFlag = false;
        PlayerReadyToBeginFlag = false;
        PlayerCancelJoinFlag = false;
        PlayerAwaitingHostStartFlag = false;
        PlayerInSessionFlag = false;

        MPHPLoadCouplingFileButton->Enabled = false;
        MPHPCancelButton->Enabled = true;
        MPHPStartButton->Enabled = false;
        MPHPGeneralLabel->Caption = "Complete the boxes and press 'Enter' for each.";
        MPHPOwnIPEditBox->Text = "0.0.0.0";//  <--temporary - change to "" for release
        MPHPOwnPortEditBox->Text = "50000";//  <--temporary - change to "" for release
        MPHPOwnIPEditBox->Enabled = true;
        MPHPOwnPortEditBox->Enabled = true;
        MPHostClient->Active = false;
        Utilities->CallLogPop(2348);
    }

    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MultiplayerHostSessionMenuItemClick " + e.Message); //<--temporary
        Utilities->CallLogPop(2407);
    }
    catch(const Exception &e)
    {
        ErrorLog(226, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPHPLoadCouplingFileButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MPHPLoadCouplingFileButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPHPLoadCouplingFileButtonClick");
        LoadCouplingFileDialog->Filter = "Text file (*.txt)|*.txt";
        if(LoadCouplingFileDialog->Execute()) //error messages given in PopulateCouplingMap
        {
            NumPlayers = 0;
            TrainController->LogEvent("LoadCouplingFile " + AnsiString(LoadCouplingFileDialog->FileName));
            if(PopulateCouplingMap(AnsiString(LoadCouplingFileDialog->FileName), NumPlayers))
            {
                MultiplayerHostStringGrid->RowCount = 1;    //clear it before loading or reloading
                MultiplayerHostStringGrid->ColCount = 1;
                MultiplayerHostStringGrid->Cells[0][0] = "";
                MultiplayerHostStringGrid->Top = MultiplayerHostPanel->Top;
                MultiplayerHostStringGrid->Width = 260;
                MultiplayerHostStringGrid->Left = MultiplayerHostPanel->Left - MultiplayerHostStringGrid->Width - 10;
                MultiplayerHostStringGrid->Height = (25 * NumPlayers) + 54;
                if(MultiplayerHostStringGrid->Height > MainScreen->Height - 100)
                {
                    MultiplayerHostStringGrid->Height = MainScreen->Height - 120;
                }
                MultiplayerHostStringGrid->ColCount = 3;
                MultiplayerHostStringGrid->RowCount = NumPlayers + 2; //2 = heading & blank row
                MultiplayerHostStringGrid->ColWidths[1] = 128;
                MultiplayerHostStringGrid->Cells[0][0] = "Player";
                MultiplayerHostStringGrid->Cells[1][0] = "Railway";
                MultiplayerHostStringGrid->Cells[2][0] = "Ready?";
                bool RailwayFound = false;
                for(RLIt = RailwayList.begin(); RLIt != RailwayList.end(); RLIt++)
                {
                    if(*RLIt != RailwayTitle)  //host's railway
                    {
                        continue;
                    }
                    else
                    {
                        RailwayFound = true;
                        break;
                    }
                }
                if(!RailwayFound)
                {
                    ShowMessage("Can't find '" + RailwayTitle + "' in coupling file - please load an appropriate railway and timetable or a pre-start session file");
                    Utilities->CallLogPop(2349);
                    return;
                }
                MultiplayerHostStringGrid->Visible = true;
                MPHPLoadCouplingFileButton->Enabled = false;
                MPHPGeneralLabel->Caption = "Awaiting player connections";
                int GridCount = 2;  ;//row 1 is blank
                InfoVector.clear();
                TRlyUserInfo RlyUserInfo; //has default values
                unsigned char x = 1; //numbers start at 1
                //populate StringGrid & InfoVector with RailwayNames & numbers + "Host" as user in correct place
                for(RLIt = RailwayList.begin(); RLIt != RailwayList.end(); RLIt++)//railways in order
                {
                    if(*RLIt == RailwayTitle) //host's railway
                    {
                        MultiplayerHostStringGrid->Cells[0][GridCount] = "Host";
                        MultiplayerHostStringGrid->Cells[1][GridCount] = *RLIt;  //RailwayName
                        MultiplayerHostStringGrid->Cells[2][GridCount] = "Yes";
                        RlyUserInfo.RailwayName = *RLIt;  //RailwayName
                        RlyUserInfo.UserName = "Host";
                        RlyUserInfo.RlyUserNumber = x;
                        InfoVector.push_back(RlyUserInfo);
                        x++;
                    }
                    else
                    {
                        MultiplayerHostStringGrid->Cells[0][GridCount] = ""; //UserName
                        MultiplayerHostStringGrid->Cells[1][GridCount] = *RLIt;  //RailwayName
                        MultiplayerHostStringGrid->Cells[2][GridCount] = "No";
                        RlyUserInfo.RailwayName = *RLIt;  //RailwayName
                        RlyUserInfo.RlyUserNumber = x;
                        InfoVector.push_back(RlyUserInfo);
                        x++;
                    }
                    GridCount++;
                }
                CouplingFileLoadedFlag = true;
                MPHostClient->Active = true;
            }
            //no need for 'else' - messages given in called functions
        }
        Utilities->CallLogPop(2324);
    }
    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MPHPLoadCouplingFileButtonClick " + e.Message); //<--temporary
        Utilities->CallLogPop(2408);
    }
    catch(const Exception &e)
    {
        ErrorLog(225, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPHPCancelButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MPHPCancelButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPHPCancelButtonClick");
        MPHostClient->Active = false;
        MPHPOwnIPEditBox->Text = "";
        MPHPOwnPortEditBox->Text = "";
        MultiplayerHostPanel->Visible = false;
        MultiplayerHostStringGrid->Visible = false;
        MPHPStartButton->Enabled = false;
//        AnsiCouplingMap.clear();  cleared in PopulateCouplingMap
        CouplingFileLoadedFlag = false;
        HostInSessionFlag = false;
        Utilities->CallLogPop(2350);
    }
    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MPHPCancelButtonClick " + e.Message); //<--temporary
        Utilities->CallLogPop(2409);
    }
    catch(const Exception &e)
    {
        ErrorLog(227, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPHPStartButtonClick(TObject *Sender)
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPHPStartButtonClick");

        ShowMessage("We're off!");  //<--temporary
        MultiplayerHostPanel->Visible = false;
        MultiplayerHostStringGrid->Visible = false;
        HostInSessionFlag = true;
        OperateButton->Click(); //start own session
        Utilities->CallLogPop(2369);
    }
    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MPHPStartButtonClick " + e.Message); //<--temporary
        Utilities->CallLogPop(2410);
    }
    catch(const Exception &e)
    {
        ErrorLog(237, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPHPOwnIPEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)

{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPHPOwnIPEditBoxKeyUp," + AnsiString(Key));
        if(Key == '\x0D') //CR
        {
            if(InvalidIPAddress(MPHPOwnIPEditBox->Text))
            {
                ShowMessage("Format should be 'a.b.c.d' where a, b, c, and d are numbers between 0 and 255.\n\nObtain the address from the host and enter exactly as given.");
                MPHPOwnIPEditBox->Text = "";
                Utilities->CallLogPop(2351);
                return;
            }
            MPHPOwnIPEditBox->Enabled = false;
            if(MPHPOwnPortEditBox->Enabled == false)
            {
                MPHostClient->BoundIP = MPHPOwnIPEditBox->Text;
                MPHostClient->BoundPort = (unsigned short)MPHPOwnPortEditBox->Text.ToInt();
                MPHPLoadCouplingFileButton->Enabled = true;
                MPHPGeneralLabel->Caption = "Load coupling file";
            }
        }
        else
        {
            for(int x = 1; x <= MPHPOwnIPEditBox->Text.Length(); x++)
            {
                if((MPHPOwnIPEditBox->Text[x] != '.') && ((MPHPOwnIPEditBox->Text[x] < '0') || (MPHPOwnIPEditBox->Text[x] > '9')))
                {
                    ShowMessage("Format should be 'a.b.c.d' where a, b, c, and d are numbers between 0 and 255.\n\nObtain the address from the host and enter exactly as given.");
                    MPHPOwnIPEditBox->Text = "";
                    Utilities->CallLogPop(2352);
                    return;
                }
            }
        }
        Utilities->CallLogPop(2353);
    }
    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MPHPOwnIPEditBoxKeyUp " + e.Message); //<--temporary
        Utilities->CallLogPop(2411);
    }
    catch(const Exception &e)
    {
        ErrorLog(228, e.Message);
    }
}
//---------------------------------------------------------------------------

void __fastcall TInterface::MPHPOwnPortEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)

{
    try
    {
        TrainController->LogEvent("MPHPOwnPortEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPHPOwnPortEditBoxKeyUp," + AnsiString(Key));
        if(Key == '\x0D') //CR
        {
            if((MPHPOwnPortEditBox->Text == "") || (MPHPOwnPortEditBox->Text.Length() < 5) || (MPHPOwnPortEditBox->Text.ToInt() < 49152) || (MPHPOwnPortEditBox->Text.ToInt() > 59999))
            {
                ShowMessage("Entry should be a number between 49152 and 59999.");
                MPHPOwnPortEditBox->Text = "";
                Utilities->CallLogPop(2354);
                return;
            }
            MPHPOwnPortEditBox->Enabled = false;
            if(MPHPOwnIPEditBox->Enabled == false)
            {
                MPHostClient->BoundIP = MPHPOwnIPEditBox->Text;
                MPHostClient->BoundPort = (unsigned short)MPHPOwnPortEditBox->Text.ToInt();
                MPHPLoadCouplingFileButton->Enabled = true;
                MPHPGeneralLabel->Caption = "Load coupling file";
            }
        }
        else
        {
            for(int x = 1; x <= MPHPOwnPortEditBox->Text.Length(); x++)
            {
                if((MPHPOwnPortEditBox->Text[x] < '0') || (MPHPOwnPortEditBox->Text[x] > '9'))
                {
                    ShowMessage("Entry should be a number between 49152 and 59999.");
                    MPHPOwnPortEditBox->Text = "";
                    Utilities->CallLogPop(2355);
                    return;
                }
            }
        }
        Utilities->CallLogPop(2356);
    }
    catch(const EIdException &e) //non-error catch
    {
        ShowMessage("MPHPOwnPortEditBoxKeyUp " + e.Message); // <--temporary
        Utilities->CallLogPop(2412);
    }
    catch(const Exception &e)
    {
        ErrorLog(229, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::IPCheckLinkLabelLinkClick(TObject *Sender, const UnicodeString Link,
          TSysLinkType LinkType)
{
    if(LinkType == sltURL)
    {
        ::ShellExecute(Handle, NULL, Link.c_str(), NULL, NULL, SW_SHOWNORMAL);
    }
}

//---------------------------------------------------------------------------

bool TInterface::TAnsiCouplingMapComp:: operator()(const TAnsiCouplingPair& lower, const TAnsiCouplingPair& higher) const
{
    if(lower.first < higher.first)  //RailwayName
    {
        return(true);
    }
    else if(lower.first > higher.first)
    {
        return(false);
    }
    else if(lower.second.first < higher.second.first) //railway names same, lower H < higher H
    {
        return(true);
    }
    else if(lower.second.first > higher.second.first) //railway names same, lower H > Higher H
    {
        return(false);
    }
    else if(lower.second.second < higher.second.second) //railway names same, H values same, lower V < higher V
    {
        return(true);
    }
    else return(false); //railway names same, H values same, lower V > higher V or both V values same
                        //both H & V values shouldn't be same for same railway but if for some reason they are then
                        //the map will reject one of them as both comp(a, b) and comp(b, a) are false
}

// ---------------------------------------------------------------------------

bool TInterface::TDynamicMapComp:: operator()(const TNumHVPair& lower, const TNumHVPair& higher) const
{
    if(lower.first < higher.first) //compare numbers
    {
        return(true);
    }
    else if(lower.first > higher.first)
    {
        return(false);
    }
    else if(lower.second.first < higher.second.first) //number values same (same railway/user), compare H values
    {
        return(true);
    }
    else if(lower.second.first > higher.second.first)
    {
        return(false);
    }
    else if(lower.second.second < higher.second.second) //number & H values same, compare V values
    {
        return(true);
    }
    else if(lower.second.second > higher.second.second)
    {
        return(false);
    }
    else return(false); //number + H & V values same, shouldn't be same for same railway but if for some reason they are then
                        //the map will reject one of them as both comp(a, b) and comp(b, a) are false
}

// ---------------------------------------------------------------------------

bool TInterface::PopulateCouplingMap(AnsiString FileName, int &NumExt)
// read file CouplingMap.csv (in same directory as railway.exe) and build AnsiCouplingMap (based on railway name), AllRailwaysCouplingMap (based on
//RlyUserNumber) & HostCombinedDynamicMap.  The maps have two sets of couplings so each railway/HVpair is a key
{
    TrainController->LogEvent("PopulateCouplingMap");
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PopulateCouplingMap,FileName," + FileName); //no caller as only called once
    AnsiString RailwayName1 = "", RailwayName2 = "", OneLine = "", ExitID1 = "", ExitID2 = "";
    int HLoc1, HLoc2, VLoc1, VLoc2, CPos, NumRailways;
    TAnsiCouplingPair AnsiCouplingPair1, AnsiCouplingPair2;
    TAnsiCouplingMapEntry AnsiCouplingMapEntry;
    AnsiCouplingMap.clear();
    THVShortPair HVExitPair1, HVExitPair2;
    std::ifstream TxtFile(FileName.c_str()); //railway1, HLoc, VLoc, railway2, HLoc, VLoc CRLF repeated
    AnsiString SyntaxError = "Coupling file error - structure should consist of lines of 'R1; exit1ID; R2; exit2ID' and so on "
                        "for all coupled exits, where R1 and R2 are railway names without the '.rly' extension, exit1ID is an "
                        "exit ID in R1, and exit2ID is an exit ID in R2";
    if(TxtFile.fail())
    {
        ShowMessage("Can't find the coupling file.  Please make sure it's located in the directory selected and has a .txt extension");
        Utilities->CallLogPop(2325);
        return(false);
    }
    while(!TxtFile.eof())
    {
        if(!Utilities->ReadOneLineFromCouplingFile(TxtFile, OneLine))
        {
            ShowMessage(SyntaxError);
            TxtFile.close();
            Utilities->CallLogPop(2326);
            return(false);
        }
        if(TxtFile.eof() && (OneLine == ""))
        {
            break;
        }
        if(OneLine.AnsiPos(',') != 0)
        {
            ShowMessage(SyntaxError);
            TxtFile.close();
            Utilities->CallLogPop(2327);
            return(false);
        }
        TrainController->StripSpaces(6, OneLine);
    // strip both leading and trailing spaces at ends of line and spaces before and after all commas (and semicolons) within the line
        if(OneLine != "")
        {
            int DelimPos = OneLine.Pos(';');
            if(DelimPos < 2) //0 = can't find, 1 = first character is a comma - both errors
            {
                ShowMessage(SyntaxError);
                TxtFile.close();
                Utilities->CallLogPop(2328);
                return(false);
            }
            else
            {
                RailwayName1 = OneLine.SubString(1, (DelimPos - 1));
                OneLine = OneLine.SubString(DelimPos + 1, OneLine.Length() - DelimPos);  //OneLine is now the remainder
                if(RailwayName1.LowerCase().SubString(RailwayName1.Length() - 3, 4) == ".rly")
                {
                    RailwayName1 = RailwayName1.SubString(1, RailwayName1.Length() - 4); //ignore .rly if present
                }
            }
            DelimPos = OneLine.Pos(';');
            if(DelimPos < 2) //0 = can't find, 1 = first character is a comma - both errors
            {
                ShowMessage(SyntaxError);
                TxtFile.close();
                Utilities->CallLogPop(2329);
                return(false);
            }
            else
            {
                ExitID1 = OneLine.SubString(1, (DelimPos - 1));
                OneLine = OneLine.SubString(DelimPos + 1, OneLine.Length() - DelimPos); //OneLine is now the remainder
                if(!ConvertIDToPair(ExitID1, HVExitPair1))
                {
                    TxtFile.close();
                    Utilities->CallLogPop(2330);
                    return(false);
                }
            }
            DelimPos = OneLine.Pos(';');
            if(DelimPos < 2) //0 = can't find, 1 = first character is a comma - both errors
            {
                ShowMessage(SyntaxError);
                TxtFile.close();
                Utilities->CallLogPop(2331);
                return(false);
            }
            else
            {
                RailwayName2 = OneLine.SubString(1, (DelimPos - 1));
                OneLine = OneLine.SubString(DelimPos + 1, OneLine.Length() - DelimPos); //OneLine is now the remainder
                if(RailwayName2.LowerCase().SubString(RailwayName2.Length() - 3, 4) == ".rly")
                {
                    RailwayName2 = RailwayName2.SubString(1, RailwayName2.Length() - 4); //ignore .rly if present
                }
            }
            if(OneLine == "") //should now only contain Exit2ID
            {
                ShowMessage(SyntaxError);
                TxtFile.close();
                Utilities->CallLogPop(2332);
                return(false);
            }
            else
            {
                ExitID2 = OneLine;
                if(!ConvertIDToPair(ExitID2, HVExitPair2))
                {
                    TxtFile.close();
                    Utilities->CallLogPop(2333);
                    return(false);
                }
            }
            AnsiCouplingPair1.first = RailwayName1;
            AnsiCouplingPair1.second = HVExitPair1;
            AnsiCouplingPair2.first = RailwayName2;
            AnsiCouplingPair2.second = HVExitPair2;
            AnsiCouplingMapEntry.first = AnsiCouplingPair1;
            AnsiCouplingMapEntry.second = AnsiCouplingPair2;
            AnsiCouplingMap.insert(AnsiCouplingMapEntry);
            AnsiCouplingMapEntry.first = AnsiCouplingPair2;  //add entry for reversed pairs
            AnsiCouplingMapEntry.second = AnsiCouplingPair1;
            AnsiCouplingMap.insert(AnsiCouplingMapEntry);
            RailwayList.push_back(RailwayName1);
            RailwayList.push_back(RailwayName2);
        }
        else
        {
            continue; //ignore blank lines
        }
    }
    TxtFile.close();
    RailwayList.sort();
    RailwayList.unique(); //remove duplicates
    NumPlayers = RailwayList.size();
//now convert to number based coupling map
    AllRailwaysCouplingMap.clear();
    TNumHVPair NumHVPair1, NumHVPair2;
    for(TAnsiCouplingMap::iterator ACMIt = AnsiCouplingMap.begin(); ACMIt != AnsiCouplingMap.end(); ACMIt++)
    {
        int ListCounter = 1; //RlyUserNumbers start at 1
        for(RLIt = RailwayList.begin(); RLIt != RailwayList.end(); RLIt++)
        {
            if(ACMIt->first.first == *RLIt)
            {
                NumHVPair1.first = ListCounter;
                NumHVPair1.second = ACMIt->first.second;
                break;
            }
            ListCounter++;
        }
        ListCounter = 1;
        for(RLIt = RailwayList.begin(); RLIt != RailwayList.end(); RLIt++)
        {
            if(ACMIt->second.first == *RLIt)
            {
                NumHVPair2.first = ListCounter;
                NumHVPair2.second = ACMIt->second.second;
                break;
            }
            ListCounter++;
        }
        AllRailwaysCouplingPair.first = NumHVPair1;
        AllRailwaysCouplingPair.second = NumHVPair2;
        AllRailwaysCouplingMap.insert(AllRailwaysCouplingPair);  //includes reversed couplings
    }
//now build the HostCombinedDynamicMap without any service info
    HostCombinedDynamicMap.clear();
    TDynamicMapEntry DMEntry;
    TServiceInfo ServiceInfo; //default values
    for(TCMIterator CMIt = AllRailwaysCouplingMap.begin(); CMIt != AllRailwaysCouplingMap.end(); CMIt++)
    {
        DMEntry.first = CMIt->first;
        DMEntry.second = ServiceInfo;
        HostCombinedDynamicMap.insert(DMEntry);                  //includes reversed couplings
    }
    ShowMessage("File loaded successfully");
    Utilities->CallLogPop(2334);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::ConvertIDToPair(AnsiString HVID, THVShortPair &HVPair) //true for ok
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ConvertIDToPair," + HVID); //no caller as only called twice & HVID identifies
    AnsiString HString = "", VString = "";
    if(HVID == "") //should be covered in calling function but include anyway
    {
        ShowMessage("Coupling file error - an exit ID is missing from the file");
        Utilities->CallLogPop(2335);
        return(false);
    }
    for(int x = 1; x <= HVID.Length(); x++)
    {
        char C = HVID[x];
        if(((C < '0') || (C > '9')) && (C != 'N') && (C != '-'))
        {
            ShowMessage("Coupling file error - an exit ID contains illegal characters, can only include digits, '-' or 'N'");
            Utilities->CallLogPop(2336);
            return(false);
        }
    }
    int DashPos = HVID.Pos('-');
    if(DashPos == 0)
    {
        ShowMessage("Coupling file error - structure should consist of lines of 'R1, exit1 ID, R2, corresponding exit ID' and so on "
                            "for all coupled exits, where R1 and R2 are railway names without the '.rly' extension");
        Utilities->CallLogPop(2337);
        return(false);
    }
    else
    {
        HString = HVID.SubString(1, DashPos - 1);
        VString = HVID.SubString(DashPos + 1, HVID.Length() - DashPos);
        if(HString[1] == 'N')
        {
            HString = HString.SubString(2, HString.Length() - 1);
            HVPair.first = -HString.ToInt();
        }
        else
        {
            HVPair.first = HString.ToInt();
        }
        if(VString[1] == 'N')
        {
            VString = VString.SubString(2, VString.Length() - 1);
            HVPair.second = -VString.ToInt();
        }
        else
        {
            HVPair.second = VString.ToInt();
        }
    }
    Utilities->CallLogPop(2338);
    return(true);
}

// ---------------------------------------------------------------------------

bool TInterface::MultiplayerRailwayValid(AnsiString RailwayName, char &ErrorNumber)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "MultiplayerRailwayValid");
    ErrorNumber = 0; //no error
    bool Listed = false, Available = false, RetType = false;
    for(int x = 2; x < NumPlayers + 2; x++)
    {
        if(RailwayName == MultiplayerHostStringGrid->Cells[1][x])
        {
            Listed = true;
            if(MultiplayerHostStringGrid->Cells[0][x] == "")
            {
                Available = true;
            }
            break;
        }
    }
    if(!Listed)
    {
        ErrorNumber = 1;
    }
    else if(!Available)
    {
        ErrorNumber = 2;
    }
    else
    {
        RetType = true;
    }
    Utilities->CallLogPop(2357);
    return(RetType);
}

//---------------------------------------------------------------------------

short TInterface::BuildOneRailwayCouplingMap(unsigned char PlayerNumber)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "BuildOneRailwayCouplingMap");
    OneRailwayCouplingMap.clear();
    TCouplingMap::iterator CMIt;
    short Count = 0;
    for(CMIt = AllRailwaysCouplingMap.begin(); CMIt != AllRailwaysCouplingMap.end(); CMIt++)
    {
        if(CMIt->first.first == PlayerNumber)
        {
            OneRailwayCouplingPair.first = CMIt->first; //own player number + H & V for own railway
            OneRailwayCouplingPair.second = CMIt->second; //other player number & coupled H&V
            OneRailwayCouplingMap.insert(OneRailwayCouplingPair);
            Count++;
        }
    }
    Utilities->CallLogPop(2378);
    return(Count * 10); //this is the number of bytes to be entered into a datagram (apart from marker & username if they are required)
}

//---------------------------------------------------------------------------

void TInterface::HostHandshakingActions()
{ //host read & respond new for multiplayer - every cycle
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",HostHandshakingActions");
        if(CouplingFileLoadedFlag)
        {
            EIdExceptionSource += " CouplingFileLoadedAwaitingPlayers";
            UnicodeString Data = "";
            UnicodeString PeerIP = "";
            unsigned short PeerPort = 0;
            unsigned char marker;
            bool Found1 = false, Found2 = false;
            AnsiString PlayerRailwayName, PlayerUserName;
            char ErrorNumber; //indicates type of error 0 = ok, 1 = not listed, 2 = already taken
            UnicodeString Message1 = "The railway doesn't appear in the coupled group - the host can advise which railways are valid";
            UnicodeString Message2 = "The railway has already been allocated - the host can advise which are still available";
            TBytes HostBuffer;
            HostBuffer.Length = 8192; //have to set long enough initially, will reduce later
            HostBuffer.Length = MPHostClient->ReceiveBuffer(HostBuffer, PeerIP, PeerPort, 10);
            //will be of form 'marker' then UserName ';' RailwayName (marker is '1' for first contact, '2' for ready to begin, no space or delimieter before railway name)
            MPHostClient->Active = false; //don't receive any messages until have dealt with this
            if(HostBuffer.Length != 0)
            {
                if(HostBuffer[0] == '1') //player first contact, no binary content
                {
                    //check validity
                    bool FoundFlag = false;
                    for(int x = 1; x < HostBuffer.Length; x++)
                    {
                        if((HostBuffer[x] == ';') && (x > 1) && (x < (HostBuffer.Length - 1))) // ';' present and not first ot last character
                        {
                            FoundFlag = true;
                            break;
                        }
                    }
                    if(!FoundFlag)
                    {
                        Utilities->CallLogPop(2387);   //skip this loop
                        return;
                    }
                    for(int x = 1; x < HostBuffer.Length; x++)
                    {
                        if((HostBuffer[x] < ' ') || (HostBuffer[x] > '~'))
                        {
                            MPHostClient->Active = true;
                            Utilities->CallLogPop(2371);   //skip this loop
                            return;
                        }
                    }
                    Data = BytesToString(HostBuffer);
                    int DelimPos = Data.Pos(';');
                    PlayerUserName = Data.SubString(2, DelimPos - 2);
                    PlayerRailwayName = Data.SubString(DelimPos + 1, Data.Length() - DelimPos);
                    unsigned char PlayerNumber;
                    if(!RlyToNum(PlayerRailwayName, PlayerNumber))
                    {
                        ShowMessage("Error in converting incoming information for player '" + PlayerUserName + "', ask player to cancel and join again");
                        RemovePlayerFromStringGridAndInfoVector(0, PlayerUserName);
                        MPHostClient->Active = true;
                        Utilities->CallLogPop(2372);   //skip this loop
                        return;
                    }
                    if(MultiplayerRailwayValid(PlayerRailwayName, ErrorNumber))
                    {
                    //host can accept or reject
                        UnicodeString RejectString = PlayerUserName + " is asking to join with railway " + PlayerRailwayName + ". OK to join?";
                        int button = Application->MessageBox(RejectString.c_str(), L"Request", MB_YESNO);
                        if(button == IDNO)
                        {
                            MPHostClient->SendBuffer(PeerIP, PeerPort, ToBytes("The host did not accept your request to join"));
                            MPHostClient->Active = false; //keep it false (send sets it to true)
                        }
                        else
                        {
                        //find correct slot in MultiplayerHostStringGrid & InfoVector & add username
                            for(int x = 0; x < NumPlayers; x++)
                            {
                                if(MultiplayerHostStringGrid->Cells[1][x + 2] == PlayerRailwayName)
                                {
                                    MultiplayerHostStringGrid->Cells[0][x + 2] = PlayerUserName;
                                    Found1 = true;
                                    break;
                                }
                            }
                            for(int x = 0; x < NumPlayers; x++)
                            {
                                if(InfoVector.at(x).RailwayName == PlayerRailwayName) //already have number
                                {
                                    InfoVector.at(x).UserName = PlayerUserName;
                                    InfoVector.at(x).UserIP = PeerIP;
                                    InfoVector.at(x).UserPort = PeerPort;
                                    Found2 = true;
                                    break;
                                }
                            }
                            if(!Found1 || !Found2)
                            {
                                //error, should find both
                                ShowMessage("Error in initial contact information for player '" + PlayerUserName + "', ask player to cancel and join again");
                                RemovePlayerFromStringGridAndInfoVector(1, PlayerUserName);
                                MPHostClient->Active = true;
                                Utilities->CallLogPop(2373);   //skip this loop
                                return;
                            }
// now send OwnRlyUserNumber + shortHVs then coupled number + short HVs (10 bytes total per exit/entry), no separators
                            short NumBytes = BuildOneRailwayCouplingMap(PlayerNumber);
                            TCouplingMap::iterator CMIt = OneRailwayCouplingMap.begin();
                            TBytes HVbuffer;
                            HVbuffer.Length = NumBytes;
                            for(int x = 0; x < NumBytes; x += 10)
                            {
                                HVbuffer[x] = CMIt->first.first;  // = player's OwnRlyUserNumber
                                HVbuffer[x + 1] = CMIt->first.second.first & 0x00FF;    //H low then high
                                HVbuffer[x + 2] = (CMIt->first.second.first & 0xFF00) / 256;
                                HVbuffer[x + 3] = CMIt->first.second.second & 0x00FF;    //V low then high
                                HVbuffer[x + 4] = (CMIt->first.second.second & 0xFF00) / 256;

                                HVbuffer[x + 5] = CMIt->second.first; //coupled railway usernumber
                                HVbuffer[x + 6] = CMIt->second.second.first & 0x00FF;    //H low then high
                                HVbuffer[x + 7] = (CMIt->second.second.first & 0xFF00) / 256;
                                HVbuffer[x + 8] = CMIt->second.second.second & 0x00FF;    //V low then high
                                HVbuffer[x + 9] = (CMIt->second.second.second & 0xFF00) / 256;
                                CMIt++;
                            }
                            MPHostClient->SendBuffer(PeerIP, PeerPort, HVbuffer);
                            MPHostClient->Active = false; //keep it false
                        }
                    }
                    else
                    {
                        //send message that not listed (1) or already taken (2) - cancel panel and load a valid railway (ask host which ok)
                        //send it outside the data receipt as data won't keep being sent from player
                        if(ErrorNumber == 1)
                        {
                            MPHostClient->SendBuffer(PeerIP, PeerPort, ToBytes(Message1));
                        }
                        else if(ErrorNumber == 2)
                        {
                            MPHostClient->SendBuffer(PeerIP, PeerPort, ToBytes(Message2));
                        }
                        MPHostClient->Active = false; //keep it false (send sets it to true)
                    }
                }
                else if(HostBuffer[0] == '2') //player second contact, marker = 2, username, then DynMapToHost in buffer form
                {
                    TDynamicMap::iterator DMIt, HMIt;
                    if(BuildDynamicMapFromPlayerDatagram(0, DynMapToHost, HostBuffer, marker, PlayerUserName)) //this performs validity checks
                    {
//                  update HostCombinedDynamicMap. Won't alter anything here as no service information, but acts as a check that can find all elements
                        for(DMIt = DynMapToHost.begin(); DMIt != DynMapToHost.end(); DMIt++) //unlikely to be in alphabetical order
                        {
                            HMIt = HostCombinedDynamicMap.find(DMIt->first); //should always find it
                            if(HMIt != HostCombinedDynamicMap.end())
                            {
                                HMIt->second = DMIt->second;
                            }
                            else
                            {
                                ShowMessage("Failed to locate player information in host database for player '" + PlayerUserName + "', ask player to cancel and join again");
                                RemovePlayerFromStringGridAndInfoVector(2, PlayerUserName);
                                Utilities->CallLogPop(2374);   //skip this loop
                                return;
                            }
                        }
                    }
                    else
                    {
                        Utilities->CallLogPop(2375);   //skip this loop
                        return;
                    }
                //update StringGrid & InfoVector
                    Found1 = false;
                    Found2 = false;
                    for(int x = 0; x < NumPlayers; x++)
                    {
                        if(MultiplayerHostStringGrid->Cells[0][x + 2] == PlayerUserName)
                        {
                            MultiplayerHostStringGrid->Cells[2][x + 2] = "Yes";
                            Found1 = true;
                        }
                    }
                    for(int x = 0; x < NumPlayers; x++)
                    {
                        if(InfoVector.at(x).UserName == PlayerUserName) //already have number
                        {
                            InfoVector.at(x).UserIP = PeerIP;
                            InfoVector.at(x).UserPort = PeerPort;
                            Found2 = true;
                        }
                    }
                    if(!Found1 || !Found2)
                    {
                        //error, should find both
                        ShowMessage("Error in 'ready to begin' contact information for player '" + PlayerUserName + "', ask player to cancel and join again");
                        RemovePlayerFromStringGridAndInfoVector(3, PlayerUserName);
                        Utilities->CallLogPop(2388);   //skip this loop
                        return;
                    }
//                  now send return message to player
                    TBytes HVbuffer;
                    HVbuffer.Length = 22;
                    UnicodeString Message = "Await simulation start";
                    HVbuffer = ToBytes(Message);
                    MPHostClient->SendBuffer(PeerIP, PeerPort, HVbuffer);
                    MPHostClient->Active = false; //keep it false (send sets it to true)
//check if all players ready to start, and if so enable the 'start session' button
                    bool AllReady = true;
                    for(int x = 0; x < NumPlayers; x++)
                    {
                        if(MultiplayerHostStringGrid->Cells[2][x + 2] != UnicodeString("Yes"))
                        {
                            AllReady = false;
                        }
                    }
                    if(AllReady)
                    {
                        MPHPStartButton->Enabled = true;
                    }
                }
                else if(HostBuffer[0] == '3') //player clicked cancel button
                {
                    for(int x = 1; x < HostBuffer.Length; x++) //validity check
                    {
                        if((HostBuffer[x] < ' ') || (HostBuffer[x] > '~'))
                        {
                            Utilities->CallLogPop(2392);   //skip this loop
                            return;
                        }
                    }
                    Data = BytesToString(HostBuffer); //message is '3' then username and nothing else
                    PlayerUserName = Data.SubString(2, Data.Length() - 1);
                    TBytes HVbuffer;
                    HVbuffer.Length = 9;
                    UnicodeString Message = "Cancelled";
                    HVbuffer = ToBytes(Message);
                    MPHostClient->SendBuffer(PeerIP, PeerPort, HVbuffer); //send response each time received but only show message etc. once
                    MPHostClient->Active = false; //keep it false (send sets it to true)
                    unsigned char RlyUserNumber;
                    if(!UserToNum(PlayerUserName, RlyUserNumber)) //use this to check if already removed from vector
                    {
                        Utilities->CallLogPop(2391); //already removed from infovector so go no further
                        return;
                    }
                    else
                    {
                        ShowMessage("Player '" + PlayerUserName + "', has cancelled the join request");
                        RemovePlayerFromStringGridAndInfoVector(4, PlayerUserName);
                        Utilities->CallLogPop(2389);
                        return;
                    }
                }
                else if(HostBuffer[0] == '4') //player awaiting start
                {
                    if(HostInSessionFlag)
                    {
                        for(int x = 1; x < HostBuffer.Length; x++) //validity check
                        {
                            if((HostBuffer[x] < ' ') || (HostBuffer[x] > '~'))
                            {
                                Utilities->CallLogPop(2393);   //skip this loop
                                return;
                            }
                        }
                        Data = BytesToString(HostBuffer); //message is '3' then username and nothing else
                        PlayerUserName = Data.SubString(2, Data.Length() - 1);
                        TBytes HVbuffer;
                        HVbuffer.Length = 13;
                        UnicodeString Message = "Start Session";
                        HVbuffer = ToBytes(Message);
                        MPHostClient->SendBuffer(PeerIP, PeerPort, HVbuffer); //send response each time received, eventually all players will start
                                                                              //when players are in session they just message every 5 secs & get TTClock in response
                        MPHostClient->Active = false; //keep it false (send sets it to true)
                    }
                    //else ignore
                }
                else if(HostBuffer[0] == '5') //in session
                {
                    TDynamicMap::iterator DMIt, HMIt;
                    if(BuildDynamicMapFromPlayerDatagram(1, DynMapToHost, HostBuffer, marker, PlayerUserName)) //this performs validity checks
                    {
//                  update HostCombinedDynamicMap
                        for(DMIt = DynMapToHost.begin(); DMIt != DynMapToHost.end(); DMIt++) //unlikely to be in alphabetical order
                        {
                            HMIt = HostCombinedDynamicMap.find(DMIt->first); //should always find it
                            if(HMIt != HostCombinedDynamicMap.end())         //if not skip
                            {
                                HMIt->second = DMIt->second;
                            }
                        }
                    }
                    //construct DynMapFromHost & send as buffer along with TTClockTime, then at player end receive it and update TTClock etc
                    unsigned char RlyUserNumber;
                    if(!UserToNum(PlayerUserName, RlyUserNumber)) //get number from InfoVector
                    {
                        Utilities->CallLogPop(2395);   //skip this loop
                        return;
                    }
                    DynMapFromHost.clear();
                    bool LoadingFlag = false;
                    HMIt = HostCombinedDynamicMap.begin();
                    while(HMIt != HostCombinedDynamicMap.end())
                    {
                        if(HMIt->first.first == RlyUserNumber)
                        {
                            DynMapFromHost.insert(*HMIt);
                            LoadingFlag = true;
                        }
                        if(LoadingFlag && (HMIt->first.first != RlyUserNumber))
                        {
                            break; //no point looking after last insert
                        }
                        HMIt++;
                    }
                    TBytes HVbuffer;
                    HVbuffer.Length = 8192;
                    BuildDatagramFromHostMap(0, HVbuffer, DynMapFromHost);  //length set at end of this function, this includes TTClockTime as 32 bit integer
                    MPHostClient->SendBuffer(PeerIP, PeerPort, HVbuffer);
                    MPHostClient->Active = false; //keep it false (send sets it to true)
                }

                //if hostbuffer[0] outside accepted range ignore
            }
            else
            {
                //nothing to read or error in datagram format - if error ignore & read next time it's sent
            }
        }
    MPHostClient->Active = true;
    Utilities->CallLogPop(2415);
    }
    catch(const EIdException &e) //non-error catch
//if no response from peer then get a 'connection reset by peer' message which isn't valid
    {
        Utilities->CallLogPop(2414);
    }
    catch(const Exception &e)
    {
        ErrorLog(239, e.Message);
    }
}

//---------------------------------------------------------------------------
//player functions
//---------------------------------------------------------------------------


void __fastcall TInterface::JoinMultiplayerSessionMenuItemClick(TObject *Sender) //player first action
{
    try
    {
        TrainController->LogEvent("JoinMultiplayerSessionMenuItemClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",JoinMultiplayerSessionMenuItemClick");
        MultiplayerPlayerPanel->Visible = true;
        MultiplayerPlayerPanel->Left = MainScreen->Left + (MainScreen->Width / 2) - (MultiplayerPlayerPanel->Width / 2);
        MultiplayerPlayerPanel->Top = MainScreen->Top + 100;
        MPPlayerClient->Active = false;
        MPCPLabel2->Caption = "Complete the boxes and press 'Enter' for each.";  //top box
        MPCPLabel4->Caption = "Joining request not yet sent";  //opp image
        MPCPLabel7->Caption = "Only click 'Send' when the host is ready - the host will"; //lower box top
        MPCPLabel8->Caption = "advise by communicating outside the game.";                //lower box bottom
        MPCPLabel5->Caption = "Host IP address (obtain from host)";
        MPCPLabel6->Caption = "Host port number (obtain from host)";
        MPCPLabel3->Caption = "Player name (2 to 4 characters)";

        MultiplayerHostSessionMenuItem->Enabled = false;
        SaveMultiplayerSessionMenuItem->Enabled = false;
        EndSimulationMenuItem->Enabled = false;
        ShowHideStringGridMenuItem->Enabled = false;
        JoinMultiplayerSessionMenuItem->Enabled = false;
        ExitSimulationMenuItem->Enabled = false;
        HostInSessionFlag = false;
        CouplingFileLoadedFlag = false;
        PlayerMakingInitialContactFlag = false;
        PlayerReadyToBeginFlag = false;
        PlayerCancelJoinFlag = false;
        PlayerAwaitingHostStartFlag = false;
        PlayerInSessionFlag = false;

        MPCPHostIPEditBox->Visible = true;
        MPCPHostPortEditBox->Visible = true;
        MPCPPlayerNameEditBox->Visible = true;
        MPCPHostImage->Visible = true;
        MPCPHostImage->Picture->Assign(RailGraphics->SolidCircleRed);
        MPCPSendButton->Enabled = false;
        MPCPReadyToBeginButton->Enabled = false;
        MPCPPlayerNameEditBox->Enabled = true;
        MPCPHostPortEditBox->Enabled = true;
        MPCPHostIPEditBox->Enabled = true;
        MPCPPlayerNameEditBox->Text = "AB"; //  <--temporary - change to "" for release
        MPCPHostPortEditBox->Text = "50000";//  <--temporary - change to "" for release
        MPCPHostIPEditBox->Text = "127.0.0.1";//  <--temporary - change to "" for release
        Utilities->CallLogPop(2358);
    }

    catch(const Exception &e)
    {
        ErrorLog(230, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPSendButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MPCPSendButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPSendButtonClick");
        MPCPLabel2->Caption = "Await host response then click 'Ready to begin'";
        MPCPLabel4->Caption = "Awaiting host response";
        MPCPLabel7->Caption = "";
        MPCPLabel8->Caption = "";
        MPCPHostImage->Picture->Assign(RailGraphics->SolidCircleYellow);
        MPCPSendButton->Enabled = false;
        PlayerMakingInitialContactFlag = true;
        P5SCounter = 0; //temporary


//send message every 10 seconds and listen for response
//when response received give 'received message', give greem light, and 'click ready to bein' message


        Utilities->CallLogPop(2359);
    }

    catch(const Exception &e)
    {
        ErrorLog(231, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPCancelButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MPCPCancelButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPCancelButtonClick");
        MPCPSendButton->Enabled = false;
        MPCPReadyToBeginButton->Enabled = false;
        MPCPPlayerNameEditBox->Text = "";
        MPCPHostPortEditBox->Text = "";
        MPCPHostIPEditBox->Text = "";
        MultiplayerPlayerPanel->Visible = false;
        PlayerMakingInitialContactFlag = false;
        PlayerReadyToBeginFlag = false;
        PlayerAwaitingHostStartFlag = false;
        PlayerInSessionFlag = false;
        PlayerCancelJoinFlag = true;
        Track->MultiplayerOverlayMap.clear();
        ClearandRebuildRailway(90);
        Utilities->CallLogPop(2341);
    }

    catch(const Exception &e)
    {
        ErrorLog(236, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPReadyToBeginButtonClick(TObject *Sender)
{
    try
    {
        TrainController->LogEvent("MPCPReadyToBeginButtonClick");
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPReadyToBeginButtonClick");
        int button = Application->MessageBox(L"This will transfer all timer controls to the host.\n\n  Click 'Yes' to wait for the host to start the simulation.\n\nOK to proceed?", L"Warning!", MB_YESNO | MB_ICONWARNING);
        if(button == IDNO)
        {
            Utilities->CallLogPop(2339);
            return;
        }
//transfer control etc
        PlayerReadyToBeginFlag = true;
//allow certain buttons but not timer controls
        CallingOnButton->Enabled = true;
        PresetAutoSigRoutesButton->Enabled = true;
        AutoSigsButton->Enabled = true;
        SigPrefConsecButton->Enabled = true;
        SigPrefNonConsecButton->Enabled = true;
        UnrestrictedButton->Enabled = true;
        RouteCancelButton->Enabled = true;
        PerformanceLogButton->Enabled = true;
        OperatorActionButton->Enabled = true;
        ExitOperationButton->Enabled = true;
        OperateButton->Enabled = false;
        SaveSessionButton->Enabled = false;
        TTClockAdjButton->Enabled = false;

    //await host acknowledgement
        Utilities->CallLogPop(2340);
    }
    catch(const Exception &e)
    {
        ErrorLog(232, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPHostIPEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("MPCPIPEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPIPEditBoxKeyUp," + AnsiString(Key));
        if(Key == '\x0D') //CR
        {
            if(InvalidIPAddress(MPCPHostIPEditBox->Text))
            {
                ShowMessage("Format should be 'a.b.c.d' where a, b, c, and d are numbers between 0 and 255.\n\nObtain the address from the host and enter exactly as given.");
                MPCPHostIPEditBox->Text = "";
                Utilities->CallLogPop(2360);
                return;
            }
            else
            {
                MPCPHostIPEditBox->Enabled = false;
                if((MPCPHostPortEditBox->Enabled == false) && (MPCPPlayerNameEditBox->Enabled == false))
                {
                    MPPlayerClient->Host = MPCPHostIPEditBox->Text;
                    MPPlayerClient->Port = MPCPHostPortEditBox->Text.ToInt();
                    MPCPSendButton->Enabled = true;
                }
            }
        }
        else
        {
            for(int x = 1; x <= MPCPHostIPEditBox->Text.Length(); x++)
            {
                if((MPCPHostIPEditBox->Text[x] != '.') && ((MPCPHostIPEditBox->Text[x] < '0') || (MPCPHostIPEditBox->Text[x] > '9')))
                {
                    ShowMessage("Format should be 'a.b.c.d' where a, b, c, and d are numbers between 0 and 255.\n\nObtain the address from the host and enter exactly as given.");
                    MPCPHostIPEditBox->Text = "";
                    Utilities->CallLogPop(2361);
                    return;
                }
            }
        }
        Utilities->CallLogPop(2362);
    }
    catch(const Exception &e)
    {
        ErrorLog(233, e.Message);
    }
}

//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPHostPortEditBoxKeyUp(TObject *Sender, WORD &Key,
          TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("MPCPHostPortEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPHostPortEditBoxKeyUp," + AnsiString(Key));
        if(Key == '\x0D') //CR
        {
            if((MPCPHostPortEditBox->Text == "") || (MPCPHostPortEditBox->Text.Length() < 5) || (MPCPHostPortEditBox->Text.ToInt() < 49152) || (MPCPHostPortEditBox->Text.ToInt() > 59999))
            {
                ShowMessage("Entry should be a number between 49152 and 59999.\n\nObtain the port number from the host and enter exactly as given.");
                MPCPHostPortEditBox->Text = "";
                Utilities->CallLogPop(2363);
                return;
            }
            MPCPHostPortEditBox->Enabled = false;
            if((MPCPHostIPEditBox->Enabled == false) && (MPCPPlayerNameEditBox->Enabled == false))
            {
                    MPPlayerClient->Host = MPCPHostIPEditBox->Text;
                    MPPlayerClient->Port = MPCPHostPortEditBox->Text.ToInt();
                    MPCPSendButton->Enabled = true;
            }
        }
        else
        {
            for(int x = 1; x <= MPCPHostPortEditBox->Text.Length(); x++)
            {
                if((MPCPHostPortEditBox->Text[x] < '0') || (MPCPHostPortEditBox->Text[x] > '9'))
                {
                    ShowMessage("Entry should be a number between 49152 and 59999.\n\nObtain the port number from the host and enter exactly as given.");
                    MPCPHostPortEditBox->Text = "";
                    Utilities->CallLogPop(2364);
                    return;
                }
            }
        }
        Utilities->CallLogPop(2365);
    }
    catch(const Exception &e)
    {
        ErrorLog(234, e.Message);
    }
}
//---------------------------------------------------------------------------

void __fastcall TInterface::MPCPPlayerNameEditBoxKeyUp(TObject *Sender, WORD &Key, TShiftState Shift)
{
    try
    {
        TrainController->LogEvent("MPCPPlayerNameEditBoxKeyUp," + AnsiString(Key));
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",MPCPPlayerNameEditBoxKeyUp," + AnsiString(Key));
        MPCPLabel3->Caption = "Player name (2 to 4 characters)";
        if(MPCPPlayerNameEditBox->Text.Length() > 0)
        {
            if(Key == '\x0D') //CR
            {
                if(MPCPPlayerNameEditBox->Text.Length() < 2)
                {
                    ShowMessage("Entry should have at least two and at most four characters with no numbers or special characters.");
                    MPCPPlayerNameEditBox->Text = "";
                    Utilities->CallLogPop(2366);
                    return;
                }
                else
                {
                    MPCPUserName = MPCPPlayerNameEditBox->Text;
                    MPCPPlayerNameEditBox->Enabled = false;
                    if((MPCPHostIPEditBox->Enabled == false) && (MPCPHostPortEditBox->Enabled == false))
                    {
                        MPPlayerClient->Host = MPCPHostIPEditBox->Text;
                        MPPlayerClient->Port = MPCPHostPortEditBox->Text.ToInt();
                        MPCPSendButton->Enabled = true;
                    }
                }
            }
            else
            {
                for(int x = 1; x <= MPCPPlayerNameEditBox->Text.Length(); x++)
                {
                    if((MPCPPlayerNameEditBox->Text[x] < 'A') || ((MPCPPlayerNameEditBox->Text[x] > 'Z') && (MPCPPlayerNameEditBox->Text[x] < 'a'))
                                                || (MPCPPlayerNameEditBox->Text[x] > 'z'))
                    {
                        ShowMessage("Entry should have at least two and at most four characters with no numbers or special characters.");
                        MPCPPlayerNameEditBox->Text = "";
                        Utilities->CallLogPop(2367);
                        return;
                    }
                }
            }
        }
        Utilities->CallLogPop(2368);
    }
    catch(const Exception &e)
    {
        ErrorLog(235, e.Message);
    }
}

//---------------------------------------------------------------------------

void TInterface::BuildDatagramFromPlayerMap(int Caller, char marker, AnsiString UserName, TBytes &buffer, TDynamicMap DynamicMap)
{ //datagram contents: marker + username  + ;(if < 4 chars) + multiple[usernumber + H lower + H higher + V lower + V higher]
  // all but marker & username from DynamicMap
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildDatagramFromPlayerMap, " + AnsiString(marker) + ',' + UserName);
    int bufCounter;
    buffer.Length = 8192; //initial value, reduced later
    buffer[0] = marker;
    for(bufCounter = 1; bufCounter <= UserName.Length(); bufCounter++)
    {
        buffer[bufCounter] = UserName[bufCounter];
    }
    if(UserName.Length() < 4)
    {
        buffer[bufCounter] = ';'; //marker for end of username
        bufCounter++;
    }
//AnsiString DMIt->second.ServiceReference
//short DMIt->second.RepeatNumber
//short DMIt->second.TimeToExitSecs

    for(TDynamicMap::iterator DMIt = DynamicMap.begin(); DMIt != DynamicMap.end(); DMIt++)
    {
        buffer[bufCounter] = DMIt->first.first;  //number
        bufCounter++;
        buffer[bufCounter] = DMIt->first.second.first & 0x00FF;  //H lower
        bufCounter++;
        buffer[bufCounter] = (DMIt->first.second.first & 0xFF00) / 256; //H higher
        bufCounter++;
        buffer[bufCounter] = DMIt->first.second.second & 0x00FF;  //V lower
        bufCounter++;
        buffer[bufCounter] = (DMIt->first.second.second & 0xFF00) / 256;  //v higher
        bufCounter++;
        DMIt->second.ServiceReference = DMIt->second.ServiceReference.Trim();
        for(int x = 1; x <= DMIt->second.ServiceReference.Length(); x++)
        {
            buffer[bufCounter] = DMIt->second.ServiceReference[x];
            bufCounter++;
        }
        if(DMIt->second.ServiceReference.Length() < 8)
        {
            buffer[bufCounter] = ';'; //marker for end of service ref
            bufCounter++;
        }
        buffer[bufCounter] = DMIt->second.RepeatNumber & 0x00FF;
        bufCounter++;
        buffer[bufCounter] = (DMIt->second.RepeatNumber & 0xFF00) / 256;
        bufCounter++;
        buffer[bufCounter] = DMIt->second.TimeToExitSecs & 0x00FF;
        bufCounter++;
        buffer[bufCounter] = (DMIt->second.TimeToExitSecs & 0xFF00) / 256;
        bufCounter++;
/* add if need to limit buffer length
        if(bufCounter > 490) //last value is 507 as starts at 0 & 17 max bytes for each loop, allows 29 exits/entries
        {
            break;
        }
*/
    }
    buffer.Length = bufCounter; //bufCounter incremented value = length since starts at 0
    Utilities->CallLogPop(2379);
}

//---------------------------------------------------------------------------

bool TInterface::BuildDynamicMapFromPlayerDatagram(int Caller, TDynamicMap &DMap, TBytes Buffer, unsigned char &marker, AnsiString &UserName)
{//datagrams of this type (most) are of form marker (1 byte), username (up to 4 bytes), then a series of TNumHVPairs
//unlikely to be in alphabetical order, build map in same order as datagram
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildDynamicMapFromPlayerDatagram");
    TDynamicMapEntry DMEntry;
    TNumHVPair NumHVPair;
    int y = 5; //highest NumHVPair start position
    DMap.clear();
    marker = Buffer[0];
    UserName = "    ";
    for(int x = 1; x < 5; x++)
    {
        if((Buffer[x] < ' ') || (Buffer[x] > '~'))
        {
            DMap.clear();
            Utilities->CallLogPop(2380);
            return(false);
        }
        if(Buffer[x] == ';')
        {
            break;
        }
    }
    UserName[1] = Buffer[1]; //always at least 1 character
    UserName[2] = Buffer[2];
    if(UserName[2] == ';') //1 char only
    {
        UserName.Delete(2,3);
        y = 3;
    }
    else
    {
        UserName[3] = Buffer[3];
        if(UserName[3] == ';') //2 chars
        {
            UserName.Delete(3,2);
            y = 4;
        }
        else
        {
            UserName[4] = Buffer[4];
            if(UserName[4] == ';') //3 chars
            {
                UserName.Delete(4,1);
                y = 5;
            }
        }
    }
    while(y < (Buffer.Length - 9))  //9 allows for zero length service ref
    {
        TServiceInfo ServInfo; //ServiceReference + RepeatNumber + TimeToExitSecs (need new default values for each loop)
        NumHVPair.first = Buffer[y];    //number
        NumHVPair.second.first = Buffer[y+ 1] + (256 * Buffer[y + 2]); //H
        NumHVPair.second.second = Buffer[y + 3] + (256 * Buffer[y + 4]); //V
        if(!NumHVPairCheckOK(NumHVPair))
        {
            DMap.clear();
            Utilities->CallLogPop(2381);
            return(false);
        }
        y += 5;
        int z = 0;
        while((Buffer[y + z] != ';') && (z < 8))
        {
            ServInfo.ServiceReference[z + 1] = Buffer[y + z];
            z++;
        }
        ServInfo.ServiceReference = ServInfo.ServiceReference.Trim();
        y += ServInfo.ServiceReference.Length();
        if(Buffer[y] == ';')
        {
            y++; //skip past if there is one
        }
        ServInfo.RepeatNumber = Buffer[y] + (256 * Buffer[y + 1]);
        ServInfo.TimeToExitSecs = Buffer[y + 2] + (256 * Buffer[y + 3]);
        y += 4;
        if(!ServInfo.CheckOK() && ServInfo.ServiceReference != "")
        {
            DMap.clear();
            Utilities->CallLogPop(2382);
            return(false);
        }
        DMEntry.first = NumHVPair;
        DMEntry.second = ServInfo;
        DMap.insert(DMEntry);
    }
    Utilities->CallLogPop(2383);
    return(true);
}

//---------------------------------------------------------------------------

void TInterface::BuildDatagramFromHostMap(int Caller, TBytes &buffer, TDynamicMap DynamicMap)
{ //datagram contents: TTTime as 32 bit integer representing hundredths of a second + multiple[usernumber + H lower + H higher + V lower + V higher]
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildDatagramFromHostMap");
    int bufCounter = 0;
    buffer.Length = 8192; //initial value, reduced later
    unsigned int TTTime = double(TrainController->TTClockTime) * 8640000;
    buffer[0] = TTTime % 256;
    TTTime /= 256;
    buffer[1] = TTTime % 256;
    TTTime /= 256;
    buffer[2] = TTTime % 256;
    TTTime /= 256;
    buffer[3] = TTTime % 256;
    bufCounter += 4;
    for(TDynamicMap::iterator DMIt = DynamicMap.begin(); DMIt != DynamicMap.end(); DMIt++)
    {
        buffer[bufCounter] = DMIt->first.first;  //number
        bufCounter++;
        buffer[bufCounter] = DMIt->first.second.first & 0x00FF;  //H lower
        bufCounter++;
        buffer[bufCounter] = (DMIt->first.second.first & 0xFF00) / 256; //H higher
        bufCounter++;
        buffer[bufCounter] = DMIt->first.second.second & 0x00FF;  //V lower
        bufCounter++;
        buffer[bufCounter] = (DMIt->first.second.second & 0xFF00) / 256;  //v higher
        bufCounter++;
        DMIt->second.ServiceReference = DMIt->second.ServiceReference.Trim();
        for(int x = 1; x <= DMIt->second.ServiceReference.Length(); x++)
        {
            buffer[bufCounter] = DMIt->second.ServiceReference[x];
            bufCounter++;
        }
        if(DMIt->second.ServiceReference.Length() < 8)
        {
            buffer[bufCounter] = ';'; //marker for end of service ref
            bufCounter++;
        }
        buffer[bufCounter] = DMIt->second.RepeatNumber & 0x00FF;
        bufCounter++;
        buffer[bufCounter] = (DMIt->second.RepeatNumber & 0xFF00) / 256;
        bufCounter++;
        buffer[bufCounter] = DMIt->second.TimeToExitSecs & 0x00FF;
        bufCounter++;
        buffer[bufCounter] = (DMIt->second.TimeToExitSecs & 0xFF00) / 256;
        bufCounter++;
    }
    buffer.Length = bufCounter; //bufCounter incremented value = length since starts at 0
    Utilities->CallLogPop(2394);
}

//---------------------------------------------------------------------------

bool TInterface::BuildDynamicMapFromHostDatagram(int Caller, int TTTime, TDynamicMap &DMap, TBytes Buffer)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildDynamicMapFromHostDatagram");
    TDynamicMapEntry DMEntry;
    TNumHVPair NumHVPair;
    int y = 4; //NumHVPair start position
    DMap.clear();
    TTTime = Buffer[0] + (256 * Buffer[1]) + (65536 * Buffer[2]) + (16777216 * Buffer[3]);
    if((TTTime < 0) || (TTTime > 34560000)) //34560000 = hundredths of a second in 4 x 24 hrs
    {
        DMap.clear();
        Utilities->CallLogPop(2396);
        return(false);
    }
    while(y < (Buffer.Length - 9))  //9 allows for zero length service ref
    {
        TServiceInfo ServInfo; //ServiceReference + RepeatNumber + TimeToExitSecs (need new default values for each loop)
        NumHVPair.first = Buffer[y];    //number
        if(NumHVPair.first != OwnRlyUserNumber)
        {
            DMap.clear();
            Utilities->CallLogPop(2397);
            return(false);
        }
        NumHVPair.second.first = Buffer[y+ 1] + (256 * Buffer[y + 2]); //H
        NumHVPair.second.second = Buffer[y + 3] + (256 * Buffer[y + 4]); //V
        if(!NumHVPairCheckOK(NumHVPair))
        {
            DMap.clear();
            Utilities->CallLogPop(2398);
            return(false);
        }
        y += 5;
        int z = 0;
        while((Buffer[y + z] != ';') && (z < 8))
        {
            ServInfo.ServiceReference[z + 1] = Buffer[y + z];
            z++;
        }
        ServInfo.ServiceReference = ServInfo.ServiceReference.Trim();
        y += ServInfo.ServiceReference.Length();
        if(Buffer[y] == ';')
        {
            y++; //skip past if there is one
        }
        ServInfo.RepeatNumber = Buffer[y] + (256 * Buffer[y + 1]);
        ServInfo.TimeToExitSecs = Buffer[y + 2] + (256 * Buffer[y + 3]);
        y += 4;
        if(!ServInfo.CheckOK() && ServInfo.ServiceReference != "")
        {
            DMap.clear();
            Utilities->CallLogPop(2399);
            return(false);
        }
        DMEntry.first = NumHVPair;
        DMEntry.second = ServInfo;
        DMap.insert(DMEntry);
    }
    Utilities->CallLogPop(2400);
    return(true);
}

//---------------------------------------------------------------------------

void TInterface::BuildDummyTestMap(TDynamicMap &DMap, std::ifstream &ExitFile) //<--temporary function for testing purposes
{   //ExitFile is a list of H & V values as char[] integers with '\n' delimiters between each and between each pair
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",BuildDummyTestMap");
    TDynamicMapEntry DMapEntry;
    TServiceInfo ServiceInfo; //null & zero values on construction
    THVShortPair ShortPair;
    unsigned char UserNum;
    while(!ExitFile.eof())
    {
        ExitFile >> UserNum;   //number
        UserNum -= 48; //convert from character to ordinal
        if(ExitFile.eof()) //only get eof after an unsuccessful read attempt
        {
            continue;
        }
        ExitFile >> ShortPair.first;   //H
        if(ExitFile.eof()) //only get eof after an unsuccessful read attempt
        {
            continue;
        }
        ExitFile >> ShortPair.second;  //V
        if(ExitFile.eof())
        {
            continue;
        }
        DMapEntry.first.first = UserNum;
        DMapEntry.first.second = ShortPair;
        DMapEntry.second = ServiceInfo;
        DMap.insert(DMapEntry);
    }
    Utilities->CallLogPop(2384);
}

//---------------------------------------------------------------------------

void TInterface::UpdateDynamicMapFromTimeToExitMultiMap(int Caller, TDynamicMap &DMap)
{
//The player calls this prior to sending DynMapToHost, i.e. all the coupled linkages with railwaynumbers
//typedef std::pair<TNumHVPair, TServiceInfo> TDynamicMapEntry;
//typedef std::multimap<TNumHVPair, TExitInfo> TTimeToExitMultiMap;
    Utilities->CallLog.push_back(Utilities->TimeStamp() + "UpdateDynamicMapFromTimeToExitMultiMap");
    TDynamicMapEntry DMEntry;
    TDynamicMap::iterator DMIt;
    TNumHVPair NumHVPair;

    TTimeToExitMultiMap::iterator TTEMMIt = TrainController->TimeToExitMultiMap.begin();
    while(TTEMMIt != TrainController->TimeToExitMultiMap.end())
    {
        NumHVPair.first = OwnRlyUserNumber;
        NumHVPair.second = TTEMMIt->first;
        DMIt = DMap.find(NumHVPair);
        if(DMIt != DMap.end()) //else skip it, not included in coupling map
        {
            DMIt->second.ServiceReference = TTEMMIt->second.ServiceReference.Trim();
            DMIt->second.RepeatNumber = TTEMMIt->second.RepeatNumber;
            DMIt->second.TimeToExitSecs = TTEMMIt->second.TimeToExitSecs;
        }
        TTEMMIt++;
    }
    Utilities->CallLogPop(2385);
}

//---------------------------------------------------------------------------

bool TInterface::InvalidIPAddress(AnsiString Text)
{
    try
    {
        int Dot1 = 0, Dot2 = 0, Dot3 = 0;
        AnsiString Num1 = "",Num2 = "",Num3 = "",Num4 = "";
        if(Text.Length() < 7)
        {
            return true;
        }
        for(int x = 1; x <= Text.Length(); x++)
        {
            if(Text[x] == '.')
            {
                if(Dot1 == 0)
                {
                    Dot1 = x;
                }
                else if(Dot2 == 0)
                {
                    Dot2 = x;
                }
                else if(Dot3 == 0)
                {
                    Dot3 = x;
                }
            }
        }
        if((Dot1 ==0) || (Dot2 ==0) || (Dot3 ==0))
        {
            return true; //less than 3 dots
        }
        if(Text.Length() == Dot3)
        {
            return true; //last dot at end
        }
        Num1 = Text.SubString(1, Dot1 - 1);
        Num2 = Text.SubString(Dot1 + 1, Dot2 - Dot1 - 1);
        Num3 = Text.SubString(Dot2 + 1, Dot3 - Dot2 - 1);
        Num4 = Text.SubString(Dot3 + 1, Text.Length() - Dot3);
        if((Num1 == "") || (Num2 == "") || (Num3 == "") || (Num4 == ""))
        {
            return true; //any number string empty
        }
        if((Num1.ToInt() > 255) ||(Num2.ToInt() > 255) ||(Num3.ToInt() > 255) ||(Num4.ToInt() > 255)) //EConvertError thrown if not an integer
        {
            return true;
        }
        if((Num1.ToInt() < 0) ||(Num2.ToInt() < 0) ||(Num3.ToInt() < 0) ||(Num4.ToInt() < 0))
        {
            return true;
        }
        return false;
    }
    catch(const EConvertError &e) //non-integer should have been caught earlier but include for completeness
    {
        return true;
    }
}

//---------------------------------------------------------------------------

TInterface::TServiceInfo::TServiceInfo()   //default constructor , same as TExitInfo() in TrainUnit
{
    ServiceReference = "        ";
    RepeatNumber = 0;
    TimeToExitSecs = -1;
}

//---------------------------------------------------------------------------

TInterface::TRlyUserInfo::TRlyUserInfo()
{
    RlyUserNumber = 0; //allocated numbers start from 1
    RailwayName = "";
    UserName = "";
    UserIP = "";
    UserPort = 0;
}

//---------------------------------------------------------------------------

bool TInterface::RlyToNum(AnsiString RailwayName, unsigned char &RlyUserNumber)
{
    if(InfoVector.empty())
    {
        return(false);
    }
    TIVIt IVIt;
    for(IVIt = InfoVector.begin(); IVIt  != InfoVector.end(); IVIt++)
    {
        if(IVIt->RailwayName == RailwayName)
        {
            RlyUserNumber = IVIt->RlyUserNumber;
            return(true);
        }
    }
    return(false);
}

//---------------------------------------------------------------------------

bool TInterface::UserToNum(AnsiString UserName, unsigned char &RlyUserNumber)
{
    if(InfoVector.empty())
    {
        return(false);
    }
    TIVIt IVIt;
    for(IVIt = InfoVector.begin(); IVIt  != InfoVector.end(); IVIt++)
    {
        if(IVIt->UserName == UserName)
        {
            RlyUserNumber = IVIt->RlyUserNumber;
            return(true);
        }
    }
    return(false);
}

//---------------------------------------------------------------------------

bool TInterface::NumToRly(unsigned char RlyUserNumber, AnsiString &RailwayName)
{
    if(InfoVector.empty())
    {
        return(false);
    }
    TIVIt IVIt;
    for(IVIt = InfoVector.begin(); IVIt  != InfoVector.end(); IVIt++)
    {
        if(IVIt->RlyUserNumber == RlyUserNumber)
        {
            RailwayName = IVIt->RailwayName;
            return(true);
        }
    }
    return(false);
}

//---------------------------------------------------------------------------

bool TInterface::UserToIPAndPort(AnsiString UserName, AnsiString &UserIP, short UserPort)
{
    if(InfoVector.empty())
    {
        return(false);
    }
    TIVIt IVIt;
    for(IVIt = InfoVector.begin(); IVIt  != InfoVector.end(); IVIt++)
    {
        if(IVIt->UserName == UserName)
        {
            UserIP = IVIt->UserIP;
            UserPort = IVIt->UserPort;
            return(true);
        }
    }
    return(false);
}

//---------------------------------------------------------------------------

bool TInterface::NumToIPAndPort(unsigned char RlyUserNumber, AnsiString &UserIP, short UserPort)
{
    if(InfoVector.empty())
    {
        return(false);
    }
    TIVIt IVIt;
    for(IVIt = InfoVector.begin(); IVIt  != InfoVector.end(); IVIt++)
    {
        if(IVIt->RlyUserNumber == RlyUserNumber)
        {
            UserIP = IVIt->UserIP;
            UserPort = IVIt->UserPort;
            return(true);
        }
    }
    return(false);
}

//---------------------------------------------------------------------------

bool TInterface::NumHVPairCheckOK(TNumHVPair NumHVPair)
{
    if(NumHVPair.first > 100)  //100 players max
    {
        return(false);
    }
    if((NumHVPair.second.first > 2000) || (NumHVPair.second.first < -2000))
    {
        return(false);
    }
    if((NumHVPair.second.second > 2000) || (NumHVPair.second.second < -2000))
    {
        return(false);
    }
    return(true);
}

//---------------------------------------------------------------------------

bool TInterface::TServiceInfo::CheckOK()
{
    if(!TrainController->CheckHeadCodeValidity(13, false, ServiceReference)) //false for no messages
    {
        return(false);
    }
    if((RepeatNumber < 0) || (RepeatNumber > 6000)) //allows minute repeats for 4 days
    {
        return(false);
    }
    if((TimeToExitSecs < -1) || (TimeToExitSecs > 3600))
    {
        return(false);
    }
    return(true);
}

//---------------------------------------------------------------------------

void TInterface::RemovePlayerFromStringGridAndInfoVector(int Caller, AnsiString PlayerUserName)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",RemovePlayerFromStringGridAndInfoVector, " + PlayerUserName);
    for(int x = 0; x < NumPlayers; x++)
    {
        if(MultiplayerHostStringGrid->Cells[0][x + 2] == PlayerUserName)
        {
            MultiplayerHostStringGrid->Cells[0][x + 2] = "";
            MultiplayerHostStringGrid->Cells[2][x + 2] = "No";
            break;;
        }
    }
    if(!InfoVector.empty())//clear InfoVector of all but railway name
    {
        for(int x = 0; x < NumPlayers; x++)
        {
            if(InfoVector.at(x).UserName == PlayerUserName)
            {
//                InfoVector.at(x).RlyUserNumber = 0;  //no, the number stays as is
                InfoVector.at(x).UserName = "";
                InfoVector.at(x).UserIP = "";
                InfoVector.at(x).UserPort = 0;
                break;;
            }
        }
    }
    Utilities->CallLogPop(2390);
}

//---------------------------------------------------------------------------

void __fastcall TInterface::ShowHideStringGridMenuItemClick(TObject *Sender)
{
    Utilities->CallLog.push_back(Utilities->TimeStamp() + ",ShowHideStringGridMenuItemClick");
    TrainController->LogEvent("ShowHideStringGridMenuItemClick");
    if(MultiplayerHostStringGrid->Visible)
    {
        MultiplayerHostStringGrid->Visible = false;
    }
    else
    {
        MultiplayerHostStringGrid->Visible = true;
    }
    Utilities->CallLogPop(2413);
}

//---------------------------------------------------------------------------

void TInterface::PlayerHandshakingActions()
{
    try
    {
        Utilities->CallLog.push_back(Utilities->TimeStamp() + ",PlayerHandshakingActions");
        if(PlayerFiveSecondTimer == 0) //send at 5 sec intervals
        {
            EIdExceptionSource = "PlayerFiveSecondTimer";
            if(PlayerMakingInitialContactFlag) //sends it every 5 secs until host responds & then PlayerMakingInitialContactFlag reset
            {
                EIdExceptionSource += " PlayerMakingInitialContactFlag";
            //load datagram - Marker ('1') + UserName + ';' + RailwayName (no space or delimier between marker & railway name)
                UnicodeString Data = UnicodeString('1') + MPCPUserName + UnicodeString(';') + RailwayTitle;
                MPPlayerClient->Send(Data);
            }
            else if(PlayerReadyToBeginFlag)
            {
                EIdExceptionSource += " PlayerReadyToBeginFlag";
            //load datagram - Marker = '2' + UserName + times to exit (service ref, exit H&V & time) from DynMapToHost
                TBytes buffer;
                UpdateDynamicMapFromTimeToExitMultiMap(0, DynMapToHost);
                BuildDatagramFromPlayerMap(0, '2', MPCPUserName, buffer, DynMapToHost);
                MPPlayerClient->SendBuffer(MPPlayerClient->Host, MPPlayerClient->Port, buffer);
                ConsecutiveSelfUpdates = 0;
                LastHostDataReceived = TDateTime(0);
            }
            else if(PlayerInSessionFlag)
            {
                EIdExceptionSource += " PlayerInSessionFlag5SecTimer";
                TBytes buffer;
                UpdateDynamicMapFromTimeToExitMultiMap(1, DynMapToHost);
                BuildDatagramFromPlayerMap(1, '5', MPCPUserName, buffer, DynMapToHost);  //buffer length is set within this function
                MPPlayerClient->SendBuffer(MPPlayerClient->Host, MPPlayerClient->Port, buffer);
                //check last message time
                if(((TDateTime::CurrentDateTime() - LastHostDataReceived) > TDateTime(0.00034722)) && (LastHostDataReceived > TDateTime(1))) //== 30secs
                {
                    //update all times to entry by 30 secs & have any enter that are due in that time (missed at least 4)
                    //also when any train enters check that it's not already entered and ignore if so (Service ref + repeat number defines)
                    ConsecutiveSelfUpdates++;
                    if(ConsecutiveSelfUpdates > 10) //at least 5 minutes with no contact
                    {
                        //cancel session for this player
                    }
                }
            }
            else
            {
                //default, probably won't need it
            }
        }

        if(PlayerOneSecondTimer == 10) //send at 1 sec intervals, use 10 so out of step with 5 sec timer
        {
            if(PlayerCancelJoinFlag) //send every second until acknowledged
            {
                //send message to host, marker = 3, username; nothing else, '3' tells host of the cancellation
                EIdExceptionSource += " PlayerCancelJoinFlag";
            //load datagram - Marker ('3') + UserName
                UnicodeString Data = UnicodeString('3') + MPCPUserName;
                MPPlayerClient->Send(Data);
            }
            else if(PlayerAwaitingHostStartFlag)
            {
                EIdExceptionSource += " PlayerAwaitingHostStartFlag";
            //load datagram - Marker ('4') + UserName
                UnicodeString Data = UnicodeString('4') + MPCPUserName;
                MPPlayerClient->Send(Data);
            }
            else if(PlayerInSessionFlag)
            {
                EIdExceptionSource += " PlayerInSessionFlag1SecTimer";
                UnicodeString Data = UnicodeString('6') + MPCPUserName;
                MPPlayerClient->Send(Data);
            }
        }

//here player checks for any messages from host - after intial contact or speed changes etc during multiplay (every cycle)
        if(PlayerMakingInitialContactFlag) //receive
        {
            EIdExceptionSource = "PlayerMakingInitialContactFlag every cycle";
//            UnicodeString HostMessage = MPPlayerClient->ReceiveString(10);
            TBytes Buffer;
            Buffer.Length = 8192; //have to set long enough initially, reduced later
            Buffer.Length = MPPlayerClient->ReceiveBuffer(Buffer, 10);  //<-- ReceiveBuffer
            if(Buffer.Length != 0)
            {
                PlayerMakingInitialContactFlag = false; //only if reply received
                if((Buffer[0] == 'T') && (Buffer[1] == 'h') && (Buffer[2] == 'e')) //error message
                {
                    UnicodeString HostMessage = BytesToString(Buffer);
                    ShowMessage(HostMessage);
                    MPCPSendButton->Enabled = false;
                    MPCPReadyToBeginButton->Enabled = false;
                    MPCPPlayerNameEditBox->Text = "";
                    MPCPHostPortEditBox->Text = "";
                    MPCPHostIPEditBox->Text = "";
                    PlayerReadyToBeginFlag = false;
                    PlayerCancelJoinFlag = false;
                    PlayerAwaitingHostStartFlag = false;
                    PlayerInSessionFlag = false;
                    MultiplayerPlayerPanel->Visible = false;
                    Track->MultiplayerOverlayMap.clear();
                    ClearandRebuildRailway(91);
                }
                else //receive 'raw' coupled map for this player - own NumHVPair + coupled NumHVPair with default service info
                {    //compile initial DynMapFromHost & DynMapToHost, & add overlays to the coupled exit graphics
                    TServiceInfo ServiceInfo; //default values
                    THVShortPair ShortPair;
                    unsigned char UserNumber;
                    TDynamicMapEntry DMEntry;
                    DynMapFromHost.clear();
                    DynMapToHost.clear();
                    OwnRlyUserNumber = Buffer[0];
                    for(int x = 0; x < (Buffer.Length - 9); x += 10)
                    {
                        UserNumber = Buffer[x];
                        ShortPair.first = Buffer[x + 1] + (256 * Buffer[x + 2]);
                        ShortPair.second = Buffer[x + 3] + (256 * Buffer[x + 4]);
                        DMEntry.first.first = UserNumber;
                        DMEntry.first.second = ShortPair;
                        DMEntry.second = ServiceInfo;
                        DynMapFromHost.insert(DMEntry);
                        UserNumber = Buffer[x + 5];
                        ShortPair.first = Buffer[x + 6] + (256 * Buffer[x + 7]);
                        ShortPair.second = Buffer[x + 8] + (256 * Buffer[x + 9]);
                        DMEntry.first.first = UserNumber;
                        DMEntry.first.second = ShortPair;
                        DMEntry.second = ServiceInfo;
                        DynMapToHost.insert(DMEntry);
                    }
                    //Build Track->MultiplayerOverlayMap from DynMapFromHost, it consists of key = THVPair & value = graphic pointer
                    Track->MultiplayerOverlayMap.clear();
                    for(TDMIt DMIt = DynMapFromHost.begin(); DMIt != DynMapFromHost.end(); DMIt++)
                    {
                        typedef std::pair<int, int> THLocVLocPair;
                        THLocVLocPair HVPair;
                        std::pair<THLocVLocPair, Graphics::TBitmap*> MPOMEntry;
                        int SpeedTag;
                        Graphics::TBitmap *GrPtr;
                        HVPair.first = int(DMIt->first.second.first);
                        HVPair.second = int(DMIt->first.second.second);
                        SpeedTag = Track->GetTrackElementFromTrackMap(4, HVPair.first, HVPair.second).SpeedTag;
                        if((SpeedTag < 80) || (SpeedTag > 87))
                        {
                            throw Exception("Error, SpeedTag not a continuation in DynMapFromHost, value is " + AnsiString(SpeedTag));
                        }
                        else if(SpeedTag == 80)
                        {
                            GrPtr = RailGraphics->CouplingExit4;
                        }
                        else if(SpeedTag == 81)
                        {
                            GrPtr = RailGraphics->CouplingExit6;
                        }
                        else if(SpeedTag == 82)
                        {
                            GrPtr = RailGraphics->CouplingExit8;
                        }
                        else if(SpeedTag == 83)
                        {
                            GrPtr = RailGraphics->CouplingExit2;
                        }
                        else if(SpeedTag == 84)
                        {
                            GrPtr = RailGraphics->CouplingExit1;
                        }
                        else if(SpeedTag == 85)
                        {
                            GrPtr = RailGraphics->CouplingExit3;
                        }
                        else if(SpeedTag == 86)
                        {
                            GrPtr = RailGraphics->CouplingExit7;
                        }
                        else if(SpeedTag == 87)
                        {
                            GrPtr = RailGraphics->CouplingExit9;
                        }
                        MPOMEntry.first = HVPair;
                        MPOMEntry.second = GrPtr;
                        Track->MultiplayerOverlayMap.insert(MPOMEntry);
                    }
                    ClearandRebuildRailway(89);
                    MPCPLabel2->Caption = "When ready click 'Ready to begin'";  //top box
                    MPCPLabel4->Caption = "Joining request accepted";     //opposite image
                    MPCPLabel7->Caption = "";  //Lower box top
                    MPCPLabel8->Caption = "";  //Lower box bottom
                    MPCPHostImage->Picture->Assign(RailGraphics->SolidCircleGreen);
                    MPCPReadyToBeginButton->Enabled = true;
                }
            }
        }
        else if(PlayerReadyToBeginFlag)
        {
            EIdExceptionSource = "PlayerReadyToBegin every cycle";
            TBytes Buffer;
            Buffer.Length = 8192; //have to set long enough initially, reduced later
            Buffer.Length = MPPlayerClient->ReceiveBuffer(Buffer, 10);  //<-- ReceiveBuffer
            if(Buffer.Length != 0)
            {
                if(BytesToString(Buffer) == "Await simulation start")
                {
                    PlayerReadyToBeginFlag = false;
                    PlayerAwaitingHostStartFlag = true;
                    MPCPReadyToBeginButton->Enabled = false;
                    MPCPLabel2->Caption = "Awaiting simulation start";  //top box
                    MPCPLabel4->Caption = "";  //opposite image
                    MPCPLabel7->Caption = "";  //Lower box top
                    MPCPLabel8->Caption = "";  //Lower box bottom
                    MPCPLabel5->Caption = "";  //Host IP
                    MPCPLabel6->Caption = "";  //Host Port
                    MPCPLabel3->Caption = "";  //UserName
                    MPCPHostIPEditBox->Visible = false;
                    MPCPHostPortEditBox->Visible = false;
                    MPCPPlayerNameEditBox->Visible = false;
                    MPCPHostImage->Visible = false;
                }
                else
                {
                    //do nothing, leave PlayerReadyToStart true & send message again
                }
            }
            else
            {
                //do nothing, leave PlayerReadyToStart true & send message again
            }
        }
        else if(PlayerCancelJoinFlag)
        {
            EIdExceptionSource = "PlayerCancelJoinFlag every cycle";
            TBytes Buffer;
            Buffer.Length = 8192; //have to set long enough initially, reduced later
            Buffer.Length = MPPlayerClient->ReceiveBuffer(Buffer, 10);  //<-- ReceiveBuffer
            if(Buffer.Length != 0)
            {
                if(BytesToString(Buffer) == "Cancelled")
                {
                    PlayerCancelJoinFlag = false;
                }
            }
        }
        else if(PlayerAwaitingHostStartFlag) //await start message then clear the joining box, set PlayerMultiplayerInSession & reset PlayerAwaitingHostStart
        {
            EIdExceptionSource = "PlayerAwaitingHostStartFlag every cycle";
            TBytes Buffer;
            Buffer.Length = 8192; //have to set long enough initially, reduced later
            Buffer.Length = MPPlayerClient->ReceiveBuffer(Buffer, 10);  //<-- ReceiveBuffer
            if(Buffer.Length != 0)
            {
                if(BytesToString(Buffer) == "Start Session")
                {
                    PlayerAwaitingHostStartFlag = false;
                    PlayerInSessionFlag = true;
                    MultiplayerPlayerPanel->Visible = false;
                    OperatingPanelLabel->Caption = "Operation";
                    OperateButton->Click(); //keep speed etc. buttons disabled
                }
            }
        }
        else if(PlayerInSessionFlag)
        {
            EIdExceptionSource = "PlayerMultiplayerInSession every cycle";
            TBytes Buffer;
            int TTTime;
            TDynamicMap DMap;
            TDynamicMap::iterator DMIt, DMFHIt;
            Buffer.Length = 8192; //have to set long enough initially, reduced later
            Buffer.Length = MPPlayerClient->ReceiveBuffer(Buffer, 10); //<-- ReceiveBuffer
            if(Buffer.Length != 0)
            {
                //here have DynMapFromHost as buffer with TTClockTime at start as 32 bit integer
                ConsecutiveSelfUpdates = 0;
                if(BuildDynamicMapFromHostDatagram(0, TTTime, DMap, Buffer)) //validity checks in this function
                {
                    //store TTTime & update DynMapFromHost, should be in proper order but don't rely on it
                    TrainController->TTClockTime = double(TTTime) / 8640000;
                    for(DMIt = DMap.begin(); DMIt != DMap.end(); DMIt++)
                    {
                        DMFHIt = DynMapFromHost.find(DMIt->first);
                        if(DMFHIt != DynMapFromHost.end())
                        {
                            DMFHIt->second = DMIt->second;
                        }
                        //else skip it
                    }
                    LastHostDataReceived = TDateTime::CurrentDateTime();

                    //now have TTClock updated  + service refs & times to entry in DynMapFromHost

                }
                //else skip it - catch up next time
            }
        }
    Utilities->CallLogPop(2416);
    }
    catch(const EIdException &e) //non-error catch
//if no response from peer then get a 'connection reset by peer' message which isn't valid
    {
        Utilities->CallLogPop(2417);
    }
    catch(const Exception &e)
    {
        ErrorLog(240, e.Message);
    }
}

//---------------------------------------------------------------------------

/*
   Problems with ifstream reading (see 'SessionFileIntegrityCheck(AnsiString FileName)' above):-

   These problems were with Borland C++Builder 4.

   The functions saved in OldFiles\Backups220809Duringifstream testing were used for testing the odd behaviour where the
   ifstream pointer gave different characters using get() and getline(), when reading the timetable entries in the session
   file for 20/08/09 at 18:45 (saved).  All was well until point 48677 in the session file, when for some reason the
   getline(0 & get(0 gave different results.  Many earlier timetable strings had been read OK before that, and it wasn't
   clear what was special about this particular string.
   Later more detailed study found that on reading the string beginning at point 48605 (i.e. the one earlier than above),
   within function CheckNoNewLineAtStartNonZeroTerminatedFileString the file pointer (using tellg()) reduced from 48606 to
   48604 after reading the 'F' character.  Thereafter characters were read correctly but the pointer remained 2 too low.
   This is thought to be a flaw in the compiler.
   Later again additional tellg()s and a seekg()s were included in CheckNoNewLineAtStartNonZeroTerminatedFileString, and
   though these should have had no effect they somehow caused the next getline() within CheckTimetableFromSessionFile to
   read a null, even though the pointer had been reset to its value before the call to
   CheckNoNewLineAtStartNonZeroTerminatedFileString.  Again this seems to be a flaw in the compiler, where the pointer
   that is indicated by tellg and the true pointer within the system can be different.
   Tried the old c++ stream library to see if that worked but it was exactly the same.  Probably because the same code is
   used for both with the new library just defined within the std namespace.
   Success!!  Traced to the putback function failing.  It (apparently) can't be used if the file pointer has been altered
   after the last read that is to be put back.  Corrected that & the most recent session file checked out & loaded OK.
   (note - don't need the ifstream file to be open in output mode for the putback to work)
   But:  the earlier file - 18:45 as above - still fails to advance the file pointer in the middle of checking the
   timetable, it sticks at position 48601.  This position points to 'r' in 'Frh' just before a newline.  Also the file
   integrity is OK up to and after this sticking point.  Oddly though the loading function works fine (i.e. by bypassing
   the integrity check function), though the timetable isn't read directly, it is copied to a new stand-alone timetable
   file and that read by the program.
   Created a new version of CheckNoNewLineAtStartNonZeroTerminatedFileString with 'New' at end, & got rid of all the
   internal digressions & getlines.  This passed the earlier sticking point, but stuck later at 48677, i.e. the 'h' from
   'Frh' at the end of the entry following that for the earlier sticking point.  Here
   CheckNoNewLineAtStartNonZeroTerminatedFileStringNew works fine, with end pointer correctly set at 48680, i.e. after the
   newline, but the subsequent getline() function, although it retrieves the line correctly, the file pointer is set to
   48677, i.e. before the newline, so getline seems to fail to extract the newline character.  Still to check - why doesn't
   CheckNoNewLineAtStartNonZeroTerminatedFileStringNew see 'h' instead of '0' in the subsequent read?  If it did the two
   would tally, though would still be wrong.
   Further investigation:-  CheckNoNewLineAtStartNonZeroTerminatedFileStringNew doesn't seem to recognize the file pointer
   as set by seekg at 48677.  It continues to read at the point it left off earlier, whereas getline() does read at 48677
   & recovers 'h'.  Continuing to apply getline() after the above effect it is found that it doesn't extract newlines after
   reading further lines, but extracts them when read alone i.e. it reads a line then a null in succession, although the
   lines are only separated by single newline characters.

   Need to check:
   1. Does the file read correctly if only get() functions used without getline() and without resetting the file pointer?
   2. Does the file read correctly if only getline() functions used without get() and without resetting the file pointer?
   3.  Does the file read correctly if get() functions alternated with getline() but without resetting the file pointer?

   For 1:  Still goes wrong at usual place, reads 'h' at the same point.  Try not resetting the file pointer with seekg.
   Tried this - got past the earlier point but failed later with a reduction in file pointer after a character read.  In
   fact the reduction was by 40 bytes for reading a single comma!  Try without any tellg's - yes, that got past all the
   timetable OK.  So, works OK with just get() providing no tellg's (& no seekg's).

   For 2:  Works OK using getline().

   For 3:  Gets to end of timetable OK but the next tellg gives a wrong value.  Check if using getline() alone gives a
   wrong tellg.  Tried getline() alone, reached end of TT as before, but gave the same wrong file pos on using tellg.
   Try continuing to see if works OK in spite of tellg giving wrong result.  Yes it works OK.  Hence the problem seems to
   be tellg, which sometimes returns wrong results, and they corrupt things when used in seekg.

   Overall conclusion:  Avoid all tellg's & seekg's.  If need to reset a file position then close and reopen it.
*/

//---------------------------------------------------------------------------

